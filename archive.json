{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-07-09T01:13:01.600444+00:00",
  "repo": "tlswg/draft-ietf-tls-esni",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "needs WG discussion",
      "description": "",
      "color": "c5def5"
    },
    {
      "name": "ready-for-text",
      "description": "",
      "color": "f9d0c4"
    },
    {
      "name": "pre-wglc",
      "description": "Pre-WGLC issue",
      "color": "d4c5f9"
    },
    {
      "name": "editorial",
      "description": "Editorial",
      "color": "e99695"
    },
    {
      "name": "design",
      "description": "Design-related issue",
      "color": "fef2c0"
    },
    {
      "name": "parked",
      "description": "Parked for deployment experience",
      "color": "FB56EA"
    },
    {
      "name": "propose to close",
      "description": "",
      "color": "3C1057"
    },
    {
      "name": "merge ready",
      "description": "",
      "color": "0E8A16"
    },
    {
      "name": "pr available",
      "description": "",
      "color": "c2e0c6"
    }
  ],
  "issues": [
    {
      "number": 5,
      "id": "MDU6SXNzdWUzMjI0NjYzMDg=",
      "title": "Add an optional \"fronting SNI\" to the DNS record",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/5",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In most cases, this can be absent, but it might help with deployment to have SNI in every handshake.  Controlling the value of the SNI used (or more to the point, suggesting a safe value), might give clients a better way to avoid notice.",
      "createdAt": "2018-05-12T00:16:10Z",
      "updatedAt": "2018-05-12T15:35:30Z",
      "closedAt": "2018-05-12T15:35:30Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed",
          "createdAt": "2018-05-12T15:35:30Z",
          "updatedAt": "2018-05-12T15:35:30Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "MDU6SXNzdWUzMjI0NjY3MjQ=",
      "title": "Do you need the nonce?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/6",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "You are mixing ClientHello.random in.  That would seem to be sufficient.  From that you can generate the AEAD nonce and key as though this were record protection.\r\n\r\n```\r\nesni_secret = HKDF-Extract(0, Z)\r\nk = HKDF-Expand-Label(esni_secret, \"esni key\", ClientHello.random, L)\r\niv = HKDF-Expand-Label(esni_secret, \"esni key\", ClientHello.random, L)\r\n```\r\n\r\nWe don't need another reason for people to complain about exposing the random number generator state to the network.",
      "createdAt": "2018-05-12T00:20:54Z",
      "updatedAt": "2018-05-12T13:13:33Z",
      "closedAt": "2018-05-12T13:13:33Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "If servers choose to use the same ESNI and semi-static key, not generating and including a nonce could lead to nonce-reuse for 0-RTT data. We talked about just prohibiting this sort of key sharing for servers, though it's good to have a client-side defense against it.",
          "createdAt": "2018-05-12T04:03:57Z",
          "updatedAt": "2018-05-12T04:03:57Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "MDU6SXNzdWUzMjI0NjcyNDA=",
      "title": "Where do the TXT records go?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/7",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In DNS, yes, but under what name?  \r\n\r\nI suggest at _esni.<domain>.  Usage of TXT and underscore names is now considered an acceptable way to deploy new features.  It also deploys more reliably than a new RRtype.",
      "createdAt": "2018-05-12T00:26:13Z",
      "updatedAt": "2018-05-12T15:36:25Z",
      "closedAt": "2018-05-12T15:36:25Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "I would like to note that the use of RRtype would be a no-go for many operators, because you cannot delegate an APEX name.\r\n\r\nMany websites are served by their APEX names. It is common for a web-site publisher to choose different hosting providers for HTTP (i.e. CDN) and DNS. This is especially the case with CDNs relying on anycast.\r\n\r\nThese facts lead to the conclusion that if we choose RRtype as the method, there would often be cases where the DNS record of the ESNIKey and the TLS server would be required to be operated by different entities.\r\n\r\nThis essentially means that there would be high risk of ESNIKey record and the key in TLS server becoming out-of-sync for large amount of deployments.\r\n\r\nHaving such _additional_ risk in operation for a nice-to-have feature like ESNI would be unacceptable for many operators.\r\n\r\nPS. Using TXT records with prefix sounds good to me because we can use CNAME to delegate the ESNIKey when an APEX name is used to serve the website.",
          "createdAt": "2018-05-12T05:42:56Z",
          "updatedAt": "2018-05-12T06:23:23Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho: we went with TXT.",
          "createdAt": "2018-05-12T15:36:24Z",
          "updatedAt": "2018-05-12T15:36:24Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "MDU6SXNzdWUzMjI0Njc1NTY=",
      "title": "Explain the DNS layout a little more clearly",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/8",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "When I lookup `hidden.example`, I would expect to have an A (or AAAA) for `hidden.example`, a TXT for `_esni.hidden.example` and nothing more.  \r\n\r\nThe key idea is that all hidden servers that share a front would return the same A records.  You need to say that.",
      "createdAt": "2018-05-12T00:29:21Z",
      "updatedAt": "2018-05-12T15:35:38Z",
      "closedAt": "2018-05-12T15:35:38Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed",
          "createdAt": "2018-05-12T15:35:38Z",
          "updatedAt": "2018-05-12T15:35:38Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "MDU6SXNzdWUzMjI0ODY4ODQ=",
      "title": "sending certificate chain along with ESNIKeys",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/10",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Thank you for working on the draft. I can't be more happy to see someone willing to lead the community towards having a particular ESNI solution.\r\n\r\nConsidering the fact that omitting the certificate chain and the signature was [one of the options discussed in my draft](https://tools.ietf.org/html/draft-kazuho-protected-sni-00#section-5.3) (was originally suggested by @siyengar), I am happy to support the proposal and am willing to implement it.\r\n\r\nOTOH, please let me argue here for sending the certificate-chain along with the ESNIKey.\r\n\r\nWhile I agree that there is no huge difference in terms of security, there are benefits related to performance in sending the certificate chain along with the ESNIKey.\r\n\r\nIn QUIC, we are discussing how many packets a server can send before the client's address is validated. This is because sending packets to an non-validated address is an vector for amplification attacks. We can resolve the issue by sending the certificate chain along with the ESNIKey and using an encrypted variant of Cached Certificate Extension.\r\n\r\nWe also revive the possibility of doing 0-RTT using semi-static key, because the key will be signed by the certificate.\r\n\r\nI think that providing performance improvement might give people more incentive to start using ESNI.",
      "createdAt": "2018-05-12T06:18:51Z",
      "updatedAt": "2018-05-14T13:16:57Z",
      "closedAt": "2018-05-14T13:16:57Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho: you make a good point here (and thanks for doing your original draft; as you can see,  stole a lot of ideas!) and I think it's something we should look into\r\n\r\nI would argue for keeping these two mechanisms separate, for a few reasons:\r\n\r\n1. The cached_info indication would be consumed by the hidden server, not the fronting server, so you have the issues I note in Appendix A.\r\n\r\n2. If we ultimately want to do 0-RTT priming (which seems interesting) we will likely want different keys with different lifetimes.\r\n\r\n3. Not every hidden server may want to support cached_info and so it might make it harder to get wide ESNI deployment.\r\n\r\nIn line with point 3, I think it may be easier to experiment with the simpler mechanism, because we can easily change the semantics to be the ones you propose if we need to, given that the extension is encrypted.\r\n\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2018-05-12T15:50:10Z",
          "updatedAt": "2018-05-12T15:50:10Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@ekr Thank you for your comments.\r\n\r\n> I would argue for keeping these two mechanisms separate, for a few reasons:\r\n> \r\n> 1. The cached_info indication would be consumed by the hidden server, not the fronting server, so you have the issues I note in Appendix A.\r\n> \r\n> 2. If we ultimately want to do 0-RTT priming (which seems interesting) we will likely want different keys with different lifetimes.\r\n> \r\n> 3. Not every hidden server may want to support cached_info and so it might make it harder to get wide ESNI deployment.\r\n> \r\n> In line with point 3, I think it may be easier to experiment with the simpler mechanism, because we can easily change the semantics to be the ones you propose if we need to, given that the extension is encrypted.\r\n\r\nI would argue that these three concerns could be resolved by sending the certificate as an optional feature (as well as the 0-RTT a flag in the ESNIKey structure).\r\n\r\nBut having that said, it really depends on if client and resolver developers want to implement. I also understand that a small step is a good thing.\r\n\r\nPlease feel free to close the issue (or float it around if you think we might revisit).\r\n\r\nOTOH, having an `extensions` field might be always a good idea.",
          "createdAt": "2018-05-12T22:17:47Z",
          "updatedAt": "2018-05-12T22:17:47Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW, you should remember that cached-info will reveal the identity of the server as effectively as SNI.\r\n\r\nI think that I agree with ekr here: priming clients with certificates is valuable, as is priming them for 0-RTT, but both require\r\n\r\nI think that protecting ALPN is of far less interest.  Also, as ekr observes, the lifetime for these keys might be dramatically different.  All in all, that makes me lean more toward the piecemeal approach that this draft suggests, as opposed to the \"just encrypt extensions\" approach that Richard considered.",
          "createdAt": "2018-05-12T23:30:06Z",
          "updatedAt": "2018-05-12T23:30:06Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> FWIW, you should remember that cached-info will reveal the identity of the server as effectively as SNI.\r\n\r\nWhat I am arguing for is \"an encrypted variant of Cached Certificate Extension\", which is sent by client using the ESNIKey.",
          "createdAt": "2018-05-13T00:09:56Z",
          "updatedAt": "2018-05-13T00:09:56Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think that protecting ALPN is of far less interest. Also, as ekr observes, the lifetime for these keys might be dramatically different. All in all, that makes me lean more toward the piecemeal approach that this draft suggests, as opposed to the \"just encrypt extensions\" approach that Richard considered.\r\n\r\nI agree. Considering the fact that sending the certificate-chain does not improve security, it can be an option that can be added later as an extension.\r\n\r\nDo you think that it would generally be a good idea to have an extensions slot in ESNIKey? I would assume so considering the fact that we now have extensions field in most of the TLS handshake messages.",
          "createdAt": "2018-05-13T00:21:24Z",
          "updatedAt": "2018-05-13T00:21:24Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think we need extensions.  If we miss something, we can add another extension.  We had extensions in (the unencrypted) SNI, and they ended up being unused and unusable eventually.  And there was a clear intended use for those even.",
          "createdAt": "2018-05-13T10:04:20Z",
          "updatedAt": "2018-05-13T10:04:20Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we might be having a confusion here.\r\n\r\nWhat I am arguing for is adding an extensions slot to ESNIKey, which is currently defined as:\r\n```\r\nstruct {\r\n    ESNIKeyShareEntry keys<4..2^16-1>;\r\n    CipherSuite cipher_suites<2..2^16-2>;\r\n    uint16 padded_length;\r\n} ESNIKeys;\r\n```\r\n\r\nThis structure is sent as a DNS record; you cannot extend it. If we want to add additional attributes, we would be forced to define a new DNS record that gets queried simultaneously. I think we do not want to do that.\r\n\r\nI totally agree that we do not need the capability to extend the EncryptedSNI structure.",
          "createdAt": "2018-05-13T12:31:20Z",
          "updatedAt": "2018-05-13T12:31:46Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ahh, I see what you mean.  Yeah, that's probably fine.",
          "createdAt": "2018-05-14T01:03:27Z",
          "updatedAt": "2018-05-14T01:03:27Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "MDU6SXNzdWUzMjI1MjkwMTM=",
      "title": "Proposed _esni TXT structure does not fit with DNS encodings",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/14",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The proposed DNS publication method for the key is sketched in section 4, Publishing the SNI Encryption Key. The proposed structure is\r\n~~~\r\n    struct {\r\n        ESNIKeyShareEntry keys<4..2^16-1>;\r\n        CipherSuite cipher_suites<2..2^16-2>;\r\n        uint16 padded_length;\r\n    } ESNIKeys;\r\n~~~\r\nThis can be problematic, given the constraints on TXT records. The practical length of the record payload is at most 255 bytes. The payload content is supposed to be text, which would suggest a base64 encoding, further reducing the available payload size to 189 bytes.\r\n\r\nI would suggest encoding just one key & one ciphersuite per record using base64 encoding, and using multiple records if necessary.",
      "createdAt": "2018-05-12T17:34:36Z",
      "updatedAt": "2018-05-13T03:18:44Z",
      "closedAt": "2018-05-13T03:18:44Z",
      "comments": [
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW RFC 4408 allows you to have multiple strings in the same TXT record to get around the limit https://tools.ietf.org/html/rfc4408#section-3.1.3\r\n\r\n> one key & one ciphersuite per record\r\n\r\nThis should probably be one key and _all_ cipher suites, since suites and keys are orthogonal to each other.",
          "createdAt": "2018-05-12T18:06:07Z",
          "updatedAt": "2018-05-12T18:06:07Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "We assumed a suitable encoding that would not bump into this bound. Alessandro\u2019s suggestion above seems best.",
          "createdAt": "2018-05-12T18:25:27Z",
          "updatedAt": "2018-05-12T18:25:27Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I really have two concerns, the maximum length and the char requirement. The latter may be an harder issue. For example, can I set a TXT record to contain binary data if I use Amazon's Route 53 service?",
          "createdAt": "2018-05-12T18:28:01Z",
          "updatedAt": "2018-05-12T18:28:01Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we can work around the first with the concatenation suggestion. For the second, I assumed (perhaps incorrectly) any binary data was admissible. If we can\u2019t use binary data, then we can encode it easy enough. ",
          "createdAt": "2018-05-12T18:30:39Z",
          "updatedAt": "2018-05-12T18:30:39Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@huitema Shall we close this?",
          "createdAt": "2018-05-13T00:33:13Z",
          "updatedAt": "2018-05-13T00:33:13Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closed after merging PR #18",
          "createdAt": "2018-05-13T03:18:44Z",
          "updatedAt": "2018-05-13T03:18:44Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "MDU6SXNzdWUzMjI1Mjk1MjE=",
      "title": "Think of the smiley when forwarding ESNI values",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/15",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": " Appendix A, Communicating SNI to Hidden Server, specifies mechanisms for providing the hidden server with the selected SNI. We should not assume that the network connection between fronting and hidden is private. An obvious attack path is for the adversary to rent or hack servers in the same location as the hidden server. That's one more reason for not sending the SNI in clear text.",
      "createdAt": "2018-05-12T17:42:02Z",
      "updatedAt": "2018-05-22T18:34:46Z",
      "closedAt": "2018-05-22T18:34:46Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with this. Added some clarifying text.",
          "createdAt": "2018-05-12T18:31:42Z",
          "updatedAt": "2018-05-12T18:31:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@huitema can we close this?",
          "createdAt": "2018-05-22T14:19:31Z",
          "updatedAt": "2018-05-22T14:19:31Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "EKR mentioned that the text of appendix A was clarified, but I don't see the clarification. The text says:\r\n~~~\r\nAs noted in Section 5.3, in Fronting Mode the hidden server will generally not know the true SNI. It is possible for the fronting server to communicate the true SNI to the hidden server, but at the cost of having that communication not be unmodified TLS 1.3. The basic idea is to have a shared key between the fronting server and the hidden server (this can be a symmetric key) and use it to send Z at the beginning of the connection before the ClientHello. The hidden server can then decrypt ESNI to recover the true SNI.\r\n\r\nAn obvious alternative here would be to have the fronting server forward the true SNI, but that would allow the fronting server to lie. In this design, the attacker would need to be able to find a Z which would expand into a key that would validly AEAD-encrypt a message of his choice, which should be intractable (Hand-waving alert!).\r\n~~~\r\nWhat I don't see is a mention that the network transmission between the fronting server and the hidden server  could be spied upon. I guess I need to propose a PR.\r\n",
          "createdAt": "2018-05-22T14:43:44Z",
          "updatedAt": "2018-05-22T14:43:44Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Given (a) RFC 3552 and (b) that we propose encrypting the value, I don't really think we need to say that this channel can be observed.",
          "createdAt": "2018-05-22T15:20:47Z",
          "updatedAt": "2018-05-22T15:20:47Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well, OK. I suppose the requirement for encryption solves the issue.",
          "createdAt": "2018-05-22T18:34:46Z",
          "updatedAt": "2018-05-22T18:34:46Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "MDU6SXNzdWUzMjI1MzI1ODA=",
      "title": "Refresh ESNIKeys with HelloRetryRequest",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/17",
      "state": "CLOSED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Regarding:\r\n\r\n```\r\n- If the EncryptedSNI.label value does not correspond to any known\r\n  SNI encryption key, it MUST abort the connection with an\r\n  \"illegal_parameter\" alert.\r\n  [[OPEN ISSUE: We looked at ignoring the extension but concluded\r\n  this was better.]]\r\n```\r\nRather than aborting, would it make more sense for the server to (optionally?) send a fresh `ESNIKeys` as an extension as part of `HelloRetryRequest`? Example use case would be that for whatever reason (e.g. key compromise?) the server might want to discard a previously advertised `ESNIKeys` before it expires. Not sure if it's worth the added complexity though.\r\n\r\n(With some other changes it could also be used as an alternative way to publish a key at the cost of one round trip, but the usefulness there is probably limited)\r\n",
      "createdAt": "2018-05-12T18:26:58Z",
      "updatedAt": "2018-05-14T17:22:37Z",
      "closedAt": "2018-05-14T17:22:37Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I thought about this a bit, but making sure it doesn't allow cut-and-paste attacks seemed like it was going to need a lot of thought.",
          "createdAt": "2018-05-12T18:32:49Z",
          "updatedAt": "2018-05-12T18:32:49Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@ghedo I don't think we should do this. It allows an on-path TCP proxy to inject a HRR, with a fresh ESNI key, and cause the client to reveal its SNI to that proxy. ",
          "createdAt": "2018-05-12T18:43:31Z",
          "updatedAt": "2018-05-12T18:43:31Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ugh, right. I guess the server could send the full DNS record, alongside DNSSEC signatures and chain, though that sounds like something that should be done independently from this spec.",
          "createdAt": "2018-05-14T17:22:37Z",
          "updatedAt": "2018-05-14T17:22:37Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "MDU6SXNzdWUzMjI1NDY2ODE=",
      "title": "Specify whether ESNI key is provided by hidden or by fronting server",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/19",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "The text in section 4, Publishing the SNI Encryption Key, specifies that _if a client queries example.com, the ESNI TXT name is _esni.example.com_. That's fine, but suppose that the client queries \"hidden.example.com\". The client needs to learn that \"hidden.example.com\" is fronted by \"fronting.example.com\" -- per PR #18, the client will do that by obtaining an ALT-SVC record. Should the client get the ESNI key from \"_esni.hidden.example.com\", or from \"_esni.fronting.example.com\" ?",
      "createdAt": "2018-05-12T22:11:46Z",
      "updatedAt": "2018-05-22T14:49:12Z",
      "closedAt": "2018-05-22T14:49:12Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood I think this is you.",
          "createdAt": "2018-05-12T23:23:18Z",
          "updatedAt": "2018-05-12T23:23:18Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "#18 covers this.  Mostly.  It might pay to observe that the client does not look up and DNS records for the fronting service, it is just the case that all servers in the anonymity set point to the same IP address.  I made similar comments on #18.",
          "createdAt": "2018-05-12T23:25:00Z",
          "updatedAt": "2018-05-12T23:25:00Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with @martinthomson here. I didn't see the client querying fronting.example.com.",
          "createdAt": "2018-05-12T23:38:42Z",
          "updatedAt": "2018-05-12T23:38:42Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That means all servers that share the same IP need to publish the same key. Are we confident that there is no synch issue during key rollover?",
          "createdAt": "2018-05-13T00:05:34Z",
          "updatedAt": "2018-05-13T00:05:34Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Servers can publish multiple ESNI keys with different labels in a record. That way they can retire one key and start using another as needed. Though it might be good (necessary?) to require clients to use one of those keys. ",
          "createdAt": "2018-05-13T00:30:04Z",
          "updatedAt": "2018-05-13T00:30:04Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> Servers can publish multiple ESNI keys with different labels in a record. That way they can retire one key and start using another as needed.\r\n\r\nWhile that is possible, I am not sure if it would be the approach that would generally be used.\r\n\r\nThe issue is identical to the encryption key of the session tickets. In case of session tickets, we encrypt the ticket using one key, and send the identifier of the key along with the encrypted ticket.\r\n\r\nWhen we rollover the keys, we first deploy a new key to the server as well as keeping the old one alive for decryption only. And we retire the old key after certain amount of period that we become sure that it is no longer used.\r\n\r\nI'd assume that we can and will use the same approach for ESNIKeys.",
          "createdAt": "2018-05-14T05:29:19Z",
          "updatedAt": "2018-05-14T05:33:45Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "PS. therefore, it is possible to have just one label for the set of keys rather than having labels for each of the keys (assuming that we can remove the \"choose one at random\" rule). In that approach, a server will identify the key being used by looking at the `(label, group)` tuple.\r\n\r\nThe benefit will be that you will save the space of N-1 labels assuming that you are sending N key shares. Identification of the key on the server-side might seem complicated, but I actually think that it simplifies things, because a server operator is anyways expected to deploy the entire set of keys found in ESNIKeys at the same moment.",
          "createdAt": "2018-05-14T05:41:16Z",
          "updatedAt": "2018-05-14T05:51:07Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> therefore, it is possible to have just one label for the set of keys rather than having labels for each of the keys (assuming that we can remove the \"choose one at random\" rule)\r\n\r\nTo me it seems that this is necessary to prevent downgrade attack. Hence #24.",
          "createdAt": "2018-05-14T12:02:31Z",
          "updatedAt": "2018-05-14T12:02:31Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "How do we prevent labels from becoming identifiers?",
          "createdAt": "2018-05-14T13:36:56Z",
          "updatedAt": "2018-05-14T13:36:56Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Labels as identifiers seem problematic in both approaches -- current and #24. ",
          "createdAt": "2018-05-14T13:43:30Z",
          "updatedAt": "2018-05-14T13:43:30Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "Would you mind elaborating why label becomes an identifier? We state in the document that the probability of identifying the hidden server is 1/N where N is the number of the hosts belonging to the same set of hidden servers. A label represents that entire set.\r\n\r\nSo I do not think it is an issue.",
          "createdAt": "2018-05-14T15:23:44Z",
          "updatedAt": "2018-05-14T15:23:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Now that #43 is merged, which removes the label altogether, and we've added text describing the anonymity set for hidden servers, I think this issue is covered. @huitema do you agree?",
          "createdAt": "2018-05-22T14:21:18Z",
          "updatedAt": "2018-05-22T14:21:18Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The label issue is definitely covered. ",
          "createdAt": "2018-05-22T14:49:12Z",
          "updatedAt": "2018-05-22T14:49:12Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "MDU6SXNzdWUzMjI1NTIxMjg=",
      "title": "Client-side verification of ESNIKeys",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/20",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The biggest concern from web-site operators will be the possibility of out-of-sync or broken ESNIKeys leading to service disruption.\r\n\r\nConsidering that, I propose having two attributes being added:\r\n* validity - we can borrow `notBefore` and `notAfter` from PKIX\r\n* checksum - something like 32-bits would be enough\r\n\r\nSeeing wired ESNIKeys will become a big issue especially if the clients accept ESNIKeys sent from low-quality resolvers / proxies (e.g. those in home routers).\r\n\r\nPS. One alternative approach would be to use HTTP (.well-known URI) as a transport of the semi-static key between the TLS server and the resolver. Then, we can use the vocabulary of HTTP to implement client-side verification.",
      "createdAt": "2018-05-13T00:06:15Z",
      "updatedAt": "2018-05-14T16:04:43Z",
      "closedAt": "2018-05-14T16:04:43Z",
      "comments": []
    },
    {
      "number": 25,
      "id": "MDU6SXNzdWUzMjI3OTQ4ODI=",
      "title": "wildcard delegations to hidden server",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/25",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Current text says:\r\n> If the serialized ServerNameList is longer than ESNIKeys.padded_length, the client MUST NOT use\r\nthe \"encrypted_server_name\" extension.\r\n\r\nHowever, I am not sure if this is the desired behavior. I would rather suggest encrypting even when the hostname exceeds the padded_length. Having some protection is better than none.\r\n\r\nThe issue is that in certain deployments it is impossible to guess what the maximum length of the hostname will be. Consider `*.github.io`. It uses a wildcard certificate. Anybody can add a new hostname of any length by creating a new Github account (it might be true that Github some limitation on the length, but that does not necessarily mean that Github shares the maximum length information with the fronting CDN, assuming that it uses a CDN).",
      "createdAt": "2018-05-14T12:27:23Z",
      "updatedAt": "2018-06-21T13:19:04Z",
      "closedAt": "2018-06-21T13:19:04Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "I have filed #26 that fixes another issue (it's just a clarification of an open issue) related to wildcard delegation.",
          "createdAt": "2018-05-14T12:33:38Z",
          "updatedAt": "2018-05-14T12:33:38Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Technically, it is possible to guess the maximum length of the hostname, as that maximum textual representation length is defined as 253 bytes per RFC 1034.",
          "createdAt": "2018-05-16T06:24:06Z",
          "updatedAt": "2018-05-16T06:24:06Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes. So the question is if a CDN that has a wildcard mapping needs to set `padded_length` to 253 (since current text is a MUST NOT for sending a server name longer than the padded_length), or if we should introduce a different rule.",
          "createdAt": "2018-05-16T12:16:10Z",
          "updatedAt": "2018-05-16T12:16:10Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "How about something like:\r\n\r\npadded_length : The length to pad the ServerNameList value to prior to encryption. This value SHOULD be set to the largest ServerNameList the fronting server expects to support rounded up the nearest multiple of 16. If the fronting server supports wildcard names, it SHOULD set this value to 256.",
          "createdAt": "2018-05-16T18:10:58Z",
          "updatedAt": "2018-05-16T18:10:58Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@DavidSchinazi Thank you for the suggestion.\r\n\r\nI was feeling uneasy (and am still feeling a bit) about requiring the client to send an ESNI extension as large as ~300 bytes, assuming that CDN's would have at least one wildcard mappings.\r\n\r\nBut it's about the first packet sent from the client, and we typically have enough room even when 0-RTT data is involved. So I think that we can live with that.",
          "createdAt": "2018-05-25T05:42:35Z",
          "updatedAt": "2018-05-25T05:42:35Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "To be closed by #48.",
          "createdAt": "2018-05-26T05:09:23Z",
          "updatedAt": "2018-05-26T05:09:23Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed by #48.",
          "createdAt": "2018-06-21T13:19:04Z",
          "updatedAt": "2018-06-21T13:19:04Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "MDU6SXNzdWUzMjI4MjQ2NjI=",
      "title": "Client and server ESNI key selection",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/27",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Doing so doesn't allow a server to gracefully generate new ESNI keys and retire old ones. We should mandate that clients always choose the first ESNI key for which they have group support. If we adopt #24, where servers lookup keys with a (label, group) -> key mapping, should we also require that each label have the same groups? ",
      "createdAt": "2018-05-14T13:48:27Z",
      "updatedAt": "2018-07-02T14:17:59Z",
      "closedAt": "2018-07-02T14:17:59Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho what do you think?",
          "createdAt": "2018-05-14T13:49:00Z",
          "updatedAt": "2018-05-14T13:49:00Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "I am not sure what you mean by \"doing so\", but the model I expect is something like following assuming that we adopt #24.\r\n\r\n* the fronting server generates a new ESNIKeys and pushes it to DNS server every 1 hour\r\n  * TTL will be set to 5 minutes ~~`not_after` - now~~<sup>1</sup>\r\n* the fronting server will accept the following keys to be used in the EncryptedSNI extension:\r\n  * the key for the current hour\r\n  * the key for the previous hour, for the first 10 minutes of every hour\r\n\r\nA ESNIKeys record can contain multiple keys belonging to different groups, but not belonging to the same group. So there is no ambiguity by specifying the key using (label, group).\r\n\r\nThe server can add a new Named Group or retire one when it generates a new ESNIKeys.\r\n\r\n[1] updated to reflect the fact that we can only use a constant TTL in the standard way of DNS server synchronization (i.e. DNS zone transfer) (02:47UTC May 15 2018)",
          "createdAt": "2018-05-14T15:15:13Z",
          "updatedAt": "2018-05-15T02:47:14Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "That seems perfectly fine. But it does mean that there exists only one key per group at any given point in time. Is that a restriction we are comfortable with?",
          "createdAt": "2018-05-14T15:18:39Z",
          "updatedAt": "2018-05-14T15:18:39Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> That seems perfectly fine. But it does mean that there exists only one key per group at any given point in time. \r\n\r\nI don't think so. A DNS server can send different ESNIKeys at the same hour using short TTL (e.g. 60 seconds) in response to different queries (a.k.a. round-robin DNS).",
          "createdAt": "2018-05-14T15:20:58Z",
          "updatedAt": "2018-05-14T15:20:58Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry, I mean within a single record. ",
          "createdAt": "2018-05-14T15:21:46Z",
          "updatedAt": "2018-05-14T15:21:46Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "I am comfortable with not having that. You can only have a handful of keys in ESNIKeys anyways.\r\n\r\nI'd assume that either one would be enough or we would need a way to distribute more than just a handful, for which we can use round-robin.",
          "createdAt": "2018-05-14T15:26:29Z",
          "updatedAt": "2018-05-14T15:26:29Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "SGTM. We should add this rationale as text to the DNS record section. ",
          "createdAt": "2018-05-14T15:29:09Z",
          "updatedAt": "2018-05-14T15:29:09Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that TTL suffices here.",
          "createdAt": "2018-05-15T01:04:22Z",
          "updatedAt": "2018-05-15T01:04:22Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson FWIW, `not_after` is now in master. We can certainly discuss about the necessity, but you might want to see the debate on #23.",
          "createdAt": "2018-05-15T05:05:23Z",
          "updatedAt": "2018-05-15T05:05:23Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@kazuho I think your point in the PR is quite valid. However it's probably worth noting that having explicit not_before / not_after that the client has to validate, is likely to make it very difficult, if not impossible, to deploy very-short-lived keys (say, in the order of a few hours), due to the fact that a significant portion of clients have shitty clocks (https://ai.google/research/pubs/pub46359), which affects forward secrecy.\r\n\r\nMaybe it should be noted in the spec as an appendix or something.",
          "createdAt": "2018-05-22T17:57:46Z",
          "updatedAt": "2018-05-22T17:57:46Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hmmm, thinking about this some more. In the \"split brain\" case @kazuho described in #23, the not_after is used to avoid having clients send an ESNI encrypted with an old key (as fetched from an out-of-date DNS server), to a TLS server that might have already switched to a new key (thus causing the connection to break).\r\n\r\nSo i'm guessing what happens is that the client would fallback to plaintext SNI if the key it fetched from DNS is expired. Though it seems to me this fallback could be dangerous for the client since they would end up exposing the SNI, but I can't come up with a practical way to exploit this (could be dependent on the specific deployment I guess).\r\n\r\nWhether this is something worth fixing is a different question, but an alternative to fix the split brain problem would be for the TLS server to somehow make sure the new key has been received by the DNS server, before discarding the old one.\r\n\r\nDid I understand the problem you described in #23 correctly @kazuho ?",
          "createdAt": "2018-05-22T20:18:23Z",
          "updatedAt": "2018-05-22T20:18:23Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@ghedo Thank you for your comments.\r\n\r\n> I think your point in the PR is quite valid. However it's probably worth noting that having explicit not_before / not_after that the client has to validate, is likely to make it very difficult, if not impossible, to deploy very-short-lived keys (say, in the order of a few hours), due to the fact that a significant portion of clients have shitty clocks (https://ai.google/research/pubs/pub46359), which affects forward secrecy.\r\n\r\nI think you are correct in stating that the ESNIKeys cannot have a very short lifetime. However, I would like to argue that the fact does not prevent server operators from rotating the keys frequently.\r\n\r\nServer operators can rotate the keys at the speed they like, as well as retiring them from the servers in any way.\r\n\r\n> So i'm guessing what happens is that the client would fallback to plaintext SNI if the key it fetched from DNS is expired. Though it seems to me this fallback could be dangerous for the client since they would end up exposing the SNI, but I can't come up with a practical way to exploit this (could be dependent on the specific deployment I guess).\r\n\r\nI agree with what happens.\r\n\r\nIn my view, ESNI is opportunistic encryption in sense that the unencrypted hostname is used when the ESNI resource record fails to reach the client (including the case of a middlebox dropping it intentionally).\r\n\r\nI would argue that using SNI in case of receiving an expired ESNI record is one of the failure modes in distributing the correct resource record. And therefore, I do not think that it is a security concern.\r\n\r\n> Whether this is something worth fixing is a different question, but an alternative to fix the split brain problem would be for the TLS server to somehow make sure the new key has been received by the DNS server, before discarding the old one.\r\n\r\nThat is correct. However, I fear that having such a requirement hinders us from using existing DNS deployments, because DNS authoritative servers are designed to favor availability over consistency, whereas in our case without `not_after`, we need consistency over availability.",
          "createdAt": "2018-05-23T02:02:02Z",
          "updatedAt": "2018-05-23T02:02:02Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Server operators can rotate the keys at the speed they like, as well as retiring them from the servers in any way.\r\n\r\nI didn't realize that was possible (that is, I kind of assumed servers would have to keep the key around until the not_after expired, but it's not actually written anywhere). In that case fine, though it might be worth clarifying.\r\n\r\nThe other concern I had was risking of turning this into another OCSP (where network failure and attack basically look the same so clients end up ignoring both), but I guess that with DoH, DPRIVE and DNSSEC an attack here is much harder to pull off. So all in all I don't have a strong opinion on not_before / not_after anymore.",
          "createdAt": "2018-06-01T19:15:50Z",
          "updatedAt": "2018-06-01T19:15:50Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is fine, @chris-wood please re-open if not.",
          "createdAt": "2018-07-02T14:17:59Z",
          "updatedAt": "2018-07-02T14:17:59Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "MDU6SXNzdWUzMjI4Njk1MDM=",
      "title": "Recast Fronting mode as Split Mode",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/28",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "Domain fronting already has a bad rap. Perhaps we should give this a new name to avoid pushback?",
      "createdAt": "2018-05-14T15:33:48Z",
      "updatedAt": "2018-05-22T14:18:55Z",
      "closedAt": "2018-05-22T14:18:55Z",
      "comments": [
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agree, Maybe \"Transparent\" mode? \"Proxy\" mode?",
          "createdAt": "2018-05-14T17:32:16Z",
          "updatedAt": "2018-05-14T17:32:16Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm going to go a step farther and suggest only defining shared mode in this document.\r\n\r\nit brings esni to the masses and eliminates the need for special tech to acheive classic fronting. That's a significant net-win without being weighed down by bias about fronting - I think we'll get more participation that way because the set of goals is easier to achieve consensus on (privacy is good!)\r\n\r\nIf folks need a separate document later to figure out they can tunnel based on the decrypted SNI then istm it can be separable.. true?\r\n",
          "createdAt": "2018-05-15T18:00:31Z",
          "updatedAt": "2018-05-15T18:00:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@mcmanus My reservation there is that, with only Shared Mode, a better design is probably to encrypt all of the extensions, and not just the SNI. With that change, it then later becomes infeasible to accomplish the front/hidden split. ",
          "createdAt": "2018-05-20T23:58:11Z",
          "updatedAt": "2018-05-20T23:58:11Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing via #45. @mcmanus if we want to keep only Shared Mode, let's use a new issue to track that.",
          "createdAt": "2018-05-22T14:18:55Z",
          "updatedAt": "2018-05-22T14:18:55Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "MDU6SXNzdWUzMjI5MDk3MzY=",
      "title": "Why single A and AAAA requirements?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/29",
      "state": "CLOSED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Regarding:\r\n```\r\nServers SHOULD configure DNS such that, upon querying a domain name with ESNI support, at most one each of A, AAAA, TXT ESNI, and ALTSVC {{?I-D.schwartz-httpbis-dns-alt-svc}} Resource Record is returned.\r\n```\r\nWhy is that a SHOULD? Does it apply to both fronting and shared mode?\r\n\r\nFor reference, Cloudflare almost always sends at least two A and AAAA answers for every question.\r\n\r\n(I get that it's not a MUST, though I'd also like to understand what the reasoning is in the first place)",
      "createdAt": "2018-05-14T17:27:10Z",
      "updatedAt": "2018-05-14T22:50:01Z",
      "closedAt": "2018-05-14T22:50:01Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood ??",
          "createdAt": "2018-05-14T19:51:09Z",
          "updatedAt": "2018-05-14T19:51:09Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The idea was to simplify key management. If multiple A or AAAA records are returned, the server needs to ensure each server behind those addresses have all the necessary keys. ",
          "createdAt": "2018-05-14T19:52:31Z",
          "updatedAt": "2018-05-14T19:52:31Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood I see, I'd rather the spec said that instead of trying to impose limits (I made #31 with suggested fix).",
          "createdAt": "2018-05-14T22:18:56Z",
          "updatedAt": "2018-05-14T22:18:56Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@ghedo works for me :)",
          "createdAt": "2018-05-14T22:28:59Z",
          "updatedAt": "2018-05-14T22:28:59Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "MDU6SXNzdWUzMjI5MzE2MjA=",
      "title": "Rename ESNIKeys to something more generic",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/30",
      "state": "CLOSED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "With #22 merged, I wonder if the ESNIKeys struct should just be renamed to something not specific to ESNI, but something more like \"generic TLS config in DNS\" so that it can be more cleanly reused by unrelated features.\r\n\r\n\"ServerConfiguration\" comes to mind from the early TLS 1.3 days.",
      "createdAt": "2018-05-14T18:33:48Z",
      "updatedAt": "2018-05-17T19:56:27Z",
      "closedAt": "2018-05-17T19:56:27Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "If we were to re-use these keys for other purposes, that seems fine. However, I'm not sure we want to do that. Semi-static keys, for example, should ideally be separate.",
          "createdAt": "2018-05-14T21:41:23Z",
          "updatedAt": "2018-05-14T21:41:23Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The keys yes, but I imagine the extensions field can hold \"arbitrary\" data, so while the keys would be ESNI-specific, you could also include extensions that have nothing to do with ESNI.",
          "createdAt": "2018-05-14T21:59:22Z",
          "updatedAt": "2018-05-14T21:59:22Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thinking about this some more, this would also require changing the \"_esni.\" prefix to something else.\r\n\r\nIn any case I can see how this might be out of scope for this spec. In the end it's a matter of deciding whether future TLS extensions that need similar DNS records, should be able to reuse the same structure (so no additional TXT record with its own prefix would be required), or if they should define their own structure (and have a separate TXT record).\r\n\r\nI'm happy to close this if it goes too much out of scope.",
          "createdAt": "2018-05-14T22:27:54Z",
          "updatedAt": "2018-05-14T22:27:54Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Right, I think it's verging on being out of scope. What do others think? @kazuho @ekr?",
          "createdAt": "2018-05-14T22:28:37Z",
          "updatedAt": "2018-05-14T22:28:37Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "My preference goes to keeping the name as-is, considering the fact that the role of ESNIKeys is  (at least for the moment) to negotiate properties between the client and the fronting server (not the hidden server), and that the only property we need to negotiate between the two is the information necessary for ESNI protection.\r\n\r\nIt is true that the DNS record can covey properties related to the hidden server (as you know, I've argued for using it to carry the server certificate chain). But IMO that's a change of concept, and I prefer keeping the concept simple for the time being.",
          "createdAt": "2018-05-14T22:55:51Z",
          "updatedAt": "2018-05-14T22:55:51Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok.",
          "createdAt": "2018-05-17T19:56:27Z",
          "updatedAt": "2018-05-17T19:56:27Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "MDU6SXNzdWUzMjMzMTUwODg=",
      "title": "Add text comparing ESNI to alternative approaches",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/32",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Others include those discussed in I-D.ietf-tls-sni-encryption and the H2-layer approach with secondary certs.",
      "createdAt": "2018-05-15T17:35:54Z",
      "updatedAt": "2018-07-02T14:18:08Z",
      "closedAt": "2018-07-02T14:18:08Z",
      "comments": []
    },
    {
      "number": 33,
      "id": "MDU6SXNzdWUzMjMzMTYyMjE=",
      "title": "Add text regarding fallback",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/33",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-15T17:39:26Z",
      "updatedAt": "2018-10-21T20:36:28Z",
      "closedAt": "2018-10-21T20:36:28Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Any on-path active attacker can send an unsigned alert in response to a CH it doesn't like, so perhaps it's best just to acknowledge this. ",
          "createdAt": "2018-05-15T17:43:08Z",
          "updatedAt": "2018-05-15T17:43:08Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "More than acknowledge this, should we make a recommendation as to whether the client should fail hard or fallback to unencrypted SNI?",
          "createdAt": "2018-05-16T06:48:31Z",
          "updatedAt": "2018-05-16T06:48:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@DavidSchinazi I don't think so. ",
          "createdAt": "2018-05-16T22:03:13Z",
          "updatedAt": "2018-05-16T22:03:13Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Can you elaborate?",
          "createdAt": "2018-05-16T23:59:19Z",
          "updatedAt": "2018-05-16T23:59:19Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "AFAIK, the 1.3 draft makes no recommendation for dealing with this particular problem, and so I think we shouldn't do so here, either.",
          "createdAt": "2018-05-17T19:49:22Z",
          "updatedAt": "2018-05-17T19:49:22Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Do you mean fallback to TLS 1.2 or fallback to unencrypted SNI? The latter is a new privacy concern that arises in this document so we may want recommendations for that one.",
          "createdAt": "2018-05-17T20:21:28Z",
          "updatedAt": "2018-05-17T20:21:28Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I see little difference between those fallbacks since they're triggered the same way. So I would prefer to simply acknowledge the problem and nothing more.",
          "createdAt": "2018-05-17T20:24:50Z",
          "updatedAt": "2018-05-17T20:24:50Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Acknowledging is fine if you explain the properties so implementers can make an informed decision knowing the consequences. Also these fallbacks are very different in my mind. TLS 1.3->1.2 has downgrade prevention, whereas once you've fallen back to unencrypted SNI it's too late you've leaked it.",
          "createdAt": "2018-05-17T20:35:59Z",
          "updatedAt": "2018-05-17T20:38:31Z"
        },
        {
          "author": "mhofman",
          "authorAssociation": "NONE",
          "body": "I agree there may be a risk of leaking SNI here.\r\n\r\nIf an attacker is on the path between the client and fronting server, it is capable of forcing a downgrade to a TLS 1.2 connection. Even if such downgrade might ultimately cause the connection to fail, some clients could be tricked into revealing the unencrypted server name.\r\n\r\nWhile the [Section 6.1. Misconfiguration](https://github.com/ekr/draft-rescorla-tls-esni/blob/master/draft-ietf-tls-esni.md#misconfiguration) states that `Clients SHOULD NOT fall back to cleartext SNI, because that allows a network attacker to disclose the SNI`, there is a risk that the client implementation would just switch to a 1.2 mode that completely omits any ESNI logic.\r\n\r\nThe middlebox section also focuses mostly on the stripping of the explicit encrypted_server_name extension. In a downgrade scenario, the stripping could be implicitly performed by the client.\r\n\r\nI think there should be a more explicit protection against MITM middleboxes that force a downgrade of the connection to 1.2.",
          "createdAt": "2018-09-27T19:24:05Z",
          "updatedAt": "2018-09-27T19:24:05Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "We now forbid negotiating 1.2.",
          "createdAt": "2018-10-21T20:36:28Z",
          "updatedAt": "2018-10-21T20:36:28Z"
        }
      ]
    },
    {
      "number": 34,
      "id": "MDU6SXNzdWUzMjMzMjcxMDE=",
      "title": "altsvc",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/34",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I suggest dropping the references to Ben's individual alt-svc in DNS draft.. it hasn't been adopted and its future is murky.\r\n\r\nactual alt-svc (the non dns kind) actually requires the use of the plaintext SNI. As those are both cachable and connections to new IP addresses (less linkable) you could consider updating it with mike bishop's https://tools.ietf.org/html/draft-bishop-httpbis-sni-altsvc-01 (also an individual draft atm)\r\n\r\n",
      "createdAt": "2018-05-15T18:13:00Z",
      "updatedAt": "2018-05-17T20:29:24Z",
      "closedAt": "2018-05-17T20:29:24Z",
      "comments": [
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood also suggested that the reference might not be needed in https://github.com/ekr/draft-rescorla-tls-esni/pull/31#discussion_r188117285 so I made #44 to actually remove it.",
          "createdAt": "2018-05-17T20:01:41Z",
          "updatedAt": "2018-05-17T20:01:41Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "MDU6SXNzdWUzMjMzMzM1OTk=",
      "title": "define rules for cname (aka multi-cdn or multi-cloud)",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/35",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "traditional SNI is the origin name. You can use an HTTP connect tunnel, traverse a CNAME (or 3), or engage in some alt-svc load balancing and, while these things all change the DNS name you lookup and connect() to, they don't change the SNI.\r\n\r\nwhat about eSNI? the keys are a property of the server, not really the origin. It seems really hard to coordinate this across administrative domains.\r\n\r\nThe case I'm particularly worried about is where more than one hosting provider is in the mix.. ISTM a typical way of doing this is LB'ing DNS responses with CNAMEs. (e.g. 50% of www.example.com gets CNAME www.cdnA.com and 50% gets www.cdnB.com).. We've got folks from 2 CDNs as active contributors here who know better than I, but this kind of level of indirection to get you CDN agility seems pretty common.. we would want cdnA and cdnB to be able to each use their own keys.\r\n\r\nEven without agility, its a pretty common pattern for an origin to maintain control of their own DNS and only delegate to a CDN under load/whatnot and do that via cname...\r\n\r\nthat argues to me to allow _esni TXT records on the server lookup, not just the origin name. Perhaps they could override the _esni at the origin scope but that seems like a way to trigger the misconfiguration fallback path.\r\n\r\nAlso, what about connect tunnels where you do do SNI, but don't traditionally do DNS at all?\r\n\r\n",
      "createdAt": "2018-05-15T18:32:29Z",
      "updatedAt": "2019-06-05T14:51:05Z",
      "closedAt": "2019-06-05T14:51:05Z",
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "rfc 1034 (I cannot figure out if this provision has been udpated) says\r\n\r\nThe domain system provides such a feature using the canonical name\r\n(CNAME) RR.  A CNAME RR identifies its owner name as an alias, and\r\nspecifies the corresponding canonical name in the RDATA section of the\r\nRR.  If a CNAME RR is present at a node, no other data should be\r\npresent; this ensures that the data for a canonical name and its aliases\r\ncannot be different.  This rule also insures that a cached CNAME can be\r\nused without checking with an authoritative server for other RR types.\r\n",
          "createdAt": "2018-05-15T19:03:20Z",
          "updatedAt": "2018-05-15T19:03:20Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I guess there is also the question of whether a txt query of _esni.www.example.com can return a CNAME even if www.exmaple.com returned A/AAAA (which would seem to be a good way to keep your keys straight.)\r\n\r\n",
          "createdAt": "2018-05-15T19:05:46Z",
          "updatedAt": "2018-05-15T19:05:46Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> I guess there is also the question of whether a txt query of _esni.www.example.com can return a CNAME even if www.exmaple.com returned A/AAAA (which would seem to be a good way to keep your keys straight.)\r\n\r\nWe need to allow this. As you said, certain CDNs do not provide DNS as a service and their customers use their own DNS. Please see my comment on https://github.com/ekr/draft-rescorla-tls-esni/issues/7#issuecomment-388531906.\r\n\r\nRegarding the multi-CDN use-case, I do not think there is a easy solution.\r\n\r\nOne way of supporting that kind of configuration will be to do the following:\r\n1. (instead of querying for A and _eni) client only queries for A. Let's consider example.com is queried for and 1.2.3.4 is returned.\r\n2. client then connects to the return address via https to obtain the ESNIKeys (i.e. https://1.2.3.4/.well-known/esni-keys/example.com\r\n3. client connects to 1.2.3.4 with ESNI specifying \"example.com\"\r\n\r\nBut this has more overhead, looks more like TLS tunneling...\r\n\r\nHonestly, I'd prefer to not covering multi-CDN use-case. IIUC it's mostly for entertainment content. They need least protection, to the extent to which some believe that serving using plaintext HTTP is fine.",
          "createdAt": "2018-05-15T20:38:28Z",
          "updatedAt": "2018-05-15T20:38:28Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "we need to document that when a.example.com -> cname b.example.com the TXT record that is looked up is _esni.b.example.com\r\n\r\nWe also need to document that when _esni.b.example.com is a CNAME to c.example.com the TXT record is recursively looked up from c.example.com not _esni.c.example.com. (If they want that behavior the CNAME should be from b.example.com to c.example.com).\r\n",
          "createdAt": "2018-07-03T15:58:48Z",
          "updatedAt": "2018-07-03T15:58:48Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> we need to document that when a.example.com -> cname b.example.com the TXT record that is looked up is _esni.b.example.com\r\n\r\nI am not sure if using an _intermediate_ result of address resolution as a key to obtain ESNI is a good approach. Rather, I would argue that `_esni.a.example.com` should be used in that case, due to the following reasons:\r\n\r\n* some APIs used for querying a hostname (or a DNS record) might resolve CNAME's by itself\r\n  * `getaddrinfo` is one of such APIs, though it does not provide you the ability to query TXT records\r\n* we can fully parallelize the address resolution and the ESNI key resolution if we select `_esni.original-host` as the name\r\n\r\nIf we are _not_ going to use the original hostname, I wonder if we could use the final result rather than the intermediate result (e.g., assuming that a.example.com results to 192.0.2.1, query `_esni.1.2.0.192.in-addr.apa`). That solves the API issue and the multi-CDN use-case, with the downside being that the queries cannot be parallelized.",
          "createdAt": "2018-07-04T01:15:43Z",
          "updatedAt": "2018-07-04T01:15:43Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with @kazuho.  You start with A/AAAA requests to example.com and TXT requests to _esni.example.com and see where each leads you.  The point about _esni. using CNAME to point to a leaf that might not have the underscore is valuable.",
          "createdAt": "2018-07-04T02:36:07Z",
          "updatedAt": "2018-07-04T02:36:07Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "the use case not being captured is when www.example.com is a cname to\nwww.cdn-a.com (and at other times a cname to www.cdn-b.com). presumably the\nonus to manage their key records falls on cdn-a and cdn.b and should\nrequire example.com to be managing the _esni record. (example.com may not\neven be aware which cdn is currently doing esni)\n\n\nOn Tue, Jul 3, 2018 at 10:36 PM, Martin Thomson <notifications@github.com>\nwrote:\n\n> I agree with @kazuho <https://github.com/kazuho>. You start with A/AAAA\n> requests to example.com and TXT requests to _esni.example.com and see\n> where each leads you. The point about _esni. using CNAME to point to a leaf\n> that might not have the underscore is valuable.\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ekr/draft-rescorla-tls-esni/issues/35#issuecomment-402345849>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAP5s1q0uoHCz_HMIKovuOw4eQ1kRflNks5uDCoXgaJpZM4UADk5>\n> .\n>\n",
          "createdAt": "2018-07-04T02:48:26Z",
          "updatedAt": "2018-07-04T02:48:26Z"
        },
        {
          "author": "sludin",
          "authorAssociation": "NONE",
          "body": "I know this is three months old, but did the CDN case get landed?  Entities using multiple CDNs, or even an entity flipping between using a CDN and not is a reality that needs to be fully thought through.  Reading through the tickets and RFC I am concerned about:\r\n  - The apparent need to share the private key between entities\r\n  - The possibility of the TXT or RR record returning information for one CDN and then the A record returning information for another (in cases where there are multiple keys).\r\n\r\n",
          "createdAt": "2018-10-04T18:36:15Z",
          "updatedAt": "2018-10-04T18:36:15Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@mcmanus I think this issue is resolved. Can you please confirm and close if so?",
          "createdAt": "2019-06-02T14:56:18Z",
          "updatedAt": "2019-06-02T14:56:18Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as resolved. Please re-open if something's still needed!",
          "createdAt": "2019-06-05T14:51:05Z",
          "updatedAt": "2019-06-05T14:51:05Z"
        }
      ]
    },
    {
      "number": 37,
      "id": "MDU6SXNzdWUzMjM0Mjg1MDE=",
      "title": "Remove the fronting / hidden server distinction",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/37",
      "state": "CLOSED",
      "author": "kontaxis",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In 3.1 Topologies, in Shared Mode topology the fronting and hidden servers are one and the same.\r\n\r\nFronting Mode Topology is described as \"... might not be the origin for any domains, but as a practical matter, it is probably the origin for a large set of innocuous domains\".\r\n\r\nWhy are some domains innocuous and others aren't?\r\nIs it ok for an attacker (adversary) to discover innocuous domains names?\r\n\r\nInnocuous domain names may provide cover when the threat model includes censorship.\r\nIs this what you are trying to solve here?\r\nIsn't that orthogonal to ESNI, i.e., architectures where there is a cover reason why a client is communicating with a server? (because it's a known CDN or sth)\r\n\r\n\r\nIn 5.2 Fronting Server Behavior the text says \"Upon determining the true SNI, the fronting server then either serves the connection directly (if in Shared Mode), in which case it executes the steps in the following section, or forwards the TLS connection to the hidden server (if in Fronting Mode).\"\r\n\r\n... or decrypts the TLS connections and forwards plain text traffic to the hidden server. (Bad idea I know)\r\nThe question is why should this document describe what happens after a TLS connection is established between a client and server? Seems to deviate from the problem this document is trying to address. (See below)\r\n\r\n\r\nIntroduction implicitly defines the problem as \"an on-path attacker to determine the domain name\"\r\nThis is always true with ESNI between the client and fronting server.\r\nAll domain names are hidden, innocuous, non-innocuous, hosted in the fronting or some other server.\r\n\r\nI would propose to drop any mention of hidden servers or deployment architectures, just say \"server\" and in Security Considerations mention that a server SHOULD be configured in a way that it does not leak the identities of domains it wants to protect. I.e., when the SNI / ESNI extension is missing the server SHOULD not return a certificate for a protected site. For example CDNs should just return a certificate for their own domain.",
      "createdAt": "2018-05-16T00:26:15Z",
      "updatedAt": "2018-07-02T14:18:59Z",
      "closedAt": "2018-07-02T14:18:59Z",
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "see also #28 ",
          "createdAt": "2018-05-16T02:43:50Z",
          "updatedAt": "2018-05-16T02:43:50Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "We ended up changing the terminology here.",
          "createdAt": "2018-07-02T14:18:59Z",
          "updatedAt": "2018-07-02T14:18:59Z"
        }
      ]
    },
    {
      "number": 38,
      "id": "MDU6SXNzdWUzMjM0Mjk0NzQ=",
      "title": "Make ESNI TLS 1.2 compatible",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/38",
      "state": "CLOSED",
      "author": "kontaxis",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "ESNI seems to rely on TLS 1.3 KeyShareEntry which makes it incompatible with TLS 1.2.\r\n\r\nThat's unfortunate with that \"The protocol designed in this document is quite straightforward.\"\r\n\r\nThe gist of ESNI comes down to \"encrypted_server_name extension, which contains the true extension encrypted under the provider\u2019s public key.\"\r\n\r\nThat seems pretty generic and backwards compatible.",
      "createdAt": "2018-05-16T00:32:42Z",
      "updatedAt": "2018-05-18T13:18:46Z",
      "closedAt": "2018-05-18T13:18:45Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "To prevent cut-and-paste attacks, you need to bind ESNI to the CH. That means we\u2019d need 1.2 clients to send a key share in the CH to use when deriving encryption keying material, and that\u2019s not currently done. ",
          "createdAt": "2018-05-16T00:46:43Z",
          "updatedAt": "2018-05-16T00:46:43Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Since TLS 1.2 sends the server certificate in plaintext it seems like ESNI wouldn't be particularly useful there anyway, no?",
          "createdAt": "2018-05-18T08:29:25Z",
          "updatedAt": "2018-05-18T08:29:25Z"
        },
        {
          "author": "kontaxis",
          "authorAssociation": "NONE",
          "body": "Indeed. I guess someone could argue about wildcard certificates or when multiple names are present but the names are usually related so I agree there\u2019s no significant benefit from encrypting the SNI.",
          "createdAt": "2018-05-18T13:18:45Z",
          "updatedAt": "2018-05-18T13:18:45Z"
        }
      ]
    },
    {
      "number": 39,
      "id": "MDU6SXNzdWUzMjM0MzEyMTA=",
      "title": "Reuse RFC 6066 ServerName extension / Do not define a new extension",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/39",
      "state": "CLOSED",
      "author": "kontaxis",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "6.2 Middleboxes identifies a legitimate concern where middleboxes might strip a new ESNI extension that is unknown to them.\r\n\r\nThe ServerName structure as defined in RFC 6066 has an 8-bit NameType field where 0 is defined as host_name and all other values are undefined. Why not define 1 (or any other value) as encrypted_host_name?\r\n\r\nThe name structure inside ServerName is 16 opaque bits which seems able to accommodate EncryptedSNI as defined in this document. (Make encrypted_sni slightly smaller so that \"label\" and \"suite\" fit)",
      "createdAt": "2018-05-16T00:44:07Z",
      "updatedAt": "2018-05-16T06:32:28Z",
      "closedAt": "2018-05-16T06:32:27Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "I prefer having a different extension, because we do not want to limit the capability of ESNIKeys to just protecting the \"HostName\" (as identified by the 8-bit NameType field of zero).  IMO it is better to have a mechanism that can protect any type of \"server-name\", including those covered by NameTypes other than zero.\r\n\r\nNote that DNS is just one way of publishing ESNIKeys.",
          "createdAt": "2018-05-16T03:40:23Z",
          "updatedAt": "2018-05-16T03:40:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with @kazuho.",
          "createdAt": "2018-05-16T03:53:42Z",
          "updatedAt": "2018-05-16T03:53:42Z"
        },
        {
          "author": "kontaxis",
          "authorAssociation": "NONE",
          "body": "I didn't mean for ESNI to only apply to NameType 0.\r\n\r\nThere are 256 values, 0 is host_name, 1 can be encrypted_server_name, and there are 254 more values for additional types of server name types. Going forward I doubt someone will define a plain text type that will have to be protected. But even if that happens encrypted_server_name can encapsulate all name types but itself.\r\n\r\nP.S.: Not really sure how the use of DNS is a factor here.",
          "createdAt": "2018-05-16T04:15:37Z",
          "updatedAt": "2018-05-16T04:15:37Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Recall that SNI extensibility is [irrevocably busted](https://mailarchive.ietf.org/arch/msg/tls/1t79gzNItZd71DwwoaqcQQ_4Yxc).",
          "createdAt": "2018-05-16T06:03:36Z",
          "updatedAt": "2018-05-16T06:03:36Z"
        },
        {
          "author": "kontaxis",
          "authorAssociation": "NONE",
          "body": "Fair enough.",
          "createdAt": "2018-05-16T06:32:27Z",
          "updatedAt": "2018-05-16T06:32:27Z"
        }
      ]
    },
    {
      "number": 40,
      "id": "MDU6SXNzdWUzMjM0ODgzOTE=",
      "title": "Consider using a new DNS RR Type instead of TXT",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/40",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The current document uses the TXT record for `_esni.example.org`. This will cause multiple issues.\r\n\r\n1) There is no IANA registry for prefixes that start with underscores to be used in DNS, so it is valid for existing servers to already be using _esni as part of the FQDN.\r\n2) The TXT record was designed to hold descriptive text, which means operators can already be using it for other descriptions.\r\n3) As described in issue #35 , using a prefix breaks CNAME.\r\n4) TXT requires base64 encoding which adds overhead on the network and recursive resolvers.\r\n\r\nThe generally recommended way to \"stuff it in the DNS\" is to create a new RR type for your data. For example DANE established RR type TLSA (52). There is room in the 16bit IANA registry for another value. The key here is that this prevents systems from misinterpreting the TXT record as something else, and it prevents systems from already using it for something else\r\n\r\nhttps://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-4",
      "createdAt": "2018-05-16T06:46:43Z",
      "updatedAt": "2018-05-16T21:59:06Z",
      "closedAt": "2018-05-16T21:59:06Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "That was previously discussed in #7.",
          "createdAt": "2018-05-16T07:03:09Z",
          "updatedAt": "2018-05-16T07:03:09Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See https://www.ietf.org/internet-drafts/draft-ietf-dnsop-attrleaf-fix-00.txt regarding the use of underscore names.",
          "createdAt": "2018-05-16T07:23:52Z",
          "updatedAt": "2018-05-16T07:23:52Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for those links, I had missed #7. This makes sense to me. I makes me somewhat uncomfortable to abuse TXT this way but I understand the operational concerns. Feel free to close this issue.",
          "createdAt": "2018-05-16T17:42:16Z",
          "updatedAt": "2018-05-16T17:42:16Z"
        }
      ]
    },
    {
      "number": 41,
      "id": "MDU6SXNzdWUzMjM0OTA2MjQ=",
      "title": "Clarify downsides of encrypting ALPN with the same key as SNI",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/41",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "This seems to be somewhat discussed in the draft and in issues, but I fail to see the motivation behind not using the ESNI key to encrypt other extensions such as ALPN. The main concern seems to be around entities seeing the value of decrypted ALPN, but that's still better than ALPN being the clear. Another concern is a middlebox blocking this extension, but if the client decides to fail hard, blocking is better than leaking; and if a client falls back to unencrypted then the connection works regardless. If I'm missing something, can that be clarified in the draft?",
      "createdAt": "2018-05-16T06:56:12Z",
      "updatedAt": "2020-10-16T17:14:14Z",
      "closedAt": "2019-07-08T17:26:24Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that the goal with ALPN is to ensure that the set of values that are advertised remains small and fixed.  That is, everyone can offer h2+http/1.1 and no more.  This gives no advantage to a passive observer in terms of distinguishing traffic; the pattern of TLS extensions (order and so forth) gives more away.",
          "createdAt": "2018-07-03T05:15:46Z",
          "updatedAt": "2018-07-03T05:15:46Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "The other point is that SNI designates the server the client wants to handshakes with. ALPN (as well as other properties of ClientHello) is a property of the handshake.\r\n\r\nConsider the split case. SNI is decrypted by the fronting server. ALPN will be a property that will be taken into consideration by the backend server.",
          "createdAt": "2018-07-03T05:23:06Z",
          "updatedAt": "2018-07-03T05:25:13Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that in current usage, ALPN is only used for h2 vs http/1.1. But if we had a way to hide ALPN from censors, we could use it to run a VPN over TLS to evade censorship - I'd like to have a TLS server on port 443 that mostly serves HTTPS but can also serve VPN to select clients.\r\n\r\nIn the split case, having the fronting server decrypt the ALPN and pass it decrypted to the backend server is fine - I'm mostly concerned about threats between the client and the fronting server.",
          "createdAt": "2018-07-03T05:32:33Z",
          "updatedAt": "2018-07-03T05:32:33Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> In the split case, having the fronting server decrypt the ALPN and pass it decrypted to the backend server is fine\r\n\r\nCurrent draft is designed in a way to allow stock TLS servers to be run as a hidden server. Creating a way to pass the decrypted ALPN (or decrypted SNI) from the client-facing server to hidden server destroys that design.\r\n\r\nGenerally speaking, I am not opposed to protecting more properties. OTOH, I might prefer doing things in small steps; we have the extensions field in ESNIKeys.",
          "createdAt": "2018-07-03T06:04:40Z",
          "updatedAt": "2018-07-03T06:04:53Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@DavidSchinazi, if you want to advertise a VPN ALPN on all your connections, then that would work.  I'd prefer to establish privacy-preserving usage patterns as the norm so that this is considered acceptable (and not a reason to block a connection).  Advertising a willingness to use a VPN connection in addition to HTTP would be analogous to what we're doing here; the observer doesn't know what you ended up using.  They could decide to block based on the possibility that you are doing something bad, but that applies to encrypted SNI in equal measure.",
          "createdAt": "2018-07-03T10:17:44Z",
          "updatedAt": "2018-07-03T10:17:44Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This sounds reasonable to me. If we build this solution in a way that allows us to encrypt ALPN later without it being distinguishable from ESNI by a MitM, then I'm happy \ud83d\ude04 ",
          "createdAt": "2018-07-03T20:19:34Z",
          "updatedAt": "2018-07-03T20:19:34Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@DavidSchinazi this should be fixed by #169 -- please reopen if that's not the case!",
          "createdAt": "2019-07-08T17:26:24Z",
          "updatedAt": "2019-07-08T17:26:24Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood #169 works for me, thanks.",
          "createdAt": "2019-07-08T18:18:13Z",
          "updatedAt": "2019-07-08T18:18:13Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "MDU6SXNzdWUzMjM0OTE0Njg=",
      "title": "Fronting server forwarding the TLS connection is unclear",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/42",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "From the \"Fronting Server Behavior\" section:\r\n\r\n> the fronting server then [...] forwards the TLS connection to the hidden server\r\n\r\nThis is not very clearly defined. Does the fronting server not make any changes to the client hello? Doesn't it remove the encrypted SNI extension and/or possibly add a cleartext SNI as discussed in \"Communicating SNI to Hidden Server\"?",
      "createdAt": "2018-05-16T06:59:54Z",
      "updatedAt": "2018-07-02T14:20:43Z",
      "closedAt": "2018-07-02T14:20:43Z",
      "comments": []
    },
    {
      "number": 47,
      "id": "MDU6SXNzdWUzMjU4OTIzMTQ=",
      "title": "pad the certificate too",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/47",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-23T22:12:20Z",
      "updatedAt": "2018-07-02T14:17:23Z",
      "closedAt": "2018-07-02T14:17:23Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson addressed by #48?",
          "createdAt": "2018-06-15T21:06:21Z",
          "updatedAt": "2018-06-15T21:06:21Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Mostly.  I left comments on the PR.  A few things to follow-up on.",
          "createdAt": "2018-06-15T23:28:44Z",
          "updatedAt": "2018-06-15T23:28:44Z"
        }
      ]
    },
    {
      "number": 61,
      "id": "MDU6SXNzdWUzMzc5NjQwOTQ=",
      "title": "Is DNS query for server or origin",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/61",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The TLS server name (and thus SNI) is the HTTP origin name, however it is not necessarily the same as the host name of the TLS server. HTTP Alternative Services is the obvious way that happens - but Alt-Svc never changes the origin name.\r\n\r\nWhen fetching the ESNI key, do we fetch it from _esni.origin-name or _esni.host-name?\r\n\r\nI think origin-name makes more sense - keeping everything that is an expiicit protocol element in terms of origin eliminates confusion.\r\n\r\nthe counter argument is that you can use alt-svc to do fine grained fanout to providers with different keys (using cdn specific names for them in alt-svc) in a way that is harder to do through the origin name dns controls.",
      "createdAt": "2018-07-03T16:06:46Z",
      "updatedAt": "2018-10-21T20:52:41Z",
      "closedAt": "2018-10-21T20:52:41Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "My view is that the base name that is used to lookup the ESNI value (i.e. the name excluding the `_esni.` prefix) must be the same as the hostname that is carried by the ESNI extension.\r\n\r\nESNI is a replacement for SNI, and I think that the design should allow the TLS stack to obtain the ESNI key by itself (i.e. by querying `_esni.<sni-name>`).",
          "createdAt": "2018-07-12T02:28:22Z",
          "updatedAt": "2018-07-12T02:28:34Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "PS. To give an example, golang's TLS API to establish a new connection looks like below.\r\n```\r\nconn, err := tls.Dial(\"tcp\", \"mail.google.com:443\", &tls.Config{\r\n    RootCAs: roots,\r\n})\r\n```\r\n\r\nAs is obvious from the example, name resolution happens inside the TLS stack. I'd assume that we would want to handle ESNI record lookup within the stack as well.\r\n\r\nTherefore, the name used to lookup the ESNI record cannot be the origin name, which is specific to the behavior defined in HTTP (alt-svc), which operates above the TLS stack. It needs to be the hostname that is used for the name resolution (or a name that is derived from that).\r\n\r\nMy understanding is that TLS stacks on other programming language often has the same abstraction; i.e. handle name resolution inside in the TLS connection establishment call (or the TCP connection establishment call).",
          "createdAt": "2018-07-12T03:47:28Z",
          "updatedAt": "2018-07-12T03:54:58Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> My view is that the base name that is used to lookup the ESNI value (i.e. the name excluding the `_esni.` prefix) must be the same as the hostname that is carried by the ESNI extension.\r\n> \r\n\r\nto be clear - that is the origin name. In the case of alt-svc, where the host name and the origin name diverge, the SNI remains the origin name. This is also the identity that the client stack will authenticate. The host name is resolved to get a a/aaaa but never appears on the wire.\r\n\r\n> ESNI is a replacement for SNI, and I think that the design should allow the TLS stack to obtain the ESNI key by itself (i.e. by querying `_esni.<sni-name>`).\r\n\r\nThis matches my opinion, and also what firefox nightly is currently doing.. but I'm confused by your next comment\r\n\r\n> PS. To give an example, golang's TLS API to establish a new connection looks like below.\r\n> \r\n> ```\r\n> conn, err := tls.Dial(\"tcp\", \"mail.google.com:443\", &tls.Config{\r\n>     RootCAs: roots,\r\n> })\r\n> ```\r\n> As is obvious from the example, name resolution happens inside the TLS stack. I'd assume that we would want to handle ESNI record lookup within the stack as well.\r\n\r\nafaict the SNI information actually comes from tls.Config (Falling back to mail.google.com only if not provided).. this is no doubt also the information used to authenticate the cert.. https://golang.org/src/crypto/tls/tls.go?s=3255:3347#L88\r\n\r\nThe TLS stack is going to need both pieces of information. So which should it use?\r\n> \r\n> Therefore, the name used to lookup the ESNI record cannot be the origin name, which is specific to the behavior defined in HTTP (alt-svc), which operates above the TLS stack. \r\n\r\nno - the origin name is the SNI name even with alt-svc. It might not be the host name.\r\n\r\n> It needs to be the hostname that is used for the name resolution (or a name that is derived from that).\r\n> \r\n\r\nI think that's defensible but for different reasons (key management flexibility). but I would argue against this as we don't really want you using large sets of keys\r\n\r\n> My understanding is that TLS stacks on other programming language often has the same abstraction; i.e. handle name resolution inside in the TLS connection establishment call (or the TCP connection establishment call).\r\n\r\nIf a stack can't support alt-svc, then this isn't a problem - the name is the same everywhere :)\r\n\r\nIf a stack does support alt-svc then it has 2 names to deal with.. one is the name used for SNI and auth, and the other is the one used for TCP. (or perhaps it doesn't do TCP on its own).\r\n\r\nAll this issue is trying to do is decide whether the name we lookup for ENSNI/TXT is the same as the name we lookup for A/AAAA.. I'm going to say that they don't necessarily have to match. (i.e. your A could be for the alt-svc but your txt/esni is always going to be for the origin - which is the same thing you put in your CH.\r\n\r\nI'll make a pr.",
          "createdAt": "2018-10-17T22:13:40Z",
          "updatedAt": "2018-10-17T22:13:40Z"
        }
      ]
    },
    {
      "number": 62,
      "id": "MDU6SXNzdWUzMzgzOTQ1Mzg=",
      "title": "Note about checking zero padding",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/62",
      "state": "CLOSED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Require that the server check that everything after ServerNameList is zero.",
      "createdAt": "2018-07-05T00:28:46Z",
      "updatedAt": "2018-10-21T20:41:00Z",
      "closedAt": "2018-10-21T20:41:00Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed.",
          "createdAt": "2018-10-21T20:38:55Z",
          "updatedAt": "2018-10-21T20:38:55Z"
        }
      ]
    },
    {
      "number": 63,
      "id": "MDU6SXNzdWUzMzg0MjQ5Njc=",
      "title": "Versioning for the record?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/63",
      "state": "CLOSED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Do we need it.",
      "createdAt": "2018-07-05T04:39:04Z",
      "updatedAt": "2018-09-16T20:03:24Z",
      "closedAt": "2018-09-16T20:03:24Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "For ESNIKeys (the DNS record) I do not think we need a version for the following reasons:\r\n* I think we would prefer adding extensions rather than making incompatible changes\r\n* we always have the freedom to pick a new prefix (e.g. `_esni2`) or a new RR type when making incompatible changes\r\n  * an incompatible change will require the client to query for two DNS records anyways\r\n\r\nFor the ESNI extension, I also do not think that we need a version field. When we define an extension sometime in the future, we could the advertise the support as an extension in the ESNIKeys to instruct the clients that support that extension to send a CH extension that uses a different extension ID than the ESNI extension.",
          "createdAt": "2018-07-05T06:05:15Z",
          "updatedAt": "2018-07-05T06:05:15Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> an incompatible change will require the client to query for two DNS records anyways\r\n\r\nA lot of other TXT records have a version in them.  It turns out that if you do that you can query for TXT records and get multiple answers back.  Then, you pick those with the version you like.  That's one query.\r\n\r\nI'm tempted to suggest that the first octet (or two) be used for a version number.  It's cheap.",
          "createdAt": "2018-07-05T09:39:40Z",
          "updatedAt": "2018-07-05T09:39:40Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm concerned about how we iterate on these in the field. They're not tied to TLS version, so what if we decide to change the formats, as we are discussing in #67 ",
          "createdAt": "2018-07-05T12:18:08Z",
          "updatedAt": "2018-07-05T12:18:08Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "a magic number (including version) is a pretty decent idea. right now _esni is in its own namespace but you can imagine someone doing a txt record that applies to every dns response so we would want to disambiguate that as well.\r\n\r\ntake note to update the \"concat multiple records\" rule if we go down this path..",
          "createdAt": "2018-07-05T12:32:21Z",
          "updatedAt": "2018-07-05T12:32:21Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "I think that having version is a good idea in sense that it allows to do experiments before the standardization completes.",
          "createdAt": "2018-07-17T05:29:46Z",
          "updatedAt": "2018-07-17T05:29:46Z"
        }
      ]
    },
    {
      "number": 64,
      "id": "MDU6SXNzdWUzMzg0MjgxMDU=",
      "title": "checksum and extension hashes",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/64",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The hash used in the extension should use the same hash inputs as the checksum.  The difference here just makes using this harder.",
      "createdAt": "2018-07-05T05:04:37Z",
      "updatedAt": "2020-10-16T17:14:14Z",
      "closedAt": "2019-07-03T01:20:45Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "I support the change, if that makes people feel more comfortable about having the checksum field in ESNIKeys.",
          "createdAt": "2018-07-05T06:13:26Z",
          "updatedAt": "2018-07-05T06:13:26Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not opposed, but it doesn't help as much as you might think, because\nyou need to compute the label with the cipher hash and not (necessarily)\nwith SHA-256.\n\nOn Wed, Jul 4, 2018 at 11:13 PM, Kazuho Oku <notifications@github.com>\nwrote:\n\n> I support the change, if that makes people feel more comfortable about\n> having the checksum field in ESNIKeys.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ekr/draft-rescorla-tls-esni/issues/64#issuecomment-402616617>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ABD1oepUYCUrNp7wcZST5fvAOOHtpyfvks5uDa6HgaJpZM4VDQOE>\n> .\n>\n",
          "createdAt": "2018-07-05T12:16:24Z",
          "updatedAt": "2018-07-05T12:16:24Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So, if you take my suggestion in #142 (which I know @kazuho doesn't like, but we simply disagree about that), then you can identify the ESNI using a truncated hash that is calculated using the cipher hash because it only appears in the context of a handshake.  But that just suggests that this is either not-helpful because we chose not to do anything in #142, or it is not necessary because we did.  I'm OK closing this on that basis.",
          "createdAt": "2019-07-03T00:40:10Z",
          "updatedAt": "2019-07-03T00:40:10Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Checksum is now gone. Closing this issue. @martinthomson, thanks for filing it!",
          "createdAt": "2019-07-03T01:20:45Z",
          "updatedAt": "2019-07-03T01:20:45Z"
        }
      ]
    },
    {
      "number": 65,
      "id": "MDU6SXNzdWUzMzg0MjgzNjA=",
      "title": "checksum",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/65",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Does the advertisement really need a checksum?  It complicates things for questionable benefit.\r\n\r\nUse DNS-over-something-that-isn't-as-lame-as-UDP and this problem goes away.  You probably want DNS to be protected by TLS anyway.",
      "createdAt": "2018-07-05T05:06:36Z",
      "updatedAt": "2019-06-02T15:01:11Z",
      "closedAt": "2019-06-02T15:01:11Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed on https://github.com/ekr/draft-rescorla-tls-esni/pull/23 and https://www.ietf.org/mail-archive/web/tls/current/msg26532.html, I prefer to have the checksum for end-to-end integrity checking and to not have increased risk of service disruption for better adoption of ESNI; otherwise the hosts that using ESNI would stick out.\r\n\r\nIt's not only when transmitting data over the wire that the ESNIKeys might get corrupt. That could happen before the record gets installed on the authoritative server, or while the data is being cached in a resolver. Or we might have other conveyer in the future.",
          "createdAt": "2018-07-05T06:11:18Z",
          "updatedAt": "2018-07-05T06:11:18Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, I don't find those arguments particularly persuasive.  The biggest risk is misconfiguration, which - given the nature of this - won't be persistent.  Sites that do this will test their code and once it is fixed, it should work.\r\n\r\nAs for network-level corruption, that's rare, and DNS over TLS (or DoH) aren't really vulnerable to that.",
          "createdAt": "2018-07-05T09:53:00Z",
          "updatedAt": "2018-07-05T09:53:00Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that corruption is rare; the question is if it is as rare as TCP transferring corrupt data.\r\n\r\nI would like to also point out that corruption cannot be immediately fixed; you need to wait for the cached records to expire. And even if you use DNS over TLS or DOH between the client and the resolver, you could still be using unauthenticated DNS over UDP between the resolver and the authoritative server.",
          "createdAt": "2018-07-05T15:33:51Z",
          "updatedAt": "2018-07-05T15:33:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho @martinthomson shall we consider this issue resolved?",
          "createdAt": "2019-01-19T01:15:44Z",
          "updatedAt": "2019-01-19T01:15:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Considering resolved. ",
          "createdAt": "2019-06-02T15:01:11Z",
          "updatedAt": "2019-06-02T15:01:11Z"
        }
      ]
    },
    {
      "number": 66,
      "id": "MDU6SXNzdWUzMzg0MjkwNzg=",
      "title": "Contributory behaviour",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/66",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "This might not need the same level of rigour as TLS itself, but the construction of the keys could be better.  Right now, Z is dependent on contributory behaviour.\r\n\r\nI recommend that rather than just hashing `ClientHello.random`, a pseudo-message be constructed that includes the random, the server advertisement (in its entirety), the client's key share in some form, and maybe the prologue of the esni extension as well.  Essentially the entire mini-protocol we're using.",
      "createdAt": "2018-07-05T05:12:12Z",
      "updatedAt": "2018-10-21T20:35:43Z",
      "closedAt": "2018-10-21T20:35:43Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "+1\r\n\r\nClarification question: and we will be using Derive-Secret to extract the keys to encrypt the ESNI extension? I think we should, so as to align the key derivation process to the norm.",
          "createdAt": "2018-07-05T07:27:14Z",
          "updatedAt": "2018-07-05T07:27:14Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, using Derive-Secret would be best, I think. Try to keep the entire process aligned with existing practice.",
          "createdAt": "2018-07-05T09:54:27Z",
          "updatedAt": "2018-07-05T09:54:27Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "We didn't do Derive-Secret, but otherwise we did this.",
          "createdAt": "2018-10-21T20:35:11Z",
          "updatedAt": "2018-10-21T20:35:11Z"
        }
      ]
    },
    {
      "number": 67,
      "id": "MDU6SXNzdWUzMzg0MjkzNTg=",
      "title": "Use different client key shares for ESNI and TLS KE?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/67",
      "state": "CLOSED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Using the same key share looked like a good idea, but it's actually a real pain to implement because you need to get pretty involved with the TLS 1.3 key exchange.\r\n\r\nAnother approach would be to have separate keys but bind the ClientHello.KeyShare extension into the ESNI extension. I had thought of putting a hash in the extension plaintext but @martinthomson points out that if you use it as AAD, then the client-facing server will automatically detect mismatch\r\n\r\n",
      "createdAt": "2018-07-05T05:14:20Z",
      "updatedAt": "2018-10-21T20:43:09Z",
      "closedAt": "2018-10-21T20:43:09Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> Using the same key share looked like a good idea, but it's actually a real pain to implement because you need to get pretty involved with the TLS 1.3 key exchange.\r\n\r\nI am not sure if we are going to have such pain in general. In my view, what you can do is as follows:\r\n* construct encrypted_server_name extension\r\n* construct ClientHello, with passing in the ESNI extension and the key-exchange context that was used for constructing the extension as the arguments\r\n  * add the key-exchange context being passed in to ClientHello\r\n  * omit constructing a key-exchange context if the id of the context to-be-constructed matches that of the supplied context\r\n\r\nTo me, they seem to be fairly limited change.\r\n\r\nGenerally speaking, I think the question of if we should have different key shares depends on if we want to apply different crypto to the ESNI and the TLS application payload. My preference is to use single crypto whenever possible for simplicity and in hope that we can reuse ESNIKeys for other purposes in the future.",
          "createdAt": "2018-07-05T05:56:41Z",
          "updatedAt": "2018-07-05T05:56:52Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> I had thought of putting a hash in the extension plaintext but @martinthomson points out that if you use it as AAD, then the client-facing server will automatically detect mismatch\r\n\r\n:+1:\r\n\r\nEDIT: Well, but then a server cannot use the digest to find the corresponding ESNIKeys (and the private key). So while I agree that using it as AAD makes sense, I do not think that we can omit the hash. We could send something other than a hash (e.g., ID) though.",
          "createdAt": "2018-07-05T06:20:02Z",
          "updatedAt": "2018-07-05T06:22:16Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry, there are two values here:\r\n\r\n1. The ESNIKeys hash, which I agree has to be in the clear.\r\n2. The hash of KeyShares to prevent substitution attacks.\r\n\r\n@kazuho: I agree it's doable, as I just got my POC working. Yes, the CH is as you say, which is modestly disruptive. On the server side it's a bit disruptive because of the way NSS handles extensions, which is to say in-order. So, ESNI could come either before or after KeyShares. I could refactor this of course.\r\n\r\nIt also affects negotiation, so if the client didn't pick the server's most preferred group, you have to refrain from sending HRR, which is a bit of a pain.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2018-07-05T14:05:46Z",
          "updatedAt": "2018-07-05T14:05:46Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you for the clarification.\r\n\r\nI can understand the pain on the server-side. Current approach of ESNI changes the negotiation from client-offers-a-list-server-chooses-one, to server-offers-a-list-client-chooses-one.\r\n\r\nI think that it might be fine to revert to the TLS 1.3 way of negotiation. Actually we might be required to do that, if we want to prevent a client-facing server downgrading the crypto in the split server scenario.\r\n\r\nOTOH, I am not sure if we would want to use a _separate_ key share for ESNI, because that would require additional CPU cost. My benchmark tells me that in case of X25519, key generation takes about half the time of key derivation. That means that if we are going to have separate key shares but the algorithm collides, the client will be spending 17% more CPU cycles (i.e. 1 key generation + 2 derivations vs. 2 key generations and 2 derivations).\r\n\r\nConsidering the cost, I think that we'd be tempted to try reuse the key-share for two purposes (i.e. ESNI and TLS handshake), even if we define separate key exchange fields for the two.\r\n\r\nAnd that in turn make me wonder what the value is for having separate key exchange fields.\r\n\r\nTo summarize, I do not oppose to allowing client send multiple key shares or allowing server send HRR when ESNI is involved, but I prefer using the value of the KeyShares extension for carrying the ECDH key being used to encrypt ESNI.",
          "createdAt": "2018-07-05T16:06:35Z",
          "updatedAt": "2018-07-05T16:06:35Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> To summarize, I do not oppose to allowing client send multiple key shares or allowing server send HRR when ESNI is involved, but I prefer using the value of the KeyShares extension for carrying the ECDH key being used to encrypt ESNI.\r\n\r\nFWIW, I've created #70 that implements this, hoping that having a PR would help us evaluate the approach.",
          "createdAt": "2018-07-05T23:20:56Z",
          "updatedAt": "2018-07-05T23:20:56Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed",
          "createdAt": "2018-10-21T20:43:09Z",
          "updatedAt": "2018-10-21T20:43:09Z"
        }
      ]
    },
    {
      "number": 68,
      "id": "MDU6SXNzdWUzMzg1MDgxMDI=",
      "title": "Limit this to DNS names",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/68",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "Extensibility failed for SNI, no point in repeating that failure.  This is less complex:\r\n\r\n```\r\n   struct {\r\n       opaque domain_name<1..255>;\r\n       opaque zeros[ESNIKeys.padded_length - length(sni)];\r\n   } PaddedServerNameList;\r\n```\r\n\r\n",
      "createdAt": "2018-07-05T10:03:54Z",
      "updatedAt": "2020-10-16T17:14:14Z",
      "closedAt": "2019-07-03T20:30:29Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Are there other ways we expect servers to select certificates? I can imagine a scenario where clients pin server leaf certificates, and hint servers to the right leaf certificate by sending the leaf SPKI hash in the SNI. Would we want to rule something like that out?",
          "createdAt": "2019-01-19T01:19:07Z",
          "updatedAt": "2019-01-19T01:19:07Z"
        }
      ]
    },
    {
      "number": 69,
      "id": "MDU6SXNzdWUzMzg1OTY5MDU=",
      "title": "ESNIKeys can be used for Downgrade",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/69",
      "state": "CLOSED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Say that you have a server whose policy is that it will accept any KeyShare that is in the overlap between the client and server supported_groups (this isn't really an advisable policy). An on-path to DNS attacker can force you into the weakest joint group by creating an invalid ESNIKeys structure with a key in that group. The client will then send a KeyShare in that group, and you have been undetectably downgraded. Note that this will lead to suppression of SNI (because the client will be encrypting), but many servers don't require SNI. This works even against a non-ESNI servers.\r\n\r\nThere's also a weaker attack in which the client-facing server just sends a weaker share in ESNIKeys. This will be very hard for the server to detect.\r\n\r\nThis doesn't seem ideal, and I'm not quite sure how to remove it. This seems like an argument for #67 if we can make that work.\r\n\r\nThanks to @tvdmerwe for discussions leading to this.\r\n\r\n@kazuho: ^^\r\n",
      "createdAt": "2018-07-05T14:23:23Z",
      "updatedAt": "2018-10-21T20:35:33Z",
      "closedAt": "2018-10-21T20:35:33Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "See also the big disclaimer at the top :)",
          "createdAt": "2018-07-05T14:25:41Z",
          "updatedAt": "2018-07-05T14:25:41Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> An on-path to DNS attacker can force you into the weakest joint group by creating an invalid ESNIKeys structure with a key in that group. The client will then send a KeyShare in that group, and you have been undetectably downgraded.\r\n\r\nI do not think that the attack works against servers that support ESNI. The server will fail to find the private key that matches the ESNIKeys being used by the client (based on the value of record_digest), and the handshake will fail (that is the defense we implemented in #24).\r\n\r\n> This works even against a non-ESNI servers.\r\n\r\nI think that this is true. One way to fix the issue will be to use the value of ESNIKeys as an input to the Key Schedule (see #66), but a fix like that will not work with unmodified hidden server in Split mode. \r\n\r\nHaving that said, I am not sure if this is kind of an attack we need to fix. An attacker that can tamper the DNS responses can mount a DoS attack in a simpler way: send a negative response to an A query. Our model of sending unauthenticated ESNIKeys over DNS is based on the perception that DoS or preventing ESNI from working is possible when unauthenticated transmission of DNS is involved, but that does not open _new_ attack vectors.\r\n\r\n> There's also a weaker attack in which the client-facing server just sends a weaker share in ESNIKeys. This will be very hard for the server to detect.\r\n\r\nThis is true. I think the question here is if we want to permit using different key-shares / cipher-suites for ESNI and application data. As you point out, it relates to #67.",
          "createdAt": "2018-07-05T15:25:50Z",
          "updatedAt": "2018-07-06T00:06:44Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed with the new structure.",
          "createdAt": "2018-10-21T20:35:33Z",
          "updatedAt": "2018-10-21T20:35:33Z"
        }
      ]
    },
    {
      "number": 74,
      "id": "MDU6SXNzdWUzNDAzOTE3OTc=",
      "title": "don't base 64 encode",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/74",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "dns records are 8 bit clean and rfc 6763 is an example of a TXT record carrying arbitrary data\r\n\r\n",
      "createdAt": "2018-07-11T20:22:17Z",
      "updatedAt": "2019-03-06T22:44:27Z",
      "closedAt": "2019-03-06T22:44:26Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": ":+1:\r\n\r\nBase64 is not only complication. It is a space overhead for a large object like ESNIKeys. Seeing corruption of binary will be rare; we can detect them by validating the checksum and fallback to non-ESNI in such case. So why not go for binary?\r\n\r\nFWIW, base64 was introduced in #18.",
          "createdAt": "2018-07-11T21:47:07Z",
          "updatedAt": "2018-07-12T03:38:17Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is solved in #73 which removes base64 with new ESNI RR type.",
          "createdAt": "2018-07-12T12:09:29Z",
          "updatedAt": "2018-07-12T12:09:29Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "We only added this since TXT records were claimed to not work well with binary, per Christian\u2019s suggestion. I\u2019m fine either way. ",
          "createdAt": "2018-07-12T12:53:32Z",
          "updatedAt": "2018-07-12T12:53:32Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the info. I found https://github.com/ekr/draft-rescorla-tls-esni/issues/14#issuecomment-388573921, in which @huitema asks:\r\n> I really have two concerns, the maximum length and the char requirement. The latter may be an harder issue. For example, can I set a TXT record to contain binary data if I use Amazon's Route 53 service?\r\n\r\nWe know that we can store more than 128 octets in TXT record, and that we have a precedent that uses TXT to store binary data, as @mcmanus has pointed out.\r\n\r\nRegarding configurability, my understanding is that RFC 1035 defines how binary TXT records can be specified in a zone file, and therefore many DNS server \"softwares\" support having such records. Googling also tells me that managed DNS services like Route 53 and Azure DNS provide the capability, although surprisingly they use different escape sequences ([Route 53](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/ResourceRecordTypes.html#TXTFormat) uses `\\` + 3 octal, [Azure](https://docs.microsoft.com/en-US/azure/dns/dns-faq) uses `\\` + 3 decimal).",
          "createdAt": "2018-07-12T14:33:32Z",
          "updatedAt": "2018-07-12T14:33:32Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I do not think it\u2019s a complication, and I\u2019m not convinced space is an issue as per your comment above.",
          "createdAt": "2018-07-12T14:58:53Z",
          "updatedAt": "2018-07-12T14:58:53Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "only tangentially related - @kazuho do you know why your examp1e.net txt record is broken into 127 char strings instead of 255? Is there a bug being worked around somewhere?",
          "createdAt": "2018-07-12T15:15:10Z",
          "updatedAt": "2018-07-12T15:15:10Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@mcmanus Oh I did not notice that. I am using tinydns (of djbdns), and it seems like tinydns works that way (see https://github.com/abh/djbdns/blob/master/tinydns-data.c#L402).",
          "createdAt": "2018-07-12T15:53:20Z",
          "updatedAt": "2018-07-12T15:53:20Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood The issue about the size is that with base64 we might hit the 512-octet threshold when publishing keys of multiple strengths.\r\n\r\nAs an example, query for _esni.esni.examp1e.net currently returns a 186-byte response, which contains just secp256r1 key. If we add secp384r1 and secp521r1, I'd assume that the size will come near to 490 octets. In other words, for longer hostnames we will hit the 512-octet threshold if we publish three keys.\r\n\r\nIf we avoid the base64 encoding, we will have enough room to store 3 ECDH keys that can provide 128-, 192-, 256-bit-level security.\r\n\r\nI do not think this argument is strong enough to prohibit the use of base64 for the following reasons:\r\n\r\n* we will be using DoH / DNS over TLS between the client and the resolver\r\n* we might be using DNS over UDP that has the 512-octet threshold between the resolver and the authoritative server, but we would want that to migrate to DNSSEC or something even better\r\n* we might be just fine with publishing only two keys: X25519, X448\r\n\r\nBut it does make me prefer not to have the overhead of base64, if that is possible.",
          "createdAt": "2018-07-12T16:09:19Z",
          "updatedAt": "2018-07-12T16:09:19Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #144.",
          "createdAt": "2019-03-06T22:44:26Z",
          "updatedAt": "2019-03-06T22:44:26Z"
        }
      ]
    },
    {
      "number": 75,
      "id": "MDU6SXNzdWUzNDEzMjM3MDI=",
      "title": "iana registry for underscore scoped name",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/75",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "https://datatracker.ietf.org/doc/draft-ietf-dnsop-attrleaf/\r\n\r\nis in wglc and seems likely to become a standards track doc.\r\n\r\nIt establishes a registry for undesrscore scoped names\r\n```\r\n      \"Per\" [Attrleaf] \"please add the following entry to the DNS\r\n      Underscore Global Scoped Entry Registry:\"\r\n\r\n   +--------+----------------+-----------------------------------------+\r\n   | RR     | _NODE NAME     | REFERENCE                               |\r\n   | Type   |                |                                         |\r\n   +--------+----------------+-----------------------------------------+\r\n   | TXT    | _esni          | this document                           |\r\n   +--------+----------------+-----------------------------------------+\r\n```\r\n\r\nit means a blocking reference to ATTRLEAF, but that doesn't seem like a problem time wise",
      "createdAt": "2018-07-15T14:05:39Z",
      "updatedAt": "2018-07-15T14:36:02Z",
      "closedAt": "2018-07-15T14:36:02Z",
      "comments": []
    },
    {
      "number": 79,
      "id": "MDU6SXNzdWUzNDI4NjExMjI=",
      "title": "_esni prefix is challenging for DNS wildcard syntax with TXT type",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/79",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "if you dynamically syntehsize a whole bunch of names in example.com you would probably use a *.example.com a/aaaa configuration to do so and give them all the same addresses.\r\n\r\nbut you can't do the same things for TXT records with the _esni prefix..  basically _esni.*.example.com doesn't do the trick (rfc 4592).\r\n\r\ninitially I viewed this as a configuration and implementation issue because queries and responses do not carry the * at all - the records are synthesized on demand from this config.\r\n\r\nhowever, the wildcard is part of AXFR which forms an open interface between resolvers so its syntax and meaning is quite reasonably standardized and should be considered.\r\n",
      "createdAt": "2018-07-19T19:34:14Z",
      "updatedAt": "2019-03-06T22:43:23Z",
      "closedAt": "2019-03-06T22:43:23Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> however, the wildcard is part of AXFR which forms an open interface between resolvers\r\n\r\nMinor point but I am not sure if AXFR is something that is exposed to the resolvers. My understanding is standardized interface for synchronizing authoritative servers. So this will be an issue only for websites that use a DNS that either depends on AXFR (or in other ways depend on the vocabulary of the AXFR).\r\n\r\nI agree that it would be preferable to address the issue.",
          "createdAt": "2018-07-19T19:55:58Z",
          "updatedAt": "2018-07-19T19:55:58Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "my thought here is that axfr represents an interface between, potentially,\ndifferent implementations so we should try and respect that to whatever\nextent is possible.\n\nOn Thu, Jul 19, 2018 at 3:55 PM, Kazuho Oku <notifications@github.com>\nwrote:\n\n> however, the wildcard is part of AXFR which forms an open interface\n> between resolvers\n>\n> Minor point but I am not sure if AXFR is something that is exposed to the\n> resolvers. My understanding is standardized interface for synchronizing\n> authoritative servers. So this will be an issue only for websites that use\n> a DNS that either depends on AXFR (or in other ways depend on the\n> vocabulary of the AXFR).\n>\n> I agree that it would be preferable to address the issue.\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ekr/draft-rescorla-tls-esni/issues/79#issuecomment-406395145>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAP5s4s6W1bSbCrcAOda5E9l00lvVmO5ks5uIORPgaJpZM4VW-J6>\n> .\n>\n",
          "createdAt": "2018-07-19T20:08:48Z",
          "updatedAt": "2018-07-19T20:08:48Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "My view of the issue is that we can support all the models that we need to support if we adopt #73 so that ESNIKeys will be distributed using a dedicated type with a prefix.\r\n\r\nThe patterns we need to consider are the combination of three types of DNS records (i.e. single-host, APEX, wildcard) and a boolean indicating if DNS is maintained by someone other than the CDN.\r\n\r\nThe table below illustrates how you could configure the DNS on each case. There are certain cases in which you could use CNAME instead of A / ESNI.\r\n\r\n|**DNS operated by**|**single-host**|**APEX**|**wildcard**|\r\n|:---|:---|:---|:---|\r\n|**CDN**|host IN A addr<br>_esni.host IN ESNI ...|@ IN A addr<br>_esni IN ESNI ...|* IN A addr<br>* IN ESNI ...<sup>1</sup>|\r\n|**not CDN**|host IN CNAME addr<br>_esni.host CNAME _esni.cdn|@ IN A cdn-ipaddr<br>_esni IN CNAME _esni.cdn|* IN CNAME cdn<sup>1<sup>|\r\n\r\n1: You will be required to create _esni records for all hosts that you specify explicitly, if it is necessary to disable ESNI for those hosts (or if those hosts use different ESNI keys).",
          "createdAt": "2018-07-19T22:55:42Z",
          "updatedAt": "2018-07-19T22:57:38Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #144.",
          "createdAt": "2019-03-06T22:43:23Z",
          "updatedAt": "2019-03-06T22:43:23Z"
        }
      ]
    },
    {
      "number": 80,
      "id": "MDU6SXNzdWUzNDMwOTIxNDE=",
      "title": "Add consolidations considerations section",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/80",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-20T12:38:51Z",
      "updatedAt": "2020-10-16T17:14:14Z",
      "closedAt": "2019-07-03T00:11:14Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Can you explain what you mean about this? Or submit a PR",
          "createdAt": "2018-10-21T20:46:21Z",
          "updatedAt": "2018-10-21T20:46:21Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@ekr I missed your comment.... in October. Oops. Closing as NTBF. We can add text if required later.",
          "createdAt": "2019-07-03T00:11:14Z",
          "updatedAt": "2019-07-03T00:11:14Z"
        }
      ]
    },
    {
      "number": 81,
      "id": "MDU6SXNzdWUzNDU0OTU2MDE=",
      "title": "Mix client KeyShare into AEAD to prevent malleability",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/81",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See \r\nhttps://mailarchive.ietf.org/arch/msg/tls/rc_tgkgVIeB4yeNCgPcyPzRnrBI",
      "createdAt": "2018-07-29T02:37:15Z",
      "updatedAt": "2018-10-21T20:34:12Z",
      "closedAt": "2018-10-21T20:34:11Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Done.",
          "createdAt": "2018-10-21T20:34:11Z",
          "updatedAt": "2018-10-21T20:34:11Z"
        }
      ]
    },
    {
      "number": 82,
      "id": "MDU6SXNzdWUzNDU0OTU2ODI=",
      "title": "Consider new extension that permits server to supply new ESNI key upon mismatch",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/82",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, the connect fails when a mismatch occurs. An alternative strategy might be to return a new ESNI key that is then used for a subsequent connection.",
      "createdAt": "2018-07-29T02:39:04Z",
      "updatedAt": "2019-02-26T21:14:12Z",
      "closedAt": "2019-02-26T21:14:12Z",
      "comments": [
        {
          "author": "yfdyh000",
          "authorAssociation": "NONE",
          "body": "How to understand the reliability of the public key from server?",
          "createdAt": "2018-09-14T18:01:17Z",
          "updatedAt": "2018-09-14T18:01:17Z"
        }
      ]
    },
    {
      "number": 83,
      "id": "MDU6SXNzdWUzNDU0OTU3Mzk=",
      "title": "Discuss query strategies and how to deal with loss",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/83",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The order of DNS queries may matter in systems that use Happy Eyeballs. Also, should TLS connections block until ESNI key queries come back? What if they never come back?",
      "createdAt": "2018-07-29T02:40:53Z",
      "updatedAt": "2018-08-14T17:13:09Z",
      "closedAt": "2018-08-14T17:13:09Z",
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "can you elaborate on what you're thinking about wrt he? (assuming the inaddr.arpa plan is off the table)",
          "createdAt": "2018-08-05T00:47:26Z",
          "updatedAt": "2018-08-05T00:47:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Basically addressed in #86.",
          "createdAt": "2018-08-14T17:13:09Z",
          "updatedAt": "2018-08-14T17:13:09Z"
        }
      ]
    },
    {
      "number": 84,
      "id": "MDU6SXNzdWUzNDYzMjgyMTc=",
      "title": "Supporting multiple protocols text is slightly misleading",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/84",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "Replace \r\n\r\n\"It only affects connection routing, server certificate selection, and client certificate verification.\" \r\n\r\nwith \r\n\r\n\"It may affect connection routing, server certificate selection, and client certificate verification.\" ",
      "createdAt": "2018-07-31T19:33:47Z",
      "updatedAt": "2020-10-16T17:14:14Z",
      "closedAt": "2019-07-03T00:15:11Z",
      "comments": [
        {
          "author": "yfdyh000",
          "authorAssociation": "NONE",
          "body": "https://ekr.github.io/draft-rescorla-tls-esni/draft-rescorla-tls-esni.html#rfc.section.7.2.8\r\nIt is relative to \"This design has no impact on application layer protocol negotiation.\", so \"only\" is more explicit.",
          "createdAt": "2018-09-14T18:05:32Z",
          "updatedAt": "2018-09-14T18:05:32Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This was fixed in #87 and I forgot to close. ",
          "createdAt": "2019-07-03T00:15:11Z",
          "updatedAt": "2019-07-03T00:15:11Z"
        }
      ]
    },
    {
      "number": 88,
      "id": "MDU6SXNzdWUzNTIwMTIwODc=",
      "title": "DNS record disadvantage & Purpose enhancement & My suggestion",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/88",
      "state": "CLOSED",
      "author": "Jemmy1228",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I don't know that I can give out my advice here before, so I had written an e-mail to draft-rescorla-tls-esni@ietf.org and that's my first time to send an email to IETF. I don't know whether sending an e-mail is the right thing, so I would paste it here again.\r\n\r\nI'm not a native English speaker, I would apologize for my poor English first.\r\n\r\n\r\n### DNS record disadvantage\r\n\r\n#### 1.Impossible for wildcard A or AAAA record\r\n\r\nIt isn't possible for us to set a txt record for wildcard A or AAAA record (_esni.*.example.com. 60S IN TXT \"...\" \"...\"). \r\nThe same problem as https://github.com/ekr/draft-rescorla-tls-esni/issues/79 mentioned.\r\n\r\n#### 2.Publishing a public key using DNS is very inconvenient and insecure. \r\n\r\nIn general, we can't change the DNS record very conveniently (except some DNS which provide API), so that most domain owners won't change the key very often. \r\n\r\nAnd in some cases, domain owners host their site at host service providers (I don't know how to explain that in English. Host service provider use one physical or virtual server to host many sites) once the provider want to change the ESNI public key, all owners on this server need to change their txt record on time, which is very inconvenient and nearly impossible.\r\n\r\nThe lack of frequently changing public key and the lack of Perfect Forward Security only provide us little security.\r\n\r\n#### 3.DNS record limited only exist domains can enable ESNI\r\n\r\nAs DNS record is needed to be set, only the owner of a exist and valid domain can enable ESNI.\r\n\r\nHowever, sometimes we want to use encrypted-sni as a private entry. For example, I configured my server that client hello with the sni \"vps.panel\" would lead to the vps control panel ( I issued a cert for \"vps.panel\" from my own PKI ). Though I configured that the server must verify my identity using a client certificate, I don't want this private sni to be known to the public. But your draft's method won't allow this use case as \"vps.panel\" isn't a valid domain name, so that I won't be able to own this domain and set a DNS record for it.\r\n\r\n#### 4.Local DNS (hosts) won't work\r\n\r\nThe hosts file can only take the place of A and AAAA record and won't be able to set public key in hosts in the near future.\r\n\r\n#### 5.Requirements to the server is too high\r\n\r\nThis ESNI draft requires that the server can the decrypt the sni which is encrypted by any public key. This means that the server has to take hold all ESNI private keys. However, I think that it's not proper.  \r\nTo CDN service provider like Cloudflare, it means that one Cloudflare server has to storage all private ESNI keys of the websites hosted on it.  \r\nIn my opinion, the browser should encrypt the sni using all public keys found in the DNS record and add a few invalid ESNI along with those, to prevent the attacker identify the real sni from the number of public keys.\r\n\r\n\r\n### Purpose Enhancement - Wall-resistent\r\n\r\nIn some countries (e.g. China, North Korea, Iran) , people may want to use ESNI to break the government's GreatFireWall, which blocks people from visiting some website.\r\n\r\nThe wall isn't just a wall, but a very complicated system which can modify DNS resolve result ( DNSSEC isn't common ). They can simply block all _esni txt record, so that all browsers can' get the public key and downgrade to cleartext-sni.\r\n\r\nIf ESNI can be used with SNI Proxy, it would be a good solution to break the wall. However the DNS record limited only the owner can enable ESNI ( Another disadvantage of DNS :D )\r\n\r\n\r\n### My suggestions\r\n\r\nI think some ideas of https://datatracker.ietf.org/doc/draft-ietf-tls-sni-encryption/ is quite good. One good idea is to use a certificate to authenticate the Client-Facing Server instead of publishing a public key. My main idea is to introduce a series of HTTP headers like HSTS and HPKP. I will give an example below:\r\n\r\nFirstly, I would introduce these headers\r\n( These names may be not proper due to my poor English )\r\n\r\n```\r\nESNI:(preload);(includeSubdomains);max-age=??\r\nIf ESNI header presents in the response, it means this domain enables ESNI. Otherwise, the browser MUST ignore other ESNI-* headers.\r\ne.g.\r\nESNI:preload;includeSubdomains;max-age=31536000\r\n\r\nESNI-Resolve:{address};max-age=??\r\n{address} can be either FQDN or IP(s) the purpose is to hide the real domain during DNS resolve. The server MUST keep this header up-to-date. This header just like a cacheable CNAME record.\r\ne.g. \r\nESNI-Resolve: server233.domain-cdn.com;max-age=31536000\r\nESNI-Resolve: 0.0.0.0/16;max-age=2592000\r\nESNI-Resolve: 1.1.1.1;max-age=2592000\r\n\r\nESNI-Trust:{address or pin-hash};max-age=??\r\n{address} is the same as above. The only difference is that the FQDN can contain wildcard.\r\n{pin-hash} is similar to HPKP's pin-hash.\r\nCan have more than one this header in the HTTP Response. (Explain later)\r\ne.g.\r\nESNI-Trust:fqdn{ *.domain-cdn.com};max-age=31536000\r\nESNI-Trust:ip{0.0.0.0/16};max-age=31536000\r\nESNI-Trust:pin-hash{X523zEOQCuEJeU6PzewOGkKCRX+YLvfAsCYJbQubCuE=};max-age=31536000\r\n\r\n\r\nESNI-Policy:{policy};max-age=??\r\n{policy} can be \"force-encrypted-sni\", \"retry-clear-sni\", \"allow-dns-re-resolve\", \"disallow-dns-re-resolve\" defines the action if error happens using ESNI. \r\nCan have more than one this header in the Response. (Explain below)\r\n```\r\n\r\nIt's impossible to have more than one header with the same name, but we may construct these in to a structure and encode (e.g.base64) into one header. The header may be very big, but don't worry, only the first response contains it, HTTP2 will automatically compress them into a few bits in the later response.\r\n\r\nWhen the first time I visit https://www.example.com , I just do the normal tls1.3 hand shake with clear-text sni. The server just do what it should do, but the response MUST contain those ESNI headers if ESNI is enabled. The browser MUST remember these headers ( unless in incognito mode )\r\n\r\nWhen the second time I visit https://www.example.com , the browser SHOULD NOT query DNS resolve for www.example.com, instead, it should visit the FQDN/IP mentioned in the ESNI-Resolve header. And the browser MUST NOT send clear-text sni in the ClientHello, instead, send a CH without sni or a special CH indicates using ESNI.  The Client-Facing Server  send back certificate, the browser validates the certificate and makes sure the certificate contains at least one FQDN/IP mentioned in the ESNI-Trust header. If mismatch, check the ESNI-Policy and determine whether to retry or not. \r\nAnd then re-handshake with the server with encrypted-ClientHello in the 0RTT data or another CH extension. \r\n( similar to draft-ietf-tls-sni-encryption method )\r\n\r\nMy suggestions' advantages and disadvantages are nearly the same as draft-ietf-tls-sni-encryption method. It provides PFS, don't need to change the Split-Mode Server and solved some part of DNS sniffing. But the disadvantage is obvious too, the first hand shake can't be encrypted and the ESNI-Resolve may become incorrect over time. It needs to handshake twice, however, it provided PFS and I think it worth it. And if multiple sites are hosted on the same server (e.g.CDN, Host Service Provider), we just need to do the second handshake, which eliminate the risk of DoS attack in some level.... And I think 0RTT symmetric decryption is better than asymmetric decryption.\r\nSetting max-age too big or too small both have some risks, and I don't know how to solve it.\r\n\r\n**If you don't like the idea of authenticating the Client-Facing Server, you can simply replace the ESNI-Trust header's content into a public key and use your method. But I don' think set a static public key is a good idea ( explained in some part of DNS disadvantage ).**\r\n\r\nAll in all, we can't have both efficiency, performance and security,  reliability. You should make up your mind and choose whether to provide perfect security or perfect performance. I prefer the former.\r\n\r\nI know that my idea is similar to draft-ietf-tls-sni-encryption than yours. However, you are the candidate for TLS WG, so I hope you can think it over. But I do agree with your idea that \"no need to don't stick out\" or simply \"we can stick out\" :D",
      "createdAt": "2018-08-20T07:15:32Z",
      "updatedAt": "2018-10-21T20:44:31Z",
      "closedAt": "2018-10-21T20:44:31Z",
      "comments": [
        {
          "author": "yfdyh000",
          "authorAssociation": "NONE",
          "body": "> so that all browsers can' get the public key and downgrade to cleartext-sni.\r\n\r\nhttps://github.com/ekr/draft-rescorla-tls-esni/blob/master/draft-ietf-tls-esni.md#misconfiguration prevent this case happening.\r\n\r\n> My main idea is to introduce a series of HTTP headers like HSTS and HPKP. \r\n> When the first time I visit https://www.example.com , I just do the normal tls1.3 hand shake with clear-text sni.\r\n\r\nThis introduces exposure and interception opportunities; a TLS connection that remains connected may not require an external SNI. (I am not sure)\r\n\r\nTLS also works with protocols other than HTTP(S). If the ESNI relies on HTTP headers, it is HTTPS only.",
          "createdAt": "2018-09-14T17:45:18Z",
          "updatedAt": "2018-09-14T17:45:18Z"
        },
        {
          "author": "Jemmy1228",
          "authorAssociation": "NONE",
          "body": "@yfdyh000 \r\n> This introduces exposure and interception opportunities; a TLS connection that remains connected may not require an external SNI. (I am not sure)\r\n> \r\n> TLS also works with protocols other than HTTP(S). If the ESNI relies on HTTP headers, it is HTTPS only.\r\n\r\nTo solve this problem, we can simply change from HTTP headers to TLS extensions. In TLS1.3, handshake extensions are encrypted as well. The only thing need to be done is defining the structure of these settings.",
          "createdAt": "2018-09-15T08:51:53Z",
          "updatedAt": "2018-09-15T08:51:53Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Not seeing much support for removing DNS here, so closing this issue.",
          "createdAt": "2018-10-21T20:44:31Z",
          "updatedAt": "2018-10-21T20:44:31Z"
        }
      ]
    },
    {
      "number": 97,
      "id": "MDU6SXNzdWUzNjI5ODY2OTg=",
      "title": "Should the server send the SNI confirmation extension?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/97",
      "state": "CLOSED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-23T23:20:42Z",
      "updatedAt": "2018-10-21T20:33:05Z",
      "closedAt": "2018-10-21T20:33:05Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed when we added the nonce",
          "createdAt": "2018-10-21T20:33:05Z",
          "updatedAt": "2018-10-21T20:33:05Z"
        }
      ]
    },
    {
      "number": 99,
      "id": "MDU6SXNzdWUzNjg0MzcwOTc=",
      "title": "Add a reference to draft-ietf-dns-attrleaf",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/99",
      "state": "CLOSED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As well as the IANA registrations",
      "createdAt": "2018-10-09T23:27:53Z",
      "updatedAt": "2018-10-21T22:21:25Z",
      "closedAt": "2018-10-21T22:21:25Z",
      "comments": []
    },
    {
      "number": 103,
      "id": "MDU6SXNzdWUzNzMwMTI3ODU=",
      "title": "Extension as vector of ClientEncryptedSNI structures",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/103",
      "state": "CLOSED",
      "author": "roelfdutoit",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Please consider changing the ESNI client extension to a vector of ESNI values.  This could be used for server-side redundancy and key rollover.  I understand that only one of the entries would be ack'd in EE, and that we would have to think through the possible attacks on the mechanism due to the change.\r\n",
      "createdAt": "2018-10-23T13:54:25Z",
      "updatedAt": "2019-07-03T21:06:44Z",
      "closedAt": "2019-07-03T21:06:44Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@roelfdutoit can you please bring this issue to the list for further discussion?",
          "createdAt": "2019-07-03T03:52:22Z",
          "updatedAt": "2019-07-03T03:52:22Z"
        }
      ]
    },
    {
      "number": 105,
      "id": "MDU6SXNzdWUzNzM3Mzc3MDQ=",
      "title": "remove _esni prefix because it makes CNAME alias too hard",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/105",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "issue #7 briefly discussed the choice of a _esni DNS prefix for the TXT record. I think we should revisit that.\r\n\r\nMy primary concern is that using 2 different names for the addressing and key information makes DNS aliasing un-necessarily complicated.\r\n\r\nConsider the case where www.example.com is a customer of bigHoster.com and bigHoster.com is deploying ESNI for all its customers.\r\n\r\nA classic way to do this is to have www.example.com be a CNAME for host1.bighoster.com\r\n\r\nunfortunately to use bighoster.com's new ESNI infrastructure www.example.com would need to add a CNAME record for _esni.www.example.com as well. So the ESNI deployment requires DNS changes outside of the org deploying ESNI, which is going to limit its deployment, which in turn is going to limit the breadth of its anonymity pool. :(\r\n\r\nAdditionally, I've been told that anecdotally putting names under a CNAME is legal but error prone. RFC 1912 seems to have some language that suggests its not even legal (though that is informational).\r\n\r\nIf the ESNI information were instead stored without a prefix then the alias would automatically apply as the CNAME applies to all the RR's of a hostname.\r\n\r\nPart of the reason for choosing the prefix was to avoid collisions in the TXT space, so it makes sense to also reopen #40 and use a non TXT RR type if we drop the prefix. I think the consensus is moving towards that being fine.\r\n\r\nThis would also resolve #79 to harmonize esni with existing dns deployments.\r\n\r\n",
      "createdAt": "2018-10-25T01:31:36Z",
      "updatedAt": "2019-03-06T00:55:58Z",
      "closedAt": "2019-03-06T00:55:58Z",
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I forgot to acknowledge the downside here is with apex records. You can't cname an apex record, so the normally annoying second cname with the prefix is actually the only thing the apex can use natively as an alias and this proposal gives that up.\r\n\r\notoh apex records inline someone's A records (usually a single provider's anycast) already so they can  do the same thing with esni.. and/or we could allow some kind of delegation explicitly as part of the new rrtype (i.e. delegation within the new rrtype data, not via cname)",
          "createdAt": "2018-10-25T01:35:32Z",
          "updatedAt": "2018-10-25T01:35:32Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "also see pr #73 ",
          "createdAt": "2018-10-25T01:36:59Z",
          "updatedAt": "2018-10-25T01:36:59Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> unfortunately to use bighoster.com's new ESNI infrastructure www.example.com would need to add a CNAME record for _esni.www.example.com as well. So the ESNI deployment requires DNS changes outside of the org deploying ESNI, which is going to limit its deployment, which in turn is going to limit the breadth of its anonymity pool. :(\r\n\r\nI am not sure if I agree with the problem statement.\r\n\r\nTo me it seems that the argument is based on the assumption that bighoster.com is the one to decide if ESNI should be applied for www.example.com. I am not sure if all of us would be happy with that assumption.\r\n\r\nThe alternative approach here is to give the owner of each hostname the freedom of deciding whether the hostname should be covered by ESNI. Current design allows the hosting companies to adopt that model, by using the DNS configuration that the hostname owner controls as the switch.",
          "createdAt": "2018-10-25T02:49:22Z",
          "updatedAt": "2018-10-25T03:48:22Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ESNI is already a property of the server not the origin name.. in the same way the version of TLS or the cipher suite set is a property of the server.. or the level of http. All necessarily under the control of bighoster.com because it reflects whatever is available on their infrastructure.\r\n\r\nbighoster may commonly allow their customers to configure this stuff on a per customer or service basis, but that's a bit of a different take and not incompatible with the approach here.",
          "createdAt": "2018-10-25T14:04:12Z",
          "updatedAt": "2018-10-25T14:04:12Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@mcmanus While that might be true, I am not sure if removing the `_esni` prefix and introducing ESNIInclude (#110) is worth the additional complexity and overhead.\r\n\r\nAssuming that we merge #109, #79 becomes a non-issue. Because a wildcard will much all names with the designated type, including the `_esni` prefix.\r\n\r\nFor example, the following configuration will support ESNI for all the hostnames under example.com, like `a.example.com`, `b.c.example.com`, because any query for `_esni.*.example.com` resolves to `*.example.com`.\r\n\r\n```\r\n*.example.com. IN A 192.0.2.1\r\n*.example.com IN ESNI ...\r\n```\r\n\r\nSo the only downside is that using prefix and a dedicated RR type at the same time might look strange. But it's practical.\r\n\r\nI am not sure if we would prefer to require alias resolution for every ESNI client.\r\n\r\nImplementation wise, it's about reimplementing what DNS recursor usually does in the stub resolver. You need to do things like detecting too many redirects and/or loops.\r\n\r\nThere would also be a performance degradation, because each client needs to do the recursive lookup, while with the prefix we can rely on the recursive resolvers to do it and cache it for other clients.\r\n\r\nTo reiterate, I wonder if there is any *practical* reason to reinvent the wheel.",
          "createdAt": "2018-11-02T04:09:19Z",
          "updatedAt": "2018-11-02T04:11:58Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Stretching the bounds of my DNS knowledge here, but I *think* this makes divergence between the A/AAAA and ESNIKeys records much less likely.  That is, when www.example.com is served by both CDN A and CDN B, the DNS will return `www.example.com CNAME www.example.com.cdnalpha.com` or `www.example.com CNAME www.example.com.cdnbeta.com`.  If both things are record types on the same hostname, then the divergence only happens when the queries happen on opposite sides of a cached CNAME record expiring and getting the opposite answer the next time around.\r\n\r\nBut if they're separate hostnames, as in the current doc, it's entirely possible to get opposite CNAME records cached, and you've diverged for all clients of the caching resolver for the TTL of the shorter CNAME record.  That's a far worse probability of divergence.",
          "createdAt": "2019-03-01T23:06:17Z",
          "updatedAt": "2019-03-01T23:06:17Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #144. Closing. ",
          "createdAt": "2019-03-06T00:55:58Z",
          "updatedAt": "2019-03-06T00:55:58Z"
        }
      ]
    },
    {
      "number": 107,
      "id": "MDU6SXNzdWUzNzQyNzU1MTQ=",
      "title": "Unclear sentence in section 7.1 \"Why is cleartext DNS OK?\"",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/107",
      "state": "CLOSED",
      "author": "thomwiggers",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The second paragraph of this section currently contains:\r\n\r\n```\r\nClearly, DNSSEC (if the client validates and hard fails) is a defense against\r\nthis form of attack, but DoH/DPRIVE are also defenses against DNS attacks\r\nby attackers on the local network, which is a common case where SNI.\r\n```\r\n\r\nClearly, the sentence abruptly ends.\r\n\r\nMoreover, the sentence could probably be split in two, at the \"but\". This should make it easier to read.",
      "createdAt": "2018-10-26T08:19:00Z",
      "updatedAt": "2018-11-26T22:13:21Z",
      "closedAt": "2018-11-26T22:13:21Z",
      "comments": [
        {
          "author": "Eudi4H",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Nick Lamb [comments](https://www.ietf.org/mail-archive/web/tls/current/msg27298.html) on the same passage:\r\n> In section 7.1 the -02 draft says:\r\n>> Clearly, DNSSEC (if the client validates and hard fails) is a defense against this form of attack, but DoH/DPRIVE are also defenses against DNS attacks by attackers on the local network, which is a common case where SNI.\r\n>\r\n> Where SNI what?\r\n>\r\n> I'd be tempted to just say that yes, an active adversary can force you to choose between privacy and connectivity, and hard fail DNSSEC is the only existing way to choose privacy.\r\n> \r\n> The current text feels more like an attempt by people who don't want to face the Dancing Pig problem to justify why their latest seat-belt that snaps in a crash (to borrow Adam Langley's phrase) is a good idea anyway. But regardless of whether I'm correct about that, the sentence is confusing as it stands now.",
          "createdAt": "2018-11-26T22:08:54Z",
          "updatedAt": "2018-11-26T22:08:54Z"
        }
      ]
    },
    {
      "number": 109,
      "id": "MDU6SXNzdWUzNzQ0NDY5MTg=",
      "title": "Use ESNI RRType instead of TXT",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/109",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "PR #73 from @ghedo implements the ESNI RRType, but there doesn't seem to be another issue currently open to track discussion of it.\r\n\r\n* a new RRType allows the removal of the _esni prefix (#105 and #79)\r\n* reusing TXT has the potential for conflicts with other uses even with the prefix. (imagine the definition of a TXT record that simply applied to all DNS entries)\r\n* while both TXT and ESNI are 8 bit clean, some people are surprised to learn that about TXT so using a new type may be more robust. Some generic tools processing TXT records would benefit from this.\r\n* TXT is a set of  <= 255 byte strings, defining a new type removes that complexity and reduces overhead\r\n* There was initially concern about the viability of new RRTypes, but I believe people are more comfortable with that now than when the text was drafted.",
      "createdAt": "2018-10-26T15:58:31Z",
      "updatedAt": "2019-03-06T00:55:27Z",
      "closedAt": "2019-03-06T00:55:27Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #144.",
          "createdAt": "2019-03-06T00:55:27Z",
          "updatedAt": "2019-03-06T00:55:27Z"
        }
      ]
    },
    {
      "number": 110,
      "id": "MDU6SXNzdWUzNzQ0NTIyMDA=",
      "title": "ESNIInclude",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/110",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "needs WG discussion"
      ],
      "body": "issues #105 and #79 advocate for the removal of the _esni prefix.\r\n\r\nA significant side effect of that is that it becomes impossible to use a CNAME at the apex of a zone in order to refer to ESNIKeys of a server operated elsewhere. Inlining keys, as is often done with A/AAAA at the apex, is not plausible due to key rotation.\r\n\r\nThe issue can largely be mitigated with the introduction of an inclusion mechanism directly in the TXT/ESNI record.\r\n",
      "createdAt": "2018-10-26T16:13:11Z",
      "updatedAt": "2019-11-02T01:02:56Z",
      "closedAt": "2019-11-02T01:02:56Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This should be fixed by #136 and follow up changes. Closing as such. Please reopen if necessary!",
          "createdAt": "2019-06-19T16:53:07Z",
          "updatedAt": "2019-06-19T16:53:07Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't believe #136 resolves this.\r\n\r\n136 effectively requires the address and ESNI information to be stapled together (which I still find objectionable). The issue here is that the apex cannot use a CNAME to delegate to the actual third party provider's ESNI record.. typically it just includes an A/AAAA record at the apex and hopes the pointer doesn't go stale. That's bad enough for A/AAAA but it would be terrible for ESNI because it means copying keying information and hoping it doesn't go stale between two different entities.\r\n\r\n@chris-wood can you reopen?",
          "createdAt": "2019-06-27T20:21:01Z",
          "updatedAt": "2019-06-27T20:21:01Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Sure! Sorry for the misunderstanding. We can probably update this PR to make use of the new DNS-specific extensions.",
          "createdAt": "2019-06-28T15:12:59Z",
          "updatedAt": "2019-06-28T15:12:59Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #187.",
          "createdAt": "2019-11-02T01:02:56Z",
          "updatedAt": "2019-11-02T01:02:56Z"
        }
      ]
    },
    {
      "number": 113,
      "id": "MDU6SXNzdWUzNzcwMjM2Njk=",
      "title": "Requirements on backend servers in Split Mode",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/113",
      "state": "CLOSED",
      "author": "Eudi4H",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As of 7bd60fc, Section 3.1 says that in Split Mode, \"the backend server can be an unmodified TLS 1.3 server.\"\r\n\r\nBut I feel that statement is contradicted by:\r\n- Section 5.4: \"In Split Mode, the backend server must know PaddedServerNameList.nonce to echo it back in EncryptedExtensions and complete the handshake. ... backend servers function the same as servers operating in Shared mode.\"\r\n- Section 7.3: \"...the backend server also only has one identity.\"\r\n- Appendix B: \"When operating in Split mode, backend servers will not have access to PaddedServerNameList.sni or ClientESNIInner.nonce...\"\r\n\r\nA standard TLS 1.3 server that has more than one identity (i.e., requires plaintext SNI) won't work as a backend server. Even if the backend server has only one identity and ignores the forwarded encrypted_server_name extension, and therefore returns a default certificate, it seems that the connection will still fail because of the requirement in Section 5.1 that the client \"MUST check that ClientESNIInner.nonce matches the value of the 'encrypted_server_name' extension provided by the server.\" So I propose removing or amending the statement in Section 3.1. I don't see a way to deploy a Split-Mode topology without making the backend server ESNI-aware and doing some exchange along the lines of Appendix B, but I might have missed something.\r\n\r\nAm I correct in thinking that the current Cloudflare deployment is Shared Mode, not Split Mode, despite that Figure 2 looks more like a typical CDN topology? Because the TLS gets terminated at the Cloudflare CDN edge server, and the connection to the Cloudflare customer's web server is done with an independent connection.",
      "createdAt": "2018-11-03T04:59:57Z",
      "updatedAt": "2019-05-09T06:31:15Z",
      "closedAt": "2019-05-09T06:31:15Z",
      "comments": [
        {
          "author": "Eudi4H",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing in favor of #130.",
          "createdAt": "2019-05-09T06:31:15Z",
          "updatedAt": "2019-05-09T06:31:15Z"
        }
      ]
    },
    {
      "number": 116,
      "id": "MDU6SXNzdWUzNzcxMzQ4MjM=",
      "title": "Compress server name in ClientHello",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/116",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "needs WG discussion"
      ],
      "body": "In a large-scale server deployment that benefits the most from ESNI (due to the size of the umbrella under which you would hide the domain names), it is often the case that the largest length of the server name to be supported is *unknown*. That leads such server deployments to use a padded_length of 260 because the longest valid DNS name is 253 characters, bloating the ClientHello.\r\n\r\nIt is beneficial to apply a lightweight compression algorithm to the server name to reduce the overhead.\r\n\r\nSome points to consider:\r\n* We cannot use a pre-learnt dictionary, because what we care is the longest possible length. Compression algorithm using a pre-learnt dictionary assigns longer symbols for rarely used patterns, which means that the worst case is longer than the non-compressed string.\r\n* We can use an adaptive compression algorithm (e.g. lz77, brotli), however they also would not compress well if the server-name is a random-looking string.",
      "createdAt": "2018-11-04T09:13:59Z",
      "updatedAt": "2019-11-05T20:10:41Z",
      "closedAt": "2019-11-05T20:10:41Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "Considering the two points, one practical solution will be to map the valid characters of a DNS name (i.e. `a`-`z`,`0`-`9`,`.`,`-`,`_`) to integers between 0 to 38, and encode three characters into a 16-bit value (39<sup>3</sup>=59319).\r\n\r\nBy applying the conversion, the worst length changes from 253 to 169 (i.e. `ceil(253/3*2)`), giving us 84 bytes back.",
          "createdAt": "2018-11-04T09:17:34Z",
          "updatedAt": "2018-11-05T00:11:40Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "To put it another way, the entropy we have when the set of server names is unknown is 39<sup>253</sup> ~ 256<sup>167.2</sup>.\r\n\r\nI do not think that we can go far below this limit by using contexts between the characters, because there aren't many patterns that are forbidden (two consecutive dots is (possibly one of the) rare pattern that never appears).\r\n\r\nConsidering that, using `mod 39` to squeeze three characters into 16 bit to achieve 256<sup>169</sup> is reasonable.",
          "createdAt": "2018-11-05T02:36:31Z",
          "updatedAt": "2018-11-05T02:36:31Z"
        },
        {
          "author": "kontaxis",
          "authorAssociation": "NONE",
          "body": "The valid characters in a DNS host name are [a-zA-Z0-9-] so 63.\r\n\r\nYou can represent each 8-bit character in the above set using 6 bits and group 4 characters together to form 24 bits.\r\nYou can then represent the 24 bits as 3 8-bit characters.\r\nThis is basically the Base64 decoding process.\r\nThe output is 3/4 of the input which means you gain 25%.\r\n\r\nBut then ServerName in ClientESNIInner won't be the same as the ServerName defined in RFC 3546 and it probably won't be printable.",
          "createdAt": "2019-03-08T00:24:04Z",
          "updatedAt": "2019-03-08T00:58:48Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho how do you want to proceed here?",
          "createdAt": "2019-11-04T20:48:37Z",
          "updatedAt": "2019-11-04T20:48:37Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood I think we should close this with no action.",
          "createdAt": "2019-11-05T06:03:32Z",
          "updatedAt": "2019-11-05T06:03:32Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds good! Closing.",
          "createdAt": "2019-11-05T20:10:41Z",
          "updatedAt": "2019-11-05T20:10:41Z"
        }
      ]
    },
    {
      "number": 117,
      "id": "MDU6SXNzdWUzNzcyODUwNzA=",
      "title": "easy to miss validity intervals",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/117",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "@hardie notes that the not_before and not_after fields are there and described, but not really part of the operational notes.  Having something there that talks about these, particularly as it relates to clock skew, would be valuable.",
      "createdAt": "2018-11-05T07:52:04Z",
      "updatedAt": "2019-06-17T18:17:54Z",
      "closedAt": "2019-06-17T18:17:54Z",
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "(My ~monthly login into github.com - this'd be better on the TLS WG list, and I will send mail on this sometime but anyway...)\r\nThe not-before and not-after fields are a mistake.\r\nSame as turned out true for x.509.\r\nI was just doing testing where FF nightly barfed on ESNIKeys I'd published for only that non-reason. (There is no overall security win in so-doing, in general.)\r\nCreating a tangle between the cadence at which one updates DNS, the ESNIKeys-internal \"lifetime\" of a key, the DNS TTL and server-state is basically just pointless nonsense. \r\nLet's delete those fields from ESNIKeys before we're done and just rely on DNS for what it already does.",
          "createdAt": "2019-06-10T22:49:18Z",
          "updatedAt": "2019-06-10T22:49:18Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "Now that #124 has been merged, I agree that there is less need for not_before and not_after fields. Previously, a client using an expired key led to connection failure, and therefore having these fields were necessary.",
          "createdAt": "2019-06-11T02:49:02Z",
          "updatedAt": "2019-06-11T02:49:13Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by removing these fields with #161.",
          "createdAt": "2019-06-17T18:17:49Z",
          "updatedAt": "2019-06-17T18:17:49Z"
        }
      ]
    },
    {
      "number": 118,
      "id": "MDU6SXNzdWUzNzc0MDY4OTc=",
      "title": "Is there a debug/development server to test client side implementation",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/118",
      "state": "CLOSED",
      "author": "mosajjal",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "We've recently developed a PoC for ESNI and we're having trouble pinning down what we're doing wrong since the test URL (https://cloudflare.com/cdn-cgi/trace) is still showing sni=off. \r\n\r\nI was wondering if CloudFlare is considering running a test/debug server to help us facilitate the development of various clients. ",
      "createdAt": "2018-11-05T13:46:41Z",
      "updatedAt": "2020-10-13T12:40:32Z",
      "closedAt": "2019-06-02T15:08:29Z",
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "Same here - well, sorta, I've just got to where I've an openssl [build](https://github.com/sftcd/openssl/tree/master/esnistuff)  sending a CH with the ESNI extension in that seems maybe correctish;-)\r\n\r\nWould be great if there was a public server to bang against.",
          "createdAt": "2018-11-20T21:26:09Z",
          "updatedAt": "2018-11-20T21:26:09Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "https://www.cloudflare.com/ssl/encrypted-sni/ supports the latest, Firefox does too (if you turn on all the right options, which I can share if necessary).",
          "createdAt": "2018-11-20T21:50:15Z",
          "updatedAt": "2018-11-20T21:50:15Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "Ta - was trying cloudflare.net - www.cloudflare.com seems to get me a bit further. Off to debug so:-)",
          "createdAt": "2018-11-20T21:56:31Z",
          "updatedAt": "2018-11-20T21:56:31Z"
        },
        {
          "author": "mosajjal",
          "authorAssociation": "NONE",
          "body": "[this](https://www.cloudflare.com/cdn-cgi/trace)  address is also good. But I'm looking for a debug server because my request's ESNI gets ignored by the server and I can't figure out why. ",
          "createdAt": "2018-11-21T04:43:53Z",
          "updatedAt": "2018-11-21T04:43:53Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing, since this is not an issue with the draft. Moved initial implementation list to https://github.com/tlswg/draft-ietf-tls-esni/wiki/ESNI-Implementations.",
          "createdAt": "2019-06-02T15:08:29Z",
          "updatedAt": "2019-06-02T15:08:29Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "Hiya, I just put up a server based on my openssl code; see https://defo.ie/ for details. (I would've tried edit the wiki but didn't see a button;-)",
          "createdAt": "2019-06-14T15:04:00Z",
          "updatedAt": "2019-06-14T15:04:00Z"
        },
        {
          "author": "avened",
          "authorAssociation": "NONE",
          "body": "Hello. There is a test server with ESNI support available at https://tls13.1d.pw/ (TLS 1.3 only).",
          "createdAt": "2019-11-04T16:33:15Z",
          "updatedAt": "2019-11-04T16:33:15Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "Hiya, that works with my ``openssl s_client`` client... so long as you don't send me an HRR! (Which you seem to be doing about every 2nd time?) If you do send me an HRR, then my side doesn't do the right thing yet - my code admittedly did have a \"TODO: ... implement ... handling HRR\" comment;-) ",
          "createdAt": "2019-11-06T21:28:56Z",
          "updatedAt": "2019-11-06T21:28:56Z"
        },
        {
          "author": "avened",
          "authorAssociation": "NONE",
          "body": "Actual probability of HRR being sent depends on key shares received from client (but, yes, it can be near 1/2). What concerns HRR + ESNI - interestingly, the same happened in NSS and Firefox, I've encountered it while testing browsers against this same test server (fixed in NSS 3.43 release).",
          "createdAt": "2019-11-06T22:02:20Z",
          "updatedAt": "2019-11-06T22:02:20Z"
        },
        {
          "author": "avened",
          "authorAssociation": "NONE",
          "body": "@ValZapod \r\n> Is there some source code of your server available? https://github.com/tlswg/draft-ietf-tls-esni/issues/118#issuecomment-707579615\r\n\r\nNo, not yet.\r\n\r\n> \u041a\u043b\u0430\u0441\u0441\u043d\u0430\u044f \u0448\u0442\u0443\u043a\u0430 \u043a\u0441\u0442\u0430\u0442\u0438.\r\n\r\n\u0421\u043f\u0430\u0441\u0438\u0431\u043e!",
          "createdAt": "2020-10-13T12:40:32Z",
          "updatedAt": "2020-10-13T12:40:32Z"
        }
      ]
    },
    {
      "number": 119,
      "id": "MDU6SXNzdWUzODM4NDMzMzU=",
      "title": "record_digest input bytes",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/119",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The I-D says: \"record_digest : A cryptographic hash of the ESNIKeys structure from which the ESNI key was obtained, i.e., from the first byte of \"checksum\" to the end of the structure. This hash is computed using the hash function associated with suite.\"\r\n\r\nFrom looking at the NSS code it appears that the record_digest input is actually the entire ESNIKeys (after base64 decode) including the version and checksum. Is that correct?\r\n\r\nIOW, does the following also produce the right value (for CF and sha256)?\r\n\r\n``dig +short txt _esni.www.cloudflare.com  | sed -e 's/\"//g' | base64 -d | openssl sha256``",
      "createdAt": "2018-11-23T14:27:47Z",
      "updatedAt": "2019-07-03T03:51:26Z",
      "closedAt": "2019-07-03T03:51:26Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "#163 proposes removing the checksum, which should clear this up. ",
          "createdAt": "2019-07-03T01:16:34Z",
          "updatedAt": "2019-07-03T01:16:34Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing since #163 landed. @sftcd, please re-open if this is still an issue!",
          "createdAt": "2019-07-03T03:51:26Z",
          "updatedAt": "2019-07-03T03:51:26Z"
        }
      ]
    },
    {
      "number": 121,
      "id": "MDU6SXNzdWUzODkzODExMjM=",
      "title": "Can the ESNI values change upon HRR?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/121",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [
        "needs WG discussion"
      ],
      "body": "RFC 8446 requires us to specify if the contents of ESNI can change upon a HRR.\r\n\r\nIn case of ESNI, the payload of the extension obviously can change, because the AAD (i.e. ClientHello.KeyShareClientHello) can change. However, we haven't specified if other values (e.g., ClientESNIInner.nonce) can.\r\n\r\nIMO, we should prohibit needless changes.\r\n\r\nTo clarify, all the non-encrypted portion and the encrypted payload of ESNI MUST be consistent between the first ClientHello and the second one.",
      "createdAt": "2018-12-10T16:28:25Z",
      "updatedAt": "2020-10-16T17:14:14Z",
      "closedAt": "2020-03-09T21:58:12Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "\ud83d\udc4d ",
          "createdAt": "2018-12-10T16:56:17Z",
          "updatedAt": "2018-12-10T16:56:17Z"
        },
        {
          "author": "jb-wisemo",
          "authorAssociation": "NONE",
          "body": "Bad idea.  Causing the encrypted ESNI to change such that observers cannot determine if this is a request for the same or a different back end name is a major security feature of the mechanism.  If a popular CDN such a cloudflare or S3 enables ESNI on their front end servers, observers should not be able to detect if repeated requests from a client are the usual pattern of retrieving common noise from web frameworks, random surfing of many sites or a long visit to a banned site.  ESNI servers (and only ESNI servers) would deal with recognizing that requests are actually resuming the same session despite the camouflage differences.\r\n",
          "createdAt": "2019-03-01T18:51:41Z",
          "updatedAt": "2019-03-01T18:51:41Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@jb-wisemo \r\n> Causing the encrypted ESNI to change such that observers cannot determine if this is a request for the same or a different back end name is a major security feature of the mechanism.\r\n\r\nI do not get that. When HRR is used on TCP, the fact that the 1st CH and 2nd CH (sent in HRR) specify the same server name will be evident from the fact that they are sent on a single TCP connection. In case of HRR used with cookies, an observer will be able to track the pair by using cookies.",
          "createdAt": "2019-03-02T21:45:06Z",
          "updatedAt": "2019-03-02T21:45:06Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This is addressed in #207.",
          "createdAt": "2020-03-08T00:33:40Z",
          "updatedAt": "2020-03-08T00:33:40Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #207.",
          "createdAt": "2020-03-09T21:58:12Z",
          "updatedAt": "2020-03-09T21:58:12Z"
        }
      ]
    },
    {
      "number": 123,
      "id": "MDU6SXNzdWUzOTA4Mjg3Nzk=",
      "title": "Encrypted nonce in ClientESNIInner",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/123",
      "state": "CLOSED",
      "author": "roelfdutoit",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Would you consider a PR for encrypting the ClientESNIInner nonce?\r\n\r\nWhat I have in mind is the following:\r\n`struct {\r\n       EncryptedNonce enc_nonce;\r\n       PaddedServerNameList realSNI;\r\n   } ClientESNIInner;`\r\n.. where:\r\n`nonceAAD = ClientHello.KeyShareClientHello || realSNI`\r\n`EncryptedNonce = AEAD-Encrypt(nonce_key, nonce_iv, nonceAAD, nonce)`\r\n.. and:\r\n`nonce_key = HKDF-Expand-Label(Zx, \"nonce key\", Hash(ESNIContents), key_length)`\r\n`nonce_iv = HKDF-Expand-Label(Zx, \"nonce iv\", Hash(ESNIContents), iv_length)`\r\n\r\nThe use case is an escrow system where the client wants to allow **read-only** visibility of the real SNI value by only sharing {key,iv} and keeping {nonce_key,nonce_iv} and Zx secret.   Only the real server would be able to acknowledge 'nonce' in EncryptedExtensions.",
      "createdAt": "2018-12-13T19:38:59Z",
      "updatedAt": "2019-07-03T21:06:27Z",
      "closedAt": "2019-07-03T21:06:27Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "This seems like a change which is very hard to analyze with limited value,\nso I would not be in favor.\n\nOn Thu, Dec 13, 2018 at 11:39 AM Roelof DuToit <notifications@github.com>\nwrote:\n\n> Would you consider a PR for encrypting the ClientESNIInner nonce?\n>\n> What I have in mind is the following:\n> struct { EncryptedNonce enc_nonce; PaddedServerNameList realSNI; }\n> ClientESNIInner;\n> .. where:\n> nonceAAD = ClientHello.KeyShareClientHello || realSNI\n> EncryptedNonce = AEAD-Encrypt(nonce_key, nonce_iv, nonceAAD, nonce)\n> .. and:\n> nonce_key = HKDF-Expand-Label(Zx, \"nonce key\", Hash(ESNIContents),\n> key_length)\n> nonce_iv = HKDF-Expand-Label(Zx, \"nonce iv\", Hash(ESNIContents), iv_length)\n>\n> The use case is an escrow system where the client wants to allow\n> *read-only* visibility of the real SNI value by only sharing {key,iv} and\n> keeping {nonce_key,nonce_iv} and Zx secret. Only the real server would be\n> able to acknowledge 'nonce' in EncryptedExtensions.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/issues/123>, or mute the\n> thread\n> <https://github.com/notifications/unsubscribe-auth/ABD1oU3KagiPrj04JxnWI89FlD92g9EQks5u4qzTgaJpZM4ZSSdw>\n> .\n>\n",
          "createdAt": "2018-12-13T19:44:37Z",
          "updatedAt": "2018-12-13T19:44:37Z"
        },
        {
          "author": "roelfdutoit",
          "authorAssociation": "NONE",
          "body": "PR created:\r\nhttps://github.com/tlswg/draft-ietf-tls-esni/pull/147",
          "createdAt": "2019-03-07T23:33:48Z",
          "updatedAt": "2019-03-07T23:33:48Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi @roelfdutoit, can you elaborate on the motivations for this change? In what scenario would the client wish to share the SNI with a third party?",
          "createdAt": "2019-03-08T00:41:18Z",
          "updatedAt": "2019-03-08T00:41:18Z"
        },
        {
          "author": "roelfdutoit",
          "authorAssociation": "NONE",
          "body": "Enterprise network security solutions are evolving, especially in the area of monitoring and analytics, and SNI is a valuable attribute in such an environment.  A client would share the ESNI {key,iv} with configured enterprise monitoring devices (NGFW, IPS, Proxy, IDS, DLP, etc) and this becomes critical in a zero trust network.  There is a lot of focus on using ESNI in a CDN world, but the mechanism would also be very valuable for enterprises that host multiple proprietary services - again, in a zero trust environment.  Those proprietary services and applications must be monitored at different points in the enterprise network, requiring access to the true SNI.  The PR would provide a responsible way to share the true SNI, without the need for traditional TLS intercept - assuming a secure sharing mechanism is used.",
          "createdAt": "2019-03-08T02:44:07Z",
          "updatedAt": "2019-03-08T02:44:07Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@roelfdutoit can you please bring this issue to the list for further discussion?",
          "createdAt": "2019-07-03T03:52:36Z",
          "updatedAt": "2019-07-03T03:52:36Z"
        }
      ]
    },
    {
      "number": 126,
      "id": "MDU6SXNzdWUzOTUwODkzNTI=",
      "title": "Do not send cached_info cert type when using ESNI",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/126",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "An adversary who observes the certificate fingerprint could confirm certificates previously fetched by a ESNI-compatible client.",
      "createdAt": "2019-01-01T14:46:54Z",
      "updatedAt": "2019-03-16T03:37:43Z",
      "closedAt": "2019-03-16T03:37:43Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #127.",
          "createdAt": "2019-03-16T03:37:43Z",
          "updatedAt": "2019-03-16T03:37:43Z"
        }
      ]
    },
    {
      "number": 130,
      "id": "MDU6SXNzdWU0MDA5NDQxODc=",
      "title": "Consider dropping split mode altogether",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/130",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "needs WG discussion"
      ],
      "body": "The mechanism to make split mode work in practice requires non-trivial changes to both the fronting server and origin. Moreover, as the main (mass user base) benefit for ESNI is shared mode, perhaps we should consider dropping split mode.",
      "createdAt": "2019-01-19T01:14:24Z",
      "updatedAt": "2019-09-28T14:41:38Z",
      "closedAt": "2019-09-28T14:41:38Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I would not be in favor of this change. There are real uses for split mode and we should try to address them",
          "createdAt": "2019-01-19T03:00:16Z",
          "updatedAt": "2019-01-19T03:00:16Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm in favor of removing split mode from this draft, the added complexity is not necessarily worth it.",
          "createdAt": "2019-01-20T00:33:47Z",
          "updatedAt": "2019-01-20T00:33:47Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I thought about this some and decided that:\r\n * Split mode is valuable and worth supporting.\r\n * It needs more specification than can reasonably fit in this draft.\r\n * It's part of a larger problem related to load balancers.\r\n\r\nSo I wrote a [new draft on this topic](https://tools.ietf.org/html/draft-schwartz-tls-lb-00).  My hope is that we can remove the detailed discussion of split mode here and replace it with a reference to that draft.\r\n\r\nThere's one thing I'd like to resolve before sending that draft to the TLS list: That draft is derived from the brief proposal in this draft to use a PSK to transfer `Z` between the servers.  I'm not 100% sure who proposed that design, but in my draft I added an acknowledgement to @ekr after looking through the version history here.  I'd like to make sure that credit is correct, and I'm happy to add whoever came up with that to the authors list.",
          "createdAt": "2019-06-28T15:03:31Z",
          "updatedAt": "2019-06-28T15:03:31Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "1. I am not in favor of removing the discussion of split mode from this\ndocument, though I am fine to have detail elsewhere.\n2. I think I was the person who proposed the PSK idea, but honestly, it's\npretty obvious so I'm not worried about credit and if someone else thinks\nthey were first, I'm not going to argue,\n\nOn Fri, Jun 28, 2019 at 8:03 AM Benjamin M. Schwartz <\nnotifications@github.com> wrote:\n\n> I thought about this some and decided that:\n>\n>    - Split mode is valuable and worth supporting.\n>    - It needs more specification than can reasonably fit in this draft.\n>    - It's part of a larger problem related to load balancers.\n>\n> So I wrote a new draft on this topic\n> <https://tools.ietf.org/html/draft-schwartz-tls-lb-00>. My hope is that\n> we can remove the detailed discussion of split mode here and replace it\n> with a reference to that draft.\n>\n> There's one thing I'd like to resolve before sending that draft to the TLS\n> list: That draft is derived from the brief proposal in this draft to use a\n> PSK to transfer Z between the servers. I'm not 100% sure who proposed\n> that design, but in my draft I added an acknowledgement to @ekr\n> <https://github.com/ekr> after looking through the version history here.\n> I'd like to make sure that credit is correct, and I'm happy to add whoever\n> came up with that to the authors list.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/issues/130?email_source=notifications&email_token=AAIPLINHQPO5SJFANUDLRF3P4YR4JA5CNFSM4GRDQ36KYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODY2KNDA#issuecomment-506766988>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAIPLILIAK7IRVQRIZ3HQDTP4YR4JANCNFSM4GRDQ36A>\n> .\n>\n",
          "createdAt": "2019-06-28T16:32:15Z",
          "updatedAt": "2019-06-28T16:32:15Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "One discrepancy is whether the frontend shares the Z value with the backend or the ClientESNIInner. The new draft says the latter and the appendix in the ESNI draft says the former.\r\n\r\nWas there a particular reason to send Z? All else equal, ClientESNIInner seems much more straightforward to deploy and reason about. Frontend and backend need to coordinate on which ESNI encryption schemes to support if sending Z. It also feels odd to send along a raw unKDFed key exchange secret like that, but maybe it's fine?\r\n\r\n[Edit: I wrote \"do not need\" originally when I should have written \"need\".]",
          "createdAt": "2019-06-28T16:40:29Z",
          "updatedAt": "2019-06-28T16:41:03Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I suggested Z on the theory that it would make it hard to lie about\nClientESNIInner. I haven't thought through it all in detail, though.\n\nOn Fri, Jun 28, 2019 at 9:40 AM David Benjamin <notifications@github.com>\nwrote:\n\n> One discrepancy is whether the frontend shares the Z value with the\n> backend or the ClientESNIInner. The new draft says the latter and the\n> appendix in the ESNI draft says the former.\n>\n> Was there a particular reason to send Z? All else equal, ClientESNIInner\n> seems much more straightforward to deploy and reason about. Frontend and\n> backend do not need to coordinate on which ESNI encryption schemes to\n> support if sending Z. It also feels odd to send along a raw unKDFed key\n> exchange secret like that, but maybe it's fine?\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/issues/130?email_source=notifications&email_token=AAIPLIIZ6L5ZNA73CCD2GB3P4Y5H5A5CNFSM4GRDQ36KYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODY2SNKI#issuecomment-506799785>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAIPLIJ2KE2AHR4J6D4ZCHTP4Y5H5ANCNFSM4GRDQ36A>\n> .\n>\n",
          "createdAt": "2019-06-28T16:45:25Z",
          "updatedAt": "2019-06-28T16:45:25Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "(Late filling this out...)\r\n\r\nDiscussed in Montreal: we don't need to remove it -- we simply shouldn't make it impossible to implement, and the draft as of now achieves that goal. So, I'm closing this issue.",
          "createdAt": "2019-09-28T14:41:11Z",
          "updatedAt": "2019-09-28T14:41:36Z"
        }
      ]
    },
    {
      "number": 131,
      "id": "MDU6SXNzdWU0MDczOTYwOTc=",
      "title": "Proposal: ESNI record Implies TLS support",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/131",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "needs WG discussion"
      ],
      "body": "Proposal:\r\nThe ESNI DNS record specification, wherever it ends up, should have the following requirement:\r\n\"If a domain or endpoint publishes an ESNI DNS record, then that domain MUST be accessible over TLS.\"\r\n\r\nThis is almost trivial (why would you publish an ESNI record if you don't have TLS support?), but it would be tremendously useful for browsers, as a way to learn that the specified domain supports HTTPS before attempting a connection.  If DNS records are fetched over a secure channel, this would enable HSTS-like behavior without an insecure bootstrap or a preload list.",
      "createdAt": "2019-02-06T19:34:35Z",
      "updatedAt": "2019-07-03T00:10:21Z",
      "closedAt": "2019-07-03T00:10:21Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A domain name that has ESNI keys is very likely to support TLS, but you can't assume that is supports HTTPS on port 443 - they could be using TLS for something else.",
          "createdAt": "2019-02-06T19:47:06Z",
          "updatedAt": "2019-02-06T19:47:06Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That depends on how we define the ESNI record.  For example, we could insert a port in the name (like SRV), or include a list of the applicable ports in the record contents.  (Or we could just declare that ESNI implicitly blacklists port 80, which I believe is what you are arguing against.)\r\n\r\nIt's up to us.",
          "createdAt": "2019-02-06T19:58:19Z",
          "updatedAt": "2019-02-06T19:58:19Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "By default, http and https are different origins. HSTS is a opt-in signal that changes the behavior. \r\n\r\nConsidering that, I think that the discussion needs to happen the HTTPbis WG on if the WG should define an extension to ESNI.",
          "createdAt": "2019-02-08T08:02:14Z",
          "updatedAt": "2019-02-08T08:02:14Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Is ESNI something you would use for protocols other than HTTP?",
          "createdAt": "2019-07-03T00:00:54Z",
          "updatedAt": "2019-07-03T00:00:54Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I tend to think yes. Suppose, for instance, you had DoQ.",
          "createdAt": "2019-07-03T00:07:40Z",
          "updatedAt": "2019-07-03T00:07:40Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed. @bemasc, this should probably go to httpbis for discussion! I'm closing for now.",
          "createdAt": "2019-07-03T00:10:21Z",
          "updatedAt": "2019-07-03T00:10:21Z"
        }
      ]
    },
    {
      "number": 132,
      "id": "MDU6SXNzdWU0MDk5NjcxMTM=",
      "title": "Interaction with Alternative Services is confusing",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/132",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The draft currently states:\r\n\r\n> In cases where the domain of the A or AAAA records being resolved do not match the SNI Server Name, such as when {{!RFC7838}} is being used, the SNI domain should be used for querying the ESNI TXT record.\r\n\r\nI'm confused about what this means. From reading RFC 7838, I'm not sure the SNI and DNS names do not match when you're querying an alternate name. In particular, RFC 7838 states:\r\n\r\n> For example, if the origin's host is \"www.example.com\" and an alternative is offered on \"other.example.com\" with the \"h2\" protocol, and the certificate offered is valid for \"www.example.com\", the client can use the alternative.\r\n\r\nWhich means, if I understand it correctly, the client will send \"other.example.com\" in the SNI when trying to query resources from it - the requirement is only that the certificate for \"other.example.com\" also cover \"www.example.com\".",
      "createdAt": "2019-02-13T19:36:27Z",
      "updatedAt": "2019-03-08T21:24:28Z",
      "closedAt": "2019-03-08T21:24:28Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed. I'm parsing RFC 7838 the same way. I think we should drop this text.",
          "createdAt": "2019-02-16T00:41:15Z",
          "updatedAt": "2019-02-16T00:41:15Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The problem the text presents is real (though the resolution is arbitrary).\r\n\r\n> Which means, if I understand it correctly, the client will send \"other.example.com\" in the SNI when trying to query resources from it - the requirement is only that the certificate for \"other.example.com\" also cover \"www.example.com\".\r\n\r\nno.. that's a misread. See section 2.3 of 7838\r\n```\r\n Note that the SNI information provided in TLS by the client will be\r\n   that of the origin, not the alternative (as will the Host HTTP header\r\n   field value).\r\n```\r\n\r\nThe alternate is essentially just a cname for the origin. If host b is an alternate for origin a, in order to use the alternate you look up the DNS a/aaaa of b, do a TCP connect to b, and then use sni=a and expect a certificate valid for a. (indeed the point of the SNI is to tell the server what certificate you expect to see)\r\n\r\nWith esni you would continue to do all of those things, except of course sni=encrypted(a).. and the question becomes where do you find the key used for the encryption. Is it the ESNI DNS record of a (the origin) or b (the alternate host). That's the question the text is trying to resolve - it says to use a (the origin). I could make a case for either choice but I think the text needs to decide \r\n",
          "createdAt": "2019-02-17T01:59:38Z",
          "updatedAt": "2019-02-17T02:14:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@mcmanus Would you mind suggesting some text with an example to clear this up?",
          "createdAt": "2019-02-19T17:11:54Z",
          "updatedAt": "2019-02-19T17:11:54Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mcmanus thanks for the clarification and pointer to s2.3 of 7838.\r\n\r\nAfter reading that I think the text in the ESNI draft looks fine. (I'd just add a pointer to s2.3 of 7838 instead of just 7838 to help prevent the confusion I had)",
          "createdAt": "2019-02-21T20:32:08Z",
          "updatedAt": "2019-02-21T20:32:17Z"
        }
      ]
    },
    {
      "number": 133,
      "id": "MDU6SXNzdWU0MTA1MDgxNDI=",
      "title": "Always returning the same records is too restrictive",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/133",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The document currently states:\r\n\r\n> Servers operating in Split Mode SHOULD have DNS configured to return the same A (or AAAA) record for all ESNI-enabled servers they service. This yields an anonymity set of cardinality equal to the number of ESNI-enabled server domains supported by a given client-facing server. Thus, even with SNI encryption, an attacker which can enumerate the set of ESNI-enabled domains supported by a client-facing server can guess the correct SNI with probability at least 1/K, where K is the size of this ESNI-enabled server anonymity set. This probability may be increased via traffic analysis or other mechanisms.\r\n\r\nI think this is too restrictive. If I have 100000 names and 100 IPs and for all queries I randomly return four out of my 100 IPs chosen randomly, I still provide the same anonymity set but I violate the SHOULD. How about: `Content providers operating in Split Mode SHOULD ensure that the A and AAAA records for ESNI-enabled server names do not allow identifying the server name from the IP address. This can for example be achieved by always returning the same records for all ESNI-enabled names, or by having the function that picks addresses from a pool not depend on the server name. This yields an anonymity set...`",
      "createdAt": "2019-02-14T21:50:38Z",
      "updatedAt": "2019-06-02T15:13:39Z",
      "closedAt": "2019-06-02T15:13:39Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "NONE",
          "body": "Agreed.  At a minimum this should reference a set of A and AAAA records rather than \"the record\" (as many records across the A and AAAA rrsets is very common).\r\n\r\nI think @DavidSchinazi's proposed text is fine.",
          "createdAt": "2019-02-21T16:21:12Z",
          "updatedAt": "2019-02-21T16:21:12Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@DavidSchinazi sgtm, do you plan to open a PR? I made https://github.com/ghedo/draft-ietf-tls-esni/commit/c9570cf4a00925bead63d46ecd6744288209146e but I think your wording is better.",
          "createdAt": "2019-06-01T10:52:28Z",
          "updatedAt": "2019-06-01T10:52:28Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Created #157",
          "createdAt": "2019-06-02T09:36:08Z",
          "updatedAt": "2019-06-02T09:36:08Z"
        }
      ]
    },
    {
      "number": 134,
      "id": "MDU6SXNzdWU0MTA5MjY4OTU=",
      "title": "260 bytes is maybe a bit much?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/134",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Stephen Farrell pointed out on the list that 260 is rather a lot of waste to stick into the ClientHello.\r\nhttps://mailarchive.ietf.org/arch/msg/tls/kW_SWFamoj6IME4JzGseBKDyUV4\r\n\r\n260 characters is this large of a hostname:\r\n```\r\n>>> \"a\" * 260\r\n'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'`\r\n```\r\n\r\nIt's probably reasonable to recommend a smaller default value like 64 or 96 or 128. (Numbers pulled out of a hat. I have no data on how big it actually should be.)",
      "createdAt": "2019-02-15T20:15:01Z",
      "updatedAt": "2019-07-03T00:33:47Z",
      "closedAt": "2019-07-03T00:33:47Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah. The question is if we are happy with hostnames longer than the threshold (e.g., 64, 96, 128) sticking out. I think the current design of allowing the server to choose the correct value is the right approach.\r\n\r\nOTOH, regarding the size you'd use for greasing, I can understand the concern of wasting bytes. Maybe browsers can use smaller sized payloads when greasing the ESNI extension, under the premise that they would be sometimes using the maximum.\r\n\r\nThe size of the extension being different from when it is actually used does not matter in practice, because an observer can typically tell if ESNI was used by checking if the unencrypted SNI record contains the fallback domain name (here I assume that we adopt #134).",
          "createdAt": "2019-02-16T00:30:58Z",
          "updatedAt": "2019-02-16T00:30:58Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed that letting the server choose the correct value makes sense. But I think the specification should also be opinionated about this, so we don't get wildly different values for everyone, and so implementors have something to pick if they don't really care. The closely thing the spec currently has to an opinion is 260, which is kind of large.",
          "createdAt": "2019-02-16T00:35:58Z",
          "updatedAt": "2019-02-16T00:35:58Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Absent data that shows there's a tighter upper bound, I would prefer to keep the 260 recommendation and perhaps suggest that servers may choose something smaller if they know better. ",
          "createdAt": "2019-02-16T00:39:11Z",
          "updatedAt": "2019-02-16T00:39:11Z"
        },
        {
          "author": "kontaxis",
          "authorAssociation": "NONE",
          "body": "According to RFC 1035 host names can be up to 255 octets.\r\nI don't think this has changed.\r\nSo if this document makes a recommendation it should cover the worst case.\r\n\r\nSomeone could argue for something more efficient.\r\nFor instance, if we were to do draw the distribution of name lengths we would find that the median is 13 characters. (An excellent number) Min is 4 and max is 117. (Source: https://scans.io/study/umich-https)\r\nBut this can change and the recommendation in this document will become outdated.\r\n\r\nMaybe add something like the following: \"servers COULD tailor the padding length to cover the longest name associated with the hosts they handle.\" (And keep the existing number)",
          "createdAt": "2019-03-08T06:14:27Z",
          "updatedAt": "2019-03-08T06:14:27Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In the current text, the \"260\" number only matters for GREASE; anyone who actually publishes ESNIKeys SHOULD choose the smallest number that covers their names, \"rounded up to the nearest multiple of 16\".  Given @kontaxis's data, the most common choices will likely be 16 and 32.  This state of affairs makes GREASE less effective, because (1) it doesn't resemble real usage and (2) it isn't exercising the length \"joint\".\r\n\r\nAs a solution, I would propose recommending that GREASE clients choose a valid length at random.  If we want to get fancy we could say that the random choice may be non-uniform (to favor shorter ClientHellos) but should have at least x% chance of choosing each length option.\r\n\r\nAlso, instead of saying that the padded_length \"SHOULD\" be 16*N or 260, I think we should consider a \"MUST\", and/or a denser encoding (e.g. enum with values 0..16).  Otherwise, we have to figure out what clients should do if `padded_length` is huge.  (I wonder how that interacts with QUIC and DDoS...)",
          "createdAt": "2019-05-21T18:40:27Z",
          "updatedAt": "2019-05-21T18:40:27Z"
        },
        {
          "author": "mrsylerpowers",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Another proposal is mentioned in #116 of just compressing these bits instead",
          "createdAt": "2019-06-10T16:14:07Z",
          "updatedAt": "2019-06-10T16:14:07Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@davidben this should be fixed, with new recommendation text, via #162. Please re-open if not!",
          "createdAt": "2019-07-03T00:33:46Z",
          "updatedAt": "2019-07-03T00:33:46Z"
        }
      ]
    },
    {
      "number": 135,
      "id": "MDU6SXNzdWU0MTMwMDU3MDU=",
      "title": "Extensible information in ESNIKey DNS record",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/135",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "We may wish to have a way to indicate additional (extensible?) information relevant to establishing a connection alongside ESNIKeys in whatever record is introduced.  This increases the value of clients doing an additional DNS resolution in cases where it reduces future round-trips and reduces the need for subsequent DNS lookups.  In particular (and their might be others in the future):\r\n\r\n* Being able to indicate that an Alternate Service (such as QUIC can/should be used).  Being able to switch directly to QUIC out of DNS without adding in additional resolutions, the need to go via TCP, or RTTs would add significant value and motivation to implement for clients and servers.\r\n\r\n* Being able to indicate that HSTS should be used on a bareword hostname (ie, to default to HTTPS when no scheme is present).  This might unblock browsers from defaulting to HTTPS.\r\n\r\n",
      "createdAt": "2019-02-21T16:14:52Z",
      "updatedAt": "2019-02-21T16:17:36Z",
      "closedAt": "2019-02-21T16:17:36Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "There already is such a field:\r\n\r\n```\r\n    struct {\r\n        uint16 version;\r\n        uint8 checksum[4];\r\n        KeyShareEntry keys<4..2^16-1>;\r\n        CipherSuite cipher_suites<2..2^16-2>;\r\n        uint16 padded_length;\r\n        uint64 not_before;\r\n        uint64 not_after;\r\n        Extension extensions<0..2^16-1>;   <---- HERE\r\n    } ESNIKeys;````\r\n",
          "createdAt": "2019-02-21T16:17:36Z",
          "updatedAt": "2019-02-21T16:17:36Z"
        }
      ]
    },
    {
      "number": 138,
      "id": "MDU6SXNzdWU0MTU0MDkxMDQ=",
      "title": "Use ESNI in local discovery mode",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/138",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "I am looking at using ESNI for local private discovery. It would work as follow:\r\n\r\n1) Authorized clients know the ESNI public key of the private server, which is otherwise kept secret.\r\n\r\n2) Client initiates a DTLS session or a QUIC connection by broadcasting a message containing ESNI extension targeting the specific server.\r\n\r\n3) Servers only respond if the recognize their key and name in the extension.\r\n\r\nESNI almost works as is for that, but not quite. First, the \"record_digest\" component allows identification and tracking of the server. In the private discovery mode, we would want to either not use it at all, or incorporate a nonce in the digest.\r\n\r\nSecond, ALPN. But you know that.",
      "createdAt": "2019-02-28T01:50:14Z",
      "updatedAt": "2020-10-16T17:14:15Z",
      "closedAt": "2019-07-08T17:26:01Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Re: ALPN: Why can't that be public?  You aren't intending to try to keep the fact that this is local private discovery, are you?",
          "createdAt": "2019-02-28T03:13:31Z",
          "updatedAt": "2019-02-28T03:13:31Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ALPN: It depends. Model 1 would be discovery over DTLS, i.e. handshake followed by DNS/MDNS over DTLS. Model 2 would be discovery integrated in the application, say using QUIC. The first client initial packet would be broadcast, and then the connection just proceeds.",
          "createdAt": "2019-02-28T03:44:00Z",
          "updatedAt": "2019-02-28T03:44:00Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I see, you are suggesting that - in model 2 - the connection is used for both discovery AND the application protocol.  I agree that the application protocol might be too revealing in that case.  \"h3\" might not be, but something more device-specific might leave nothing to the imagination.",
          "createdAt": "2019-02-28T03:51:46Z",
          "updatedAt": "2019-02-28T03:51:46Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Further analysis shows that even adding salt to the hash before computing the \"record digest\" will not help.  This is a defense in depth issue. The privacy of the discovery depends on keeping secret the \"discovery ESNI key\" of the service. If for some reason that key leaks, the attackers can mount active attacks and discover whether a target is present on a network. The record digest, even if it was salted, allows them to also perform passive attacks, such as looking at the digests in a log and checking whether they match a known key.\r\n\r\nThe simplest solution is to just omit the digest when using the ESNI extension for local discovery, e.g. when a DTLS or QUIC initial packet is received over a multicast address.",
          "createdAt": "2019-02-28T18:47:42Z",
          "updatedAt": "2019-02-28T18:47:42Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> The simplest solution is to just omit the digest when using the ESNI extension for local discovery, e.g. when a DTLS or QUIC initial packet is received over a multicast address.\r\n\r\nSounds correct to me. To me it seems that the trade-off here is trial-decryption vs. exposing the key identifier. In the proposed local discovery scheme, every node is expected to perform trial decryption. That's fine for the proposed scheme, but not for ordinary ESNI keys in which we need a key identifier to avoid trial decryption.",
          "createdAt": "2019-03-05T07:08:54Z",
          "updatedAt": "2019-03-05T07:08:54Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This should be fixed by #166. @huitema, please reopen if that's not the case!",
          "createdAt": "2019-07-08T17:26:01Z",
          "updatedAt": "2019-07-08T17:26:01Z"
        }
      ]
    },
    {
      "number": 139,
      "id": "MDU6SXNzdWU0MTYyMjg0NDU=",
      "title": "Associate the ESNI record with the client-facing server IP",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/139",
      "state": "CLOSED",
      "author": "jb-wisemo",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "help wanted"
      ],
      "body": "To maximize the cover range for clients and simplify management of the ESNI records, it is more useful to associate the ESNI records with the server rather than the query domain name.  This has the additional benefit of allowing different client-facing servers to use different rotating private DH keys.\r\n\r\nThis eliminates the issues with CNAMEs, individual query domain holders having to make changes, DNS namespace issues etc.\r\n\r\nFor example a large hoster wishing to provide cover for some clients by having their primary / CDN front ends offer ESNI for all requests can then simply enable the code on their server then add the ESNI records.  They can even do this gradually over a large pool of servers, thus having some servers with different (or no) ESNI support during each careful rollout of ESNI software upgrades.\r\n\r\nIn practice the following conventions would be used:\r\n\r\n1. Any ESNI server IP must have exactly one PTR record (typically pointing to the hoster domain, such as a typical systematic CDN node DNS name).  Lets call this name ptrnam.dom\r\n\r\n2. The ESNI records would be under _esni.ptrnam.dom\r\n\r\n3. As with most PTR records ptrnam.dom is expected to have exactly one AAAA or A record pointing back at the same IP (if the starting IP is IPv6 only AAAA need to satisfy this, if IPv4 only A, the same ptrnam.dom can be used for one IPv4 and one IPv6 address if the ESNI records would be the same).\r\n\r\n4. For address-less server types such as tor hidden services, the ESNI records would be published via whatever DNS or DNS-like mechanism is used for that transport, or queried by sending a DNS query for the record to the target, allowing the target to respond within that transport.\r\n\r\nBenefits:\r\n\r\n- B1. Large client-facing servers such as CDNs and shared IP hosters can deploy ESNI without having to negotiate DNS changes with all their customers (in fact with any of their customers).\r\n\r\n- B2. Operators of large pools of client-facing servers such as CDNs can roll out ESNI support and ESNI implementation upgrades in a piecemeal and controlled manner similar to how other system updates are rolled out.  Simply because each IP address will have its own ESNI records.\r\n\r\n- B3. ESNI key rotation becomes much simpler as there is no need to synchronize it between different servers in a pool (except where a pure layer 1/2/3 load balancer shares a single IP among multiple physical/virtual servers, such as the layer 2 HALinux scheme).\r\n\r\n- B4. ESNI private key protection can be much stronger when it is not shared among all the servers.  The private key may be kept in protected hardware and/or in volatile RAM.  The latter case would require clients to fall back to a different A or AAAA record until the DNS entries for now forgotten keys to have expired, but only in case of a server crash or similar event.\r\n\r\n- B5. Client queries for ESNI records do not reveal the actual query domain that will be encrypted, only the IP address to which the ESNI extension will be sent.\r\n\r\n- B6. The whole discussion about _esni prefix or no _esni prefix becomes a lot simpler when there is no need to put ESNI records in every end query domain, only domains of the client-facing servers, allowing to keep the unprefixed TXT name space clean for existing uses such as SPF.\r\n\r\nDownsides:\r\n\r\n- P1: Clients will have to postpone the _esni DNS query until after receiving the answer to the A or AAAA query, thus adding an extra DNS roundtrip before the first connection to a name.  The usual DNS caching hierarchy should mitigate this.  In particular for popular CDNs, a client will typically use the same handful of IPs for lots of unrelated traffic, thus getting the ESNI records in its local cache.\r\n\r\n- P2: VM hosting/Physical hosting/connectivity providers not granting PTR name assignment control to IP address customers will cause the same problems as for other protocols (such as mail) and should thus be under the same or greater pressure to add that service.  However since the greatest ESNI benefit is with IPs shared among many unrelated domains, and the operators of such IPs typically have full IP space ownership or the leverage to get PTR records where normal customers cannnot, the effect on ESNI deployment should be limited.\r\n\r\n- P3: This may or may not make it easier to do spoofing attacks, as an MitM attacker can spoof DNS responses either for the A/AAAA records of a target query domain (pointing to servers entirely under the attackers control, including legitimate ESNI records for that server) OR spoof the ESNI records of a server address for which the attacker has obtained traffic intercept ability.  However these can be secured with the same DNS countermeasures already applicable to those DNS domains.\r\n\r\n- P4: query domains wishing to remain available in massively blocking markets (the kind that would not hesitate to block an entire CDN to stop access to a single web page) may have more difficulty opting out of ESNI so such blocking filters can recognize them as a permitted service.\r\n",
      "createdAt": "2019-03-01T18:35:45Z",
      "updatedAt": "2020-05-28T03:57:18Z",
      "closedAt": "2020-05-27T12:20:56Z",
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This has been kicked around before and generally not selected based on the\ndownsides you identify - prinicipally the serialization issue as well as\npractical matters of control of PTR records. It also prohibits the use of\nmore than 1 key on an address - that's obviously a bad thing for the\nanonymity pool at its extreme, but some architectures might require more\nthan one pool.\n\nYou can fix the latter two issues by using another suggestion that has\npreviously been made: connect to the server and validate an IP based\ncertificate and then get the ESNI key via a REST API (or equivalent) - but\nthat is still likely too slow and comes with the challenges of IP based\ncertificate management.\n\nOn Fri, Mar 1, 2019 at 1:35 PM jb-wisemo <notifications@github.com> wrote:\n\n> To maximize the cover range for clients and simplify management of the\n> ESNI records, it is more useful to associate the ESNI records with the\n> server rather than the query domain name. This has the additional benefit\n> of allowing different client-facing servers to use different rotating\n> private DH keys.\n>\n> This eliminates the issues with CNAMEs, individual query domain holders\n> having to make changes, DNS namespace issues etc.\n>\n> For example a large hoster wishing to provide cover for some clients by\n> having their primary / CDN front ends offer ESNI for all requests can then\n> simply enable the code on their server then add the ESNI records. They can\n> even do this gradually over a large pool of servers, thus having some\n> servers with different (or no) ESNI support during each careful rollout of\n> ESNI software upgrades.\n>\n> In practice the following conventions would be used:\n>\n>    -\n>       1. Any ESNI server IP must have exactly one PTR record (typically\n>       pointing to the hoster domain, such as a typical systematic CDN node DNS\n>       name). Lets call this name ptrnam.dom\n>    -\n>       1. The ESNI records would be under _esni.ptrnam.dom\n>    -\n>       1. As with most PTR records ptrnam.dom is expected to have exactly\n>       one AAAA or A record pointing back at the same IP (if the starting IP is\n>       IPv6 only AAAA need to satisfy this, if IPv4 only A, the same ptrnam.dom\n>       can be used for one IPv4 and one IPv6 address if the ESNI records would be\n>       the same).\n>    -\n>       1. For address-less server types such as tor hidden services, the\n>       ESNI records would be published via whatever DNS or DNS-like mechanism is\n>       used for that transport, or queried by sending a DNS query for the record\n>       to the target, allowing the target to respond within that transport.\n>\n> Benefits:\n>\n>    -\n>\n>    B1. Large client-facing servers such as CDNs and shared IP hosters can\n>    deploy ESNI without having to negotiate DNS changes with all their\n>    customers (in fact with any of their customers).\n>    -\n>\n>    B2. Operators of large pools of client-facing servers such as CDNs can\n>    roll out ESNI support and ESNI implementation upgrades in a piecemeal and\n>    controlled manner similar to how other system updates are rolled out.\n>    Simply because each IP address will have its own ESNI records.\n>    -\n>\n>    B3. ESNI key rotation becomes much simpler as there is no need to\n>    synchronize it between different servers in a pool (except where a pure\n>    layer 1/2/3 load balancer shares a single IP among multiple\n>    physical/virtual servers, such as the layer 2 HALinux scheme).\n>    -\n>\n>    B4. ESNI private key protection can be much stronger when it is not\n>    shared among all the servers. The private key may be kept in protected\n>    hardware and/or in volatile RAM. The latter case would require clients to\n>    fall back to a different A or AAAA record until the DNS entries for now\n>    forgotten keys to have expired, but only in case of a server crash or\n>    similar event.\n>    -\n>\n>    B5. Client queries for ESNI records do not reveal the actual query\n>    domain that will be encrypted, only the IP address to which the ESNI\n>    extension will be sent.\n>    -\n>\n>    B6. The whole discussion about _esni prefix or no _esni prefix becomes\n>    a lot simpler when there is no need to put ESNI records in every end query\n>    domain, only domains of the client-facing servers, allowing to keep the\n>    unprefixed TXT name space clean for existing uses such as SPF.\n>\n> Downsides:\n>\n>    -\n>\n>    P1: Clients will have to postpone the _esni DNS query until after\n>    receiving the answer to the A or AAAA query, thus adding an extra DNS\n>    roundtrip before the first connection to a name. The usual DNS caching\n>    hierarchy should mitigate this. In particular for popular CDNs, a client\n>    will typically use the same handful of IPs for lots of unrelated traffic,\n>    thus getting the ESNI records in its local cache.\n>    -\n>\n>    P2: VM hosting/Physical hosting/connectivity providers not granting\n>    PTR name assignment control to IP address customers will cause the same\n>    problems as for other protocols (such as mail) and should thus be under the\n>    same or greater pressure to add that service. However since the greatest\n>    ESNI benefit is with IPs shared among many unrelated domains, and the\n>    operators of such IPs typically have full IP space ownership or the\n>    leverage to get PTR records where normal customers cannnot, the effect on\n>    ESNI deployment should be limited.\n>    -\n>\n>    P3: This may or may not make it easier to do spoofing attacks, as an\n>    MitM attacker can spoof DNS responses either for the A/AAAA records of a\n>    target query domain (pointing to servers entirely under the attackers\n>    control, including legitimate ESNI records for that server) OR spoof the\n>    ESNI records of a server address for which the attacker has obtained\n>    traffic intercept ability. However these can be secured with the same DNS\n>    countermeasures already applicable to those DNS domains.\n>    -\n>\n>    P4: query domains wishing to remain available in massively blocking\n>    markets (the kind that would not hesitate to block an entire CDN to stop\n>    access to a single web page) may have more difficulty opting out of ESNI so\n>    such blocking filters can recognize them as a permitted service.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/issues/139>, or mute the\n> thread\n> <https://github.com/notifications/unsubscribe-auth/AAP5szSqBkYuhH39f6ZWOFhNfNZdY9dlks5vSXMCgaJpZM4bZlWX>\n> .\n>\n",
          "createdAt": "2019-03-01T18:59:29Z",
          "updatedAt": "2019-03-01T18:59:29Z"
        },
        {
          "author": "jb-wisemo",
          "authorAssociation": "NONE",
          "body": "The PTR record problem is a real issue, but less so for the servers best placed to be anonymity pools.\r\n\r\nThere are other mechanisms of cause.  The key part is making ESNI a server property rather than an origin property, bypassing most of the issues with configuring each of the non-controversial origin domains that are just used as cover traffic.  Hard part is finding a hello content that doesn't stick out by using any values specific to using a controversial domain.  Per origin ESNI would stick out as most origins would feel pressured to not actively join the pool, while having to do something difficult or even pricey to stay out of the pool would be less easy to encourage via generic mass pressure.\r\n\r\nFor the following approaches compare to a normal first TLS connection:\r\n  Round 1: DNS query for A and DNS query for AAAA (happy eyeballs)\r\n  Round 2: TCP SYN\r\n  Round 3: TLS Handshake round 1\r\n\r\nWith the PTR based approach the parallelizing would go like this for first contact (later contacts benefit from DNS caching):\r\n\r\nRound 1: DNS query for A and DNS query for AAAA (happy eyeballs)\r\nRound 2: TCP SYN, DNS query for PTR and DNS query for ESNI keys directly in i*.arpa\r\nRound 3: DNS query for ESNI keys at PTR name (perhaps cached at nearby resolver).\r\n    This round is done only if\r\n     A: no ESNI record (not even an empty one) returned in round 2 AND\r\n     B: PTR name returned and contains the substring \"esni.\"  For example \r\n          example x1234.cdn.esni.example.net or x1234esni.example.net would cause queries of\r\n          _esni.example x1234.cdn.esni.example.net or _esni.x1234esni.example.net\r\nRound 4: TLS Handshake round 1\r\n\r\nRule 3 B would require ESNI client facing servers without ability to add arbitrary reverse records to at least be able to choose a PTR name of the magic form.  Note that the magic form contains no underscore but will only cost an extra DNS lookup returning NXDOMAIN if a non-ESNI server has that name form by chance.  The rule may require further refinement to deal with common provider practices.\r\n\r\nOne technique requiring less round trips than a full HTTP REST API would be to use a clever sequence of TLS extensions, signalling suites etc. to do everything in the TLS layer at the cost of extra TCP round trips compared to the current draft.\r\n\r\nA hybrid approach could go like this (first contact):\r\n\r\n  Round 1: DNS query for A and DNS query for AAAA (happy eyeballs)\r\n  Round 2: TCP SYN, DNS query for _esni.$reverseip.arpa\r\n\r\nIf _esni returned with \"no\" record:\r\n  Round 3: TLS Hello with the signalling suite and normal SNI, server responds normally\r\n\r\nIf _esni returned with key:\r\n   Round 3: TLS hello with ESNI as per draft-02\r\n\r\nIf _esni returned with \"ask\" record:\r\n   Round 3: TCP hello with invalid right-size data in ESNI extension, server sends keys in encrypted ESNI response.\r\n   Round 4: Send new hello with real ESNI extension inside encrypted stream, server forwards to origin server, once encrypted by origin server, client-side server drops the outer encryption and forwards remaining packets unchanged.\r\n\r\nIf no _esni record returned from DNS, server is actually ESNI:\r\n  Round 3: TLS Hello with a signalling suite and no SNI or ESNI, server sends keys in encrypted ESNI response.  In parallel a new TCP SYN.\r\n  Round 4: Send new hello with real ESNI extension inside encrypted stream, server forwards to origin server, once encryption activated by origin server, client-side server drops the outer encryption and forwards remaining packets unchanged.\r\n (Second TCP connection may be used or closed)\r\n\r\nIf no _esni record returned from DNS, server is not ESNI and has a default certificate matching desired SNI:\r\n  Round 3: TLS Hello with a signalling suite and no SNI or ESNI, server server responds normally using its default certificate, client uses the connection.  In parallel a new TCP SYN.\r\n (Second TCP connection may be used or closed)\r\n\r\nIf no _esni record returned from DNS, server is not ESNI and has a default certificate not matching desired SNI:\r\n  Round 3: TLS Hello with a signalling suite and no SNI or ESNI, server server responds normally using its default certificate, client aborts.  In parallel a new TCP SYN.\r\n  Round 4: TLS Hello with the signalling suite and normal SNI, server responds normally.  In parallel the first session is closed.\r\n\r\nIf no _esni record returned from DNS, server is not ESNI and has no default certificate:\r\n  Round 3: TLS Hello with a signalling suite and no SNI or ESNI, server aborts.  In parallel a new TCP SYN.\r\n  Round 4: TLS Hello with the signalling suite and normal SNI, server responds normally  In parallel the first session is closed.\r\n\r\n(Inclusion of the signalling suite after concluding its a non-esni server is to detect downgrade attacks)\r\n\r\nIntent is that the 4 round cases will be less common than the 3 round cases.  All subsequent contacts to same server IP (up to a cache period) will be simply:\r\n  Round 1: TCP SYN\r\n  Round 2: TLS Hello according to cached type and keys (with or without session resumption), Server responds as expected.\r\n\r\nNeither approach requires special IP address certificates.",
          "createdAt": "2019-03-01T23:11:31Z",
          "updatedAt": "2019-03-01T23:11:31Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> A hybrid approach could go like this (first contact):\r\n> \r\n> Round 1: DNS query for A and DNS query for AAAA (happy eyeballs)\r\n> Round 2: TCP SYN, DNS query for _esni.$reverseip.arpa\r\n> \r\n> If _esni returned with \"no\" record:\r\n> Round 3: TLS Hello with the signalling suite and normal SNI, server responds normally\r\n> \r\n> If _esni returned with key:\r\n> Round 3: TLS hello with ESNI as per draft-02\r\n\r\nI agree that this method does not introduce an additional round-trip for TCP. But it will for QUIC, and I do not think we'd want to have that overhead always for QUIC.",
          "createdAt": "2019-03-02T22:26:10Z",
          "updatedAt": "2019-03-02T22:26:10Z"
        },
        {
          "author": "jb-wisemo",
          "authorAssociation": "NONE",
          "body": "Since QUIC is a new undeployed protocol running on UDP instead of TCP, it can move its SNI-like operation into the encrypted part and (where applicable) use some kind of in-protocol session resumption to switch from client-facing server public keys to origin server public keys.  QUIC can also design its own mechanism for providing an encrypted non-repeating origin server indication in the early client to server packets.",
          "createdAt": "2019-03-07T17:26:51Z",
          "updatedAt": "2019-03-07T17:26:51Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Given that QUIC is already using TLS 1.3, I'd prefer that it be able to share mechanisms.",
          "createdAt": "2019-03-07T17:34:19Z",
          "updatedAt": "2019-03-07T17:34:19Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is orthogonal to the contents of the draft. Namely, servers could maintain this sort of IP<->key association on their own without any client changes. Thus, closing as is. Please re-open if you think otherwise and have a suggested change for the document!",
          "createdAt": "2020-05-27T12:20:56Z",
          "updatedAt": "2020-05-27T12:20:56Z"
        },
        {
          "author": "jb-wisemo",
          "authorAssociation": "NONE",
          "body": "Closing reason seems a complete misunderstanding.  I have not checked how my old wording fits or does not fit the current draft.\r\n\r\nIssue #139 is about handling multiple public servers (with different \"client-facing\" server IPs and different configuration), not about tracking client IPs.",
          "createdAt": "2020-05-28T03:55:26Z",
          "updatedAt": "2020-05-28T03:55:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The reasoning above isn\u2019t about tracking client IPs. Please give the latest draft a review and re-open if you think it\u2019s needed. And please provide suggested changes if they\u2019re needed!",
          "createdAt": "2020-05-28T03:57:18Z",
          "updatedAt": "2020-05-28T03:57:18Z"
        }
      ]
    },
    {
      "number": 140,
      "id": "MDU6SXNzdWU0MTYyMzEwNzM=",
      "title": "Minor nit: This is static DH, not DHE",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/140",
      "state": "CLOSED",
      "author": "jb-wisemo",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Since the mechanism is essentially static DH key mode (with ephemeral client key), the text should not refer to it as DHE / ECDHE, as those acronyms indicate that both sides use a fresh ephemeral (EC)DH key for each connection, when the client-facing server is in fact using a fixed key (which may be rotated a lot more often than a key from a certificate).",
      "createdAt": "2019-03-01T18:43:17Z",
      "updatedAt": "2019-03-06T22:42:28Z",
      "closedAt": "2019-03-06T22:42:28Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "We'll likely address this by adopting notation and terminology from HPKE. See #145.",
          "createdAt": "2019-03-06T22:42:28Z",
          "updatedAt": "2019-03-06T22:42:28Z"
        }
      ]
    },
    {
      "number": 141,
      "id": "MDU6SXNzdWU0MTYyNDE0MTg=",
      "title": "Use the RFC1952/ISO3309/V.42 CRC32",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/141",
      "state": "CLOSED",
      "author": "jb-wisemo",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Since the 32 bit checksum in ESNI records does not server a cryptographic purpose, only error detection, and since the chosen suite for the exchange does not necessarily use the SHA-256 algorithm, it would be more efficient to use a dedicated fast error detecting checksum.  The CRC32 algorithm used in RFC1952 (gzip), ISO 3309 and ITU-T V.42 is optimized for this task, widely available in software and hardware, and likely to already be implemented in ESNI using systems for other purposes.\r\n\r\nThis would also remove the only part of the draft that requires a specific single cryptographic algorithm, thereby making the specification algorithm agile without introducing any new algorithm registries for IANA to maintain.",
      "createdAt": "2019-03-01T19:13:32Z",
      "updatedAt": "2019-06-17T18:21:16Z",
      "closedAt": "2019-06-17T18:21:16Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't see how this makes it algorithm agile, it just requires baking in some other algorithm. Given that for the foreseeable future, every TLS 1.3 stack will have SHA-256, this would seem to make the implementation profile strictly worse. As for performance, the SHA-256 is trivial compared to the EC cost.",
          "createdAt": "2019-03-01T19:20:39Z",
          "updatedAt": "2019-03-01T19:20:39Z"
        },
        {
          "author": "jb-wisemo",
          "authorAssociation": "NONE",
          "body": "CRC32 makes no pretense to be a cryptographic algorithm, hence is not subject to the usual considerations of cryptographic algorithm agility.  A key lesson from baking SHA-1 into earlier protocols was that keeping it around for protocol compatibility made it more difficult to ensure it wasn't used in places where it would cause security issues.  Looking forward a few decades, there is little or no assurance that SHA-256 won't be in a similar situation.  In contrast the error detection abilities of CRC-32 (the only purpose it has in this place) has been proven mathematically, has survived for much much longer and is much faster to run before deciding if the cryptographic calculations are needed at all.  Like my other proposals, it's all about simplifying the protocol extension as much as possible.",
          "createdAt": "2019-03-01T20:09:38Z",
          "updatedAt": "2019-03-01T20:09:38Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I am familiar with these arguments, but I don't agree that this is a meaningful simplification. SHA-256 does not need to be agile in this case.\r\n",
          "createdAt": "2019-03-01T20:10:56Z",
          "updatedAt": "2019-03-01T20:10:56Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with @ekr here. Modern TLS implementations already have support for SHA-256 whereas CRC32 isn't always readily available.",
          "createdAt": "2019-03-01T23:56:35Z",
          "updatedAt": "2019-03-01T23:56:35Z"
        },
        {
          "author": "jb-wisemo",
          "authorAssociation": "NONE",
          "body": "You seem to misunderstand the issue.  The problematic scenario is this:\r\n\r\n1. Many years from now, SHA-256 is broken by new research (not faster computers), similar to what happened to MD5.\r\n\r\n2. Everyone works hard to remove SHA-256 from their cryptographic applications, or at least establish onerous review procedures to ensure any remaining SHA-256 invocation is not a security problem.\r\n\r\n3. ESNI using SHA-256 for a non-cryptographic purpose will then become a very real practical liability, as every implementation will need to make excuses and audit documents just to prove they are not really using SHA-256 for anything risky.\r\n\r\nIf in contrast, ESNI used something non-cryptographic, like CRC-32 or the TCP checksum algorithm, this step 3 of the problem wouldn't happen.  Of the commonly implemented short checksums, CRC-32 is the only one optimized for detecting accidental data corruption, while the other are optimized for tiny speed margins at the cost of less effective detection.\r\n\r\nAs for CRC-32 being available in ESNI implementations, this is likely to be present already because it is used in gzip HTTP compression, but standard CRC-32 may be available for many other reasons.  Anyway, CRC-32 is a trivially small algorithm that doesn't need CPU specific optimization for the data sizes in question.",
          "createdAt": "2019-03-07T16:39:17Z",
          "updatedAt": "2019-03-07T16:39:17Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I understood the scenario and I've been through this before with SHA-1. I don't think that this is a particularly serious concern.",
          "createdAt": "2019-03-07T17:33:26Z",
          "updatedAt": "2019-03-07T17:33:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "SHA-256 is fine for this purpose. Closing for now.",
          "createdAt": "2019-06-17T18:21:16Z",
          "updatedAt": "2019-06-17T18:21:16Z"
        }
      ]
    },
    {
      "number": 142,
      "id": "MDU6SXNzdWU0MTYyNTM2OTg=",
      "title": "Eliminating record_digest",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/142",
      "state": "CLOSED",
      "author": "jb-wisemo",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "To simplify implementation, the record_digest can be eliminated as follows:\r\n\r\n1. In ESNIKeys, provide a server-assigned 32 bit id.  Servers are free to manage that id space as they see fit e.g. to optimize lookup in a history of rotating keys.  However the server MAY obscure any structure in the numbering in any convenient manner.  As a further optimization, move all fixed length fields before the variable length fields and order them such that natural alignment is achieved (as per IETF tradition).\r\n\r\n2. In ClientEncryptedSNI, insert the 32 bit id right after the Ciphersuite, making it part of the fixed-length part of the structure.  The record_digest field and its calculation is removed, thus reducing the size of the ESNI extension.\r\n\r\n3. In ESNIContents, just use the full record instead of hashing it separately.  This costs a few extra blocks of hash invocations (as the cache record_digest can no longer be cached for each hash algorithm), but simplifies the code.  Alternatively, record_digest can be kept for this non-transmitted field to preserve that caching opportunity.",
      "createdAt": "2019-03-01T19:49:21Z",
      "updatedAt": "2019-07-03T00:57:49Z",
      "closedAt": "2019-07-03T00:57:49Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not in favor of this proposal. Computing record_digest is quite trivial as is, and using SHA256 gives us good assurance of its correctness. That is, we don't have to worry about servers possibly assigning incorrect IDs.",
          "createdAt": "2019-06-25T20:44:55Z",
          "updatedAt": "2019-06-25T23:47:03Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We do have to worry about collisions, which could be even harder to get right.  I don't think that sending it in the record makes any sense, but as an identifier, a hash is fine.",
          "createdAt": "2019-06-25T23:46:00Z",
          "updatedAt": "2019-06-25T23:46:00Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So my new insight here is that corruption of DNS records (if that does happen) will now be detected with `record_digest` and corrected through the use of the fallback mechanism.  So that makes `record_digest` important, but `checksum` useless.",
          "createdAt": "2019-07-03T00:53:45Z",
          "updatedAt": "2019-07-03T00:53:45Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Since a cryptographic proof of key possession is needed for downgrade protection, we can't remove record_digest in this way. Thus, I'm closing this issue as NTBF. ",
          "createdAt": "2019-07-03T00:57:49Z",
          "updatedAt": "2019-07-03T00:57:49Z"
        }
      ]
    },
    {
      "number": 143,
      "id": "MDU6SXNzdWU0MTYzMzAxMzI=",
      "title": "gh-pages is stale",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/143",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The Editor's Copy link leads to a version of the document from July 4, 2018, and there have been no commits to the gh-pages branch since then.  The document is obviously in active development, which suggests that CI is broken / not configured on this repo.",
      "createdAt": "2019-03-02T00:24:43Z",
      "updatedAt": "2019-07-03T01:33:53Z",
      "closedAt": "2019-07-03T01:33:53Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed -- sorry for the delay!",
          "createdAt": "2019-07-03T01:33:53Z",
          "updatedAt": "2019-07-03T01:33:53Z"
        }
      ]
    },
    {
      "number": 145,
      "id": "MDU6SXNzdWU0MTcwOTI1NzQ=",
      "title": "Adopt HPKE",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/145",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "needs WG discussion"
      ],
      "body": "See https://datatracker.ietf.org/doc/draft-barnes-cfrg-hpke/ for more info. ",
      "createdAt": "2019-03-05T03:03:26Z",
      "updatedAt": "2020-03-09T21:58:07Z",
      "closedAt": "2020-03-09T21:58:07Z",
      "comments": [
        {
          "author": "jb-wisemo",
          "authorAssociation": "NONE",
          "body": "Please don't.  The TLS series of RFCs and other related RFCs already contain established terminology for anything in the HPKE draft.   HPKE is basically two guys thinking they reinvented the wheel.",
          "createdAt": "2019-03-07T16:04:51Z",
          "updatedAt": "2019-03-07T16:04:51Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Hmm... As one of the designers of the construction in this current ESNI draft, I would welcome a more carefully vetted construction that came with the CFRG's endorsement, and I generally assume that Karthik and Richard are at least as well equipped to design this as I am.",
          "createdAt": "2019-03-07T16:08:38Z",
          "updatedAt": "2019-03-07T16:09:21Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd like to second what @ekr says. In a way, this document reinvents the wheel. We should defer such constructions to the CFRG.",
          "createdAt": "2019-03-07T17:56:57Z",
          "updatedAt": "2019-03-07T17:56:57Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This is part of #207, as discussed in Singapore.",
          "createdAt": "2020-03-08T00:33:26Z",
          "updatedAt": "2020-03-08T00:33:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #207.",
          "createdAt": "2020-03-09T21:58:07Z",
          "updatedAt": "2020-03-09T21:58:07Z"
        }
      ]
    },
    {
      "number": 146,
      "id": "MDU6SXNzdWU0MTczMjEwODk=",
      "title": "User tracking via ESNI keys",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/146",
      "state": "CLOSED",
      "author": "kirsey",
      "authorAssociation": "NONE",
      "assignees": [
        "chris-wood"
      ],
      "labels": [
        "help wanted"
      ],
      "body": "If each client receives a unique ESNI key from a DNS provider, it is possible to link every usage of this key to the same client. It seems feasible that online services, as well as passive observers of the network traffic, can exploit such a practice for user tracking.\r\n\r\nTo enhance the privacy protections of this draft, we should describe these privacy risks in the draft. Furthermore, I recommend a clear restriction on the clients\u2019 caching durations of ESNI keys. For example, clients MUST NOT cache ESNI keys longer than 24 hours and as privacy protection, it is RECOMMENDED to cache ESNI keys only for 10 minutes.",
      "createdAt": "2019-03-05T14:18:34Z",
      "updatedAt": "2020-10-16T17:14:15Z",
      "closedAt": "2020-05-05T20:10:31Z",
      "comments": [
        {
          "author": "jb-wisemo",
          "authorAssociation": "NONE",
          "body": "To avoid downgrade attacks (by simply filtering out the key DNS response), clients should cache the fact that there is/was an ESNI key significantly longer, perhaps 14 days.  During these 14 days the server can authoritatively report that it no longer has a key, and it can change the key.  But the client would actively look for ESNI support before falling back to plain SNI for that server.\r\n\r\nBug #139 comment 3 contains a proposal that can implicitly handle the case \"client thinks server has ESNI, but doesn't know the current keys or if it has been turned off again server side\"",
          "createdAt": "2019-03-07T17:27:38Z",
          "updatedAt": "2019-03-07T17:27:38Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I do not believe this will work. In multi-cdn scenarios, clients will sometimes just get an ESNIKeys record sometimes and no record other times and that's normal",
          "createdAt": "2019-03-07T17:32:23Z",
          "updatedAt": "2019-03-07T17:32:23Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think noting that this can track you within the same origin is a worthwhile thing to note - it gets added to a whole bucket of things with the same property (e.g. AAAA).\r\n\r\nAs its not really adding anything to that problem I'm not in favor of recommending particular cache ceilings which may or may not really address the issue anyhow..",
          "createdAt": "2019-03-07T17:54:10Z",
          "updatedAt": "2019-03-07T17:54:10Z"
        },
        {
          "author": "kirsey",
          "authorAssociation": "NONE",
          "body": "I observe, that TLS has a tradition in providing upper limits for caching durations. I think this is a good practice as it restricts the harm of an extreme configuration.\r\n\r\nFurthermore, I see added value in recommending a best practice configuration at least for a specific application type such as browsers because it leads to a description of the trade-offs at hand and facilitates the implementation. ",
          "createdAt": "2019-03-07T20:21:16Z",
          "updatedAt": "2019-03-07T20:21:16Z"
        },
        {
          "author": "kontaxis",
          "authorAssociation": "NONE",
          "body": "The document already sets the maximum TTL to the lifetime of the SNI key.\r\nIt also recommends that \"servers rotate keys frequently\" to reduce the harm from compromised keys.\r\n\r\nSo it seems that short-lived keys are good both for security and privacy.\r\n\r\nA recommended value would be useful.\r\nOtherwise \"frequently\" could be interpreted as months.",
          "createdAt": "2019-03-08T00:10:09Z",
          "updatedAt": "2019-03-08T00:10:21Z"
        }
      ]
    },
    {
      "number": 149,
      "id": "MDU6SXNzdWU0MTk2NTA2ODU=",
      "title": "Replay attack and timestamp",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/149",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [
        "needs WG discussion"
      ],
      "body": "Attackers cannot successfully replay a ClientHello and ESNI extension and establish a connection with the server. However, they can replay a ClientHello and examine whether it triggers a positive response. This can be used to check whether a server is still present. This is a particular concern when using ESNI in local discovery mode, where merely eliciting a response would be enough to give away a server's presence.\r\n\r\nTo protect against such attacks, I consider adding two elements in the ESNI:\r\n\r\n1) A 64 bit timestamp, set to the date at which the client sent the message.\r\n2) The IPv6 address from which the client is sending the message.\r\n\r\nThe timestamp prevents repeat of a message over time. The IPv6 address prevents repeat of the message from a different location. I mention IPv6 here because of NAT, of course.\r\n\r\nWhat do you think? Should that be encoded as part of `ClientEncryptedSNI` or `ClientESNIInner`? Or should it just be encoded as a separate ClientHello extension?",
      "createdAt": "2019-03-11T19:45:33Z",
      "updatedAt": "2019-11-22T14:14:30Z",
      "closedAt": "2019-11-22T14:14:30Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like the timestamp idea.  Even if it is only fuzzy.  The timestamp seems adequate, because the fact that a server remains active over short timescales is not that interesting - more so if the connection that is being replayed is still active.  \r\n\r\nFor the timestamp, fewer bits will be sufficient as long as the timestamp can express a longer duration than the maximum key validity.  32 bits is plenty, assuming second resolution.  16 might even suffice.",
          "createdAt": "2019-03-11T21:54:09Z",
          "updatedAt": "2019-03-11T21:54:09Z"
        },
        {
          "author": "Lekensteyn",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Frequent ESNIKeys rotation (and subsequent enforcement by the server) should mitigate this issue a bit.\r\n\r\nEncoding the time as-is would undo the effect of [removing the time from the client random field](https://mailarchive.ietf.org/arch/msg/tls/_clS-TIIlZUcid_2S4WPej9iMWk). Not sure if that is desirable.\r\n\r\nWhat is your attacker's model? Even with a truncated timestamp (e.g. in 1 minute intervals), there is still a time span where the confirmation attack could be executed. And if you are worried about an adversary who is trying to raid a data center and needs to track down a physical machine behind a load balancer, then having the IPv6 address binding would not help since the attacker could just spoof packets.",
          "createdAt": "2019-06-03T01:24:14Z",
          "updatedAt": "2019-06-03T01:24:14Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "How long would the server's \"replay window\" be in terms of time? If it's less than say, a day, the server would start seeing a lot of spurious failures due to client clock skew.",
          "createdAt": "2019-06-03T12:47:51Z",
          "updatedAt": "2019-06-03T12:47:51Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Likewise the client will observe failures, and these will hit all connections for some small fraction of users, which is much worse than hitting some small fraction of connections for all users.\r\n\r\nIs the expectation that the client would fail the connection or retry without ESNI? The latter has a clear downgrade attack, while the former strongly discourages ESNI deployment. I would need to check with folks on what kinds of clock skews are observed, but I expect it would be much *much* higher than a day.\r\n\r\nNow that we have the robustness mechanism (if the server does not recognize ESNI, it just responds based on SNI) is that sufficient to resolve this? The server will respond with *something* either way, and the attacker can't tell which certificate it was.",
          "createdAt": "2019-06-03T15:50:19Z",
          "updatedAt": "2019-06-03T15:50:57Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@davidben has a point about fallback to SNI.  If use of the fallback SNI is indistinguishable from successful use of ESNI, then we're good: the observer gains nothing.  Is that a requirement we levy on servers though?\r\n",
          "createdAt": "2019-07-03T00:08:48Z",
          "updatedAt": "2019-07-03T00:08:48Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Hmm, is indistinguishability possible? In the fallback SNI case, the server's EE might carry one or more ESNIKeys, which inflates the size of this message well beyond the EE message size in the normal (non-fallback) case. If we want to make them indistinguishable, we'd probably need to recommend further requirements that the server's EE message(s) are the same in both cases, which is not great. ",
          "createdAt": "2019-07-03T00:29:36Z",
          "updatedAt": "2019-07-03T00:29:36Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Good point.  The extra bits will appear to be part of the certificate chain from the outside.  That means potentially padding everything.  If that is a problem, could the fallback be made to appear more like a response to a request?  That's structurally very different though, and perhaps not worth the pain.",
          "createdAt": "2019-07-03T00:32:04Z",
          "updatedAt": "2019-07-03T00:32:04Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@huitema how do you want to proceed here? ",
          "createdAt": "2019-11-04T20:47:28Z",
          "updatedAt": "2019-11-04T20:47:28Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think the issue is mitigated yet. The problem is a \"discovery oracle\", and it is linked to a very specific ESNI usage: broadcast an ESNI on the local network to check whether someone will respond. In the normal case, the response is processed by the node doing the discovery. The issue is that an attacker can replay the message later and see whether the client is still there.\r\n\r\nThis is not a \"mainline\" ESNI issue, but just an issue arising from trying to use ESNI in a discovery scenario with Quic or DTLS. It is probably OK to not consider it for the current ESNI design, and to address it in the \"discovery scenario\" design.\r\n\r\nHence, close with no action.",
          "createdAt": "2019-11-22T14:14:29Z",
          "updatedAt": "2019-11-22T14:14:29Z"
        }
      ]
    },
    {
      "number": 150,
      "id": "MDU6SXNzdWU0MjYyNTQ1NzU=",
      "title": "record_digest should not cover address_set",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/150",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Filing this so we don't forget:\r\n\r\nCurrently the record digest covers the address_set extension. This means adding a new addresses to a deployment introduces new digests that need to be propagated to all servers to recognize. (Unless servers trial decrypt everything, but then record digests aren't doing anything.)\r\n\r\nPerhaps the A/AAAA + ESNI gluing should external to the ESNIKeys structure. The glue is probably assembled by DNS serving logic, while ESNIKeys is otherwise probably an opaque blob assembled by some key provisioning system.",
      "createdAt": "2019-03-28T01:38:56Z",
      "updatedAt": "2019-04-18T16:40:57Z",
      "closedAt": "2019-04-18T16:40:57Z",
      "comments": [
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Made #151 to try to address this by excluding extensions from the digest. A DNS server that knows it will generate extensions can keep the rest of ESNIKeys as blob, and then simply append extensions to it when serving the record. Otherwise I wouldn't know where to put the AddressSet thingy.",
          "createdAt": "2019-04-09T22:10:55Z",
          "updatedAt": "2019-04-09T22:10:55Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "What do you think about splitting it in two layers?\r\n\r\nFirst you've got ESNIKeys as it existed prior to address_set. The record digest covers the whole thing as before. DNS believes it's just an opaque blob.\r\n\r\nThen you've got, say, some BUNDLE RRTYPE whose RDATA encodes a list of (RRTYPE, RDATA) tuples in whatever DNS-y syntax people want. The DNS server then just assembles a BUNDLE with A and AAAA formatted as before, plus an ESNI record with it. This avoids this odd situation we have here where ESNI wants to be the root of the tree, to the exclusion of everyone else who may wish to correlate data with A/AAAA.\r\n\r\nA nuisance here: we do want to avoid the client having to ask for all of A, AAAA, ESNI, *and* BUNDLE. It is more risk of performance problems and acting on any response to ESNI would reintroduce multi-CDN woes. We'd have to say ESNI can only be fetched via BUNDLE or so. (That perhaps suggests the \"keys\" in BUNDLE should be its own namespace? Other than A/AAAA, everything else is likely to never be fetched on its own.)",
          "createdAt": "2019-04-09T22:30:00Z",
          "updatedAt": "2019-04-09T22:30:00Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that the problem is really in DNS, and a complete solution needs to happen there. However I think it's orthogonal to ESNI, and should probably be discussed on its own (e.g. in dnsop).\r\n\r\nThere was some talk in Prague about doing that but AFAICT nothing happened yet, so I'd be interested in helping put a  BUNDLE proposal together if nothing else comes up, and see what the DNS people think.\r\n\r\nIn the meantime AddressSet is what we have, and it's probably easier to just make that work for the specific ESNI case in the short term, and then replace it with whatever BUNDLE solution comes out later on, so the two discussions can proceed in parallel.",
          "createdAt": "2019-04-11T12:55:31Z",
          "updatedAt": "2019-04-11T12:55:31Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Well, we don't have anything right now because address_set doesn't work. :-P We can change the syntax however we like, be it defining BUNDLE in the ESNI doc, or doing something quick and hacky like:\r\n\r\n```\r\nstruct {\r\n  ESNIKeys keys;\r\n  Address address_set<0..2^16-1>;\r\n} ESNIKeysWithAddresses;\r\n```",
          "createdAt": "2019-04-12T15:54:26Z",
          "updatedAt": "2019-04-12T15:55:34Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "My +1 goes to doing this hack, assuming that it helps somebody deploying ESNI.\r\n\r\nIf it turns out to be a bad idea, we can switch to a different mechanism by just bumping the version number in ESNIKeys.",
          "createdAt": "2019-04-12T16:11:13Z",
          "updatedAt": "2019-04-12T16:11:13Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@davidben yeah, so that's similar to @chris-wood's proposal of just having an additional extensions field that doesn't go into record_digest. The additional extensions field would be somewhat more flexible and accomodate both address_set and the other multi-CDN proposal if it ever shows up. Do we care about this flexibility?\r\n\r\nI find both solutions kinda yucky, but I guess those are the options we have. I can update my PR (or create a new one) with whatever new hack.",
          "createdAt": "2019-04-12T17:38:14Z",
          "updatedAt": "2019-04-12T17:38:14Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Actually, I don't know if the other multi-CDN proposal would have the same problem, so maybe the extensibility is not needed?",
          "createdAt": "2019-04-12T17:40:22Z",
          "updatedAt": "2019-04-12T17:40:22Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@ghedo @davidben @kazuho @ekr \r\n\r\nHow about:\r\n\r\n~~~\r\nstruct {\r\n  ESNIKeys keys;\r\n  Extensions dns_extensions<0..2^16-1>;\r\n} ESNIKeysWithExtensions;\r\n~~~\r\n\r\nWe can then put address_set in dns_extensions, and TLS stacks don't ever have to see them.",
          "createdAt": "2019-04-12T17:44:57Z",
          "updatedAt": "2019-04-12T17:44:57Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, was thinking something along those lines, I'll see if I can put it into text in the next few days if nobody beats me to it.",
          "createdAt": "2019-04-12T17:47:17Z",
          "updatedAt": "2019-04-12T17:47:17Z"
        }
      ]
    },
    {
      "number": 155,
      "id": "MDU6SXNzdWU0MzcyMjA2MTg=",
      "title": "Clarification on AAD for ClientEncryptedSNI.encrypted_sni",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/155",
      "state": "CLOSED",
      "author": "Lekensteyn",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "It was initially not clear to me what should be included in the AAD for encrypting ClientESNIInner into ClientEncryptedSNI.encrypted_sni. The spec currently says:\r\n\r\n> The ClientEncryptedSNI.encrypted_sni value is then computed using the usual TLS 1.3 AEAD:\r\n>\r\n>     encrypted_sni = AEAD-Encrypt(key, iv, ClientHello.KeyShareClientHello, ClientESNIInner)\r\n>\r\n> Where ClientHello.KeyShareClientHello is the body of the extension but not including the extension header.\r\n\r\nClientHello.KeyShareClientHello is not defined in this document. At first I thought it would cover ClientEncryptedSNI.key_share, but that seemed odd.\r\n\r\nLater I found that it refers to the Key Share extension defined in [RFC 8446, Section 4.2.8. Key Share](https://tools.ietf.org/html/rfc8446#section-4.2.8). Perhaps this reference could be added?\r\n\r\nOn a related note, `HKDF-Extract(0, Z)` should probably become `HKDF-Extract(\"\", Z)` or be explicit about the salt as is done in https://tools.ietf.org/html/rfc8446#section-7.1 (or https://tools.ietf.org/html/rfc5869#section-2.2).",
      "createdAt": "2019-04-25T14:08:57Z",
      "updatedAt": "2019-06-02T19:57:43Z",
      "closedAt": "2019-06-02T19:57:43Z",
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "FWIW, I also had a little trouble with this. My initial interpretation was to use the h/s key share that ends up being used as the AAD, which worked fine for my client (vs cloudflare) and for my server (vs. NSS' tstclnt). In each of those cases though only one key share was sent by the client. FF nightly however sends two key shares in the h/s so I had to change my code to do the right thing. Could be worth a note in the internet-draft e.g. saying to use (the encoding of) all key shares from the h/s and that some clients do send more than one.  ",
          "createdAt": "2019-06-02T15:15:57Z",
          "updatedAt": "2019-06-02T15:16:33Z"
        }
      ]
    },
    {
      "number": 156,
      "id": "MDU6SXNzdWU0NDQwNzA0ODM=",
      "title": "Require OCSP stapling for ESNI",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/156",
      "state": "CLOSED",
      "author": "J0WI",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Since OCSP is [leaking](https://bugzilla.mozilla.org/show_bug.cgi?id=1535235#c3) the server name, ESNI should probably enforce OCSP stapling (similar to [RFC 7633](https://tools.ietf.org/html/rfc7633)) or any other way of encrypted OCSP checks.\r\nIgnoring OCSP status checks entirely makes it hard to revoke a certificate, even if it's only valid for a few months.\r\n\r\n",
      "createdAt": "2019-05-14T18:51:20Z",
      "updatedAt": "2019-07-04T01:12:54Z",
      "closedAt": "2019-07-04T01:12:54Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@J0WI what behavior do you expect here? Would clients fail hard if server don't send stapled responses? It's good to view ESNI as part of the leaky boat problem. It plugs one hole, but not all of them. Implementations probably should do something about cleartext OCSP if they want all holes plugged. ",
          "createdAt": "2019-07-03T04:04:57Z",
          "updatedAt": "2019-07-03T04:04:57Z"
        }
      ]
    },
    {
      "number": 160,
      "id": "MDU6SXNzdWU0NTUzNjc3NDQ=",
      "title": "Including Presentation language",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/160",
      "state": "CLOSED",
      "author": "mrsylerpowers",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "I believe it will be helpful to understanding this document to either add \"Presentation Language\" to this document or link to Presentation Language elsewhere. The TLS/1.3 document has something similar in [RFC8446 Section 3](https://tools.ietf.org/html/rfc8446#section-3)",
      "createdAt": "2019-06-12T18:44:41Z",
      "updatedAt": "2019-07-03T01:09:00Z",
      "closedAt": "2019-07-03T01:09:00Z",
      "comments": []
    },
    {
      "number": 171,
      "id": "MDU6SXNzdWU0NjY2MjMzODU=",
      "title": "Formal analysis",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/171",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "pre-wglc"
      ],
      "body": "We need some form of analysis before we ship this. Filing an issue to track that task.",
      "createdAt": "2019-07-11T02:25:38Z",
      "updatedAt": "2023-07-25T17:27:50Z",
      "closedAt": "2023-07-25T17:27:50Z",
      "comments": [
        {
          "author": "mrsylerpowers",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood Do you think that this draft is about ready for ship?\r\n",
          "createdAt": "2019-07-16T15:20:49Z",
          "updatedAt": "2019-07-16T15:20:49Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "No, not yet.",
          "createdAt": "2019-07-16T16:55:06Z",
          "updatedAt": "2019-07-16T16:55:06Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as this has been completed.",
          "createdAt": "2023-07-25T17:27:50Z",
          "updatedAt": "2023-07-25T17:27:50Z"
        }
      ]
    },
    {
      "number": 173,
      "id": "MDU6SXNzdWU0NzEyMTc5NjM=",
      "title": "Lingering references to `sni` instead of `dns_name`",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/173",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From Stephen Farrell on the TLS WG list:\r\n\r\nJust spotted that:\r\n\r\n   opaque zeros[ESNIKeys.padded_length - length(sni)];\r\n\r\nshould I guess now be:\r\n\r\n   opaque zeros[ESNIKeys.padded_length - length(dns_name)];\r\n\r\nAnd maybe s/PaddedServerNameList/PaddedDNSName/ would also make sense.",
      "createdAt": "2019-07-22T17:39:28Z",
      "updatedAt": "2019-08-15T22:20:15Z",
      "closedAt": "2019-08-15T22:20:15Z",
      "comments": [
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Think this is fixed now?",
          "createdAt": "2019-08-15T22:19:26Z",
          "updatedAt": "2019-08-15T22:19:26Z"
        }
      ]
    },
    {
      "number": 177,
      "id": "MDU6SXNzdWU0NzI0MzU0Nzk=",
      "title": "GREASE ESNI extensions are easily distinguished from real ones",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/177",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "davidben",
        "chris-wood"
      ],
      "labels": [],
      "body": "The draft has provisions for GREASE ESNI extensions, per \"Do not stick out\". However, this is not very effective if an attacker can distinguish a GREASE ESNI extension from a real one.\r\n\r\n#154 tried to address this, but it doesn't work if the (public) ESNI record is known. There's also a simpler attack: replay the ClientHello with one byte of ciphertext corrupted. ESNI currently distinguishes key mismatch from decrypt failure, with the latter resulting in an alert. We can fix that by saying decrypt failure should behave like key mismatch. This still leaves record_digest.\r\n\r\nThe natural fix is to drop record_digest in favor of trial decryption. The cost is the server must perform a DH operation per known key. The number of keys the server needs depends on its DNS TTLs and key rotation. (I think it's 1 + ceil(dns_ttl / time_between_rotation), plus some leeway[*].)\r\n\r\nInstead, we can keep a key name, but make the space dense. Suppose we replace it with a B-bit \"key phase\". The server picks a random starting key phase. Then, each time it rotates the keys, it increments the phase, with wraparound. The server then gets 2<sup>B</sup> keys for free. If it needs more, it still needs trial decryption but gains a 2<sup>B</sup> multiplicative factor in the cost. On the flip side, an individual GREASE extension with a random key phase has a 1/2<sup>B</sup> chance of colliding with a particular ESNI key.\r\n\r\nI'm not sure we actually need that many live keys, so B = 2 is probably plenty. Or even B = 1 if we say you should just rotate slower than your DNS TTL.\r\n\r\n[*] Note the robustness mechanism means that server doesn't need to cover _all_ clients with stale keys. The retry is expensive, so the server still needs to cover _almost all_ of them, but it can cut off the long tail.",
      "createdAt": "2019-07-24T18:37:10Z",
      "updatedAt": "2020-05-27T12:18:22Z",
      "closedAt": "2020-05-27T12:18:21Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Mostly a note to myself for the actual PR: the draft should also discuss padding of the EncryptedExtensions message.",
          "createdAt": "2019-07-29T23:53:40Z",
          "updatedAt": "2019-07-29T23:53:40Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we really need to go back to first principles here and ask what it is we are trying to accomplish.  First, it's public information whether a given server supports ECHO, so if an attacker wants to know that, it can mostly just ask [there is some complexity around getting candidate names, but note that you can always get the public name from the SNI value and any real attacker will see a lot of non-ECHO traffic and so will know a bunch of SNI values].\r\n\r\nWhat's not public information is whether a given *connection* uses ECHO. The attacker might not know this either because:\r\n\r\n1. It knows that the server is ECHO-supporting.\r\n1. It has a limited view of just the connection and isn't willing to do do the work of trying to determine if the server is ECHO-supporting.\r\n\r\nIn case (1) I would also expect that the attacker is not going to go to the trouble of doing probe connections, as determining if the server is ECHO supporting is easier. This leaves us with the case where the attacker knows that the server is ECHO supporting and that the client *knows* about ECHO (otherwise it couldn't generate GREASE) but doesn't know if the client is actually doing ECHO. Do we expect there to be a lot of clients like this? Why not just do ECHO?\r\n\r\n\r\n",
          "createdAt": "2020-04-24T14:46:10Z",
          "updatedAt": "2020-04-24T14:46:10Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "As per today's call, we're going to revisit the GREASE threat model and then reconvene if further work is needed.",
          "createdAt": "2020-04-27T22:02:57Z",
          "updatedAt": "2020-04-27T22:02:57Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm moving to closes this issue as resolved by #235. If we need to do something against connection blocking adversaries, perhaps we should look into MASQUE for that.",
          "createdAt": "2020-05-20T16:00:52Z",
          "updatedAt": "2020-05-20T16:00:52Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing for now. @davidben, please re-open if you still think we should address this!",
          "createdAt": "2020-05-27T12:18:21Z",
          "updatedAt": "2020-05-27T12:18:21Z"
        }
      ]
    },
    {
      "number": 178,
      "id": "MDU6SXNzdWU0NzI4OTMzMzY=",
      "title": "Cryptographic configuration consistency",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/178",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "There is an unstated constraint on deployments.  All servers in the same anonymity set need to have the same cryptographic configuration.\r\n\r\nThis means that they choose the same key exchange groups/cipher/etc.. when presented with the same ClientHello.  Concretely, servers need to produce the same profile for the ServerHello, because the ServerHello is not encrypted and the form of a ServerHello could be used to split the anonymity set if different servers make different choices.",
      "createdAt": "2019-07-25T14:18:36Z",
      "updatedAt": "2019-11-04T21:41:08Z",
      "closedAt": "2019-11-04T21:41:08Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussion in the room in Montreal suggested that this would not be a requirement, but more of the form of an observation and suggestion.  That is, the document would note that if cryptographic configuration is not consistent, the anonymity set fractures into as many sets as there are configurations.  Then it will recommend (but not require) that uniformity is desirable.",
          "createdAt": "2019-07-25T14:43:15Z",
          "updatedAt": "2019-07-25T14:43:15Z"
        }
      ]
    },
    {
      "number": 179,
      "id": "MDU6SXNzdWU0NzI5NDc0ODY=",
      "title": "Decouple ESNIKeys and the envelope DNS record",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/179",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This will let us adopt another delivery mechanism (HTTPSVC?) if needed later on.",
      "createdAt": "2019-07-25T16:00:18Z",
      "updatedAt": "2019-11-02T01:02:04Z",
      "closedAt": "2019-11-02T01:02:03Z",
      "comments": [
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We already have `ESNIKeys` and `ESNIRecord` as different structures, wouldn't a different delivery mechanism be able to simply wrap `ESNIKeys` in its own transport, without the DNS record? I guess this point could be clarified though.",
          "createdAt": "2019-08-15T22:18:23Z",
          "updatedAt": "2019-08-15T22:18:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This is mostly an editorial change to make it easy to remove `ESNIRecord`, if needed, without changing any other text.",
          "createdAt": "2019-08-15T22:19:19Z",
          "updatedAt": "2019-08-15T22:19:19Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #187.",
          "createdAt": "2019-11-02T01:02:03Z",
          "updatedAt": "2019-11-02T01:02:03Z"
        }
      ]
    },
    {
      "number": 180,
      "id": "MDU6SXNzdWU0NzQxNzYyNzU=",
      "title": "Use SRV for fronting server selection",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/180",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I think that the current ESNI record is maybe a little too\r\ncomplicated. The ESNI key is really a property of the public server, yet\r\nthe ESNI record is defined as a property of the hidden server. If the\r\npublic server rolls a new key, all the ESNI records of all the hidden\r\nservers that mentioned the old key need to be updated. I think it would\r\nbe simpler to have the ESNI record as a property of the public server,\r\nand to just have a pointer to the public server in the context of the\r\nhidden server. May an SRV record. The chain would be something like:\r\n\r\n1) Look up whether the SRV record for _esni._tcp.hidden.example.com\r\n\r\n2) If there are such records, select the appropriate public server, say\r\npublic.example.net\r\n\r\n3) Look up ESNI, A, AAAA for public.example.net\r\n\r\nIn that architecture, there is no need to encode the public server name\r\nin the ESNI record. I think there will be several advantages. The ESNI\r\nrecord's TTL can be set to the lifetime of the key. The SRV record's TTL\r\ncan be set to the expected lifetime of the relation between 'hidden\" and\r\n\"public\". If the SRV lifetime is long enough, the value can be\r\nefficiently cached by the client. If multiple clients share the same\r\nhidden server, the ESNI record is fetched only once, and can be cached.\r\nAt connection time, the client would only need to query the A/AAAA\r\nrecords of the public server, i.e. exactly the same DNS transaction as\r\nan access to the public server.",
      "createdAt": "2019-07-29T17:46:43Z",
      "updatedAt": "2019-11-02T01:02:00Z",
      "closedAt": "2019-11-02T01:02:00Z",
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Issue #139 proposes something similar, using PTR records. I think the semantic of SRV records is closer to what we need.",
          "createdAt": "2019-07-29T17:49:49Z",
          "updatedAt": "2019-07-29T17:49:49Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The practical consequence would be to remove the \"public name\" component from the ESNI record.",
          "createdAt": "2019-07-29T17:51:15Z",
          "updatedAt": "2019-07-29T17:51:15Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "IIRC, the principle that we have so far followed is that ESNI should not introduce additional latency (i.e. roundtrip). TLS WG has spent great effort in reducing the number of roundtrips spent during the handshake. It would be very unfortunate to add latency with ESNI.\r\n\r\nAlso, I am not sure how much the issue is a practical concern, because I'd assume that most if not all of the DNS records of the hidden hostnames would be a CNAME to the public name. The ESNI record would be associated to that public name.\r\n\r\nTo rephrase, the ESNI record would be associated to the public name in the current scheme.",
          "createdAt": "2019-07-30T07:21:18Z",
          "updatedAt": "2019-07-30T07:21:18Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that if the typical implementation is to have the hidden server name point to the public server with a CNAME, then the current record format is just fine. We may want to document this hidden CNAME assumption in the document.\r\n\r\nOn the other hand, I am still not convinced that CNAME is the proper tool. We definitely want to use DNSSEC to sign the record pointing from hidden to public. Otherwise, it becomes very simple to inject a false record pointing to a compromised public server, and then track clients. At a minimum, if we expect the hidden servers to use CNAME, we should explain how to use DNSSEC to secure that.\r\n\r\nApart from DNSSEC, the other feature that we want is the support for multiple public servers, in case one of them is blocked. I don't think that CNAME can do that. In practice, the simplest way will be to have multiple ESNI records listed directly in the context of the hidden server. That works, and doing DNSSEC is straightforward. But it implies replication of the public server ESNI record in many places, which brings in the issues of managing replication.",
          "createdAt": "2019-07-30T16:20:25Z",
          "updatedAt": "2019-07-30T16:20:25Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@huitema I think that elaborating on the expected practice is a good idea.\r\n\r\n> Apart from DNSSEC, the other feature that we want is the support for multiple public servers, in case one of them is blocked.\r\n\r\nWhile I appreciate the possibility, I am not sure if it is a good idea to endorse ESNI to be used as a tool to circumvent blocking. Because doing so would lead to ESNI being blocked. Rather, my preference goes to promoting ESNI as a tool for protecting privacy.",
          "createdAt": "2019-07-31T07:22:24Z",
          "updatedAt": "2019-07-31T07:22:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #187.",
          "createdAt": "2019-11-02T01:02:00Z",
          "updatedAt": "2019-11-02T01:02:00Z"
        }
      ]
    },
    {
      "number": 182,
      "id": "MDU6SXNzdWU0OTg0MzQ4OTM=",
      "title": "Consider disabling server tickets if tickets are not uniform across the ESNI anonymity set",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/182",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "Tickets and ESNI interact in a weird way, i.e., they may leak size or contain the SNI, leading to potential issues. One might want to disable them if also offering ESNI as a service.",
      "createdAt": "2019-09-25T17:54:45Z",
      "updatedAt": "2020-04-27T22:01:08Z",
      "closedAt": "2020-04-27T22:01:08Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Just to confirm, by uniform do you just mean that they're indistinguishable visually or that the server will cross-resume across names in the anonymity set?",
          "createdAt": "2019-09-26T22:47:12Z",
          "updatedAt": "2019-09-26T22:47:12Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Both!",
          "createdAt": "2019-09-26T22:48:16Z",
          "updatedAt": "2019-09-26T22:48:16Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure we want the latter. For instance, if they have different client certificate requirements, the server could be in a pickle resuming across them allows you to bypass those requirements. It also generally muddles the identity that the server is authenticating as. In the split mode case, the different backends presumably don't even share ticket keys.\r\n\r\nIs the motivation is various attacks around seeing if the server accepts a ticket in various contexts? That would certainly solve this, but I wonder if we can address them by playing games with binders instead? Though it's a little fussy since binder failures are currently fatal, whereas failing to decrypt a ticket just falls back to full handshake...",
          "createdAt": "2019-09-26T22:55:31Z",
          "updatedAt": "2019-09-26T22:55:46Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> For instance, if they have different client certificate requirements, the server could be in a pickle resuming across them allows you to bypass those requirements.\r\n\r\nCorrect! The issue as written isn't crisp :-) What we require, among possibly other things that I didn't write down, is that the information and authentication context for a ticket is indistinguishable across all tickets possible for a given set of servers. So in the example you describe, if a client gets a ticket without authenticating from one server and then resumes it to a different server that normally would require authentication, then the ticket must record whether authentication took place. And storing that bit should not reveal information about the name.\r\n\r\n(I was just aiming to make a note of this so I didn't forget it later. There's probably other things to consider, too. I don't claim this is complete as written!)\r\n\r\n> Is the motivation is various attacks around seeing if the server accepts a ticket in various contexts? \r\n\r\nYep! This is a \"flip table\" solution to the problem that some server operators may wish to do. ",
          "createdAt": "2019-09-26T23:00:16Z",
          "updatedAt": "2019-09-26T23:00:16Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood Is this about privacy or about authentication? It seems that we have two issues:\r\n\r\n1) Observers perform some trials and find out that \"hidden1.example.com\" uses 33 bytes tickets while \"hidden2.example.com\" uses 42 bytes. They can then look at TLS resume attempts and tell which server is contacted. \r\n\r\n2) Attackers find out that some servers send a ticket after authentication and other before that, and then use clever repeat attacks to benefit from the confusion.\r\n\r\nI would argue that (1) is part of the wider issue of identifying servers without breaking the encryption. We may want to address it, but it seems very complicated.\r\n\r\nAs for (2), is this an ESNI issue or a TLS issue?",
          "createdAt": "2019-09-27T02:20:38Z",
          "updatedAt": "2019-09-27T02:20:38Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@huitema it's about privacy. As you observe, (1) is clearly an issue for ESNI, but it's more an attack on tickets than it is on ESNI. It seems that if ESNI is to provide desired guarantees, then we ought to address it. (2) is a TLS issue and not related to ESNI. (Servers shouldn't be minting tickets without also including the authentication context. I'd rather not go down that rabbit hole here. :-))",
          "createdAt": "2019-09-27T02:37:41Z",
          "updatedAt": "2019-09-27T02:37:41Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(1) is a matter of degree. It is also possible to fingerprint servers by looking the sizes of pages, or the sizes of TLS blocks, or the profile of a typical session. There was a talk about that in one of the ANRW presentations.\r\n\r\nLet's assume that we want to standardize ticket sizes. Suppose that a fronting server says \"to hide behind me you should pad your tickets to exactly 64 bytes\". We are then going into two kinds of arguments. \r\n\r\nFirst, many sites owner will ask you \"how exactly do I do that with Apache2?\" So if you want uniformity, you need some deployment guidelines, and you want support in the main server distributions. Or the TLS stacks. Or the QUIC stacks. But then we are getting a bit beyond the scope of ESNI.\r\n\r\nSecond, there will be the occasional site that has the requirement for 67 bytes. Or 129. What do you do? Increase the size for everybody else? Suggest plausible sizes? Randomize?",
          "createdAt": "2019-09-27T05:54:53Z",
          "updatedAt": "2019-09-27T05:54:53Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> It is also possible to fingerprint servers by looking the sizes of pages, or the sizes of TLS blocks, or the profile of a typical session. There was a talk about that in one of the ANRW presentations.\r\n\r\nIndeed! However, the attack in mind is arguably much simpler than fingerprinting, so I'm not sure we should lump them in the same bucket. \r\n\r\nOn the question of sizes, note that we already recommend padding to hide certificate sizes. Making a similar suggestion for tickets therefore seems reasonable to me. ",
          "createdAt": "2019-09-27T14:50:24Z",
          "updatedAt": "2019-09-27T14:50:24Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, I now realize that the advice on certificate size seems a bit odd, as the size is not something that is exposed on the wire. To be accurate, I think what we care is the number of TLS records and their sizes transmitted during the handshake. Those are the things that are exposed on the wire.\r\n\r\nSimilarly, the contents of Client Hello and Server Hello are also exposed.\r\n\r\nConsidering that, it might be a good idea to recommend as a general rule to not expose _plaintext_ information that helps observers reduce the anonymity set, using the tickets and the size of the certificate as the examples.",
          "createdAt": "2019-09-28T12:51:14Z",
          "updatedAt": "2019-09-28T12:51:14Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Considering that, it might be a good idea to recommend as a general rule to not expose plaintext information that helps observers reduce the anonymity set, using the tickets and the size of the certificate as the examples.\r\n\r\nYes, that would certainly be an improvement! Would you mind preparing a PR to that effect? I can do it if you don't have the time.",
          "createdAt": "2019-09-28T14:36:21Z",
          "updatedAt": "2019-09-28T14:36:21Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood I'd appreciate it if you could, as I'm not sure when I can do it.",
          "createdAt": "2019-09-30T07:48:59Z",
          "updatedAt": "2019-09-30T07:48:59Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as this is effectively included in #209!",
          "createdAt": "2020-04-27T22:01:08Z",
          "updatedAt": "2020-04-27T22:01:08Z"
        }
      ]
    },
    {
      "number": 183,
      "id": "MDU6SXNzdWU1MDA5Nzc1Njc=",
      "title": "Clarification on repeated extensions in ESNIRecord and ESNIKeys",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/183",
      "state": "CLOSED",
      "author": "dmcardle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "[RFC8446 section 4.2](https://tools.ietf.org/html/rfc8446#section-4.2) states:\r\n\r\n> There MUST NOT be more than one extension of the\r\n   same type in a given extension block.\r\n\r\nThe ESNI draft should probably explicitly restate this for both `ESNIRecord.dns_extensions` and `ESNIKeys.extensions`.  I'd be happy to make a PR if need be. Thanks!",
      "createdAt": "2019-10-01T15:34:05Z",
      "updatedAt": "2020-03-08T00:32:55Z",
      "closedAt": "2020-03-08T00:32:54Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@dmcardle if you could propose text that takes the new ESNIConfig and HTTPSSVC change into account, that'd be great!",
          "createdAt": "2019-11-04T20:51:08Z",
          "updatedAt": "2019-11-04T20:51:08Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #195.",
          "createdAt": "2020-03-08T00:32:54Z",
          "updatedAt": "2020-03-08T00:32:54Z"
        }
      ]
    },
    {
      "number": 188,
      "id": "MDU6SXNzdWU1MTI2NzUzMzQ=",
      "title": "\"HKDF-Extract(0, Z)\"",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/188",
      "state": "CLOSED",
      "author": "sayrer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "A second point in issue #155 wasn't addressed very clearly by #158. \r\n\r\n\"...HKDF-Extract(0, Z) should probably become HKDF-Extract(\"\", Z) or be explicit about the salt as is done in https://tools.ietf.org/html/rfc8446#section-7.1 (or https://tools.ietf.org/html/rfc5869#section-2.2).\"\r\n\r\nThe current draft does clarify this in the text below, but I initially missed that. The reader has to know that the first argument to HKDF-Extract is named \"salt\" to put it together.\r\n\r\nI did end up getting it right, figuring this was intended to mean a buffer of zeros. I think it would be clearer to say:\r\n\r\n```\r\nsalt = uint8[Hash.length]\r\nZx = HKDF-Extract(salt, Z)\r\n```",
      "createdAt": "2019-10-25T19:11:24Z",
      "updatedAt": "2019-11-19T09:26:34Z",
      "closedAt": "2019-11-19T09:26:34Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sayrer a PR to clarify this point is most welcome!",
          "createdAt": "2019-11-05T02:25:58Z",
          "updatedAt": "2019-11-05T02:25:58Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It would be ok to take this suggestion into consideration under the terms of the IETF's \"Note Well\" blue sheet terms, and incorporate it into a PR by the editors.",
          "createdAt": "2019-11-15T08:05:00Z",
          "updatedAt": "2019-11-15T08:05:00Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sayrer I agree! Could you please provide that PR?",
          "createdAt": "2019-11-17T03:12:45Z",
          "updatedAt": "2019-11-17T03:12:45Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oh, I was asking you folks to do it. If there's a reason I need to do it, I'd be happy to.",
          "createdAt": "2019-11-17T21:05:14Z",
          "updatedAt": "2019-11-17T21:05:14Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think this is necessary, so while I'm willing to look at a PR, I'm not going to make one at this time.",
          "createdAt": "2019-11-17T22:23:24Z",
          "updatedAt": "2019-11-17T22:23:24Z"
        }
      ]
    },
    {
      "number": 189,
      "id": "MDU6SXNzdWU1MTI3NzIzMTE=",
      "title": "AEAD-Encrypt definition",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/189",
      "state": "CLOSED",
      "author": "sayrer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "```\r\nThe ClientEncryptedSNI.encrypted_sni value is then computed using the\r\n   usual TLS 1.3 AEAD:\r\n\r\n    encrypted_sni = AEAD-Encrypt(key, iv, KeyShareClientHello, ClientESNIInner)\r\n```\r\n\r\nHowever, the TLS 1.3 definition is:\r\n\r\n```\r\nAEADEncrypted =\r\n          AEAD-Encrypt(write_key, nonce, additional_data, plaintext)\r\n```\r\n\r\nIn the ESNI text, it's not clear how `iv` maps to TLS 1.3's `per-record nonce` routine.",
      "createdAt": "2019-10-26T01:10:02Z",
      "updatedAt": "2019-11-04T21:41:29Z",
      "closedAt": "2019-11-04T21:41:29Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not following what the problem is here: AEAD-Encrypt is a function that takes four arguments, the second of which is a nonce. In TLS 1.3 record encryption, this nonce value is set as described in S 5.3. In ESNI, it is derived via HKDF in the fashion described in S 5.1.1..",
          "createdAt": "2019-10-26T01:33:48Z",
          "updatedAt": "2019-10-26T01:33:48Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't doubt that there is a right answer. It wasn't clear to me whether I should mix in a sequence number to `iv` (maybe zero?).\r\n\r\nOtherwise, it made sense. Although it might be quite a bit clearer to define each argument in terms of the TLS 1.3 definition.\r\n\r\n```\r\n...\r\nnonce = iv\r\nadditional_data = KeyShareClientHello\r\n...\r\n\r\nAEADEncrypted =\r\n          AEAD-Encrypt(write_key, nonce, additional_data, plaintext)\r\n```",
          "createdAt": "2019-10-26T01:40:04Z",
          "updatedAt": "2019-10-26T01:43:35Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In other words, the second argument to `AEAD-Encrypt` in TLS 1.3 is \"derived from the sequence number and the client_write_iv or server_write_iv\".\r\n\r\nAs I read, it wasn't clear to me whether I should do nothing to the existing `iv` value, or mix in zero or something. This might be really obvious in some implementations, but it wasn't in the one I'm working on.",
          "createdAt": "2019-10-26T01:51:22Z",
          "updatedAt": "2019-10-26T01:52:29Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "You don't do either. The function takes a nonce argument. In TLS 1.3, that argument is computed one way, and in ESNI it is computed another way. These are positional functions and the names in scope at the call site are irrelevant.\r\n\r\nI think your proposed change would confuse rather than illuminating.\r\n\r\nI agree with you that adding test vectors would be useful, and if you want to supply some -- though I suggest you wait until the next version -- in a PR, that would be great.",
          "createdAt": "2019-10-26T02:22:40Z",
          "updatedAt": "2019-10-26T02:22:40Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK, maybe my proposed solution is not the best, but I don't think the status quo is great. I get the point of \"These are positional functions and the names in scope at the call site are irrelevant\", but that's actually not quite true in TLS, afaik. The names tend to imply input/output treatment.\r\n\r\nFor example, things called \"*_iv\" are inputs to `nonce` in TLS 1.3. In some implementations, the input \"Initialization Vector (IV)\" [RFC4106] might be a different static type from the `nonce` in the TLS 1.3 definition. That's why I got confused.\r\n\r\nmaybe adjust `ClientESNIInner ` like so:\r\n\r\n```\r\nstruct {\r\n   uint8 inner_nonce[16];\r\n   PaddedServerNameList realSNI;\r\n} ClientESNIInner;\r\n```\r\n\r\nand then:\r\n\r\n`nonce = HKDF-Expand-Label(Zx, \"esni iv\", Hash(ESNIContents), iv_length)`",
          "createdAt": "2019-10-26T02:29:49Z",
          "updatedAt": "2019-10-26T02:42:28Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "> For example, things called \"*_iv\" are inputs to nonce in TLS 1.3. \r\n\r\nI don't see how this argues your point. Again, the names are irrelevant.\r\n\r\n> In some implementations, the input \"Initialization Vector (IV)\" [RFC4106] might be a different static type from the nonce in the TLS 1.3 definition.\r\n\r\nI don't really see how the implementation types are relevant here.\r\n\r\nIn any case, given the state of the draft and the reasonable likelihood this will change, I think this decision is well within editor discretion.",
          "createdAt": "2019-10-26T03:28:49Z",
          "updatedAt": "2019-10-26T03:28:49Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > For example, things called \"*_iv\" are inputs to nonce in TLS 1.3.\r\n> \r\n> I don't see how this argues your point. Again, the names are irrelevant.\r\n\r\nThe TLS spec and the ESNI spec do not have a type system. They do have a serialization spec, and I am not arguing about that. I do think the names could be clearer without inventing a type system.\r\n \r\n> > In some implementations, the input \"Initialization Vector (IV)\" [RFC4106] might be a different static type from the nonce in the TLS 1.3 definition.\r\n> \r\n> I don't really see how the implementation types are relevant here.\r\n\r\nWell, I think this perspective leads to reverse engineering C/C++ implementations, rather than precisely specifying the inputs to functions like AEAD-Encrypt.\r\n",
          "createdAt": "2019-10-26T03:44:18Z",
          "updatedAt": "2019-10-26T03:44:18Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Maybe it could say something like \"The ClientEncryptedSNI.encrypted_sni value is then computed using the usual TLS 1.3 AEAD, but note that the second argument, 'iv', is not combined with a sequence number:\"\r\n\r\nThe reason I found this confusing was that TLS 1.3 doesn't define the \"nonce\" argument symbolically, but the ESNI draft does define \"iv\" symbolically. That's fine, but I then had to plumb a new kind of value into the library to allow for this IV, and I wasn't sure if it was right.",
          "createdAt": "2019-10-26T18:49:19Z",
          "updatedAt": "2019-10-26T18:49:19Z"
        },
        {
          "author": "nharper",
          "authorAssociation": "NONE",
          "body": "I agree with @ekr that AEAD-Encrypt is a 4 positional argument function and it shouldn't matter what they're called in the ESNI spec compared to what they're called in RFC 8446. However, from re-reading RFC 8446, I don't see a good definition of the AEAD-Encrypt function. Perhaps it would be better to describe the encryption using the Authenticated Encryption interface described in [Section 2.1 of RFC 5116](https://tools.ietf.org/html/rfc5116#section-2.1)?",
          "createdAt": "2019-10-28T18:41:48Z",
          "updatedAt": "2019-10-28T18:41:48Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\"AEAD-Encrypt is a 4 positional argument function and it shouldn't matter what they're called in the ESNI spec compared to what they're called in RFC 8446.\"\r\n\r\nThis is sort of true, but I noticed that the specs use the name of the second argument to imply its input treatment: IV vs nonce. In that light, I suppose my suggested text might sound redundant, but I think the current document is too concise.",
          "createdAt": "2019-10-28T19:13:50Z",
          "updatedAt": "2019-10-28T19:13:50Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #194.",
          "createdAt": "2019-11-04T21:41:28Z",
          "updatedAt": "2019-11-04T21:41:28Z"
        }
      ]
    },
    {
      "number": 190,
      "id": "MDU6SXNzdWU1MTYzMTQ1NDY=",
      "title": "AAD calculation could use more explanation",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/190",
      "state": "CLOSED",
      "author": "sayrer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The draft says\r\n\r\n\"The ClientEncryptedSNI.encrypted_sni value is then computed using the usual TLS 1.3 AEAD:\r\n\r\n    encrypted_sni = AEAD-Encrypt(key, iv, KeyShareClientHello, ClientESNIInner)\r\n\r\nWhere KeyShareClientHello is the \"extension_data\" field of the  \"key_share\" extension in a Client Hello (Section 4.2.8 of [RFC8446]))\"\r\n\r\nI found that NSS inserts an extra 8 bytes of zeros in front of KeyShareClientHello for its AAD:\r\nhttps://dxr.mozilla.org/mozilla-central/rev/0e1726e95801928249c4dc14fd23fe2cbbb13b3b/security/nss/lib/ssl/tls13esni.c#665\r\n\r\nI'm not sure if those zeros are implied by one of the references. I couldn't spot it after looking for 10 minutes or so, and that byte seems to be in code specifically intended for ESNI.",
      "createdAt": "2019-11-01T19:52:16Z",
      "updatedAt": "2019-11-01T23:01:34Z",
      "closedAt": "2019-11-01T22:12:42Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "You're misreading the code. This is an idiosyncracy of the internal NSS interface. The 0s here are what would be the TLS sequence number ordinarily and are not part of the AAD.",
          "createdAt": "2019-11-01T22:12:42Z",
          "updatedAt": "2019-11-01T22:12:42Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It could be a misreading, but should this be closed? At the very least, some TLS implementations will prepend 8 bytes of zeros. Another instance of unclear input treatment in this text.",
          "createdAt": "2019-11-01T22:29:27Z",
          "updatedAt": "2019-11-01T22:29:27Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "NSS's code isn't part of the text, so the spec isn't responsible for people's misinterpretations of the NSS code (or any other code).",
          "createdAt": "2019-11-01T22:32:04Z",
          "updatedAt": "2019-11-01T22:32:04Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well, currently NSS's code is implied in the spec, because no one could get the ESNI record's checksum right by following any draft. One would have to combine -02 and -04 in the way NSS does.",
          "createdAt": "2019-11-01T22:37:40Z",
          "updatedAt": "2019-11-01T22:37:40Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I haven't verified that this is true, but even if it is, NSS Is not the reference implementation for the specification and failure to interoperate with NSS is not the test for correct implementations. We (NSS) are not attempting to track the current spec because issues are still in fluc, so it's entirely possible that our implementation is in some funny state, but that's still not a spec issue.",
          "createdAt": "2019-11-01T22:43:11Z",
          "updatedAt": "2019-11-01T22:43:11Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's true. record_digest is transmitted in the clear, and I noticed my implementation's value mismatched Firefox's.\r\n\r\nI think the issue is not so much that NSS has bugs (it happens), but that the spec is vague enough that I am having trouble telling whether NSS's behavior is following the spec.",
          "createdAt": "2019-11-01T23:00:19Z",
          "updatedAt": "2019-11-01T23:01:34Z"
        }
      ]
    },
    {
      "number": 191,
      "id": "MDU6SXNzdWU1MTYzNTA0NjA=",
      "title": "Why is the PaddedSNI padded with zeros?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/191",
      "state": "CLOSED",
      "author": "sayrer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Couldn't these extra bytes be any value?",
      "createdAt": "2019-11-01T21:14:03Z",
      "updatedAt": "2019-11-05T08:13:05Z",
      "closedAt": "2019-11-04T20:52:21Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, but zeroes are quite common. See, e.g., TLS 1.3 record-layer padding: https://tools.ietf.org/html/rfc8446#section-5.4.",
          "createdAt": "2019-11-04T20:52:21Z",
          "updatedAt": "2019-11-04T20:52:21Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Would you mind reopening this issue? I think a MUST requirement with a rationale of \"everyone else does it\" seems wrong.\r\n\r\nI can think of some reasons to mandate zeros:\r\n\r\n- prevent ad-hoc extensions\r\n- prevent clients from intentionally weakening traffic\r\n\r\nstuff like that. I just think the draft should state the rationale.\r\n",
          "createdAt": "2019-11-04T22:54:43Z",
          "updatedAt": "2019-11-04T22:54:43Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I would prefer that we not add any rationale. This is a reasonable choice and if we add a rationale for everything that is reasonable the draft will get quite long.\r\n\r\nSecond, we are actively considering a number of PRs here, at least one of which does not even have these bytes, so effort spent justifying them is potentially wasted.",
          "createdAt": "2019-11-04T23:02:01Z",
          "updatedAt": "2019-11-04T23:02:01Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I would prefer that we not add any rationale. This is a reasonable choice and if we add a rationale for everything that is reasonable the draft will get quite long.\r\n\r\nIt's a not a reasonable choice if there is no reason for it.\r\n\r\n> Second, we are actively considering a number of PRs here, at least one of which does not even have these bytes, so effort spent justifying them is potentially wasted.\r\n\r\nThat makes sense. What's the link?",
          "createdAt": "2019-11-04T23:14:10Z",
          "updatedAt": "2019-11-04T23:14:10Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\nIt's a not a reasonable choice if there is no reason for it.",
          "createdAt": "2019-11-05T02:23:17Z",
          "updatedAt": "2019-11-05T02:23:17Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sayrer I don't think this needs rationale. Padding with zeros is more or less convention in TLS, and we've stuck with it. ",
          "createdAt": "2019-11-05T02:24:44Z",
          "updatedAt": "2019-11-05T02:24:44Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> It's a not a reasonable choice if there is no reason for it.\r\n\r\nJokes aside, what would the rationale be for this requirement?\r\n\r\n\"The SNI must be padded with zeros, because ________\".\r\n\r\nIt may be the case that other TLS specs have used zeros.",
          "createdAt": "2019-11-05T05:20:26Z",
          "updatedAt": "2019-11-05T05:20:26Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "It's not the case that every design decision in the specification needs to have a rationale in the specification. That's not any kind of IETF requirement.\r\n\r\nIf you have some objection to this design choice, I suggest you raise it on the mailing list and see if others agree.\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2019-11-05T05:32:43Z",
          "updatedAt": "2019-11-05T05:33:22Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's true that not every requirement needs a rationale. Some of them are obviously in service of the goals of the draft itself: for example, no one is claiming that the document should justify encryption. It's also reasonable to cite other documents as the way to do things: there's no need to provide a rationale for the use of AEAD, for instance.\r\n\r\nBut, the choice of server-controlled zeros for this padding is specific to this draft. It seems like this requirement would be better as a server-specified minimum length, where the field is variable length and filled with opaque data (zeros are acceptable).",
          "createdAt": "2019-11-05T05:42:52Z",
          "updatedAt": "2019-11-05T05:42:52Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We've been bitten by requirements for opaque data in the past.  See POODLE.",
          "createdAt": "2019-11-05T06:52:03Z",
          "updatedAt": "2019-11-05T06:52:03Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> We've been bitten by requirements for opaque data in the past. See POODLE.\r\n\r\nThis comment seems ambiguous enough to warrant reopening the issue.",
          "createdAt": "2019-11-05T08:13:04Z",
          "updatedAt": "2019-11-05T08:13:04Z"
        }
      ]
    },
    {
      "number": 192,
      "id": "MDU6SXNzdWU1MTY1MzAyMDY=",
      "title": "How to parse esni_retry_request generically?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/192",
      "state": "CLOSED",
      "author": "ocheron",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As of draft-ietf-tls-esni-04, when the server rejects ESNI with esni_retry_request, it includes one or more ESNIKeys for retry:\r\n```\r\n      struct {\r\n          ServerESNIResponseType response_type;\r\n          select (response_type) {\r\n              case esni_accept:        uint8 nonce[16];\r\n              case esni_retry_request: ESNIKeys retry_keys<1..2^16-1>;\r\n          }\r\n      } ServerEncryptedSNI;\r\n\r\n   retry_keys  One or more ESNIKeys structures containing the keys that\r\n      the client should use on subsequent connections to encrypt the\r\n      ClientESNIInner structure.\r\n```\r\n\r\nThe client behavior described in section 5.1.2 is to pick one of the ESNIKeys values from this vector:\r\n\r\n> If one of the values contains a version supported by the client,\r\n> it can regard the ESNI keys as securely replaced by the server.\r\n> It SHOULD retry the handshake with a new transport connection,\r\n> using that value to encrypt the SNI.\r\n\r\nEncoding of `retry_keys` contains the total size of the vector field but not the size of the individual ESNIKeys elements. This makes it difficult (impossible?) to parse a vector with unknown future versions, so this part is not really extensible.",
      "createdAt": "2019-11-02T08:27:46Z",
      "updatedAt": "2019-11-21T10:17:47Z",
      "closedAt": "2019-11-21T10:17:47Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the comment! https://github.com/tlswg/draft-ietf-tls-esni/pull/198 should resolve this. It's a little goofy-looking but ah well.",
          "createdAt": "2019-11-05T22:04:23Z",
          "updatedAt": "2019-11-05T22:04:23Z"
        },
        {
          "author": "ocheron",
          "authorAssociation": "NONE",
          "body": "Thank you for confirming the issue. Not the nicest but will be effective.\r\nIt's the only real blocking point I see when implementing draft -04.",
          "createdAt": "2019-11-09T08:33:36Z",
          "updatedAt": "2019-11-09T08:33:36Z"
        }
      ]
    },
    {
      "number": 193,
      "id": "MDU6SXNzdWU1MTY2OTg5MTk=",
      "title": "Reasoning for 260",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/193",
      "state": "CLOSED",
      "author": "sayrer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The initial commit for the padding in the spec gave the reason for the \"260\" figure (maximum domain + TLS struct overhead). There have been many comments mentioning slightly lower numbers (255, 253, etc). It's subtle enough that the spec should probably detail the reason.",
      "createdAt": "2019-11-02T19:39:45Z",
      "updatedAt": "2019-11-04T21:41:21Z",
      "closedAt": "2019-11-04T21:41:21Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #194.",
          "createdAt": "2019-11-04T21:41:21Z",
          "updatedAt": "2019-11-04T21:41:21Z"
        }
      ]
    },
    {
      "number": 202,
      "id": "MDU6SXNzdWU1MjMwMDI5NTM=",
      "title": "Removing ESNI RRType Considerations",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/202",
      "state": "CLOSED",
      "author": "mrsylerpowers",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Because this document now delegates the way the keys are advertised from the RRType ESNI to HTTPSSVC shouldn't the RRType Considerations be removed from this document. ",
      "createdAt": "2019-11-14T17:30:58Z",
      "updatedAt": "2019-11-14T20:35:25Z",
      "closedAt": "2019-11-14T20:35:25Z",
      "comments": []
    },
    {
      "number": 204,
      "id": "MDU6SXNzdWU1MjgzMjI0MTk=",
      "title": "Anonymity sets",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/204",
      "state": "CLOSED",
      "author": "sayrer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Even if #146 and #139 are closed without further edits, I think the draft should clarify the intended anonymity set for ESNIConfig and its associated record_digest. The draft does address this in section 7.5.2. \"Avoid widely-deployed shared secrets\", but I missed that. Additionally, the draft uses the term \"anonymity set\" only once, in section 6.1. \"Misconfiguration and Deployment Concerns\".\r\n\r\nThe explanation Ben Schwartz wrote on the list is very clear:\r\n\r\n\"The record_digest, like the ESNIConfig itself, is intended to be constant across all domains that form an anonymity set (i.e. O(1) ESNIConfigs per CDN).  Thus, the record_digest reveals no additional information to an onlooker who can observe the server IP.\"\r\n\r\nPerhaps a short section on anonymity sets would clarify this. I think some combination of section 7.5.2 and the last paragraph of the introduction would work.",
      "createdAt": "2019-11-25T20:35:36Z",
      "updatedAt": "2020-04-27T21:58:03Z",
      "closedAt": "2020-04-27T21:58:03Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sayrer text to clarify this would be most welcome. Please provide a PR!",
          "createdAt": "2019-11-25T20:59:05Z",
          "updatedAt": "2019-11-25T20:59:05Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Indeed, I'm not sure further clarification is needed. Given no action on this issue, I'm closing. Please propose a PR or text if you feel this still needs to be fixed!",
          "createdAt": "2020-04-27T21:58:03Z",
          "updatedAt": "2020-04-27T21:58:03Z"
        }
      ]
    },
    {
      "number": 205,
      "id": "MDU6SXNzdWU1Mjg5ODA1MTY=",
      "title": "Include \"receiver anonymity\" as motivation for empty record_digest values",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/205",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "And possibly also include a bit inside ESNIConfig that tells clients whether or not to populate record_digest. (See https://bford.info/pub/sec/purb.pdf for some relevant definitions.)",
      "createdAt": "2019-11-26T21:26:01Z",
      "updatedAt": "2020-05-03T14:05:15Z",
      "closedAt": "2020-05-03T14:05:15Z",
      "comments": []
    },
    {
      "number": 206,
      "id": "MDU6SXNzdWU1NTkzNjc1OTc=",
      "title": "Suggestion to support user@domain.name",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/206",
      "state": "CLOSED",
      "author": "vanrein",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I would like to suggest supporting not only the `server_name`, but also permit user names to be included.  This would provide excellent support for peer-to-peer applications for protocols that use `user@domain.name` identities and whose design can work peer-to-peer.\r\n\r\nThere are [TLS relays using SNI](https://github.com/dlundquist/sniproxy) that need no knowledge about the content of the TLS stream, so they are no men in the middle.  With user names added into ESNI, it would be possible to do similar things with registered users; [SIP](https://tools.ietf.org/html/rfc3261) springs to mind as an example, because phones/terminals `REGISTER` [to a domain's server](https://tools.ietf.org/html/rfc3261#section-10.3) that subsequently [relays](https://tools.ietf.org/html/rfc3261#page-12) `INVITE` and other messages between them but is effectively a MITM, which can modify traffic and tap [SDP](https://tools.ietf.org/html/rfc4566)-transmitted [keys](https://tools.ietf.org/html/rfc4566#section-5.12) and [communication end points](https://tools.ietf.org/html/rfc4566#section-4.1).\r\n\r\nThe general story is of course that end-to-end encryption is better than hop-by-hop encryption, as in current uses of TLS.  Peers representing users that register with an intermediate server sound like a good opportunity to be doing that.  All that is required is a way of deciding where to forward TLS traffic, without changing its contents.  ESNI comes really close to that goal (if it adds user names).",
      "createdAt": "2020-02-03T22:16:36Z",
      "updatedAt": "2020-04-27T21:56:35Z",
      "closedAt": "2020-04-27T21:56:35Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Since the draft now encrypts the entire CH, this issue is irrelevant. (In particular, if clients want to send user names, they can do so today, with or without ECHO.)",
          "createdAt": "2020-04-27T21:56:35Z",
          "updatedAt": "2020-04-27T21:56:35Z"
        }
      ]
    },
    {
      "number": 214,
      "id": "MDU6SXNzdWU1OTYwMzA5MTk=",
      "title": "Clarify 1.2 connection support (don't break connections, but also don't protect the certificate)",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/214",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "If the backend server does not include any signal for ECHO negotiation, either as a ServerHello extension or part of ServerHello.random, then it's possible to tunnel CHs to TLS 1.2 servers. This can be a feature, so let's consider whether or not it's in scope. (Note that we may discover that lack of server-side handshake message padding may make traffic analysis trivial.)\r\n\r\ncc @grittygrease ",
      "createdAt": "2020-04-07T17:24:36Z",
      "updatedAt": "2020-05-21T21:40:57Z",
      "closedAt": "2020-05-21T21:40:57Z",
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "Not sure that'd be worthwhile. Wouldn't the TLS server cert be sent in clear to the client? So the server-name will be visible anyway. I'm not sure if the remaining CH content is sufficient to justify the added complexity of having to handle a TLSv1.2 CH.",
          "createdAt": "2020-04-12T20:17:03Z",
          "updatedAt": "2020-04-12T20:17:03Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "If we didn't encrypt the server flight, that's right! But we might consider designs wherein the client-facing server encrypts (or tunnels) the server flight, just as we've done for the client flight.",
          "createdAt": "2020-04-12T22:01:57Z",
          "updatedAt": "2020-04-12T22:01:57Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, so support for TLSv1.2 here implies a new middle->client encryption. My first reaction is that we're nearly inventing masque again, so maybe this is a feature to leave for that?",
          "createdAt": "2020-04-12T22:34:16Z",
          "updatedAt": "2020-04-12T22:34:16Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Ah, so support for TLSv1.2 here implies a new middle->client encryption. My first reaction is that we're nearly inventing masque again, so maybe this is a feature to leave for that?\r\n\r\nPossibly. There may be a middle ground. Considering the amount of TLS 1.2 servers in existence, I think this is worth some thought.",
          "createdAt": "2020-04-13T13:48:14Z",
          "updatedAt": "2020-04-13T13:48:14Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "This seems clever, but on balance it seems like we are getting close to a \"tunnel everything\" design. We want people to move to 1.3 and so going out of our way to accommodate 1.2 seems backwards.",
          "createdAt": "2020-04-24T14:38:41Z",
          "updatedAt": "2020-04-24T14:38:41Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The main problem this solves is in the fronting case. Specifically, in the\ncase that an ECHO-aware fronting server is operated by a different entity\nthan the backend server and the fronting server does not know whether the\nbackend server supports TLS 1.3 or not. Enabling support for TLS 1.2\nenables this fronting server to be deployed in front of a wide set of\nservers.\n\nOn Fri, Apr 24, 2020 at 7:38 AM ekr <notifications@github.com> wrote:\n\n> This seems clever, but on balance it seems like we are getting close to a\n> \"tunnel everything\" design. We want people to move to 1.3 and so going out\n> of our way to accommodate 1.2 seems backwards.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/issues/214#issuecomment-619050908>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/ABHDHZ4SMC6TFEUWSRDFLIDROGQAFANCNFSM4MDJN5UQ>\n> .\n>\n",
          "createdAt": "2020-04-24T23:02:26Z",
          "updatedAt": "2020-04-24T23:02:26Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "As others have pointed out, the cost of adding support for TLS 1.2 servers it that there needs to be a layer below the TLS record layer, so that the plaintext records sent by the backend server can be encrypted.\r\n\r\nI'd be a bit concerned about the required cost and complexity that that has, therefore my +1 goes to just supporting TLS 1.3.",
          "createdAt": "2020-04-27T06:14:18Z",
          "updatedAt": "2020-04-27T06:14:18Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Two concerns here:\r\n\r\n1. Security: Suppose an adversary can inject a TLS 1.2 ServerHello, without the echo_nonce, and a Certificate message.  Does the client react differently depending on whether the hidden name is in the SAN list (e.g. certificate mismatch fails faster than verification failure)?  If so, the adversary might be able to learn the hidden name.\r\n\r\n2. Management: Suppose a TLS 1.2 backend is not coordinating closely with forwarder, which seems to be the goal of this model.  When the backend upgrades to TLS 1.3, will connections start failing because it is not including the echo_nonce in the transcript?",
          "createdAt": "2020-04-27T21:14:24Z",
          "updatedAt": "2020-04-27T21:14:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The client reaction issue is interesting, though maybe we can get around that by requiring constant time verification? On some systems that might be very hard to enforce, as verification doesn't even happen in the same process. Hmm... penny for your thoughts, @ekr and @davidben?\r\n\r\nAs for the nonce issue -- it's already included in the ClientHello. The server doesn't include it an extension explicitly.",
          "createdAt": "2020-04-27T21:26:05Z",
          "updatedAt": "2020-04-27T21:26:55Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the clarification.  I still think there's a potential best-practices concern if this encourages deployments that transmit the decrypted ClientHello in cleartext between the forwarder and backend, but that's less obvious.",
          "createdAt": "2020-04-27T23:28:44Z",
          "updatedAt": "2020-04-27T23:28:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed! Clarifying text there would help. I'll see if I can craft something along those lines for this issue.",
          "createdAt": "2020-04-27T23:30:47Z",
          "updatedAt": "2020-04-27T23:30:47Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\nFWIW, I still think making complexity-inducing changes\nto better support TLSv1.2 (even in this reduced manner)\nwould be a bad plan. In large part because it'd take ages to figure it\nout. If someone could demonstrate a reduction\nin complexity and increase in security I might change my\nmind. Absent that, I continue to think we're better off\nexclusively supporting TLSv1.3.\n\nCheers,\nS.\n",
          "createdAt": "2020-04-27T23:34:12Z",
          "updatedAt": "2020-04-27T23:34:12Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "The issue of not being able to clearly tell whether ServerHello used the outer or inner ClientHello does seem somewhat fatal. Deferring figuring this out to certificate verification is especially a nuisance, and I shudder at the thought having a coherent notion of constant-time X.509 verification.",
          "createdAt": "2020-05-21T21:25:26Z",
          "updatedAt": "2020-05-21T21:25:26Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we should continue to base this on the assumption that the server does TLS 1.3. Trying to analyze the question of how this integrates with TLS 1.2  -- especially given that we have concerns about the naive integration -- seems prohibitive.",
          "createdAt": "2020-05-21T21:27:31Z",
          "updatedAt": "2020-05-21T21:27:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "On reflection, I tend to agree. On platforms I'm familiar with, constant-time certificate verification would be intractable. I'm closing this issue with the recommendation that we stick to the document's intent: ESNI for TLS 1.3. ",
          "createdAt": "2020-05-21T21:40:57Z",
          "updatedAt": "2020-05-21T21:40:57Z"
        }
      ]
    },
    {
      "number": 215,
      "id": "MDU6SXNzdWU1OTYwMzMzNTQ=",
      "title": "Limit \"Don't stick out\" to explicit signals",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/215",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "There's no explicit signal indicating that ECHO was negotiated for a connection. Thus, clients must perform trial decryption with both possible handshake keys. If we intend to keep this, then we should crisply state that \"don't stick out\" is limited to explicit signals, i.e., implicit signals such as size-related information is probably out of scope. (It's certainly an open question what is the \"best\" padding scheme for handshake messages.)\r\n\r\ncc @grittygrease ",
      "createdAt": "2020-04-07T17:28:54Z",
      "updatedAt": "2020-05-05T20:10:04Z",
      "closedAt": "2020-05-05T20:10:04Z",
      "comments": []
    },
    {
      "number": 216,
      "id": "MDU6SXNzdWU1OTg1MDI5MDk=",
      "title": "Clarify ECHOConfig (HTTPSSVC) extension purpose",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/216",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "ECHOConfig.public_name provides information that goes in the outer CH. HTTPSSVC.alpn provides information to go in the inner CH (I assume). We don't specify a way for the server to  explicitly say what alpn to use in the outer CH.  I think it'd be worth re-considering where servers/admins might want to put that kind of information and how much of the inner/outer CH they may want to describe. There could be a range of potential outcomes if we re-visit this - at one extreme HTTPSSVC or ECHOConfig might provide a template for the entire CH (possibly via some template naming/numbering scheme), at the other extreme we might decide that ECHOConfig should only contain the keying information and just define alpn, public_alpn and public_name as optional fields for inclusion in HTTPSSVC. But it seems a bit broken for the only two parts of the CH the server specifies to be handled so differently,",
      "createdAt": "2020-04-12T14:54:22Z",
      "updatedAt": "2020-05-07T18:43:48Z",
      "closedAt": "2020-05-07T18:43:47Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> HTTPSSVC.alpn provides information to go in the inner CH (I assume).\r\n\r\nIt doesn't. It's important for downgrade protection that the DNS (not secured) *not* impact the client's ALPN preferences. The interaction between HTTPSSVC and ALPN is... rather a mess and the text around this still needs work.",
          "createdAt": "2020-04-13T14:54:07Z",
          "updatedAt": "2020-04-13T14:54:07Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 13/04/2020 15:54, David Benjamin wrote:\n>> HTTPSSVC.alpn provides information to go in the inner CH (I\n>> assume).\n> \n> It doesn't. It's important for downgrade protection that the DNS (not\n> secured) *not* impact the client's ALPN preferences. The interaction\n> between HTTPSSVC and ALPN is... rather a mess and the text around\n> this still needs work.\n\nAh. Fair enough. Though I guess ECHO will likely only be\nused via DoH or something equivalent which could change\nthings maybe.\n\nBut regardless... doesn't the point still stand that we'd\nbe better off with some consistency in how we manage the\nserver-name in the outer CH, the ALPNs in both inner and outer, and any\nother CH content where the server wants to\npublish some hints?\n\nI'm not particularly wedded to a specific approach (though\nI'd likely be more biased to simplifying the ECHOConfig).\n\n\n",
          "createdAt": "2020-04-13T15:00:58Z",
          "updatedAt": "2020-04-13T15:00:58Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Even DoH won't authenticate the origin, only the resolver. One hopes the resolver is reasonably trusted, but I'd still prefer not giving it new powers. (Today, only the origin server pick HTTP/1.1 vs HTTP/2. That's useful given HTTP/1.1's safety against truncation attacks is... complicated.)\r\n\r\nI guess I see the public name less as an instruction for what to put in the outer ClientHello but a delegation to another name to authenticate any ECHO key replacements or ECHO shutoffs. That then implies putting it in the outer ClientHello so the server can pick the right fallback certificate. I think I'd also rather keep that information in ECHOConfig so the TLS stack gets a single bundle of data. (Similar thinking as https://github.com/tlswg/draft-ietf-tls-esni/issues/219#issuecomment-612963381.) But maybe the overall change would make more sense? I don't fully understand the proposal.\r\n\r\nOf course, the same authentication mismatch applies to the public name as any ALPN signals. While this was ESNI rather than ECHO, the reasoning was that the DNS server learns the hostname anyway, and can always drop ESNI records. The latter still holds for ECHO. The former... I'm not sure. Over in browser land, I really only care about the hostname, but there are probably other scenarios.",
          "createdAt": "2020-04-13T16:04:40Z",
          "updatedAt": "2020-04-13T16:05:24Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Assuming we are trying to do GREASE, the important thing is that the outer ClientHello is the same for clients with real and fake ECHO.  This could be achieved by providing a template in the ECHOConfig for the outer ClientHello that matches a popular client's behavior, or by telling clients \"when constructing the outer ClientHello, pretend you're connecting to the public name without the HTTPSSVC info\".  For now, I would lean to the latter for simplicity.  We can always define an outer ClientHello template later as an ECHOConfig extension.\r\n\r\nIf we give up on GREASE, I would remove the outer ALPN entirely.",
          "createdAt": "2020-04-15T03:06:20Z",
          "updatedAt": "2020-04-15T03:06:20Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "The latter sounds reasonable.\r\n\r\nA template would not fly because the outer ClientHello must still adhere to [protocol invariants](https://tools.ietf.org/html/rfc8446#section-9.3), so any parameters in there must ones the client would legitimately accept. (Unless they ignore the fallback case and retry all errors with a more accurate outer ClientHello.)",
          "createdAt": "2020-04-15T14:58:54Z",
          "updatedAt": "2020-04-15T14:58:54Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "As per the call today, we'll use this issue to track guidance (that will be mirrored in the HTTPSSVC document) about how one populates extension information. In particular, information that pertains to the outer CH, which exists only for ECHO's sake, should be limited to ECHOConfig, whereas information that pertains to the inner CH should be put in the HTTPSSVC. We'll work with @bemasc to get this text in shape!",
          "createdAt": "2020-04-27T21:53:53Z",
          "updatedAt": "2020-04-27T21:54:08Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #226. Closing.",
          "createdAt": "2020-05-07T18:43:47Z",
          "updatedAt": "2020-05-07T18:43:47Z"
        }
      ]
    },
    {
      "number": 217,
      "id": "MDU6SXNzdWU1OTg1MjU2MTY=",
      "title": "ECHOConfigContents.extensions is not needed",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/217",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "draft-06 includes an extensions field in ECHOConfigContents but no extension types are defined. If or when something new is needed it could just as easily be introduced via a new ECHOConfig.version or a new HTTPSSVC tag. The mandatory-to-understand design wit a \"critical\" bit was also used in X.509 and has not clearly worked as planned there. I don't see why that would differ here. Expecting implementers to include all the code required for generic extension handling and introducing new failure modes via critical bits, all for no concrete reason... seems wrong. I suggest we just delete the extensions field entirely. If needed, one can be added back via a new version later. \r\n\r\nBearing in mind the target for this draft is an experimental RFC, and so there's a reasonable likelihood of changes when/if we try promote ECHO to a standards-track RFC, we also don't need to be quite as future proof as normal, so deleting this field for now is not that risky.",
      "createdAt": "2020-04-12T16:50:26Z",
      "updatedAt": "2020-04-27T21:55:36Z",
      "closedAt": "2020-04-27T21:55:36Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't agree with this proposed change.\r\n\r\n1.  Extensions for TLS have proved very useful.\r\n2. The analogy to X.509 seems false. Criticality has a different context here and IMO it works fine for (say) STUN.\r\n\r\nIntroducing a new version has all kinds of other annoyances.\r\n\r\nAs for the experimental bit, that seems like an oversight. I expected this to be PS and I'm not sure why the draft has a different tag. I expect I just screwed up when I wrote the first draft. I note the adoption call doesn't say one way or the other. As a practical matter, we expect this to have widespread deployment.\r\n \r\n",
          "createdAt": "2020-04-24T14:36:47Z",
          "updatedAt": "2020-04-24T14:36:47Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "As per the call today, we're closing this due to (a) the potential need for an extension to deliver padding hints in the future and (b) the benefits extensibility brought TLS in the past. ",
          "createdAt": "2020-04-27T21:55:36Z",
          "updatedAt": "2020-04-27T21:55:36Z"
        }
      ]
    },
    {
      "number": 218,
      "id": "MDU6SXNzdWU1OTg1NTY3MDI=",
      "title": "Use HPKE codepoints for all HPKE-relevant operations",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/218",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "HPKE has it's own cipher suite code points, as well as the KEM id. I don't see why we're using TLS codepoints (ECHOConfigContents.suites and ClientEncryptedCH.suite) and yet also use one HPKE code point (ECHOConfigContents.kem_id). But maybe I'm missing something?\r\n\r\nIf not, I think one of two things would make sense:\r\n\r\n1. Change HPKE to use TLS code points. (That could be done but'd involve a bit of nose-holding, however it might be better in the longer term.)\r\n2. Only use HPKE code points in ECHO - I don't see that TLS ciphersuites are actually needed for ECHO, so this seems easiest. (That'd mean s/suite/aead_id/g I guess.)\r\n",
      "createdAt": "2020-04-12T19:39:49Z",
      "updatedAt": "2020-05-02T01:36:23Z",
      "closedAt": "2020-05-02T01:36:23Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I tend to agree with Stephen here. ISTM that probably (1) is better, actually.",
          "createdAt": "2020-04-24T14:39:36Z",
          "updatedAt": "2020-04-24T14:39:36Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think we want HPKE to depend on TLS code points. Algorithms that come down the pipe may not be suitable for TLS. I'd prefer option (2).",
          "createdAt": "2020-04-24T15:06:48Z",
          "updatedAt": "2020-04-24T15:06:48Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "NONE",
          "body": "There's also a third option here:\r\n\r\n3. Use TLS code points (or something else) and define a mapping to HPKE code points\r\n\r\nLike @chris-wood, I am disinclined to tie HPKE to TLS, since it is a more general tool.\r\n\r\nIt seems like the answer here depends on what the negotiation in ECHO is being used for.  If it's just for the HPKE, use HPKE code points.  If it's used in TLS further down the line, use TLS code points and map to HPKE for the HPKE bits.",
          "createdAt": "2020-04-24T15:22:48Z",
          "updatedAt": "2020-04-24T15:22:48Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "How is (3) different than the current design?",
          "createdAt": "2020-04-26T20:51:52Z",
          "updatedAt": "2020-04-26T20:51:52Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Per the call today, we'll use this issue to track moving everything to HPKE codepoints. (We can remove the mapping table at the same time).",
          "createdAt": "2020-04-27T21:54:43Z",
          "updatedAt": "2020-04-27T21:54:43Z"
        }
      ]
    },
    {
      "number": 219,
      "id": "MDU6SXNzdWU1OTg1NjU3NTU=",
      "title": "cardinality of ECHOConfig vs. HTTPSSVC",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/219",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "A server can publish multuple HTTPSSVC RRs. Each of those RRs can contain multiple ECHOConfigContent values (i.e. multiple public keys and public_names). I don't see a real need for two different ways to publish more than one public key for a given server. There is a minor efficiency benefit in terms of the number of octets published in the DNS, but there is a lot of additional complexity in terms of code, and if nobody really publishes multiple public keys in one RR value, then that code is likely where we'll find CVEs. Reducing down to one public key per RR value also reduces the complexity when writing code to create/publish RRs.\r\n\r\nI think we have to support multiple RR values, because that's how the DNS works, and so the one to drop is the multiple public keys in one ECHOConfigs. IOW, I'd suggest one ECHOConfig has exactly one public key.\r\n ",
      "createdAt": "2020-04-12T20:32:56Z",
      "updatedAt": "2020-04-27T21:52:40Z",
      "closedAt": "2020-04-27T21:52:40Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "A single ECHOConfig already has only one public key from https://github.com/tlswg/draft-ietf-tls-esni/pull/201 and the HPKE bits.\r\n\r\nI'm guessing you meant ECHOConfigs? There are multiple ECHOConfig values in a single ECHOConfigs, which came from https://github.com/tlswg/draft-ietf-tls-esni/pull/200. (Gosh, that was a terrible name. My bad. Maybe we should rename it?) I think the rationale there still holds? The problem is that an HTTPSSVC RR implies transport-level decisions, while not every ECHOConfig can be consumed by your TLS logic. Folding them together means transport connect needs to be aware of the exact ECHO capabilities. For instance, the origin could advertise:\r\n\r\n* route1.example.com echo=ECHOv1\r\n* route2.example.com echo=ECHOv2\r\n\r\nThe logic picking HTTPSSVC routes no longer gets a free choice. It must be aware of the TLS layer's capabilities (down to mandatory extensions and HPKE code points). ECHOConfigs means the expectation is:\r\n\r\n* route1.example.com echo={ECHOv1,ECHOv2}\r\n* route2.example.com echo={ECHOv2,ECHOv2}\r\n\r\nNow you pick a route freely and pass the entire opaque ECHO blob to TLS to interpret. Of course, one could still advertise:\r\n\r\n* route1.example.com echo={ECHOv1}\r\n* route2.example.com echo={ECHOv2}\r\n\r\nBut you're no longer forced to explode it out like that, so we can say an ECHOv1-only client that happens to pick route2 can act as if route1 didn't exist. I.e. we set an expectation that all your routes must be equally capable. (Just as we have that expectation elsewhere. If route1 only speaks TLS 1.0, you're not getting TLS's downgrade protection because the attacker can always redirect you to the less secure config.)",
          "createdAt": "2020-04-13T16:03:22Z",
          "updatedAt": "2020-04-13T16:03:22Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 13/04/2020 17:03, David Benjamin wrote:\n> \n> But you're no longer forced to explode it out like that, so we can \n> say an ECHOv1-only client that happens to pick route2 can act as if \n> route1 didn't exist. I.e. we set an expectation that all your routes \n> must be equally capable. (Just as we have that expectation \n> elsewhere.\n\nGotta admit I'm not at all getting what you're saying,\nsorry. As-is, clients need to write the code to handle\nmultiple keys (and all other variations possible) at\nboth levels, or if not, then we're missing text in the\nspec saying what doesn't need to be supported.\n\nI don't see a real benefit in that complexity.\n",
          "createdAt": "2020-04-13T19:35:35Z",
          "updatedAt": "2020-04-13T19:35:35Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "As per today's call, we're closing this due to the simplifications it brings for client implementations, in particular around collating all logic about ECHOConfig compatibility inside the TLS stack without the need for additional interfaces.",
          "createdAt": "2020-04-27T21:52:40Z",
          "updatedAt": "2020-04-27T21:52:40Z"
        }
      ]
    },
    {
      "number": 220,
      "id": "MDU6SXNzdWU1OTg1Njc0Nzc=",
      "title": "two type codes needed for interop",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/220",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We need to pick some values for the \"encrypted_client_hello(TBD)\" and for the HTTPSSVC RR type before we can do interop. Allocating some values from the private ranges for those before draft-07 is pushed out would be good so we can do some interop testing. (Or for whatever is the next draft for which we want to do interop.)",
      "createdAt": "2020-04-12T20:43:00Z",
      "updatedAt": "2020-05-27T21:48:52Z",
      "closedAt": "2020-05-27T21:48:52Z",
      "comments": []
    },
    {
      "number": 223,
      "id": "MDU6SXNzdWU2MDY0MDExNjE=",
      "title": "Restrict ECHO inner/outer variance for interop purposes",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/223",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "First, I do think the security analysis for ECHO ought consider that the inner can be entirely different from the outer. That does not mean that we need to make full use of that flexibility when considering interop.\r\n\r\nIn the ECHO coding I've done so far, handling more restricted variation between inner and outer is a lot simpler, code-wise, and I would expect, will make interop easier and more successful. It seems (at least with OpenSSL) that once the cryptographic parameters (e.g. key shares) are allowed to vary between inner and outer, then things get significantly more complex. (That's not only down to\r\nthe trial decryption on the client btw, but is clearly demonstrated by the need for trial decryption.)\r\n\r\nI suggest we consider, for now, restricting how the inner and outer can vary, for example, only requiring implementations be able to handle minimal variation, perhaps only with server name and alpn and the nonce and ECHO that have to differ.\r\n\r\nIf, having coded this up, people figure it is actually  easy enough to support more flexibility then we could change to require support for that later. I think we should be able to decide before WGLC or IETF LC but don't believe we can currently be confident that full flexibility would be a good interop choice.\r\n ",
      "createdAt": "2020-04-24T15:32:49Z",
      "updatedAt": "2020-04-27T21:51:17Z",
      "closedAt": "2020-04-27T21:51:17Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "You need trial decryption on the client no matter what, because the transcript will be different, so that's not relevant here.\r\n\r\nI am not in favor of restricting how the inner and outer can vary. This is precisely the kind of thing that implementations might then get wrong by assuming and then we have problems.\r\n\r\nIt seems to me that your primary argument here is implementation difficulty, plus some speculation about interop. I don't anticipate any difficulty implementing this in NSS based on my experience with HRR, and it seems like we'll find out whether there are interop difficulties soon enough, so adding restrictions is premature.\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2020-04-24T16:47:23Z",
          "updatedAt": "2020-04-24T16:47:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Per the call today, we're closing this for now. We may revisit this later on if more implementation experience from the WG leads folks towards a restrictions on inner/outer variance.",
          "createdAt": "2020-04-27T21:51:17Z",
          "updatedAt": "2020-04-27T21:51:17Z"
        }
      ]
    },
    {
      "number": 229,
      "id": "MDU6SXNzdWU2MTEyODgwNDU=",
      "title": "Describe HRR cut-and-paste 1 in Security Considerations.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/229",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "<img width=\"909\" alt=\"Screen Shot 2020-05-02 at 3 33 05 PM\" src=\"https://user-images.githubusercontent.com/2172048/80893782-3fae8980-8c8a-11ea-8bca-cb5fc1e33685.png\">\r\n",
      "createdAt": "2020-05-02T22:33:24Z",
      "updatedAt": "2020-05-21T13:08:20Z",
      "closedAt": "2020-05-21T13:08:19Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed in #234.",
          "createdAt": "2020-05-21T13:08:19Z",
          "updatedAt": "2020-05-21T13:08:19Z"
        }
      ]
    },
    {
      "number": 232,
      "id": "MDU6SXNzdWU2MTQzMjI5ODM=",
      "title": "Bikeshed: finalize on naming of \"ECHO\"",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/232",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "While cutsy, the name \"ECHO\" for \"Encrypted Client Hello\" seems like it could cause problems and significant confusion.  To those not actively involved in the working group, \"ECHO\" has very different connotations.  Some potential risks include:\r\n* Other IETF standards have some form of \"ECHO\" functionality.  When bouncing this question off someone else, they responded with \"TLS ECHO, like ICMP ECHO, except totally not\"\r\n* The immediate guess people may have on hearing about a TLS ECHO functionality would be to think \"oh, like to echo back a message for heartbeat purposes?\".  Given the potential risk for confusion with heartbeat (especially given \"Heartbleed\") this has some risk of giving TLS ECHO a bad rap from the start due to confusion.\r\n* This functionality is going to have high profile with product managers and perhaps even government regulators and public policy.  Applying a name that has confusing lay-connotations is going to muddle conversations.\r\n* This has a risk of confusion when used in other contexts.  For example, \"echoconfig\" as a SVCB parameter key has potential risk for confusing people reading the config and lacking context.\r\n* ECHO is going to be harder to do searches for, both in Internet and intranet search engines.\r\n\r\nJust calling it \"ECH\" or \"EHELLO\" may be safer?\r\n\r\n(If this changes, SVCB will also need to change the \"echoconfig\".)",
      "createdAt": "2020-05-07T20:27:33Z",
      "updatedAt": "2020-05-21T19:49:50Z",
      "closedAt": "2020-05-21T19:49:50Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "NONE",
          "body": "One reason for \"EHELLO\" is that if we support Split Mode with the ClientHelloInner being TLS 1.2 then it also provides protection for the ServerHello as well.",
          "createdAt": "2020-05-07T20:31:28Z",
          "updatedAt": "2020-05-07T20:31:28Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ETCH",
          "createdAt": "2020-05-07T21:46:15Z",
          "updatedAt": "2020-05-07T21:46:15Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "NONE",
          "body": "ETCH == \"Encrypted TLS Client Hello\"?    (That also sounds like a fine option.)",
          "createdAt": "2020-05-07T21:47:52Z",
          "updatedAt": "2020-05-07T21:47:52Z"
        }
      ]
    },
    {
      "number": 233,
      "id": "MDU6SXNzdWU2MTUzNDQ4NDk=",
      "title": "Trial decryption after HelloRetryRequest",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/233",
      "state": "CLOSED",
      "author": "ocheron",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In a normal ECHO handshake with HelloRetryRequest there are 4 ClientHellos sent: ClientHelloOuter1, ClientHelloInner1, ClientHelloOuter2, ClientHelloInner2.\r\n\r\nEncryption of ClientHelloInner2 is bound to echo_hrr_key so the server must have the ECHOConfig used for ClientHelloInner1 in order to process ECHO the second time.\r\nAnd by the time the client receives encrypted handshake traffic it is not useful to signal if ClientHelloInner1 was successfully decrypted, what matters is to know if ECHO is globally successful or not.\r\n\r\nSo one aspect that I find not explained enough is whether the server replying with HRR should use ClientHelloInner1 in the transcript, or instead always takes ClientHelloOuter1 (data on the wire) regardless of the first decryption status. The ECHO status accept/reject can be conveyed based on distinction ClientHello2 inner/outer only.\r\n\r\nThis point impacts the number of transcripts the client may have to try, i.e. can be sure the combination (ClientHelloInner1, ClientHelloOuter2) is never valid.",
      "createdAt": "2020-05-10T08:39:16Z",
      "updatedAt": "2020-11-19T00:10:06Z",
      "closedAt": "2020-11-19T00:10:06Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi @ocheron, the spec has changed quite a bit since this question was first posed. In particular, we've landed #287, which changes the server behavior so that it provides an explicit signal of ECH acceptance in its SH. Hence, no more trial decryption. I'm wondering if your question still applies?\r\n\r\nI believe what to do in case of HRR is well-specified at this point. There is no such ECH accdeptance signal provided in the HRR, so to determine if ECH was accepted, the client must wait until the SH. Until that point, the client needs to compute two transcripts in parallel: one assuming the ClientHelloOuter was used, and another assuming the ClientHelloInner was used.",
          "createdAt": "2020-09-23T18:39:53Z",
          "updatedAt": "2020-09-23T18:39:53Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think #287 resolves this. If the client has different HRR-relevant preferences (key share and cipher suite) between CHInner and CHOuter, I believe HRR is still a mess because the HRR message doesn't contain a signal for whether ECH was accepted. Though I suppose it is a little less complex now that you don't need to go as far as trial decrypting. Different HRR-relevant preferences means the HRR may be good for one ClientHello but not the other, yet the client needs to manage that state and defer the actual error-handling to when ECH acceptance is known. An option where the HRR message included an ECH acceptance signal would close this, but then we have sticking out woes.\r\n\r\nThe draft touches on this, but somewhat vaguely.\r\nhttps://tlswg.org/draft-ietf-tls-esni/draft-ietf-tls-esni.html#section-6.3.3-1\r\n\r\nWe've been intending that our implementation would always match inner and outer preferences for HRR-sensitive fields, to avoid this case. But having this odd complexity cliff hidden in the spec is poor. I'd advocate we either require or at least strongly recommend clients do this.",
          "createdAt": "2020-09-23T19:02:49Z",
          "updatedAt": "2020-09-23T19:02:49Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "#308 suggests to add the following text to the HRR section: \r\n\r\n> It is an error for the client to offer ECH before the HelloRetryRequest but not\r\nafter. Likewise, it is an error for the client to offer ECH after the\r\nHelloRetryRequest but not before. If the client-facing server accepts ECH for\r\nthe first ClientHello but not the second, or it accepts ECH for the second\r\nClientHello but not the first, then it MUST abort the handshake with an\r\n\"illegal_parameter\" alert.\r\n\r\nI think this solves the problem, at least partially. It ensures that the HRR path aligns with ECH acceptance/rejection.",
          "createdAt": "2020-09-23T19:41:55Z",
          "updatedAt": "2020-09-23T19:43:01Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "That doesn't address the problem. This is about complexity for the client, not the server. Yes, the server needs to enforce consistency between the two modes, but it is easy for it to do this.\r\n\r\nImagine you're the client and your CHOuter has:\r\n* key_shares = {X25519}\r\n* supported_groups = {X25519, P-256, P-384}\r\n* cipher_suites = {TLS_AES_128_GCM_SHA256, TLS_AES_256_GCM_SHA384}\r\n\r\nAnd your CHInner has:\r\n* key_shares = {P-256}\r\n* supported_groups = {X25519, P-256, P-384}\r\n* cipher_suites = {TLS_AES_256_GCM_SHA384, TLS_CHACHA20_POLY1305_SHA256}\r\n\r\nNow consider how you have to respond to each of these HRRs. Remember that at the time you process the HRR, you *don't know if ECH was accepted*.\r\n1. cipher_suite = TLS_AES_256_GCM_SHA384; key_share = P-384\r\n2. cipher_suite = TLS_AES_128_CCM_SHA256; key_share = P-521\r\n3. cipher_suite = TLS_CHACHA20_POLY1305_SHA256; key_share = X25519\r\n4. cipher_suite = TLS_AES_128_GCM_SHA256; key_share = P-256\r\n5. cipher_suite = TLS_CHACHA20_POLY1305_SHA256; key_share = X25519\r\n\r\n1 is valid for both ClientHellos. This is the easy case and you can compute new CHInner and CHOuter values.\r\n2 is valid for neither ClientHello. If you can detect this, you can error immediately.\r\n3 is valid for neither ClientHello, but for messy reasons. The key share is valid for CHOuter but the cipher suite is not. The cipher suite is valid for CHInner but the key share is not. (Recall that a key share in HRR is allowed if it is in CH.supported_groups and *not* CH.key_shares. If it were in CH.key_shares, you shouldn't have sent HRR.)\r\n4 is valid for only CHOuter, so you can't error. It is not possible to compute a CHInner, so I guess you drop the extension? But you still need to make a note to raise an error later if you see SH which claims it did accept ECH.\r\n5 is valid for only CHInner, so you can't error. It is not possible to compute a CHOuter, but you have to, so I guess you send something garbage? But you still need to make a note to raise an error if you see SH which claims it rejected ECH.\r\n\r\nThis is a huge mess. The client can avoid this mess by always matching key_shares, supported_groups, and cipher_suites between CHInner and CHOuter. That means it can process HRR without knowing which CH to use. It is not obvious in the spec that you should do this, and the spec allows you to not do this.",
          "createdAt": "2020-09-23T20:17:14Z",
          "updatedAt": "2020-09-23T20:17:14Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I see, I wasn't thinking about client complexity. Thanks for laying out the various edge cases. I would favor being stricter about how the key_shares, supported_groups, and cipher_suites are chosen. At the very least, we should guide implementations towards ensuring they are the same in the CHInner and CHOuter.\r\n\r\nAn alternative would be to add an ECH signal to HRR. We can't do the same trick we did with the SH.random, as this would stick out. But maybe there's another way? I thought of using HRR.session_id, but that could get messy.",
          "createdAt": "2020-09-23T21:09:05Z",
          "updatedAt": "2020-09-23T21:11:13Z"
        },
        {
          "author": "ocheron",
          "authorAssociation": "NONE",
          "body": "> I'm wondering if your question still applies?\r\n\r\nI think there is still ambiguity in the design about what CH is used by the client-facing server in its own transcript when forwarding CHInner to the backend server. Or else the combination (ECH accepted before HRR, ECH rejected after HRR) can be explicitly forbidden, but I don't see why/how.",
          "createdAt": "2020-09-29T17:31:06Z",
          "updatedAt": "2020-09-29T17:31:06Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Or else the combination (ECH accepted before HRR, ECH rejected after HRR) can be explicitly forbidden, but I don't see why/how.\r\n\r\nIncidentally, this is addressed by https://github.com/tlswg/draft-ietf-tls-esni/pull/311. This adds the following to client-facing server behavior: \r\n\r\n> It is an error for the client to offer ECH before the HelloRetryRequest but not\r\nafter. Likewise, it is an error for the client to offer ECH after the\r\nHelloRetryRequest but not before. If either of these conditions occurs, then the\r\nclient-facing server MUST abort the handshake with an \"illegal_parameter\" alert.\r\n\r\nIt's not hard for the client-facing server to enforce this. It just needs to remember if an HRR was triggered and whether ECH was offered in in the first CH.",
          "createdAt": "2020-09-29T17:38:44Z",
          "updatedAt": "2020-09-29T17:38:44Z"
        },
        {
          "author": "ocheron",
          "authorAssociation": "NONE",
          "body": "Ok that will do it.\r\nAssuming \"ECH not offered\" is same as \"ECH not accepted\", due to greasing.",
          "createdAt": "2020-10-01T04:40:29Z",
          "updatedAt": "2020-10-01T04:40:29Z"
        }
      ]
    },
    {
      "number": 237,
      "id": "MDU6SXNzdWU2MjI5MTg3NDM=",
      "title": "Remove 1.3 from the title",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/237",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The design can apply to TLS 1.4 and beyond (presumably).",
      "createdAt": "2020-05-22T03:12:25Z",
      "updatedAt": "2020-05-26T21:19:26Z",
      "closedAt": "2020-05-26T21:19:25Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Done in #238.",
          "createdAt": "2020-05-26T21:19:25Z",
          "updatedAt": "2020-05-26T21:19:25Z"
        }
      ]
    },
    {
      "number": 240,
      "id": "MDU6SXNzdWU2MjYwNTczMTU=",
      "title": "Consider strict ECH mode",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/240",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From a TODO in the draft:\r\n\r\nKey replacement is significantly less scary than saying that ECH-naive servers bounce ECH off. Is it worth defining a strict mode toggle in the ECH keys, for a deployment to indicate it is ready for that?\r\n\r\ncc @davidben ",
      "createdAt": "2020-05-27T21:51:02Z",
      "updatedAt": "2020-06-17T18:40:14Z",
      "closedAt": "2020-06-17T18:40:14Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I imagine clients that talk to general HTTPS servers like browsers wouldn't do this, but maybe more dedicated clients would? I work on a browser and don't know much about those kinds of use cases, so I figured I'd leave it as a TODO in case the WG felt strongly one way or another.",
          "createdAt": "2020-05-28T16:02:56Z",
          "updatedAt": "2020-05-28T16:02:56Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Given that no one asked for this, I'm inclined to close this without action. So... doing that now. :)",
          "createdAt": "2020-06-17T18:40:14Z",
          "updatedAt": "2020-06-17T18:40:14Z"
        }
      ]
    },
    {
      "number": 245,
      "id": "MDU6SXNzdWU2NDAzMTIxNjk=",
      "title": "Describe risks and mitigations for privacy leaks from configuration digest",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/245",
      "state": "CLOSED",
      "author": "sharpie7",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The ID proposes an optional configuration digest parameter to be included in the clientHello. This parameter is advantageous because it improves the efficiency of the solution by avoiding the server having to do trial decryptions. However, in some scenarios the configuration digest could leak privacy information. In version 7 of the ID, section 10.2 on \u201cClient Tracking\u201d describes one scenario, but there are others. A more complete and general discussion of the risks and mitigations would be useful.\r\n\r\nIf a particular domain has a unique public key then the configuration digest becomes a fingerprint for that domain. An attacker that has a list of such domains that they want to monitor can build a dictionary of the corresponding digests use this to identify traffic to the domains on their list.\r\n\r\nSome mitigations could be:\r\n1)\tAvoid the use of configuration digest\r\n2)\tOnly deploy in a mode where many domains share the same public key to make finger-printing too general to be useful\r\n3)\tTo change keys faster than attackers can update their list of fingerprints\r\n",
      "createdAt": "2020-06-17T10:02:52Z",
      "updatedAt": "2020-06-18T02:50:27Z",
      "closedAt": "2020-06-18T02:50:27Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This should be addressed by #247. Please re-open (and suggest text edits!) if you think otherwise.",
          "createdAt": "2020-06-18T02:50:26Z",
          "updatedAt": "2020-06-18T02:50:26Z"
        }
      ]
    },
    {
      "number": 248,
      "id": "MDU6SXNzdWU2NDEzNzgyNTg=",
      "title": "Decryption failure guidance could be more detailed for trial decryption",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/248",
      "state": "CLOSED",
      "author": "raycoll",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hello,\r\n\r\nIn section 8, there is a description of two approaches to match an ECHConfig with the ClientEncryptedCH:\r\n\r\n```\r\nThis matching procedure should be done using one of the following two checks:\r\n1. Compare ClientEncryptedCH.record_digest against cryptographic hashes of known ECHConfig and choose the one that matches.\r\n2. Use trial decryption of ClientEncryptedCH.encrypted_ch with known ECHConfig and choose the one that succeeds.\r\n```\r\n\r\nAnd later, we have guidance on what the server should do if decryption fails:\r\n\r\n```\r\nIf decryption fails, the server MUST abort the connection with a \"decrypt_error\" alert.\r\n```\r\n\r\nThis guidance makes sense to me for a server that is using record_digest matching to select an ECHConfig. If decryption fails using the matching record_digest, we must abort. However, I think it could be more clear for the trial decryption case, which is expected to have failed decryption attempt(s). \r\n\r\nI think something like this could be more clear:\r\n\r\n```\r\nIf record_digest matching is used and decryption fails using the matching ECHConfig, the server MUST abort the connection with a \"decrypt_error\" alert.\r\n```\r\n",
      "createdAt": "2020-06-18T16:42:35Z",
      "updatedAt": "2020-06-25T23:52:03Z",
      "closedAt": "2020-06-25T23:51:01Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is clarified above in that section. Namely, for trial decryption, we say that the record_digest does not \"match\" the ClientHello if there's no key which successfully decrypts the ClientHello. In this case, the server ignores the ECH extension and proceeds as specified. A \"match\" in the trial decryption case therefore implies that a key successfully decrypts the ClientHello, so the text referenced (\"If decryption fails...\") does not apply. ",
          "createdAt": "2020-06-25T23:45:20Z",
          "updatedAt": "2020-06-25T23:49:06Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I also feel like this is clear.",
          "createdAt": "2020-06-25T23:51:01Z",
          "updatedAt": "2020-06-25T23:51:01Z"
        },
        {
          "author": "raycoll",
          "authorAssociation": "NONE",
          "body": "On reread, that makes sense. Thanks!",
          "createdAt": "2020-06-25T23:52:03Z",
          "updatedAt": "2020-06-25T23:52:03Z"
        }
      ]
    },
    {
      "number": 251,
      "id": "MDU6SXNzdWU2NzAwMTgzMDY=",
      "title": "Common supported KEM",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/251",
      "state": "CLOSED",
      "author": "FredericJacobs",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "needs WG discussion"
      ],
      "body": "It might make sense to have a default KEM that all implementations would need to support for each ECH version.\r\n\r\nThis would prevent clients to have to support all KEMs at the risk of falling back to plaintext because they don't support the server-supported KEM.\r\n",
      "createdAt": "2020-07-31T17:01:52Z",
      "updatedAt": "2020-09-22T21:11:30Z",
      "closedAt": "2020-09-22T21:11:30Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "As Chris Patton says, we should also specify an AEAD and KDF. These should be AES-GCM and HMAC-SHA256.",
          "createdAt": "2020-09-21T15:53:18Z",
          "updatedAt": "2020-09-21T15:53:18Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "From the interim: HPKE(x25519, AES-128-GCM, SHA-256)",
          "createdAt": "2020-09-21T15:53:54Z",
          "updatedAt": "2020-09-21T15:53:54Z"
        }
      ]
    },
    {
      "number": 252,
      "id": "MDU6SXNzdWU2NzMxNjc5OTI=",
      "title": "Avoid padding cliff",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/252",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Section 7.2 says\r\n> 1. If L > D, add L - D bytes of padding. This rounds to the server's advertised hint, i.e., ECHConfig.maximum_name_length.\r\n> 2. Otherwise, add 32 - (D % 32) bytes of padding. This rounds D up to the nearest multiple of 32 bytes.\r\n\r\nThis has some problems:\r\n\r\n1. If L == D, or D > L and D % 32 == 0, this results in unnecessary padding.\r\n2. If L == D == 31, there is no length protection.  The output is 32, and that is the only length that produces that output.\r\n\r\nThe easiest solution is to replace \"32 - (D % 32)\" with \"(L - D) & 0x1f\".  This pads up to the nearest L + 32*n.\r\n\r\nIf it's considered important to pad to a multiple of 32, I would suggest ensuring that the initial bucket is at least 32, e.g. \r\n\r\n> 1. If L >= D, add L - D bytes of padding. This rounds to the server's advertised hint, i.e., ECHConfig.maximum_name_length.\r\n> 2. Otherwise, add 31 - ((D - 1) % 32) bytes of padding, plus an additional 32 bytes if L > 0 and D < L + 31 - ((L - 1) % 32)",
      "createdAt": "2020-08-05T00:34:55Z",
      "updatedAt": "2020-08-30T15:37:22Z",
      "closedAt": "2020-08-30T15:37:22Z",
      "comments": []
    },
    {
      "number": 253,
      "id": "MDU6SXNzdWU2NzMyMDYxMTQ=",
      "title": "Nonce rationale clarity",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/253",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "needs WG discussion"
      ],
      "body": "There are several rationales provided about the need for `ech_nonce`:\r\n\r\n1. This nonce ensures that the server's encrypted Certificate can only be read by the entity which sent this ClientHello.\r\n2. Since servers process either ClientHelloInner or ClientHelloOuter, and ClientHelloInner contains an HPKE-derived nonce, it is not possible for an attacker to \"cut and paste\" the ECH value in a different Client Hello and learn information from ClientHelloInner. This is because the attacker lacks access to the HPKE-derived nonce used to derive the handshake secrets.\r\n3. Client Reaction Attack Mitigation ... The \"ech_nonce\" extension in the inner ClientHello prevents this attack. In particular, since the attacker does not have access to this value, it cannot produce the right transcript and handshake keys needed for encrypting the Certificate message. Thus, the client will fail to decrypt the Certificate and abort the connection.\r\n\r\nThese rationales are all subtly different, and having read them all, I still don't understand why the nonce is necessary, when the server_handshake_traffic_secret already depends on the inner client random, which is not known to the attacker.\r\n\r\nI would appreciate some more explanation on this point.  It also might make sense to move these rationales up into the ech_nonce section, or add forward references to them there.",
      "createdAt": "2020-08-05T02:33:20Z",
      "updatedAt": "2020-09-22T21:10:51Z",
      "closedAt": "2020-09-22T21:10:50Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that the rationale isn't clear from the description. This needs to be cleaned up. However, it does seem to prevent a real attack (see Sec. 10.8.1).",
          "createdAt": "2020-08-12T22:35:04Z",
          "updatedAt": "2020-08-12T22:35:04Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@cjpatton As I noted above, the server_handshake_traffic_secret already depends on the inner client random, which is not known to the attacker.  It therefore seems to me that the attacker therefore cannot produce a Certificate message that the client will decrypt, even without the nonce.  If that's true, I don't see how the attack in Sec. 10.8.1 is possible.",
          "createdAt": "2020-08-13T00:35:54Z",
          "updatedAt": "2020-08-13T00:35:54Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What if the inner CH.random is the same as the outer CH.random? This is currently allowed by the spec, i.e., there's no guidance on \"copying\" extensions from the outer CH to the inner.",
          "createdAt": "2020-08-13T16:03:35Z",
          "updatedAt": "2020-08-13T16:03:35Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's an interesting question that I think the spec should probably address.  I assumed they could not be the same, because they are both required to be random.  If they _can_ be the same, I would suggest making them always the same, and remove the inner one to save 32 bytes and simplify the analysis.",
          "createdAt": "2020-08-13T16:48:42Z",
          "updatedAt": "2020-08-13T16:48:42Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The semantics of copying outer CH extensions into inner CH needs to be clarified: see also https://github.com/tlswg/draft-ietf-tls-esni/issues/262. To my read, the intent is that any extension MAY be copied, bit-by-bit, into the inner CH.",
          "createdAt": "2020-08-13T17:04:48Z",
          "updatedAt": "2020-08-13T17:04:48Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The client random is a fixed field of the ClientHello, not an extension.",
          "createdAt": "2020-08-13T17:33:52Z",
          "updatedAt": "2020-08-13T17:33:52Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> If they can be the same, I would suggest making them always the same, and remove the inner one to save 32 bytes and simplify the analysis.\r\n\r\nHmm, I'm not really a fan of this (and bit shaving in general). The idea is to make the inner CH as close to a full CH as possible, so keeping the same encoding makes most sense to me. \r\n\r\nThat said, even if they are random, there may be cases where the attacker can predict the randomness generated. ",
          "createdAt": "2020-08-13T18:05:45Z",
          "updatedAt": "2020-08-13T18:05:45Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I think an attacker that can predict a random value generated by the TLS stack has much more exciting avenues of attack here. (E.g. the client's key share is lost.) Though it is a good point that they are slightly different: the ECH nonce is exported from the HPKE context while the client random is simply random. I forget if that ends up being important anywhere.",
          "createdAt": "2020-08-13T18:08:28Z",
          "updatedAt": "2020-08-13T18:08:28Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The client random is a fixed field of the ClientHello, not an extension.\r\n\r\nAh you're right. Thanks!",
          "createdAt": "2020-08-13T18:12:14Z",
          "updatedAt": "2020-08-13T18:12:22Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Exactly -- even if an attacker knew the client's key share, random value, etc, it *might* not know the ECH nonce (without access to the sever's private key), depending on the KEM used. (If DHKEM was used, it would know the client's ephemeral private key, so the point is moot.) \r\n\r\nAll that said, we *may* be able to remove it. But I'm hesitant to do so without backing analysis.",
          "createdAt": "2020-08-13T18:13:01Z",
          "updatedAt": "2020-08-13T18:13:01Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> If DHKEM was used, it would know the client's ephemeral private key, so the point is moot.\r\n\r\nI think this is true for any KEM. If your KEM looks more like public key encryption, the attacker would instead know the shared secret the client generated. More generally, if we assume the client is incapable of generating random numbers, the attacker can simply run through the client's implementation of SetupBaseS, replacing all non-determinism with the predicted random number. It will then end up with the same HPKE context.",
          "createdAt": "2020-08-13T18:16:07Z",
          "updatedAt": "2020-08-13T18:16:07Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think this is true for any KEM. If your KEM looks more like public key encryption, the attacker would instead know the shared secret the client generated. More generally, if we assume the client is incapable of generating random numbers, the attacker can simply run through the client's implementation of SetupBaseS, replacing all non-determinism with the predicted random number. It will then end up with the same HPKE context.\r\n\r\nThat's true! ",
          "createdAt": "2020-08-13T18:18:48Z",
          "updatedAt": "2020-08-13T18:18:48Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "RFC 8446 Appendix C.1 says \"Implementations can provide extra security against [broken RNG] attack by using separate CSPRNGs to generate public and private values.\".  If that's the motivation for the nonce, I think the spec should mention it.",
          "createdAt": "2020-08-13T19:12:31Z",
          "updatedAt": "2020-08-13T19:12:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "For what it's worth, the [formal model](https://github.com/chris-wood/reftls/blob/esni/pv/tls13_echo_noninterf_factored.pv) checks out after removing \"ech_nonce.\" ",
          "createdAt": "2020-08-21T16:18:50Z",
          "updatedAt": "2020-08-21T16:18:50Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is the current proposal for removing \"ech_nonce\" and clarifying behavior around choosing the ClientHelloInner.random: https://github.com/tlswg/draft-ietf-tls-esni/pull/292",
          "createdAt": "2020-09-03T17:29:36Z",
          "updatedAt": "2020-09-03T17:29:36Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing now that #292 landed.",
          "createdAt": "2020-09-22T21:10:50Z",
          "updatedAt": "2020-09-22T21:10:50Z"
        }
      ]
    },
    {
      "number": 260,
      "id": "MDU6SXNzdWU2NzgwMTAxMDY=",
      "title": "Need a high-level description of the security goal in the intro",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/260",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "In just a few sentences, let's define the anonymity set and say what it means for connections to end points in this set to be indistignuishable. We might also enumerate non-goals (though we still need consensus on what these are).\r\n",
      "createdAt": "2020-08-12T22:11:36Z",
      "updatedAt": "2020-09-22T21:25:43Z",
      "closedAt": "2020-09-22T21:25:43Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I've not yet gotten around to the PR yet, but here's the gist:\r\n\r\nAttackers:\r\n- Passive attackers are those which cannot probe, e.g., buggy middleboxes that filter based on plaintext packet contents.\r\n- Active attackers can probe, e.g., censors. \r\n\r\nGoals:\r\n- ECH does not negatively affect any existing security properties of TLS 1.3.\r\n- ECH connections to servers in the same anonymity set are indistinguishable from one another for passive and active attackers, modulo traffic analysis. (Note: an anonymity set is determined by the client and server parameters, e.g., the SNI, supported application protocols, and so on.)\r\n- ECH support is secret from passive attackers who don't know the ECH configuration, but not active attackers. \r\n- ECH usage is secret from passive attackers who don't know the ECH configuration, but not active attackers. More specifically:\r\n  - Passive attackers with a known ECH configuration can distinguish between a connection that negotiates ECH with that configuration and one which does not (GREASEd or using a different configuration).\r\n  - Passive attackers without the ECH configuration cannot distinguish between a connection that negotiates ECH and one which does not (but GREASEd).\r\n  - Active attackers can distinguish between a connection that negotiates ECH and one which does not (but GREASEd).\r\n\r\n",
          "createdAt": "2020-09-21T11:58:03Z",
          "updatedAt": "2020-09-21T15:17:07Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah this looks good.",
          "createdAt": "2020-09-21T15:12:58Z",
          "updatedAt": "2020-09-21T15:12:58Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "From the interim: merge this as a PR and then address censorship separately (if desired).",
          "createdAt": "2020-09-21T15:36:56Z",
          "updatedAt": "2020-09-21T15:36:56Z"
        }
      ]
    },
    {
      "number": 261,
      "id": "MDU6SXNzdWU2NzgwMTM2ODc=",
      "title": "Spec assumes HPKE uses HKDF",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/261",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "From Section 6.1:\r\n\r\n```\r\n   When sending ClientHello, the client first computes ClientHelloInner,\r\n   including any PSK binders, and then MAY substitute extensions which\r\n   it knows will be duplicated in ClientHelloOuter.  To do so, the\r\n   client computes a hash H of the entire ClientHelloInner message with\r\n   the same hash as for the KDF used to encrypt ClienHelloInner.  Then,\r\n   the client removes and and replaces extensions from ClientHelloInner\r\n   with a single \"outer_extensions\" extension.  The list of\r\n   outer_extensions include those which were removed from\r\n   ClientHelloInner, in the order in which they were removed.  The hash\r\n   contains the full ClientHelloInner hash H computed above.\r\n```\r\n\r\nThis assumes that the KDF specifies some underlying hash function. From the HPKE spec, it seems like all that's required of the KDF is that it's an \"extract-then-expand\" KDF:\r\nhttps://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hpke-05#section-4\r\n\r\nIn fact, the currently assigned code points are all for HKDF:\r\nhttps://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hpke-05#section-7.2\r\n\r\nBut there's no requirement that the KDF always have some underlying hash function. As an alternative to HKDF, one can imagine a dedicated primitive that satisfies the extract-then-expand API but is not constructed from a hash function.",
      "createdAt": "2020-08-12T22:20:25Z",
      "updatedAt": "2020-08-26T12:46:54Z",
      "closedAt": "2020-08-26T12:46:54Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Impacted fields:\r\n- ClientEncryptedCH.record_digest\r\n- OuterExtensions.hash",
          "createdAt": "2020-08-13T16:54:51Z",
          "updatedAt": "2020-08-13T16:54:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "We can probably replace `Hash` with `Extract` and be done with it. ",
          "createdAt": "2020-08-13T18:03:29Z",
          "updatedAt": "2020-08-13T18:03:29Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Putting on my theorist hat, I'd say that the extract function is a \"randomness extractor\" and not a collision resistant hash function. We want the latter in this context. From a practical stand point, using the extract function is more hashing than we need.\r\n\r\nI'd suggest doing away with `OuterExtensions.hash` (see #263) and figuring something else out for `ClientEncryptedCH.record_digest`. Could we simply require HKDF be used with HPKE?",
          "createdAt": "2020-08-13T18:09:59Z",
          "updatedAt": "2020-08-13T18:09:59Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Sure, but in practice randomness extractors use a collision resistant hash or PRF (CBC) under the hood. \r\n\r\nI don't think we can require HKDF for HPKE. That seems too restrictive. We might just say that ECH requires HKDF-based HPKE ciphersuites, as HKDF is already paramount for TLS 1.3, and then just reference HKDF's hash function. ",
          "createdAt": "2020-08-13T18:17:41Z",
          "updatedAt": "2020-08-13T18:17:41Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "#271 addresses this issue.",
          "createdAt": "2020-08-17T20:09:40Z",
          "updatedAt": "2020-08-17T20:09:40Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As I mentioned on the list, we can use the KDF in place of a hash.",
          "createdAt": "2020-08-17T23:06:09Z",
          "updatedAt": "2020-08-17T23:06:09Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I tend to agree. I'll create a new PR.",
          "createdAt": "2020-08-17T23:09:45Z",
          "updatedAt": "2020-08-17T23:09:45Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Have a look at #276, @martinthomson!",
          "createdAt": "2020-08-17T23:44:39Z",
          "updatedAt": "2020-08-17T23:44:39Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Resolved in #276. Closing.",
          "createdAt": "2020-08-26T12:46:53Z",
          "updatedAt": "2020-08-26T12:46:53Z"
        }
      ]
    },
    {
      "number": 262,
      "id": "MDU6SXNzdWU2NzgwMTcwMTI=",
      "title": "\"outer_extensions\" mechanism is lossy compression",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/262",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "needs WG discussion",
        "ready-for-text"
      ],
      "body": "Say we want the outer CH to have extensions a and b. Let's write this as\r\n```\r\n  ClientHelloOuter = [a, b]\r\n```\r\nSay the inner CH should have extensions a, b, c, and d. But b is really big, so we want a shallow copy it. Then we write the compressed inner CH as\r\n```\r\n   ClientHelloInner = [a, c, d, outer_extensions = [ shallow_copy_of_b ]]\r\n```\r\nThe decompressed ClientHelloInner should be `[a, b, c, d]`, but using `outer_extensions` destroys the intended order.\r\n\r\n",
      "createdAt": "2020-08-12T22:28:26Z",
      "updatedAt": "2020-10-14T23:30:50Z",
      "closedAt": "2020-10-14T23:30:50Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Extension order in TLS isn't meaningful, so I think that's fine, provided the code producing the inner ClientHello and the code encoding it get to coordinate. (I.e. a client that says \"I don't care about secrecy of `key_share` and will send the same one on both sides\" can probably live with `key_share` being at the end.)\r\n\r\nThere have been cases where extension order has interop impacts due to server bugs. (E.g. the last extension needs to be non-empty to avoid a bug in some old servers.) But those old servers wouldn't see inner ClientHellos anyway.",
          "createdAt": "2020-08-13T17:53:30Z",
          "updatedAt": "2020-08-13T17:53:30Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think maybe a concern is that the client and server wind up using extension lists with different orders, for whatever reasons, thereby yielding different transcripts. Wouldn't that be an issue?",
          "createdAt": "2020-08-13T18:02:57Z",
          "updatedAt": "2020-08-13T18:02:57Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Right, hence \"provided the code producing the inner ClientHello and the code encoding it get to coordinate\". If compression is done with inner + outer ClientHello being produced by the same thing, the client can simply take this into account and always put referenced extensions at the end. If it's a proxying picture, where the client does not know it is doing ECH (is that even possible? I suspect the ech_nonce would be an issue), that may not work.",
          "createdAt": "2020-08-13T18:11:23Z",
          "updatedAt": "2020-08-13T18:11:43Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Right. I don't expect the latter (proxy case) to be common, though perhaps modifying this to prevent misuse might be useful.",
          "createdAt": "2020-08-13T18:14:25Z",
          "updatedAt": "2020-08-13T18:14:25Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This make me worry about interoperability. For a client and server to speak to eachother they need to adopt the same convention that is not specified anywhere, but only evident when you look at existing implementations. My vote would be to modify compression so that extension order is preserved.",
          "createdAt": "2020-08-13T18:16:03Z",
          "updatedAt": "2020-08-13T18:19:45Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "It is certainly necessary that the decompression function produces a deterministic ClientHello, down to what goes into the transcript. I think section 6.1 does that. That's a different criteria from requiring that every possible input ClientHello be efficiently compressible.",
          "createdAt": "2020-08-13T18:21:41Z",
          "updatedAt": "2020-08-13T18:21:41Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't compare about it being \"efficiently\" compressible, but I see your point about the transcript being the same. Just to clarify, my concern is in Section 6.1: \r\n\r\n> Then,\r\n   the client removes and and replaces extensions from ClientHelloInner\r\n   with a single \"outer_extensions\" extension.  The list of\r\n   outer_extensions include those which were removed from\r\n   ClientHelloInner, in the order in which they were removed.\r\n\r\nI interpret this as the following procedure:\r\n```python\r\n   outer_extensions = OuterExtensions()\r\n   for extension in client_hello_inner.extensions:\r\n      if extension in client_hello_outer.extensions and too_big(extension.get_payload()):\r\n          outer_extensions.append(extension.get_type())\r\n          client_hello_inner.remove(extension)\r\n   client_hello_inner.extensions.append(outer_extensions)\r\n```\r\nIs it clear what I mean here? Do we agree that, in general, this procedure doesn't preserve the order of extensions?\r\n\r\nMy concern had to do with servers being ossified around the order of extensions. If this isn't a problem, then I guess we're good here. It's worth flagging this, however (from RFC 8446): \r\n\r\n>    When multiple extensions of different types are present, the\r\n   extensions MAY appear in any order, with the exception of\r\n   \"pre_shared_key\" (Section 4.2.11) which MUST be the last extension in\r\n   the ClientHello (but can appear anywhere in the ServerHello\r\n   extensions block).\r\n\r\nAn order-preserving alternative would be something like this:\r\n```python\r\n   # compress\r\n   for extension in client_hello_inner.extensions:\r\n      if extension in client_hello_outer.extensions and too_big(extension.get_payload()):\r\n          extension.drop_payload() # Send extension with empty payload.\r\n   \r\n   # decompress\r\n   for inner in client_hello_inner.extensions:\r\n       if inner.get_payload() == None\r\n            for outer in client_hello_outer.extensions:\r\n                 if outer.get_type() == inner.get_type():\r\n                      inner.set_payload(outer.get_payload())\r\n```\r\nThis would have the added benefit of not needing to define an additional extension point.",
          "createdAt": "2020-08-13T19:39:31Z",
          "updatedAt": "2020-08-13T19:59:45Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "The alternative doesn't quite work because extensions can legitimately be empty, so it's ambiguous whether you meant to explicitly encode an empty extension or reference the outer one. For example, the old TLS 1.2 `session_ticket` extension was empty to signal \"I support tickets but am not sending one\" and a non-empty string to send a ticket.\r\n\r\nThat's a good point though. The compression algorithm in 6.1 breaks if the removed extensions are non-contiguous, so it should either include that requirement, or we come up with a different goofy encoding. :-)",
          "createdAt": "2020-08-13T20:23:17Z",
          "updatedAt": "2020-08-13T20:23:17Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, good point. I would be fine with adding the requirement, though it might be worth trying to come up with something more general.",
          "createdAt": "2020-08-13T20:45:33Z",
          "updatedAt": "2020-08-13T20:45:33Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "One possible replacement paragraph:\r\n\r\n> When sending ClientHello, the client MAY substitute extensions which it knows will be duplicated in ClientHelloOuter. To do so, the client arranges the duplicate extensions contiguously in the extension list when computing ClientHelloInner, including any PSK binders. The client then computes a hash of the entire ClientHelloInner message with the same hash as for the KDF used to encrypt ClientHelloInner. Finally, the client removes and replaces extensions from ClientHelloInner with a single \"outer_extensions\" extension. The list of outer_extensions include those which were removed from ClientHelloInner, in the order in which they were removed. The hash contains the full ClientHelloInner hash computed above.\r\n\r\n(I'm also fine with replacing with a more general encoding.)",
          "createdAt": "2020-08-13T21:01:47Z",
          "updatedAt": "2020-08-13T21:01:47Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We should also require that the \"outer_extensions\" extension appears where the contiguous extensions were. For example,  to compress `b` and `c`, we encode `[a, b, c, d]` as `[a, outer_extensions = [b_shallow_copy, c_shallow_copy], d]`. Otherwise the \"outer_extensions\" MAY appear somewhere else.\r\n",
          "createdAt": "2020-08-13T21:09:49Z",
          "updatedAt": "2020-08-13T21:20:45Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In fact, that leads to a more general encoding.\r\n```python\r\n# encode (i.e., compress)\r\nencoded_client_hello_inner = ClientHelloInner()\r\nouter_extensions = OuterExtensions()\r\nfor inner in client_hello_inner.extensions:\r\n    if inner in client_hello_outer.extensions and too_big(inner): # processing contiguous compressed extensions\r\n        outer_extensions.append(inner.get_type())\r\n    else:\r\n        if not outer_extensions.empty(): # end of contiguous compressed extensions \r\n            encoded_client_hello_inner.append(outer_extensions)\r\n            outer_extensions = OuterExtensions()\r\n        encoded_client_hello_inner.append(inner)\r\nif not outer_extensions.empty():\r\n    encoded_client_hello_inner.append(outer_extensions) \r\n```\r\nI guess the problem with this is that we can have multiple \"outer_extension\" extensions in the inner CH, so we would still need to ensure there is just one contiguous block. Or we can say \"screw it\" and decide that **the encoded form of** ClientHelloInner need not be a well-formed ClientHello.",
          "createdAt": "2020-08-13T21:10:12Z",
          "updatedAt": "2020-08-13T22:00:47Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The proposed change is here: #293.\r\n\r\nAs @ekr suggested in the interim meeting, before changing this mechanism, we should look at real ClientHellos to see what we would actually want to compress.",
          "createdAt": "2020-09-03T18:07:38Z",
          "updatedAt": "2020-09-03T18:07:38Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "My inclination is also that the contiguous constraint is probably fine, though we have played games with extension ordering before with the PSK extension. Although I would actually anticipate compressing most extensions, and just ordering things to match. Most of them aren't sensitive and, assuming you're already compressing one extension, even an empty extension would cost just four bytes uncompressed and two bytes compressed.",
          "createdAt": "2020-09-03T18:25:31Z",
          "updatedAt": "2020-09-03T18:25:31Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm pretty happy with the state of things. I'm closing this issue.",
          "createdAt": "2020-10-14T23:30:49Z",
          "updatedAt": "2020-10-14T23:30:49Z"
        }
      ]
    },
    {
      "number": 263,
      "id": "MDU6SXNzdWU2Nzg2Mjc5OTk=",
      "title": "\"outer_extensions\": What's the purpose of the hash?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/263",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "question",
        "needs WG discussion"
      ],
      "body": "Field `OuterExtensions.hash` is computed as \"digest of the complete ClientHelloInner\" (including presumably, the \"outer_extensions\" extension). I don't understand the analytical value of this hash. Can anyone explain its reasoning?",
      "createdAt": "2020-08-13T17:50:29Z",
      "updatedAt": "2020-09-23T18:53:32Z",
      "closedAt": "2020-09-23T18:53:32Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "The hash is intended to prevent the attacker from influencing the reconstructed CHInner by manipulating CHOuter. Consider the contrived example of an extension which is separately protected but only works for SNI-A and not SNI-B. E.g., it's constructed by doing E(K_sni, SNI). If that extension were included in CHOuter and then imported into CHInner via this mechanism, then an attacker could substitute it and use a reaction attack to determine whether the CH referred to A or B.\r\n\r\nHowever, with the hash (which may be not well-specified), this attack gets caught by the client-facing server and the handshake is rejected without leaking information.\r\n",
          "createdAt": "2020-09-03T14:28:56Z",
          "updatedAt": "2020-09-03T14:28:56Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My initial understanding of this mechanism was incorrect. What happens is that the hash is computed over the ClientHelloInner that is consumed by the backend server. This is intended to ensure that if ECH accepts, then the backend server consumes the CH intended by the client. (PR https://github.com/tlswg/draft-ietf-tls-esni/pull/293 makes this more clear, I think.)\r\n\r\nI wonder if this mechanism is redundant. Agreement on the CH between the client and backend server is provided by the binding of the transcript hash to the handshake traffic secret, so any attempt to manipulate the ClientHelloInner by fiddling with the ClientHelloOuter should be detected. On the other hand, the binding of the outer extensions to ClientHelloInner ensures agreement on the CH *prior to the backend server consuming it*. This is a strictly stronger property, which may or may not be useful.\r\n\r\n> Consider the contrived example of an extension which is separately protected but only works for SNI-A and not SNI-B.\r\n\r\nI agree that the attack works, but the example seems *really* contrived :) I'd be interested if there are more natural extensions for which this extra layer of security would be useful.",
          "createdAt": "2020-09-03T15:14:17Z",
          "updatedAt": "2020-09-03T15:14:17Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "From the interim meeting, the consensus seems to be that we should err on the conservative side.",
          "createdAt": "2020-09-03T17:44:47Z",
          "updatedAt": "2020-09-03T17:44:47Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Let's close this issue and leave the mechanism as is.",
          "createdAt": "2020-09-03T18:05:39Z",
          "updatedAt": "2020-09-03T18:05:39Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hrm, before closing I think it might be worth noting, in the spec, the stronger security property this provides.",
          "createdAt": "2020-09-03T19:10:12Z",
          "updatedAt": "2020-09-03T19:10:12Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we should also consider binding the CHInner to a hash of the whole CHOuter (minus the ClientEncryptedCH extension).  That would have the same size overhead, but would give us a stronger property: modifying anything in CHOuter (not just one of the copied extensions) invalidates the whole thing.",
          "createdAt": "2020-09-03T20:56:14Z",
          "updatedAt": "2020-09-03T20:56:14Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The point of hashing outer extensions is to provide integrity of the ClientHelloInner. What would be the point in hashing more of the ClientHelloOuter? (Not a rhetorical question :) It seems conceptually different, and I'm curious what the security benefit might be.)",
          "createdAt": "2020-09-03T21:01:05Z",
          "updatedAt": "2020-09-03T21:01:05Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "If we authenticate the ClientHelloOuter, we'd be authenticating all the inputs that go into the ClientHelloInner, so I think that would also provide integrity. I expect Ben is suggesting this in the context of https://github.com/tlswg/draft-ietf-tls-esni/pull/287#issuecomment-686746358, where GREASE can additionally be made a little stronger if we did that. Getting that to interact well with any PSK binders in ClientHelloOuter is tricky though, unless we decide to ban resumption attempts in outer ClientHellos.\r\n\r\n(Probably best to keep the GREASE-related conversation in one place. Though I see I didn't help on that front because some discussion is also in #274. Ah, GitHub.)",
          "createdAt": "2020-09-03T21:10:57Z",
          "updatedAt": "2020-09-03T21:10:57Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yep, I'm just echoing @davidben's observation. See also https://github.com/tlswg/draft-ietf-tls-esni/issues/274#issuecomment-686768299.",
          "createdAt": "2020-09-03T21:17:37Z",
          "updatedAt": "2020-09-03T21:17:37Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> If we authenticate the ClientHelloOuter, we'd be authenticating all the inputs that go into the ClientHelloInner, so I think that would also provide integrity.\r\n\r\nToday, the only thing that gets copied into ClientHelloInner is extensions, so I don't see how it's an improvement in terms of our primary security goal. (Not sure about the \"don't stick out\" benefit.)",
          "createdAt": "2020-09-03T23:01:01Z",
          "updatedAt": "2020-09-03T23:01:01Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't understand how hashing all of CHOuter is going to work. In split\nmode, the server never sees any of CHOuter.\n\nOn Thu, Sep 3, 2020 at 4:01 PM Christopher Patton <notifications@github.com>\nwrote:\n\n> If we authenticate the ClientHelloOuter, we'd be authenticating all the\n> inputs that go into the ClientHelloInner, so I think that would also\n> provide integrity.\n>\n> Today, the only thing that gets copied into ClientHelloInner is\n> extensions, so I don't see how it's an improvement in terms of our primary\n> security goal. (Not sure about the \"don't stick out\" benefit.)\n>\n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/issues/263#issuecomment-686806030>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAIPLIPUBDXMNJRDMQ3CZZTSEAN33ANCNFSM4P6WBVHQ>\n> .\n>\n",
          "createdAt": "2020-09-04T15:07:14Z",
          "updatedAt": "2020-09-04T15:07:14Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, the hash would be checked when reconstructing the inner ClientHello (as here), and would not be present in the reconstructed ClientHello.",
          "createdAt": "2020-09-04T15:43:15Z",
          "updatedAt": "2020-09-04T15:43:15Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There's not much discussion here. Unless there's objection, shall we leave the mechanism as-is and close out this issue? cc/ @chris-wood ",
          "createdAt": "2020-09-23T18:41:39Z",
          "updatedAt": "2020-09-23T18:41:39Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Works for me.",
          "createdAt": "2020-09-23T18:46:44Z",
          "updatedAt": "2020-09-23T18:46:44Z"
        }
      ]
    },
    {
      "number": 264,
      "id": "MDU6SXNzdWU2Nzg2MzUxMzg=",
      "title": "Handshake-level vs record-level padding",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/264",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "design",
        "parked"
      ],
      "body": "ECH currently uses two different kinds of padding. The encrypted ClientHello is padded with the padding extension, while the server response is padded with TLS 1.3 record layer padding.\r\nhttps://datatracker.ietf.org/doc/html/draft-ietf-tls-esni-07#section-7.1\r\nhttps://datatracker.ietf.org/doc/html/draft-ietf-tls-esni-07#section-7.2\r\n\r\nUsing record-level padding in TLS over TCP is relatively straightforward as it\u2019s ordered. However DTLS and QUIC have their own record layers, with retransmission logic. Properly hiding some length then requires that packet loss and retransmission logic track and retransmit padding as if it were integrated into the byte stream.\r\n\r\nIn the case of QUIC, when a QUIC packet is determined to be lost, it is not retransmitted whole; instead information carried in the frames in lost packets might be sent again in new frames (draft-ietf-quic-transport, section 13.3). That same section states that PADDING frames do not need to be retransmitted. If ECH in QUIC relies on QUIC transport layer padding, that would need to be changed, and implementations would need to track how much adding is associated with CRYPTO frame data for retransmission.\r\n\r\nQUIC additionally needs the padding size communicated across API boundaries between the TLS and QUIC implementations. It\u2019s likely that everyone\u2019s first pass at the API will omit this, only to need to add an extra parameter (API change) later when they implement ECH.\r\n\r\nThis seems a somewhat general issue between padding at reliably- and unreliably-transmitted layers of the stack. HTTP/3 has something analogous (though carried in slightly frames). That draft actually discusses two options for padding and calls out the relation to packet loss:\r\n\r\n> Where HTTP/2 employs PADDING frames and Padding fields in other frames to make a connection more resistant to traffic analysis, HTTP/3 can either rely on transport-layer padding or employ the reserved frame and stream types discussed in Section 7.2.8 and Section 6.2.3. These methods of padding produce different results in terms of the granularity of padding, how padding is arranged in relation to the information that is being protected, whether padding is applied in the case of packet loss, and how an implementation might control padding. Redundant padding could even be counterproductive.\r\n\r\nhttps://quicwg.org/base-drafts/draft-ietf-quic-http.html#name-padding-and-traffic-analysi\r\n\r\nShould we match that precedent and move the padding into the handshake itself? That would make it apply to DTLS and QUIC transparently. If we do, a couple possibilities to start with:\r\n\r\n* Say that ECH implementations must tolerate unsolicited padding extensions and inject those into various messages. This is a goofy around messages without extensions (CertificateVerify), or messages with multiple extension blocks (Certificate), but as long as there is an extension block _somewhere_ in each padded flight, it's probably possible to fudge it.\r\n* Say that ECH adds a new kind of Padding handshake message, which the sender can incorporate into the handshake as needed, and the receiver ignores.\r\n\r\nIf we leave ECH as-is, it seems to me QUIC (both spec and implementations) needs some changes to track padding across retransmission.",
      "createdAt": "2020-08-13T18:03:12Z",
      "updatedAt": "2023-11-06T08:54:21Z",
      "closedAt": "2023-11-06T08:54:21Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "(2) seems simplest and most useful to me. The receiver path is trivial, and avoiding per-message semantics for adding padding (or not, if the extension isn't supported) seems easier. (This would also let clients move inner CH padding from an extension to a message, which might simplify padding calculations in the case where binders are used? That is, it can pad a fully-formed CH, rather than only part of a CH.)",
          "createdAt": "2020-08-13T18:25:20Z",
          "updatedAt": "2020-08-13T18:25:20Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The alternative is to tell the QUIC stack to pad, in the same way that TLS is told to pad.  This is more complicated in QUIC, because you have to respect packet boundaries and ensure that you include ack-eliciting frames in packets that might other contain only padding, but it is doable.\r\n\r\nThis is not by any means perfect, but it matches the signals in TLS.  The handshake tells the record layer: \"pad to X\".",
          "createdAt": "2020-08-14T01:23:01Z",
          "updatedAt": "2020-08-14T01:23:01Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "My +1 goes to padding at the handshake message level.\r\n\r\nPadding at the record layer (or QUIC packet layer) is going to require more work and have more security concerns, as the transport needs to pad retransmissions.\r\n\r\nAs an example, when a handshake message that requires padding is split into multiple packets, and one of the packets gets lost, the transport has to figure out what to send and how to pad. In case of QUIC, we also have to make sure that PING frame would be used when the only thing that has to be retransmitted is padding, because not sending an ack-eliciting packet would reveal to a passive observer that it was padding only.",
          "createdAt": "2020-08-14T01:29:05Z",
          "updatedAt": "2020-08-14T01:29:05Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "An alternative to a Padding message is to use the existing padding extension (in Certificate or EncryptedExtensions or both) to ensure that the overall message is the right size.  That accomplishes the goal, but it does require that the client be willing to send it, or we create a new exception to the rules for extensions.  You could, I guess, add the padding to the ECH extension.\r\n\r\nNew messages cost more (than I'd like).",
          "createdAt": "2020-08-14T04:48:12Z",
          "updatedAt": "2020-08-14T04:48:12Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I just realized a nuisance with the extensions option: certificate extensions are incompatible with draft-ietf-tls-certificate-compression, which is [important for QUIC](https://www.fastly.com/blog/quic-handshake-tls-compression-certificates-extension-study). The extension compresses the entire Certificate message, so any padding messages inside the payload would get compressed away.\r\n\r\nWe could still fudge this by computing how much padding would be needed ahead of time and then adjusting the padding in EncryptedExtensions (same flight and all), but this is getting pretty silly. :-)\r\n\r\nAn aside since this comes up alot: ECH and certificate compression are perfectly compatible. Rather than padding up to `max(len(cert) for cert in anonymity_set)`, you pad the compressed cert up to `max(len(compress(cert)) for cert in anonymity_set)`. The key observation is that, assuming compression support is uniform across the anonymity set, *whether* you compressed is not sensitive, only *what* you compressed.\r\n\r\n> New messages cost more (than I'd like).\r\n\r\nHuh, I'd actually seen the extension as more annoying, since we'd need to add quirks to the unsolicited extensions rule. Is the issue for you all the state machine integration or something else? (I was envisioning we'd just have the handshake message logic silently drop all the padding messages on the ground so the handshake state machine doesn't notice.)",
          "createdAt": "2020-08-14T16:03:01Z",
          "updatedAt": "2020-08-14T16:03:01Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": "I would really like the QUIC padding to be independent of any TLS padding. The TLS RFC tries to keep the handshake and record layers separate -- heck, it even calls them protocols :). We're just starting to think about the next version of NTP-Security, and using *just* the handshake would likely be helpful there.\r\n\r\nNo matter what happens, I think draft-ietf-quic-tls will need an update to cover this issue.",
          "createdAt": "2020-08-21T13:55:54Z",
          "updatedAt": "2020-08-21T13:55:54Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": "As an implementation detail: right now Akamai uses a port of the boringSSL QUIC patches. They are pretty cleanly layered on top of OpenSSL and getting entangled deeper into other parts of the OpenSSL code will be an issue. @sftcd is working on an ECH implementation and we would like to keep that clean separation as well.\r\n\r\nNeither of these efforts will be part of OpenSSL 3.0, which many people will want because it will be FIPS validated. They will also want QUIC and ECH, which means they will have to be added in as separate patches. Mixing up the layers, then, will make that harder and slow down adoption. I'm writing this as a separate comment to separate the protocol from the deployment issues. :)",
          "createdAt": "2020-08-21T14:02:31Z",
          "updatedAt": "2020-08-21T14:02:31Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "From the interim meeting, it seems folks are not enthusiastic about doing padding in the record layer. We still need a proposal for doing padding in the handshake.",
          "createdAt": "2020-09-03T17:38:18Z",
          "updatedAt": "2020-09-03T17:38:18Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "As I was saying on the call, what I propose is:\r\n\r\n1. The client pads with the RFC 7685 padding extension in CHInner\r\n2. The server pads in EE with RFC 7685 padding\r\n\r\nWe would then relax the restriction on servers sending padding in 7685 Section 3 but not the restriction on unsolicited extensions.\r\n\r\nThere is a minor inconvenience here in that you would be required to compute the amount of padding needed before sending EE (because it appears prior to Certificate).\r\n",
          "createdAt": "2020-09-03T17:45:23Z",
          "updatedAt": "2020-09-03T17:45:23Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "(Oof, I got confused by time zones and thought the call was much later in the day.)\r\n\r\nPrecomputing the padding in EE would probably work, if a bit obnoxious to implement on the sender's side. It also doesn't allow padding the client certificate, if the client wishes to hide some information on that end.",
          "createdAt": "2020-09-03T18:17:22Z",
          "updatedAt": "2020-09-03T18:17:22Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> It also doesn't allow padding the client certificate, if the client wishes to hide some information on that end.\r\n\r\nYeah, I'd like there to be a mechanism for supporting this on the client side. Something that only works for one end doesn't seem like the best solution here.",
          "createdAt": "2020-09-03T20:53:51Z",
          "updatedAt": "2020-09-03T20:53:51Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed that it doesn't allow padding the client cert, however, this issue already exists in TLS 1.3 w/o ECH. My proposal for that would be the dual of this: include the padding extension in CR and then pad in CERT.",
          "createdAt": "2020-09-04T15:05:19Z",
          "updatedAt": "2020-09-04T15:05:19Z"
        },
        {
          "author": "kaduk",
          "authorAssociation": "NONE",
          "body": "> Agreed that it doesn't allow padding the client cert, however, this issue already exists in TLS 1.3 w/o ECH. My proposal for that would be the dual of this: include the padding extension in CR and then pad in CERT.\r\n\r\nJust to check my understanding: this is predicated on fixing the interaction of CERT and compression w.r.t. preserving padding, right?",
          "createdAt": "2020-09-15T16:48:37Z",
          "updatedAt": "2020-09-15T16:48:37Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "(@vasilvv FYI.) Certificate compression already got a code point allocated June 2018 and went through WGLC April 2019. That code point's shipped for some time now. So if we're to change anything there, we'd at minimum need to burn the old code point and get a new one.\r\n\r\n(I'm not opposed to doing that if it's the right path forward. Just wanted to make sure folks were aware of the complication.)\r\n\r\nWhat fix are folks envisioning?",
          "createdAt": "2020-09-15T19:25:55Z",
          "updatedAt": "2020-09-15T19:25:55Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "From the interim: stick with EE for padding, and address the client-side padding issue separately (as a change to ALPS or a new handshake message type).",
          "createdAt": "2020-09-21T15:42:48Z",
          "updatedAt": "2020-09-21T15:42:48Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi issue, I'm working on a PR for server-side padding (using EE) now. Will post a link once it's ready.",
          "createdAt": "2020-09-30T15:15:33Z",
          "updatedAt": "2020-09-30T15:15:33Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Two questions.\r\n1. RFC 7685 only specifies the usage of the padding extension in the ClientHello. Will ECH need to update the IANA registry to allow the extension to appear in EncryptedExtensions?\r\n1. RFC 7685 mandates that the server MUST NOT echo the extension. We need to amend this rule here. What's the best way to do so? A couple options:\r\n          (a) \"The server MAY echo the padding extension in its EncryptedExtensions message.\"\r\n          (b) \"The server MAY send an [unsolicited] padding extension in its EncryptedExtensions message.\"\r\n          (c) Define a new codepoint for server-side padding, which MAY be solicited by the client.",
          "createdAt": "2020-09-30T15:22:53Z",
          "updatedAt": "2020-09-30T15:25:36Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> RFC 7685 only specifies the usage of the padding extension in the ClientHello. Will ECH need to update the IANA registry to allow the extension to appear in EncryptedExtensions?\r\n\r\nI think yes.\r\n\r\n> RFC 7685 mandates that the server MUST NOT echo the extension. We need to amend this rule here. What's the best way to do so? A couple options:\r\n\r\n(a) or (b) on their own won't work. Today's clients already send the padding extension and expect that the server will not echo the extension, per the existing definition. Any phrasing must preserve that server MUST NOT for existing ClientHellos. So I think our options are (c), which is to define a whole new padding extension, or:\r\n\r\n(d) Use the same code point as before, but bodge it by saying the server is allowed to send it in EncryptedExtensions if encrypted_client_hello shows up in the ClientHello.\r\n\r\nWhat we need is something to distinguish a client which knows about the new rules and doesn't.",
          "createdAt": "2020-09-30T15:30:15Z",
          "updatedAt": "2020-09-30T15:30:15Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For (d) I'm not sure what to do about this (RFC8446, 4.3.1): \r\n>    The EncryptedExtensions message contains extensions that can be\r\n   protected, i.e., any which are not needed to establish the\r\n   cryptographic context but which are not associated with individual\r\n   certificates.  The client MUST check EncryptedExtensions for the\r\n   presence of any forbidden extensions and if any are found MUST abort\r\n   the handshake with an \"illegal_parameter\" alert.\r\n\r\nRegardless of whether the client knows the new rule, the presence of the extension causes an abort, no? I guess the question is: what's a \"forbidden extension\"? cc/ @ekr ",
          "createdAt": "2020-09-30T15:35:07Z",
          "updatedAt": "2020-09-30T15:47:44Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Note that the standard Go implementation (crypto/tls) does not appear to enforce this \"MUST\": see `readServerParameters()` in https://golang.org/src/crypto/tls/handshake_client_tls13.go.",
          "createdAt": "2020-09-30T15:43:02Z",
          "updatedAt": "2020-09-30T15:43:02Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "BoringSSL does. But yes (d) would contradict the no unsolicited extensions rule and would need some text to undo it (as is already done for the cookie extension in HRR).\r\n\r\nThe no unsolicited extensions rule is really an approximation of a more subtle rule: the server can only send things in EncryptedExtensions that it knows the client will understand. The client can expect to fully parse the entirety of EncryptedExtensions.\r\n\r\nNo matter how we slice it, this is a change to the wire protocol. Changes to the wire protocol require some flavor of negotiation, so we retain compatibility with existing implementations.",
          "createdAt": "2020-09-30T16:00:48Z",
          "updatedAt": "2020-09-30T16:01:21Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": "I think C makes more sense.  The code changes, let alone the wording changes, for it seem more clean and simple.",
          "createdAt": "2020-09-30T16:04:22Z",
          "updatedAt": "2020-09-30T16:04:22Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I tend to agree with @richsalz, though I think @davidben's idea is very doable. I think the trade off is cleanliness (c) vs not defining a new codepoint (d). I'm not sure what's more important.",
          "createdAt": "2020-09-30T16:05:51Z",
          "updatedAt": "2020-09-30T16:05:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd go for (c). I think code points are (intentionally) cheap, so we might as well use them, especially since it's an extension inside EE (and less likely something a middlebox might already latch onto?).",
          "createdAt": "2020-09-30T16:18:01Z",
          "updatedAt": "2020-09-30T16:19:05Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "(c) SGTM. And yeah I agree it's probably less fuss.\r\n\r\nSince the inner CH should have padding anyway, perhaps the ClientHello extension should not just solicit padding but also just contain padding as before. Then we're effectively dropping ECH's dependency on RFC7685 and moving it to a more general padding extension.",
          "createdAt": "2020-09-30T16:31:52Z",
          "updatedAt": "2020-09-30T16:31:52Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like that idea.",
          "createdAt": "2020-09-30T16:34:33Z",
          "updatedAt": "2020-09-30T16:34:33Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Alrighty,  https://github.com/tlswg/draft-ietf-tls-esni/pull/313 is my attempt to spell (c) with @davidben's suggestion of dropping dependency on RFC7685. I look forward to your feedback.",
          "createdAt": "2020-09-30T18:52:38Z",
          "updatedAt": "2020-09-30T18:52:38Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing per discussion at IETF 118. The concrete proposal here is to define the desired padding mechanism in a separate draft, be it one based on a handshake message, extension, or more details about how to do this at the record layer.",
          "createdAt": "2023-11-06T08:54:21Z",
          "updatedAt": "2023-11-06T08:54:21Z"
        }
      ]
    },
    {
      "number": 265,
      "id": "MDU6SXNzdWU2Nzg2NDk4ODk=",
      "title": "\"outer_extensions\": Guidance on what to compress",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/265",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In Section 6.1:\r\n\r\n> Clients SHOULD only use this mechanism for extensions which are large. All other extensions SHOULD appear in both ClientHelloInner and ClientHelloOuter even if they have identical values. \r\n\r\nif I were implementing this extension, I think the simplest thing would be to compress all copied extensions by default:\r\n1. it's not computationally intensive;\r\n1. it minimizes bandwidth overhead; and\r\n1. it's simpler for future \"big\" extensions, since no code changes would be needed here.\r\n\r\nI suggest removing this guidance.",
      "createdAt": "2020-08-13T18:29:51Z",
      "updatedAt": "2020-08-19T22:40:41Z",
      "closedAt": "2020-08-19T22:40:41Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "#272 addresses this issue.",
          "createdAt": "2020-08-17T20:09:03Z",
          "updatedAt": "2020-08-17T20:09:03Z"
        }
      ]
    },
    {
      "number": 266,
      "id": "MDU6SXNzdWU2Nzg2NTQ0NjM=",
      "title": "Security considerations: SNI leakage vectors",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/266",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Section 7.1 provides a bit of guidance on how ECH might interact with other extensions:\r\n\r\n> The client MUST place the value of ECHConfig.public_name in the ClientHelloOuter\r\n\"server_name\" extension. The ClientHelloOuter MUST NOT contain a \"cached_info\"\r\nextension {{!RFC7924}} with a CachedObject entry whose CachedInformationType is\r\n\"cert\", since this indication would divulge the true server name. The remaining\r\ncontents of the ClientHelloOuter MAY be identical to those in ClientHelloInner\r\nbut MAY also differ.\r\n\r\nI think it's worth expanding on this in \"Security Considerations\". There may be other ways that private CH extensions get leaked, now or in the future.",
      "createdAt": "2020-08-13T18:38:13Z",
      "updatedAt": "2020-08-18T03:55:45Z",
      "closedAt": "2020-08-18T03:55:45Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Now that we've switched to encrypting an entire ClientHello, I think the text wants to say something else anyway: if you want ECH + cached info, you simply include the cached_info extension in the ClientHelloInner, not the ClientHelloOuter. There wouldn't be much point in sending a true name cached_info in ClientHelloOuter since the true server would ignore it. Sending a public name cached_info in ClientHelloOuter is also plausible and also needn't be forbidden (it reveals information about the public name, which is public). It's also probably not that useful since it's just a recovery mechanism, but maybe to avoid sticking out, for clients that normally send it?\r\n\r\nMore generally, anything dependent on the inner name goes in ClientHelloInner and not ClientHelloOuter.",
          "createdAt": "2020-08-13T19:13:21Z",
          "updatedAt": "2020-08-13T19:13:21Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I took a stab at replacement text in https://github.com/tlswg/draft-ietf-tls-esni/pull/270. Thoughts?",
          "createdAt": "2020-08-17T18:55:20Z",
          "updatedAt": "2020-08-17T18:55:20Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm happy with it.",
          "createdAt": "2020-08-17T19:55:39Z",
          "updatedAt": "2020-08-17T19:55:39Z"
        }
      ]
    },
    {
      "number": 267,
      "id": "MDU6SXNzdWU2Nzg2NTgwNTQ=",
      "title": "\"ech_accept\" response type undefined",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/267",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Section 6: \r\n\r\n> Finally, requirements in {{client-behavior}} and {{server-behavior}} require\r\nimplementations to track, alongside each PSK established by a previous\r\nconnection, whether the connection negotiated this extension with the\r\n\"ech_accept\" response type. If so, this is referred to as an \"ECH PSK\".\r\nOtherwise, it is a \"non-ECH PSK\". This may be implemented by adding a new field\r\nto client and server session states.\r\n\r\n\"ech_accept\" is not defined anywhere.\r\n",
      "createdAt": "2020-08-13T18:44:56Z",
      "updatedAt": "2020-09-18T21:31:04Z",
      "closedAt": "2020-09-18T21:31:04Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I suspect \"the connection negotiated this extension with the 'ech_accept' response type\" is an incorrect way of saying that ECH was accepted.",
          "createdAt": "2020-09-01T00:05:40Z",
          "updatedAt": "2020-09-01T00:05:40Z"
        }
      ]
    },
    {
      "number": 274,
      "id": "MDU6SXNzdWU2ODA1MDY2Njk=",
      "title": "Usage indication: alternatives to trial decryption",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/274",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "needs WG discussion"
      ],
      "body": "In the current spec, the server provides no indication of whether the inner or outer ClientHello (CH) was used. This means the client must do trial decryption to make this determination, which creates complexity and potentially raises security concerns. As such, it would be useful to explore possible alternatives. In order to drive the discussion, I'll provide a few simple alternatives below, which we can refine as folks provide feedback. (The current spec, draft-07, is listed as option (0) for comparison.)\r\n\r\nBesides implementation complexity, one of our design considerations is ensuring that middleboxes don't ossify on ECH. As such, indication of ECH usage should \"stick out\" (see [draft-ietf-tls-sni-encryption, Sec 3.4](https://tools.ietf.org/html/draft-ietf-tls-sni-encryption-09#section-3.4)) as little as possible.\r\n\r\nFor our purposes, \"do not stick out\" means a middlebox who observes connections between the client and the client-facing server can't distinguish between real ECH and \"dummy\" ECH (i.e., a \"GREASEd\" extension, as described [Section 7.4](https://tools.ietf.org/html/draft-ietf-tls-esni-07#section-7.4)). We assume the middlebox doesn't know the ECH configuration or the public-facing name. (Note that this rules out adversaries such as the GFW, which can actively probe to discover this information.)\r\n\r\n## Option (0): Do not indicate usage\r\n**Protocol flow:**\r\n* **On input of the client's outer CH.** If the server accepts `ech` (i.e., `encrypted_client_hello`), it uses the inner CH; and if the server rejects or does not support ECH, then it uses the outer CH. It proceeds with the handshake as normal, except that in case of rejection, it sends an `ech` extension in its EE with the updated `ech` configuration.\r\n* **On input of the server's SH, EE, \u2026, Finished.** The client determines whether the inner CH or outer CH was used by computing the decryption key for each scenario and attempting to decrypt EE. It then proceeds with the handshake as usual, updating its `ech` configuration if applicable.\r\n\r\n**Pros**\r\n* Sticks out the least.\r\n* Is the least complex for servers to implement (same for Option (2)).\r\n\r\n**Cons**\r\n* Is the most complex for clients to implement.\r\n\r\n**Spec changes:** None.\r\n\r\n## Option (1): Publicly indicate acceptance\r\n**Protocol flow:**\r\n* **On input of the client's outer CH.** If the server accepts `ech`, it uses the inner CH; and if the server rejects or does not support `ech`, then it uses the outer CH. If the server accepts, then it adds an empty `ech` extension to its SH; if the server rejects, then it adds an `ech` extension to its EE with the updated `ech` configuration; and If the server doesn't support `ech`, then it proceeds as normal.\r\n* **On input of the server's SH, EE, \u2026, Finished.** If the SH has the `ech` extension, then the client proceeds as normal, assuming the inner CH was used; otherwise, the client proceeds as if the outer CH was used, updating its `ech` configuration if applicable.\r\n\r\n**Pros**\r\n* Is the least complex for clients to implement.\r\n\r\n**Cons**\r\n* Breaks Split Mode: the backend server must indicate acceptance in its SH but does not know whether the client-facing server accepted or not. (We could ameliorate this problem by adding an indication of acceptance to the inner CH.)\r\n* Sticks out the most. (See Option (3).)\r\n\r\n**Spec changes:** Semantics of the `ech`  extension changes; changes are needed to accommodate \"Split Mode\".\r\n\r\n## Option (2): Publicly indicate rejection\r\n\r\n**Protocol flow**:\r\n*  **On input of the client's outer CH.** If the server accepts `ech`, it uses the inner CH; and if the server rejects or does not support `ech`, then it uses the outer CH. If the server accepts or does not support `ech`, then it proceeds as usual; and if the server rejects, then it adds an `ech` extension to its SH with the updated `ech` configuration.\r\n*  **On input of the server's SH, EE, \u2026, Finished.** If the SH has the `ech` extension, then the client proceeds as if the outer CH was used and updates its `ech` configuration; otherwise, the client proceeds as if the inner CH was used. Decryption failure indicates either that the server does not support `ech` (i.e., outer CH was used) or the connection is under attack.\r\n\r\n**Pros**\r\n* Is the least complex for the server to implement (same as Option (0)).\r\n\r\n**Cons**\r\n* Sticks out, but only on rejection.\r\n* Complicates deployment: if the client offers `ech` to a server that has turned off support for the extension, then the connection will fail hard, as the client assumes lack of signal means that `ech` was accepted. (We could ameliorate this problem, at the cost of added complexity on the client side implementation.)\r\n\r\n**Spec changes:** Semantics of the `ech` extension changes; `ech` configuration update is sent in the clear. (We could avoid this by sending the new configuration in a new extension in the EE.)\r\n\r\n## Option (3): Privately indicate acceptance\r\nIt may be worth considering an alternative to Option (1) that doesn't stick out as much. Namely, it's possible to make `ech` acceptance in the SH indistinguishable from `ech` rejection.",
      "createdAt": "2020-08-17T20:30:05Z",
      "updatedAt": "2020-09-22T21:10:35Z",
      "closedAt": "2020-09-22T21:10:35Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for writing this up! We've also been pondering this issue in the context of QUIC. In particular, the status quo (option (0)) requires the handshake and record layer coordinate to implement the trial decryption. This would need to happen separately in TLS, DTLS, and QUIC.\r\n\r\nThis is especially a nuisance for QUIC as it will typically cross the TLS library\u2019s public API. TLS must configure two different keys for QUIC, then QUIC must do some trial decryption, and it must report back to TLS which keys were used. Public APIs and changes in them require coordination across groups, so ideally such interfaces stay as simple as possible. As in #264, I think an option that stays entirely in the handshake would apply to QUIC better.",
          "createdAt": "2020-08-17T21:05:29Z",
          "updatedAt": "2020-08-17T21:05:29Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That (option (1) or something like it) would be my preference as well.",
          "createdAt": "2020-08-17T21:25:55Z",
          "updatedAt": "2020-08-17T21:25:55Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would prefer Option 3, or something like it, if trial decryption is not acceptable.  Martin Thomson's proposal from March (placing a signal in ServerHello.random) seems like the logical approach to me.  There were [some concerns](https://mailarchive.ietf.org/arch/msg/tls/tvJx0setNnskI6eCR2Q20kcdy_M/) about an active attack that can distinguish acceptance from rejection, but that's still much better than a cleartext signal.",
          "createdAt": "2020-08-17T21:31:45Z",
          "updatedAt": "2020-08-17T21:31:45Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "To clarify, I think any of (1-3) would avoid the QUIC issues. The deployment concerns of (2) worry me, and the extent to which (1) sticks out makes me a little uncomfortable. I'm interested in exploring option (3).",
          "createdAt": "2020-08-17T21:32:16Z",
          "updatedAt": "2020-08-17T21:32:16Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Here's a suggestion for Option (3), worked out by me and some folks at Cloudflare. (Others might have had a similar idea, I don't mean to take credit!) The indication is a pseudorandom value output by the HPKE state. (If `ech` is not accepted, then a random value is used instead.)\r\n\r\n## Suggestion for Option (3)\r\nLet `context` denote the HPKE state shared by the client and server when `ech` is accepted. Its output can be treated as pseudorandom, e.g., `context.Export(\"tls13-ech-hrr-key', 16)` in Section 7.1 is treated as being indistinguishable from random.\r\n\r\n**Protocol flow:**\r\n* **On input of the client's outer CH.** If the server accepts `ech`, it uses the inner CH; and if the server rejects or does not support `ech`, then it uses the outer CH. If the server accepts, then it adds an `ech` extension to its SH with `context.Export(\"tls13-ech-accept\", 16)` as the value; if the server rejects, then it adds an `ech` extension to its SH with a random, 16-byte string and an \"ech_retry\" extension to its EE with the updated `ech` configuration; if the server does not support `ech`, then it proceeds as normal, but MAY mimic `ech` rejection.\r\n* **On input of the server's SH, EE, \u2026, Finished.** If the SH has the `ech` extension with payload `context.Export(\"tls13-ech-accept\", 16)`, then it proceeds as if the inner CH was used; otherwise it proceeds as if the outer CH was used, updating its `ech` configuration if applicable.\r\n\r\n**Pros**\r\n* Similar to Option (1)\r\n\r\n**Cons**\r\n* Similar to Option (1), but doesn't stick out as much. (It sticks out as much as the CH when dummy `ech` is used as described in Section 7.4.)\r\n\r\n**Spec changes:** Semantics of `ech` extension changes; adds `ech_retry` (i.e., `encrypted_client_hello_retry`) extension.",
          "createdAt": "2020-08-17T21:34:53Z",
          "updatedAt": "2020-08-17T21:41:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "(FWIW, I think the ServerHello.Random trick is due to @davidben or @dvorak42)",
          "createdAt": "2020-08-17T21:38:02Z",
          "updatedAt": "2020-08-17T21:38:02Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Weighing in: my vote goes to something like (3) as a means of not sticking out.",
          "createdAt": "2020-08-17T21:41:02Z",
          "updatedAt": "2020-08-17T21:41:02Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Before I even finished reading the opening post, I was thinking (3), so that seems like an obvious win.  What this does is signals *support* for ECH at a server, but doesn't indicate anything more.  It's an expensive way to signal a single bit, but that's not terrible.\r\n\r\nNote that this can be used to indicate support in-principle without any config, because servers (or stacks) that want to join the crowd can always produce this random string.  That would increase the number of servers that appear to support ECH, at very little cost.",
          "createdAt": "2020-08-17T21:54:38Z",
          "updatedAt": "2020-08-17T21:54:38Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm pleasantly surprised by how much consensus there is for Option (3). (BTW, kudos to the HPKE authors for designing a really nice API!) Does anyone have comments on the suggestion for Option (3) above?",
          "createdAt": "2020-08-17T21:59:15Z",
          "updatedAt": "2020-08-17T21:59:15Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Signalling that the server supports ECH in cleartext seems like a significant loss to me, and I think we can avoid it.  For example, if the first ~8 bytes of ServerHello.random were replaced by a MAC of the rest of the ServerHello, keyed from the HPKE context, that would be a tamperproof signal that the inner ClientHello was used.",
          "createdAt": "2020-08-17T22:14:37Z",
          "updatedAt": "2020-08-17T22:14:37Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Signalling that the server supports ECH in cleartext seems like a significant loss to me, and I think we can avoid it. For example, if the first ~8 bytes of ServerHello.random were replaced by a MAC of the rest of the ServerHello, keyed from the HPKE context, that would be a tamperproof signal that the inner ClientHello was used.\r\n\r\nThis would require security analysis to be sure it's actually safe. \r\n\r\nBut beyond that, what type of adversary are you considering?",
          "createdAt": "2020-08-17T23:00:13Z",
          "updatedAt": "2020-08-17T23:00:13Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Of course, if every stack produced the 16 byte extension in ServerHello, how is that materially different than 8 bytes embedded in ServerHello.random?",
          "createdAt": "2020-08-17T23:29:31Z",
          "updatedAt": "2020-08-17T23:29:31Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Overloading the SH.random this way is likely to violate assumptions made in existing security analyses for TLS 1.3. @bemasc's suggestion might turn out to be OK, but it would be safer to stick this in our own extension. That point notwithstanding, I'm worried about the broader precedent this could set, since overloading the semantics of CH.random and SH.random got us into trouble in earlier versions of TLS.",
          "createdAt": "2020-08-17T23:54:55Z",
          "updatedAt": "2020-08-17T23:55:29Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't know that this is necessarily the case, but unless we need to, avoiding more use of those bits is desirable.  We could run out, and with 32 bytes, that's saying something.",
          "createdAt": "2020-08-17T23:58:47Z",
          "updatedAt": "2020-08-17T23:58:47Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think what's clear is that the SH.random trick requires analysis, whereas the SH extension variant does not. Right?",
          "createdAt": "2020-08-18T00:00:07Z",
          "updatedAt": "2020-08-18T00:00:14Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think they both need analysis, but the SH.random trick is much more invasive and likely to break things. In addition, if more \"users\" of the SH.random come along, then we would need to vet the interaction of our extension with theirs. (As @martinthomson points out.)",
          "createdAt": "2020-08-18T00:03:33Z",
          "updatedAt": "2020-08-18T00:06:26Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 to option 3, and I tend to think that use of a SH extension is not a big concern.\r\n\r\nIt's correct that the extension might indicate the use of ECH. But from the perspective of a middlebox, that would always be the case when the _client_ sends an ECH extension. Also, there would be other ways to determine if a large-scale server supports ECH (note: ECH is about hiding a tree in the wood, so it's about the cost of finding such woods). Therefore, in practice there's marginal benefit in making the server support signal indistinguishable.",
          "createdAt": "2020-08-18T03:52:02Z",
          "updatedAt": "2020-08-18T03:52:02Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "From @cjpatton \r\n> I think they both need analysis, but the SH.random trick is much more invasive and likely to break things. In addition, if more \"users\" of the SH.random come along, then we would need to vet the interaction of our extension with theirs. (As @martinthomson points out.)\r\n\r\nI agree that analysis is needed, but I think using 8 bytes of SH.random is not a weird hack. It's at least a well-understood hack, because it's nicely parallel to the downgrade sentinel, and they never coexist.\r\n\r\nFrom @kazuho\r\n> It's correct that the extension might indicate the use of ECH. But from the perspective of a middlebox, that would always be the case when the client sends an ECH extension.\r\n\r\nTLS 1.2 middleboxes frequently take action based on the certificate, so  ServerHello extensions seem likely to be used as well.  If there's a ServerHello extension, I expect that some firewall vendor will offer a checkbox labeled \"Block Encrypted ClientHello\" based on this extension, in the \"Security\" section, and some admins will turn it on without understanding what it does.  If the local network is normally used to access a small set of services, and none of them support ECH yet, then this will appear to work fine, perhaps for years.  Then, if one of those services tries to enable ECH, they'll get angry phone calls from customers who can no longer access the service.  For them, ECH will be ossified.\r\n\r\nFor QUIC, I agree that a visible extension is OK, since it's not too late to get it into 1.0.  For TLS, I worry that it is too late.",
          "createdAt": "2020-08-18T14:14:00Z",
          "updatedAt": "2020-08-18T14:14:00Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bemasc, given that servers can respond with rejection even without actual ECH support, would your concern be alleviated if some servers started rejecting the GREASE ECH extensions in the near future?",
          "createdAt": "2020-08-18T14:24:43Z",
          "updatedAt": "2020-08-18T14:24:43Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi thread, since there's largely consensus here, I'm going to start working on a PR for Option (3). I'll post it here when it's ready. Thanks for your input!",
          "createdAt": "2020-08-18T20:45:38Z",
          "updatedAt": "2020-08-18T20:45:38Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@MikeBishop Sure, the sooner many servers become \"ECH-aware\", the better.  However, I expect that conservative institutional services will be very slow to update.  In the extreme case, if a network is only used to access one service, then the broader ecosystem has limited direct impact.\r\n\r\nI don't mean to claim that this ossification is inevitable, but I'd prefer to reduce the risk if we can find a reasonable alternative.",
          "createdAt": "2020-08-18T20:58:39Z",
          "updatedAt": "2020-08-18T20:58:39Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@cjpatton Regarding your second-extension proposal above, it seems to me that there are two options here.  In the one you wrote (\"ech_retry\"), the second extension (empty from the client) is paired with the retry configs.  Syntactically, this makes the retry functionality optional: a client that doesn't support retry could omit the \"ech_retry\" extension.\r\n\r\nAn alternative would be to pair the retries with the \"ech\" extension (as in the current draft), and pair the context tag response with a new empty extension.  I would call it \"context_tag\".  Syntactically, this makes the context tag functionality optional: clients that support trial decryption could omit it.\r\n\r\nI think the \"context_tag\" arrangement is preferable.  It's not explicitly connected to ECH, which I think makes it more likely to be implemented and less likely to be blocked.  In principle, it could be used for any future situation where the cryptographic context is ambiguous.  It would also give clients the option to use trial decryption in TLS/TCP, and avoid it for QUIC.  (Support would be mandatory for ECH and QUIC servers, but optional for clients.)",
          "createdAt": "2020-08-19T13:38:08Z",
          "updatedAt": "2020-08-19T13:39:29Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bemasc, this sounds like an alternative to Option (3) that makes the explicit indication of acceptance optional. Just so we're on the same page, we think this is what you mean (@chris-wood and I really like this idea, if this is in fact what you intend):\r\n\r\n**Protocol flow:**\r\n* **On input of the client's outer CH.** If the server accepts `ech`, it uses the inner CH; and if the server rejects or does not support `ech`, then it uses the outer CH.\r\n   * If the client requested a context tag in its `ech`:\r\n       * If the server accepts, then it adds an `ech_context_tag` extension to its SH with `context.Export(\"tls13-ech-accept\", 16)` as the value.\r\n       * if the server rejects, then it adds an `ech_context_tag` extension to its SH with a random, 16-byte string.\r\n    * If the server rejects, then it adds and an `ech` extension to its EE with the updated `ech` configuration.\r\n    * if the server does not support `ech`, then it proceeds as normal, but MAY mimic `ech` rejection.\r\n* **On input of the server's SH, EE, \u2026, Finished.**  If the client didn't request a context tag, then it proceeds as in Option (0).  If the client requested a context tag and the SH has the `ech_context_tag` extension with payload `context.Export(\"tls13-ech-accept\", 16)`, then it proceeds as if the inner CH was used; otherwise it proceeds as if the outer CH was used, updating its `ech` configuration if applicable.",
          "createdAt": "2020-08-19T15:26:01Z",
          "updatedAt": "2020-08-19T15:28:58Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that's about what I mean, but I'm not clear on what you're saying the client would send. Here's what I was thinking:\r\n\r\n* The `ech` extension is not changed at all from the current draft.\r\n* We define a new extension: `context_tag`.  In the ClientHello, it is empty.  The response (in the ServerHello) contains 16 random bytes by default.  If the server is using an ECH context, the value is `context.Export(<constant>, 16)` instead.\r\n* A ClientHello may contain either or both of `ech` and `context_tag`.  The client should include `context_tag` in all their ClientHellos (inner and outer, ECH and GREASE) or none, for a given protocol (TCP or QUIC).\r\n* Servers that implement `ech` must also support `context_tag`.  All other servers should support `context_tag` (which is trivial).\r\n* All QUIC servers must implement `context_tag`.  (Possibly not something we can specify in this draft.)",
          "createdAt": "2020-08-19T17:19:23Z",
          "updatedAt": "2020-08-19T17:19:23Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This seems fine, except that it doesn't make sense to offer the `context_tag` extension without the `ech` extension, since the `context_tag` response is derived from the HPKE state.\r\n\r\nI'm suggesting that the client \"requests\" a context tag in its `ech` extension. In particular, there's a flag in the extension that is \"true' if it requests a tag and \"false\" otherwise. Doing this in a separate extension is fine, but you wouldn't want to offer that extension without also offering `ech`.",
          "createdAt": "2020-08-19T17:23:37Z",
          "updatedAt": "2020-08-19T17:24:57Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I'm suggesting that the client \"requests\" a context tag in its ech extension.\r\n\r\nI'm not sure this is [allowed](https://tools.ietf.org/html/rfc8446#section-4.2):\r\n> Implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests...  Upon receiving such an extension, an endpoint MUST abort the handshake with an \"unsupported_extension\" alert.\r\n\r\nI also think this formulation is clearer from the perspective of a server that does not implement ECH.\r\n\r\nBTW, here's a variation that's even simpler, and might work better with split mode:\r\n* If the ClientHello's `context_tag` is empty, the server responds with 16 random bytes.\r\n* Otherwise, the server echoes the contents.\r\n* The client includes an empty `context_tag` in the outer ClientHello, and one containing 16 random bytes in the inner ClientHello.",
          "createdAt": "2020-08-19T17:43:17Z",
          "updatedAt": "2020-08-19T17:43:17Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I also think this formulation is clearer from the perspective of a server that does not implement ECH.\r\n\r\nYup, I agree! This will be what the PR does.",
          "createdAt": "2020-08-19T17:43:44Z",
          "updatedAt": "2020-08-19T17:47:17Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "PR is underway, I just need to revise the client and server behavior. Should be done tomorrow!",
          "createdAt": "2020-08-20T00:44:14Z",
          "updatedAt": "2020-08-20T00:44:14Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": "Another possibility is that in the ECH message the client sends a FLAGS extension with a bunch of bits set, and the server responds with a FLAGS extension that has one of those bits set.  The plaintext CH could have a superset of the ECH flags.",
          "createdAt": "2020-08-20T17:03:05Z",
          "updatedAt": "2020-08-20T17:03:05Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "@richsalz Right, that would the flags-encoded of option (1). It does, however, stick out.",
          "createdAt": "2020-08-20T17:05:10Z",
          "updatedAt": "2020-08-20T17:05:10Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": "I thought my \"plaintext CH could have a superset of the ECH flags\" handled the sticking out part.",
          "createdAt": "2020-08-20T17:07:12Z",
          "updatedAt": "2020-08-20T17:07:12Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh I see. Sorry, I misunderstood. Though that seems to also stick out: you can tell by just checking the flags for the superset, etc., rule or however we decide to encode it.",
          "createdAt": "2020-08-20T17:09:34Z",
          "updatedAt": "2020-08-20T17:09:34Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": "I'm not pushing on this very hard, but if you grease flag-bits in the CH and pick one of those bits in the ECH.  Maybe that doesn't work, so I'm willing to let this drop.\r\n",
          "createdAt": "2020-08-20T17:56:13Z",
          "updatedAt": "2020-08-20T17:56:13Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My model of the implementation here is that the server is made up of two components in a stack:\r\n\r\nECH-unwrapping portion of the server\r\n- can broadly be thought of as the proxy frontend, think large proxy provider pointed to by the site's DNS\r\n- has access to the ECH key and the fallback key only\r\n- forwards the inner client hello to the backend service if encryption works\r\n- finishes the handshake with updated ECH config with the updated key if ECH doesn't decrypt\r\n- can be deployed on a global edge network close to eyeballs (even places where TLS termination isn't safe)\r\n\r\nBackend service\r\n- associated with the site certificate owner, think individual dedicated host behind proxy provider\r\n- has access to private key for the certificate\r\n- standard TLS 1.3 implementation, answers inner CHs or non-ECH CHs\r\n- can be deployed in a hardened/trusted datacenter (no need to put on global edge where content isn't decrypted)\r\n- could even be something like an AWS LB or other service that has no incentive to implement anything ECH-related\r\n\r\nThese two components communicate over the network, or in the degenerate case, are in the same machine.\r\n\r\nMy understanding is that Option (1)\r\na) requires there to be signaling between the front-end and the back-end, and\r\nb) requires changes to the backend service to support ECH and the signaling\r\n\r\nThis additional complexity seems hard to justify and could hinder many deployment scenarios (especially ones we haven't thought of yet). What is the proposed mechanism for signaling whether an inner client hello was used or an outer client hello? This eliminates the ability to use existing TLS stacks without modification, and on top to support a signaling layer. Option (1) seems fraught.\r\n\r\nIt seems like Option (3) does not require signaling (signaling would come in-handshake from the new extension), but it does require backend changes to implement the new extension. This wouldn't work in situations where a third party doesn't have any motivation to implement ECH-related extensions, a tough loss, but not fatal. The problem here is that the combination of the presence of the client extension (signaling client support for ECH) and the server extensions (signaling server support for ECH) is going to make ECH-enabled traffic stick out from non-ECH-enabled traffic, even if dummy ECHs are sent 100% of the time from supporting clients. The ossification risk is huge.\r\n\r\nOption (2) is my strong preference because it doesn't require backend changes and doesn't stick out unless ECH fails to be decrypted (which is a degenerate case).\r\n",
          "createdAt": "2020-08-20T19:18:50Z",
          "updatedAt": "2020-08-20T19:18:50Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "It seems to me that we are trading off between three things:\r\n\r\n- Ability/difficulty of an adversary to determine that ECH is in use (as opposed\r\n  to that ECH is possible with a server)\r\n- Compatibility with split mode.\r\n- Ease of client implementation\r\n\r\nAs I understand the situation we have (Y is good in each column)\r\n\r\n~~~~\r\n                Can't detect ECH-in-use        Split-Mode       Easy Client Impl\r\nCurrent           Y                              Y                N\r\nOption 1          N                              N                Y\r\nOption 2          Y*                             Y                ?\r\nOption 3          Y                              N                Y\r\n~~~~\r\n\r\n* Except on rejection, for what that's worth.\r\n\r\nUnless I misunderstand, Ben's proposals are just different spellings of (3).\r\n\r\nI don't think anyone likes 1 so that leaves us with Current, 2, and 3.\r\n\r\nI'm not that concerned about the \"implementation\" issues of Current, but I am\r\nquite concerned about the QUIC/DTLS issues, so I think we should strive to\r\navoid that. That leaves us with 2 and 3.\r\n\r\nAs I understand it, the complexity issue is that if the server has\r\nturned off support for ECH entirely, then the connection will hard\r\nfail. However, with the current state of the spec I believe that this\r\nis effectively the state anyway. Here's the relevant text:\r\n\r\n   Note that authenticating a connection for the public name does not\r\n   authenticate it for the origin. The TLS implementation MUST NOT\r\n   report such connections as successful to the application. It\r\n   additionally MUST ignore all session tickets and session IDs\r\n   presented by the server. These connections are only used to trigger\r\n   retries, as described in {{handle-server-response}}. This may be\r\n   implemented, for instance, by reporting a failed connection with a\r\n   dedicated error code.\r\n\r\nIOW, we don't try to recover for cases where the client-facing server\r\nhas just forgotten about ECH but rather where it has forgotten the\r\nECH key. So, hard fail is actually not a problem here. I'm similarly\r\nnot worried about signaling that the server is ECH-capable (especially\r\nin this case where it's actually not). So, I think my ? under \"Easy\r\nClient Impl\" turns out to be a Y.\r\n\r\nWith that said, I do find Option 3 aesthetically cleaner, though I'd\r\nstruggle a bit to explain why and there is an obvious appeal to not\r\nhaving *any* public signaling in terms of being able to analyze it,\r\nthough I'm not sure how strong an argument that is. I'm also not\r\nthat worried about the sticking out piece, as I would expect that\r\nwe can rapidly make a lot of servers accept and pretend do respond\r\nto grease-ECH -- which we would want to do in any case.\r\n\r\nI'd like to hear from some other people about why they prefer (3) to (2)\r\nand whether there is some split mode-compatible variant of (3).\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2020-08-20T20:28:25Z",
          "updatedAt": "2020-08-20T20:28:53Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Option (2) means ECH becomes much riskier to deploy. In options (0), (1), or (3), a service can advertise ECH in the DNS and not largely panic about inconsistencies between hard-to-predict DNS cache behavior, and hard-to-predict future or present rollout decisions on individual servers.\r\n\r\nThe only hard commitment is that the servers advertised in DNS are able to speak on behalf of the public name. As long as that that's true, the client has an authenticated signal to recover from any DNS / server mismatches. In particular, if there is a problem and the service needs to roll back ECH (or if the service was in the process of rolling out ECH and missed a few spots initially), the existing TLS server behavior will be correctly interpreted by the client as an authenticated rollback, and the client can recover. This is true for every TLS feature I can think of to date: it is always safe to rollback. With the exception that proves the rule being 0-RTT, which got a note in the spec (RFC8446, appendix D.3.) to describe client behavior to restore safety.\r\n\r\nOption (2) breaks this invariant.",
          "createdAt": "2020-08-20T20:42:17Z",
          "updatedAt": "2020-08-20T20:42:34Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@davidben. Sorry, I had misread the specification and I agree with you. To recap for those following at home presently the client's algorithm is:\r\n\r\n~~~\r\n1. Trial decrypt as if ECH accepted. If success, then proceed.\r\n2. Trial decrypt as if ECH rejected. If failure, then abort.\r\n3. If retry_keys is present, then restart with ECHConfig == retry_keys\r\n4. If retry_keys is absent, then retry without ECH\r\n~~~\r\n\r\nIt's point 4 that is relevant here. I had read the spec as requiring a hard failure, but it in fact recovers. That pushes me more towards (3).\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2020-08-20T20:52:37Z",
          "updatedAt": "2020-08-20T20:52:37Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I'd like to hear ... whether there is some split mode-compatible variant of (3).\r\n\r\nI believe I described one above.  I'll rephrase, in case it was unclear:\r\n\r\n* `context_tag` is an extension that appears in ClientHello and ServerHello.\r\n* If the ClientHello contains a `context_tag` with empty contents, the server replies with a `context_tag` containing 16 random bytes.\r\n* Otherwise, the ServerHello's `context_tag` echoes the contents of the ClientHello's `context_tag`.\r\n* The client includes an empty `context_tag` in the outer ClientHello, and a `context_tag` containing 16 random bytes in the inner ClientHello.\r\n\r\n",
          "createdAt": "2020-08-20T20:53:19Z",
          "updatedAt": "2020-08-20T20:53:19Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@bemasc this is only *partially* split-mode compatible in that it requires changing every origin server. It just doesn't require coordination between the servers.",
          "createdAt": "2020-08-20T20:54:29Z",
          "updatedAt": "2020-08-20T20:54:29Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "True!  For any extension implementing Option 3, I think we want those changes anyway.  If a ServerHello extension is only implemented by ECH terminating servers, then its presence distinguishes real ECH from GREASE.  If it's widely implemented, then that signal is diminished.\r\n\r\nAlternatively, we could say that the new extension is only for QUIC, and make TLS/TCP stick to trial decryption.",
          "createdAt": "2020-08-20T21:04:09Z",
          "updatedAt": "2020-08-20T21:04:09Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Sure. I'm comparing it to (2).",
          "createdAt": "2020-08-20T22:50:02Z",
          "updatedAt": "2020-08-20T22:50:02Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi all, see PR #283 for our proposal for Option (3), with @bemasc's improvements incorporated. The main points:\r\n* The client may request confirmation of ECH acceptance (Option (3)), but the default behavior is Option (0).\r\n* Acceptance is indistinguishable from rejection, which is the primary motivation for choosing Option (3) over Option (1).\r\n* Split Mode works for Option (3), but the backend server needs to support ECH. (All it has to do is echo an extension sent by the client-facing server.) There's no change to the backend if confirmation isn't requested.",
          "createdAt": "2020-08-20T23:07:24Z",
          "updatedAt": "2020-08-20T23:08:33Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't understand why this is better than (3). Won't every client just send ech_confirm, in which case this is isomorphic to 3?",
          "createdAt": "2020-08-21T21:34:12Z",
          "updatedAt": "2020-08-21T21:34:12Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Option (0) sticks out less than option (3), which is why a client might opt to not send \"ech_confirm\".",
          "createdAt": "2020-08-21T23:14:37Z",
          "updatedAt": "2020-08-21T23:14:37Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hmm ... I think there should be away to resolve the deployment issues between (2) and (3). Will post on Monday.",
          "createdAt": "2020-08-22T00:13:01Z",
          "updatedAt": "2020-08-22T00:13:01Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "(3') This seems strictly worse than either (0) or (3). We'll have an odd mix of people doing one or the other and every server will have to do and test both.",
          "createdAt": "2020-08-24T13:53:17Z",
          "updatedAt": "2020-08-24T13:53:17Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ekr:\r\n\r\n> (3') This seems strictly worse than either (0) or (3). We'll have an odd mix of people doing one or the other and every server will have to do and test both.\r\n\r\nYou're suggesting that confirmation SHOULD NOT be optional, correct? I'm Ok with this, but it seems to me that it's not especially complicated to implement this correctly on the server side. The hard bit is the client, since it has to do trial decryption.\r\n\r\n@davidben:\r\n\r\n> Option (2) means ECH becomes much riskier to deploy.\r\n\r\nI'd like to drill down on the problem of rolling back ECH. The essence of the problem is that an ECH server that advertised a configuration in the past must support ECH for as long as that configuration is valid. What are some \"bad\" events that may lead to this contract being violated?\r\n\r\n- *The ECH secret key has been compromised, so the service needs to be shut off until a new key is rolled.* In the meantime, the service can explicitly reject ECH without providing a new configuration. The client would take this as a signal of ECH being disabled by the server.\r\n- *A bug is found somewhere in the TLS stack, and the quick fix is to revert to a point before the ECH code was committed.* This is definitely a risk, but I wonder if there are ways to mitigate it. For example, if the configuration is valid for the next hour, say, then we must delay the rollback until the hour has lapsed. Alternatively, we can roll-back right away, and when the client aborts because of decryption failure, it might make a DNS query to see if ECH support has been turned off.",
          "createdAt": "2020-08-24T18:06:36Z",
          "updatedAt": "2020-08-24T18:11:15Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "@cjpatton \r\n\r\nI agree that the first issue is fine by option (2). (Though probably the mitigation would be to roll out a new key. One hopes that pipeline is already built out and regularly exercised by routine key rotation.)\r\n\r\nI'm worried about the second one, but I think the characterization is too simple. TLS implementations are part of a complex system, both within the service and on the internet as a whole. Complex systems break unpredictably. Maybe it's a TLS bug. Maybe ECH inadvertently broke some assumption in some other part of the stack. Maybe some large client had a bug that only triggered due here to some quirk of the server. Maybe some printer happened to be [using the code point](https://mailarchive.ietf.org/arch/msg/tls/i9blmvG2BEPf1s1OJkenHknRw9c/) and now breaks. Maybe it had nothing to do with TLS at all, but some other concurrent server change broke and the entire release needs to be rolled back.\r\n\r\nAnything which interferes with the default response (rollback to a known good configuration) is expensive and risky. This risk needs to be communicated across a long game of telephone from...\r\n\r\n* the people who wrote the ECH to spec, to...\r\n* the people who implemented it in the TLS library, to...\r\n* the people who integrated it into some server software, to...\r\n* the people who perhaps packaged the server software into some OS release, to...\r\n* the people who perhaps shipped the OS release in some server appliance, to...\r\n* the people who manage the rollout of the change in some deployment, to...\r\n* the people who noticed a failure in a faraway system and are trying to mitigate it\r\n\r\nThis is not practical, especially if we want ECH to be widely adopted.\r\n\r\nTo the alternatives you list, when things go wrong, the priority is to get the service working again. Leaving it broken until the ECH config expires is thus not great. Moreover, expiry itself is a property of a complex system (DNS), so it may not be clear when it actually expires. Mandating a client retry on decryption failure is more plausible (compatible with rollback), but it relies on caching properties of the DNS, which is where much of the deployment mismatch risk comes from in the first place.",
          "createdAt": "2020-08-24T19:41:01Z",
          "updatedAt": "2020-08-24T19:41:01Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Mandating a client retry on decryption failure is more plausible (compatible with rollback), but it relies on caching properties of the DNS, which is where much of the deployment mismatch risk comes from in the first place.\r\n\r\nCan you elaborate on this issue a bit more? Suppose the DNS and ECH provider are the same entity, and suppose that entity can synchronize the DNS response with the rollback. I guess one potential pitfall is that the client could use a DNS response cached by its operating system? Any others?",
          "createdAt": "2020-08-24T21:05:52Z",
          "updatedAt": "2020-08-24T21:05:52Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": ">  Suppose the DNS and ECH provider are the same entity, \r\n\r\nThat's a simplifying assumption and doesn't always hold.  Even within an enterprise, it's not uncommon for the DNS folks to be a separate group from those running the webservers.",
          "createdAt": "2020-08-24T21:23:07Z",
          "updatedAt": "2020-08-24T21:23:07Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Even when they are the same entity, I don't think synchronizing the DNS response with the rollback is meaningful. As you note, the OS has a cache. The client may have a cache in front of that. The recursive resolver may have a cache. There are probably other caches in various DNS middleware. There is also no guarantee that the same server instance and will serve the client's DNS query and the client's TLS connection, which means that during the course of a rollout or rollback, there will be mismatches.",
          "createdAt": "2020-08-24T21:25:31Z",
          "updatedAt": "2020-08-24T21:25:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "~~Turtles~~ caches all the way down!",
          "createdAt": "2020-08-24T21:27:19Z",
          "updatedAt": "2020-08-24T21:27:19Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> There is also no guarantee that the same server instance and will serve the client's DNS query and the client's TLS connection, which means that during the course of a rollout or rollback, there will be mismatches.\r\n\r\nEr, by \"mismatch\" here, I mean that the client will see DNS and TLS configs from different generations. If a very careful server operator carefully controls changes based on TTLs and deployment times, they may be able to arrange for all observed cross-generation configs to be compatible. (And indeed they *should* arrange for TLS servers to know about ECH keys before advertising them, etc.)\r\n\r\nBut this is the careful, happy case, not a failure recovery case.",
          "createdAt": "2020-08-24T21:28:39Z",
          "updatedAt": "2020-08-24T21:28:39Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> That's a simplifying assumption and doesn't always hold. Even within an enterprise, it's not uncommon for the DNS folks to be a separate group from those running the webservers.\r\n\r\nVery true, and I don't think we should assume this is the case. I think (3) is the best option for many deployments, but there are use cases for which (2) is much better, assuming the server can manage the DNS/TLS synchronization complexity. It might be worth exploring a hybrid approach: in its ECHConfig, the server might indicate *what* it confirms: acceptance a la (3), or rejection al a (2). \r\n\r\nThe main concern I have with (2) is that the client needs to evict its cache before making the DNS request, and I'm not sure how platform-dependent this behavior is.",
          "createdAt": "2020-08-24T21:47:47Z",
          "updatedAt": "2020-08-24T21:47:47Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "The client can't evict the recursive resolver's cache. I'm not sure if even the OSes provide APIs to clear caches. (I don't see an obvious flag to pass into `getaddrinfo`.)\r\n\r\nWe also should not have two different spellings of the same thing in the protocol. It is complex enough as it is.",
          "createdAt": "2020-08-24T21:56:46Z",
          "updatedAt": "2020-08-24T21:56:46Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So the only way to safely rollback for option (2) is to wait until the DNS record expires. Does anyone have a sense of the degree to which clients respect the record's TTL? Google measured clock skew among Chrome clients years ago and found it was pretty dismal. Is the state of affairs any better today?\r\n\r\nIn any case, counting on clients to get DNS right appears to be risky. If we go with (2), then it seems the best option on the table so far is to use trial decryption to distinguish between ECH acceptance and (the unlikely case of) ECH rollback. \r\n\r\nLet me make one more pitch for (something like) option (2). As @grittygrease pointed out, we have largely ignored a potentially important \"don't stick out\" consideration. The goal of (3) is to make connections from a real ECH client to an ECH server look like connections from a dummy ECH client (i.e., one that sends a GREASEd extension) to an ECH server. A property that (0,2) have that (1,3) don't is that connections from a real ECH client to an ECH server look like connections from a dummy ECH client to a non-ECH server. In other words, options (1,3) don't provide covertext for non-ECH servers, whereas (0,2) do. (ECH rejection sticks out for (2), but the happy path doesn't.) Do we regard this as a risk to deployment?",
          "createdAt": "2020-08-25T15:43:40Z",
          "updatedAt": "2020-08-25T15:43:40Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> In any case, counting on clients to get DNS right appears to be risky. If we go with (2), then it seems the best option on the table so far is to use trial decryption to distinguish between ECH acceptance and (the unlikely case of) ECH rollback.\r\n\r\nIf we do that, we haven't addressed this issue. If clients still need to implement trial decryption for one case, however unlikely, we're still paying for it and there's no point in building a separate thing. How common a codepath is affects performance considerations, but not complexity considerations. The issue with trial decryption is complexity, not performance. (Trial decryption also breaks some in-place decryption strategies, so there can be a performance concern too, but it's just one record so I'm not concerned about that.)\r\n\r\n> A property that (0,2) have that (1,3) don't is that connections from a real ECH client to an ECH server look like connections from a dummy ECH client to a non-ECH server. In other words, options (1,3) don't provide covertext for non-ECH servers, whereas (0,2) do. (ECH rejection sticks out for (2), but the happy path doesn't.) Do we regard this as a risk to deployment?\r\n\r\nRight, I think this is the ServerHello.random vs. new extension question for (3). Sticking the indicator in ServerHello.random makes the full cross product of {ECH-client, GREASE-client} x {ECH-server, non-ECH-server} look the same, provided the server supports TLS 1.3. This is nice, but it's a weird one-off trick we can't do again. Sticking the indicator in a new extension also makes the same cross product look the same, provided the server supports TLS 1.3 *and* has been updated to send this extension. It can send this extension independent of ECH support, but it's not a thing anyone does today because the extension doesn't exist, so the deployment curve will be different.\r\n\r\nIn contrast, (2) is missing coverage. It makes the following tuples look the same: (ECH-client, ECH-server), (ECH-client, non-ECH-server), (GREASE-client, non-ECH-server). It misses (GREASE-client, ECH-server). In particular, clients may be ECH-capable (and thus know to send GREASE extensions) but not configured with a DoH resolver and unable to get HTTPS records over Do53 (either due to cleartext problems or ossification).",
          "createdAt": "2020-08-25T16:11:59Z",
          "updatedAt": "2020-08-25T16:12:32Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The issue with trial decryption is complexity, not performance. \r\n\r\nAgreed, I'm just reiterating that we haven't solved the problem with (2) if we can't solve the problem with client-side DNS.",
          "createdAt": "2020-08-25T16:33:11Z",
          "updatedAt": "2020-08-25T17:18:28Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@davidben, do you expect clients to send GREASE on all connections or only connections for which DoH is available? If you expect clients to send a dummy ECH in situations where the ECHConfig is potentially unavailable, do you expect the server to send ECHConfig back in the handshake and the client to restart the handshake? That seems like a pretty big performance hit.",
          "createdAt": "2020-08-25T17:33:20Z",
          "updatedAt": "2020-08-25T17:33:20Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> do you expect clients to send GREASE on all connections or only connections for which DoH is available?\r\n\r\nI think they should send it for all connections. That was a big part of the motivation.\r\n\r\n> If you expect clients to send a dummy ECH in situations where the ECHConfig is potentially unavailable, do you expect the server to send ECHConfig back in the handshake and the client to restart the handshake? That seems like a pretty big performance hit.\r\n\r\nNo, clients don't process retry configs on GREASE connections.\r\n\r\n> Offering a GREASE extension is not considered offering an encrypted ClientHello for purposes of requirements in {{client-behavior}}.\r\n\r\nPossibly the spec should be clearer here. The intent is that this is a different mode altogether. (~~Probably the business around sessions remembering whether ECH was negotiated can be dropped too now that we encrypted the whole ClientHello. That was originally added to work around some goofiness between the public and private names.~~ Edit: filed https://github.com/tlswg/draft-ietf-tls-esni/issues/285)\r\n\r\nThat was an intentional limitation in at least the first iteration of the retry flow. Picking up a retry config without a DNS lookup is odd for several reasons. As you note, there is a performance penalty to the retry. More importantly, the client has *already* leaked the name at that point. It'd really only be useful for subsequent connections and the text intentionally only applies the retry to one connection attempt. Trying to solve it for subsequent connections would be interesting, but there are several nuisances to resolve:\r\n\r\n* State is a tracking vector. This is easy enough to address\u2014adjust the scope of the state to meet your privacy goals, same as resumption itself\u2014but we'd need to discuss it and reducing scope also reduces effectiveness.\r\n* Remembering TLS-level state, rather than SVCB- or Alt-Svc-level state breaks the multi-CDN story. (At the time this text was written, we hadn't even figured out the multi-CDN story.)\r\n* Even if the retry keys contained a full SVCB record, one CDN won't know the config of the other CDN, so it ends up being a CDN pin, which seems awkward.\r\n* Any cache for subsequent connections needs to deal with the larger lifetimes necessary for effectiveness (see https://github.com/MikeBishop/dns-alt-svc/issues/105)\r\n\r\nGiven all that mess, I omitted it from the PR when proposing this mechanism and figured we'd think about these issues later if the WG wanted to pursue a non-DNS flow.",
          "createdAt": "2020-08-25T18:01:09Z",
          "updatedAt": "2020-08-25T18:54:42Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The DNS expiration complaint seems like overthinking a bit.\r\n\r\nStep 1: Update Registry to remove DS\r\nStep 2: Wait until DNS caches expire\r\nStep 3: Remove zone keys (KSK, ZSK, RRSIG, etc.)\r\n\r\nThis is done pretty frequently, and the servers take the risk of the site having an outage if the client has record synchronization issues.\r\n\r\nIn fact, RRSIG records have explicit expiration times, which makes them less flimsy with respect to expiration. If we follow the lead of RRSIG and add an expiration time to ECHConfig, then we're only relying on clock synchronization during rollover rather than DNS cache expiration.\r\n\r\nHow about:\r\n1) add a time box to the ECHConfig record\r\n2) recommend only sending GREASE in the same situations as 10.2. describes: when you expect to reliably get the ECHConfig record if it exists (i.e. DNSSEC or DoH)",
          "createdAt": "2020-08-25T18:03:43Z",
          "updatedAt": "2020-08-25T18:03:43Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> In fact, RRSIG records have explicit expiration times, which makes them less flimsy with respect to expiration.\r\n\r\nI think this is not quite right.  When all RRSIGs in the zone are expired, [the status is 'Bogus'](https://tools.ietf.org/html/rfc4641#section-4.1), not ['Insecure'](https://tools.ietf.org/html/rfc4035#section-4.3).  In other words, DNSSEC fails hard when the validation expires, and relies on caches to respect TTL.  This is a security feature to prevent an attacker from resurrecting expired data.  This arguably supports your overall argument, but not your proposed mitigation.\r\n\r\nFrom this discussion, it sounds like trial decryption (Option 0) is only modestly inconvenient for TLS/TCP.  If so, that makes me think that we should focus on a simple, separate Option 3 extension only for QUIC, and keep TLS/TCP at Option 0.",
          "createdAt": "2020-08-25T18:51:16Z",
          "updatedAt": "2020-08-25T18:51:16Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi folks, in order to help drive the discussion, I've created PRs for the options currently being discussed.\r\n- #283: option (3), but incorporates various changes and improvements.\r\n- #286: based on #283, but with fallback to option (2). In case option (3) sticks out too much and gets blocked, then we can fall back to option (2) at the cost of deployment complexity. \r\n- #287: based on #283, but the indication of acceptance appears in the SH.random instead of a new SH extension. This stick out less than (3), but requires security considerations.\r\n\r\n> From this discussion, it sounds like trial decryption (Option 0) is only modestly inconvenient for TLS/TCP. If so, that makes me think that we should focus on a simple, separate Option 3 extension only for QUIC, and keep TLS/TCP at Option 0.\r\n\r\nBased on the discussion on #283, most people seem to not favor supporting this behavior.",
          "createdAt": "2020-08-25T21:27:31Z",
          "updatedAt": "2020-08-25T21:28:04Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi all, a quick update for those who haven't been following the proposals:\r\n1. #283 adds an explicit confirmation of acceptance as an extension to the SH.\r\n1. #286  is the same as #283, except the server can opt to only explicitly confirm rejection.\r\n1. #287 adds an explicit confirmation of acceptance by hijacking SH.random.\r\n\r\nIt seems that consensus is coalescing around #287 because it minimizes deployment coimplexity and sticks out less than #283. The open issue for this change is security.\r\n\r\n@chris-wood and I reached out to a variety of people who have worked on security proofs of TLS 1.3 to see how this change might impact their analysis. While this change is significant enough to requires generating fresh proofs, no one expects it to lead to an attack if the confirmation string is sufficiently short. The current proposal uses the last 8 bytes of the SH.random, which leaves 24 bytes of entropy to ensure uniqueness of the session id. I added discussion of this point to the PR... it would be helpful to get more eyes on this.",
          "createdAt": "2020-09-02T18:32:19Z",
          "updatedAt": "2020-09-02T18:59:36Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": "2 and 3 talk to the same PR?\r\n\r\n(edited to remove the email cruft)\r\n",
          "createdAt": "2020-09-02T18:42:13Z",
          "updatedAt": "2020-09-02T19:11:07Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oops, fixed!",
          "createdAt": "2020-09-02T19:00:13Z",
          "updatedAt": "2020-09-02T19:00:13Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "To follow up on the comment I made at the mic and then decided didn't work.\r\n\r\nAssuming we accept PR#292, and decide the CHInner.Random is secret\r\nthen can we just say that the ESNI accepted signal is to have the low\r\norder bytes of SH.Random be derived from CHInner.Random (copied might\r\nwork, but hashed would make me feel better). I haven't done any\r\nreal analysis of this, but it seems like it would not permit an\r\nattacker who does not know CHInner.Random to determine whether\r\nECH was accepted.\r\n",
          "createdAt": "2020-09-03T17:22:48Z",
          "updatedAt": "2020-09-03T17:23:03Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we should consider a construction like `Expand(Extract(ServerHello.random[0:24], CHInner.random), \"ech-tag\", 8)`, i.e. to make the tag dependent on the rest of `ServerHello.random`.  This would at least partly address @huitema's concern about replays.",
          "createdAt": "2020-09-03T20:45:40Z",
          "updatedAt": "2020-09-03T20:45:40Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't see the replay concern as important, since all it does is reveal if ECH was used. There are easier ways for an attacker to learn this information. In fact, it doesn't need to interfere with the connection at all: all it needs to do is learn the ECH configuration.\r\n\r\nI think it's best to keep the mechanism as simple as possible. In particular, I'd like to do everything we can to not increase the requirements for the backend server in Split Mode.\r\n\r\nOf course, if there is an attack that violates the intended security goal of ECH (confidentiality of CH extensions), then we should take that seriously. But I don't think this change (i.e., #287) increases this risk compared to the status quo.",
          "createdAt": "2020-09-03T20:52:47Z",
          "updatedAt": "2020-09-03T20:54:53Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "These attacks aren't part of our core threat model, but it seems like we have an opportunity to defeat some or all of them at low cost, so I think we should consider doing so.\r\n\r\n> There are easier ways for an attacker to learn this information. In fact, it doesn't need to interfere with the connection at all: all it needs to do is learn the ECH configuration.\r\n\r\nThis is true in the main deployment models we're discussing, but I can also imagine use cases where the ECHConfig is not available to the attacker.",
          "createdAt": "2020-09-03T21:14:40Z",
          "updatedAt": "2020-09-03T21:14:40Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I think we should consider a construction like `Expand(Extract(ServerHello.random[0:24], CHInner.random), \"ech-tag\", 8)`, i.e. to make the tag dependent on the rest of `ServerHello.random`. This would at least partly address @huitema's concern about replays.\r\n\r\nThat doesn't work. The attacker just needs to replay the entire server random. If you want protection you need to mix in the server's key share.\r\n",
          "createdAt": "2020-09-03T21:25:30Z",
          "updatedAt": "2020-09-03T21:25:30Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bemasc \r\n\r\n> These attacks aren't part of our core threat model, but it seems like we have an opportunity to defeat some or all of them at low cost, so I think we should consider doing so.\r\n\r\nIf we're going to go down this road, then I think we need to take a step back and think about our \"don't stick out\" threat model in more detail. Currently our requirement is that a **passive observer**, who doesn't know the configuration, is unable distinguish real ECH usage from the \"cover traffic\" provided by clients who \"GREASE\" the ECH extension. The attackers mentioned so far are **active** and may know the config. So let's start here: do we anticipate an attacker this powerful? So far we've mostly been talking about \"don't stick out\" in terms of dumb middleboxes that we don't want ossifying on our extension. The current threat model captures this pretty well, I think. If we want to go for something stronger, then we clearly need to re-think the design of #287 (or decide we shouldn't do it).\r\n\r\nSomething to keep in mind is that indistinguishability of the \"real\" protocol from some \"cover\" protocol is a property that TLS was never designed to have. It seems to me that the task of endowing TLS with some sort of stegonagraphic security property goes way beyond this one extension. It's an interesting and valuable goal, but one that should be addressed in a more general way.\r\n\r\nFor ECH, I think we should focus our efforts on coming up with a design that we feel we can deploy today, and iterate and re-deploy as needed.",
          "createdAt": "2020-09-03T22:55:45Z",
          "updatedAt": "2020-09-04T01:26:35Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with @cjpatton that there is value in simplicity. A really stealthy ESNI would be a different design than ECH. ",
          "createdAt": "2020-09-04T03:42:10Z",
          "updatedAt": "2020-09-04T03:42:10Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 -- ECH is *not* about censorship circumvention, or being stealthy.",
          "createdAt": "2020-09-04T14:35:14Z",
          "updatedAt": "2020-09-04T14:35:14Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood you should maybe expand a bit on that. If you are not trying to defeat *some* form of censorship, then why are you hiding the SNI in the first place?",
          "createdAt": "2020-09-04T15:50:26Z",
          "updatedAt": "2020-09-04T15:50:26Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The problem I'm focusing on is an \"attack\" so trivial it could almost happen by accident.  If a ClientHello is issued twice, verbatim, and elicits two independent ServerHellos, an observer can see whether the last 8 bytes of .Random are the same in both responses.  This might happen sporadically to DTLS or QUIC in some configurations, even without an active attacker.\r\n\r\nThe formula I proposed above avoids this repetition.  If we're going to use a hash, as EKR suggested, this calculation seems like a pretty natural way to do it.\r\n\r\nI definitely don't want to slow down progress, and I'm not proposing that we substantially expand our threat model.  I do think closing trivial attacks has some value even if more advanced ones still exist.  For example, the other attacks may be more difficult or less deniable.",
          "createdAt": "2020-09-04T16:03:36Z",
          "updatedAt": "2020-09-04T16:04:17Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> @chris-wood you should maybe expand a bit on that. If you are not trying to defeat some form of censorship, then why are you hiding the SNI in the first place?\r\n\r\nCensorship is, for example, active blocking of a connection based on the name, whereas ECH hides SNI (and other things) from those that just passively snoop and try to learn about clients.",
          "createdAt": "2020-09-04T16:05:31Z",
          "updatedAt": "2020-09-04T16:05:31Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "EDITED TO FIX PROPOSAL 3.\r\n\r\n@bemasc \r\n\r\n> The problem I'm focusing on is an \"attack\" so trivial it could almost happen by accident.\r\n\r\nI agree that it would be worth mitigating this attack, as long as the mechanism isn't too complicated. Let's consider the \"replay protection\" properties of the current proposals. Suppose the attacker wants to learn if a client offered ECH, so it replays the ClientHelloOuter to the server. Here are the proposals (please chime in if I got this wrong!)\r\n\r\n1. current proposal: `accept_confirmation = getrandom(8)`\r\n2. @ekr proposes: `accept_confirmation = Hash(ClientHelloInner.random)`\r\n3. @bemasc proposes: `accept_confirmation = Hash(ServerHello.random[0:24] + ClientHelloInner.random)`\r\n\r\nwhere `Hash` is something like `Expand(Extract( . , some_salt), some_info, 8)`. (Though since the ikm is a random string, I think it would suffice to just call `Extract( . , some_info, 8)`.)\r\n\r\nNeither 1 nor 2 mitigates the attack, but 3 does. All options \"stick out\" the same if the ClientHelloInner is known, e.g., if the adversary is on-path from the client-facing server to the backend server. \r\n\r\nIncidentally, proposals 2 and 3 are an improvement over 1 since we don't have to send an extension in the ClientHelloInner. On the down side, the backend server needs to know how to instantiate `Hash`, i.e., it needs to know the HPKE cipher suite. We could get around this by using the hash from the TLS cipher suite.",
          "createdAt": "2020-09-04T16:36:55Z",
          "updatedAt": "2020-09-04T16:43:26Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@cjpatton In this shorthand, my proposal is more like `Hash(ServerHello.random[0:24], ClientHelloInner.random)`.  This avoids the leak that you identified.",
          "createdAt": "2020-09-04T16:40:29Z",
          "updatedAt": "2020-09-04T16:40:29Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, you're right. My apologies! Fixing above.",
          "createdAt": "2020-09-04T16:41:37Z",
          "updatedAt": "2020-09-04T16:41:37Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd be fine with 2 or 3, though we should use the TLS cipher suite instead of the HPKE cipher suite so that the backend server doesn't need to know the latter.",
          "createdAt": "2020-09-04T16:44:26Z",
          "updatedAt": "2020-09-04T16:44:26Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bemasc proposes `accept_confirmation = Hash(ServerHello.random[0:24] + ClientHelloInner.random)`\r\nMy proposal would be: `accept_confirmation = Hash(ServerHello.KeyShare + ClientHelloInner.random))`\r\n\r\nThe rationale is that merely hashing the reminder of the server random is insufficient. The attacker could just do the attack I delineated in issue #287 by copying the whole `ServerHello.random[0:32]` instead of just copying `ServerHello.random[24:32]`. But if you mix the server key share in the hash, then the attacker cannot do that without also copying a key share for which the private key is unknown.",
          "createdAt": "2020-09-04T17:22:43Z",
          "updatedAt": "2020-09-04T17:22:43Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "EDITED AFTER DISCUSSION WITH @chris-wood\r\n\r\nRoger that. Here's what we have on the table:\r\n\r\n1. current: `accept_confirmation = getrandom(8)`\r\n1. @ekr: `accept_confirmation = PRF(ClientHelloInner.random, \"\")`\r\n1. @bemasc: `accept_confirmation = PRF(ClientHelloInner.random, ServerHello.random[0:24])`\r\n1. @huitema: `accept_confirmation = PRF(ClientHelloInner.random, ServerHello.KeyShare)`\r\n\r\nLet's instantiate `PRF( . , . )` with `Expand( . , . , 8)`, where `Expand` is for the TLS cipher suite (and not HPKE). Proposal 1 and 2 are for the status-quo threat model, i.e., the \"don't stick out\" distinguisher is passive; proposal 3 provides additional \"don't stick out\" protection in case the CH is replayed; and proposal 4 improves on 3 by providing some protection against manipulation of the SH.\r\n\r\nMy preference is proposal 2, since it simplifies the extension. I would be fine with 3 or 4, though I'm not convinced that either fully addresses the stronger threat model. ",
          "createdAt": "2020-09-04T18:00:55Z",
          "updatedAt": "2020-09-04T18:16:42Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hmm, on second thought I'm not so sure how much simpler 2 is than 1. The ClientHelloInner would still have to carry some sort of indication of ECH acceptance so that the backend server knows to confirm. But an empty \"encrypted_client_hello\" extension (or maybe a new code point?) would do just fine.\r\n\r\nSomething weird about 4 is that the backend server has to wait to finish the ServerHello.random until it generates a key share. This might add a bit of complexity, though it depends on the code base.",
          "createdAt": "2020-09-04T18:25:15Z",
          "updatedAt": "2020-09-04T18:27:07Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@cjpatton Yes, incorporating the key share is more complex. But let's look at what we are doing, replacing trial decryption by a hint. Trial decryption generates complexity, especially in the QUIC mapping, but the result is unambiguous and hard to fool. The client knows for sure whether the key was generated from the inner CH or the outer CH, and it is very hard for third parties to partially fool the client. The hint introduces another failure mode, i.e. wrong hint value, and I believe it can be exploited. For protection, the code has to be almost as hard to fool as trial decryption. That's what I am trying to achieve by incorporating the server key share in the mix.\r\n\r\nThere are of course implementation issues. The server has to know what key share it will use before generating `Server.Random`. That may or may not be easy to do, depending on implementation. The `KeyShareEntry` value do not depend on the `Server.Random` value, so this is definitely possible. But the code path depends on the implementation, and it may be more difficult for some stacks than for others.",
          "createdAt": "2020-09-04T19:23:06Z",
          "updatedAt": "2020-09-04T19:23:06Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "HI all, I added a commit to #287 that implements @bemasc's suggestion. Specifically, `accept_confirmation` (i.e., the last 8 bytes of `ServerHello.random` is computed as \r\n~~~~\r\n    HKDF-Expand-Label(\r\n        HKDF-Extract(0, ClientHello.random),\r\n        \"tls13-ech-accept-confirm\",\r\n        ServerHello.random[0:24],\r\n        8\r\n    )\r\n~~~~\r\nwhere HKDF-Extract and HKDF-Expand-Label are as defined in RFC8446. Doing Extract-then-Expand ensures that we don't run into any issues with the length of the ClientHello.random not matching the Hash.length in the TLS stack.\r\n\r\nPlease have a look to make sure it's spelled correctly.",
          "createdAt": "2020-09-08T21:18:21Z",
          "updatedAt": "2020-09-08T21:18:21Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "`HKDF-Expand-Label` adds a \"tls13 \" prefix to the label, so I think you can shorten the label.\r\n\r\nI agree, we need `HKDF-Extract()` for `Hash.length > 32` (e.g. SHA-512).  Given the need for `HKDF-Extract()`, it would seem more natural to me to put `ServerHello.random[0:24]` in the extraction salt, and use `HKDF-Expand` instead of `HKDF-Expand-Label`.",
          "createdAt": "2020-09-08T22:13:09Z",
          "updatedAt": "2020-09-08T22:13:09Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bemasc \r\n\r\n> `HKDF-Expand-Label` adds a \"tls13 \" prefix to the label, so I think you can shorten the label.\r\n\r\nGood call! Fixing. This reminds me that we need to do a pass of the spec to ensure all the constants have the same structure.\r\n\r\n> Given the need for `HKDF-Extract()`, it would seem more natural to me to put `ServerHello.random[0:24]` in the extraction salt, ...\r\n\r\nI disagree. In any case, the salt being Hash.length bytes long avoids indifferentiability issues [1].\r\n\r\n> ... and use `HKDF-Expand` instead of `HKDF-Expand-Label`.\r\n\r\nWhat does this buy us?\r\n\r\n[1] https://ieeexplore.ieee.org/document/8806752\r\n\r\n\r\n",
          "createdAt": "2020-09-08T23:37:04Z",
          "updatedAt": "2020-09-08T23:37:04Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not familiar with that paper, but Section 4.3 seems to say that HKDF is suitably indifferentiable without any such restriction on the salt length.\r\n\r\nUsing HKDF-Expand instead of HKDF-Expand-Label would seem to make use of fewer, better-analyzed constructions, but I'm not aware of a practical difference, so if HKDF-Expand-Label is more convenient to implement for some reason then that seems like enough justification.",
          "createdAt": "2020-09-09T00:13:46Z",
          "updatedAt": "2020-09-09T00:13:46Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I'm not familiar with that paper, but Section 4.3 seems to say that HKDF is suitably indifferentiable without any such restriction on the salt length.\r\n\r\nThere are many \"safe\" salt lengths. I'm not sure 24 is \"safe\", but I know Hash.length is.\r\n\r\n> Using HKDF-Expand instead of HKDF-Expand-Label would seem to make use of fewer, better-analyzed constructions, but I'm not aware of a practical difference, so if HKDF-Expand-Label is more convenient to implement for some reason then that seems like enough justification.\r\n\r\nI don't think one is any harder than the other. The only difference between them is that `HKDF-Expand-Label` exposes an additional `context` parameter, which I think aligns a bit better with what we're doing here.\r\n\r\nIf you'd like to keep pushing for these changes, then please follow up by making a comment on the PR.\r\n\r\n",
          "createdAt": "2020-09-09T00:46:12Z",
          "updatedAt": "2020-09-09T00:46:12Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I appreciate the safety concerns, but you are going to extract an 8 bytes hint from the hash. That's a serious step down from 32 or even 16 bytes, and with such a short length I would be really surprised if two different hash constructs resulted in any security difference!",
          "createdAt": "2020-09-09T01:05:12Z",
          "updatedAt": "2020-09-09T01:05:12Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hahaha, yeah. We need the 8 bytes to be pseudorandom, and I think the current design is defensible from a provable security perspective. We may be able to do a bit better. What do you think of this, @bemasc?\r\n~~~\r\n    accept_confirmation = HKDF-Extract(ServerHello.random[0:24] + 0^{Hash.len-24}, ClientHello.random)[0:8]\r\n~~~\r\nThis is valid as long as Hash.len >= 24, which I believe is guaranteed by RFC8446.",
          "createdAt": "2020-09-09T15:25:00Z",
          "updatedAt": "2020-09-09T15:26:03Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's fine with me, although I'm not sure why you need to pad the salt.  (HKDF-Extract will pad it for you.)",
          "createdAt": "2020-09-09T16:59:30Z",
          "updatedAt": "2020-09-09T16:59:30Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">  (HKDF-Extract will pad it for you.)\r\n\r\nRoger that.\r\n\r\nAre you happy with this @huitema?\r\n",
          "createdAt": "2020-09-09T17:14:08Z",
          "updatedAt": "2020-09-09T17:14:08Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> (HKDF-Extract will pad it for you.)\r\n\r\nHmm, looking at RFC5869, it's not clear to me that the salt is padded by this function. I think I prefer the following:\r\n```\r\n     accept_confirmation = HKDF-Extract(0, ClientHelloInner.random + ServerHello.random[0:24])[0:8]\r\n```\r\n\r\n",
          "createdAt": "2020-09-09T18:37:44Z",
          "updatedAt": "2020-09-09T18:37:44Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Updated #287 with this change.",
          "createdAt": "2020-09-09T18:52:10Z",
          "updatedAt": "2020-09-09T18:52:10Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that's a fine implementation of the suggestion made by @bemasc . I am waiting for the resolution of the \"don't stick out\" issue on the TLS mailing list.",
          "createdAt": "2020-09-09T20:08:39Z",
          "updatedAt": "2020-09-09T20:08:39Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The decision in today's interim meeting is to merge #287 as-is and reconsider the \"don't stick out\" threat model later on. In particular, we won't be adopting Karthik's suggestion from the mailing list for this PR. @ekr also pointed out that it could be done as an ECH extension.",
          "createdAt": "2020-09-21T18:09:24Z",
          "updatedAt": "2020-09-21T18:09:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing now that #287 landed.",
          "createdAt": "2020-09-22T21:10:35Z",
          "updatedAt": "2020-09-22T21:10:35Z"
        }
      ]
    },
    {
      "number": 275,
      "id": "MDU6SXNzdWU2ODA1NjUyMTY=",
      "title": "s/Hkpe/Hpke/?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/275",
      "state": "CLOSED",
      "author": "cbartle891",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Are these typos or is there some reason HkpeKemId, HkpeKdfId, and HkpeAeadId should be \"Hkpe\" instead of \"Hpke\"? I don't see \"Hkpe\" anywhere in the cited draft.\r\n\r\n```\r\nuint16 HkpeKemId;  // Defined in I-D.irtf-cfrg-hpke\r\nuint16 HkpeKdfId;  // Defined in I-D.irtf-cfrg-hpke\r\nuint16 HkpeAeadId; // Defined in I-D.irtf-cfrg-hpke\r\n```",
      "createdAt": "2020-08-17T22:34:31Z",
      "updatedAt": "2020-08-18T03:55:05Z",
      "closedAt": "2020-08-18T03:55:05Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yep -- typo! Can you please send a PR to fix them?",
          "createdAt": "2020-08-17T23:15:56Z",
          "updatedAt": "2020-08-17T23:15:56Z"
        }
      ]
    },
    {
      "number": 278,
      "id": "MDU6SXNzdWU2ODEzMzg4MDA=",
      "title": "Computation of `config_digest`: which KDF?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/278",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The `config_digest` field is defined as;\r\n> A cryptographic hash of the ECHConfig structure from which the ECH key was obtained, i.e., from the first byte of \"version\" to the end of the structure. This hash is computed using the hash function associated with cipher_suite, i.e., the corresponding HPKE KDF algorithm hash.\r\n\r\nBut the `ECHConfig` structure in draft-07 specifies a list of KDF/AEAD pairs. So which KDF is used to compute `config_digest`? The client is supposed to ignore any KDF/AEAD it doesn't support, so it's not clear how a client and server who need to negotiate the cipher suite can compute `config_digest` correctly.",
      "createdAt": "2020-08-18T20:59:39Z",
      "updatedAt": "2020-08-30T15:35:17Z",
      "closedAt": "2020-08-30T15:35:17Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One way to solve this problem is to only allow one cipher suite per ECH configuration.",
          "createdAt": "2020-08-18T21:00:07Z",
          "updatedAt": "2020-08-18T21:00:07Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I think one cipher suite per ECH configuration is a step too far in flattening. While juggling lots of KEM algorithms is unlikely (we basically have one correct answer right now, and each KEM algorithm is another long-lived key to manage), cipher suites are easier to shuffle and there are multiple correct answers depending on hardware capabilities. Whether AES-GCM and ChaCha20-Poly1305 is preferred is complex.\r\n\r\nPerhaps we use KDF associated with the KEM instead?",
          "createdAt": "2020-08-18T21:57:02Z",
          "updatedAt": "2020-08-18T21:57:02Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hmm, doesn't the cipher suite list indicate a set of KDFs that MAY be used with the KEM? In other words, if there's a KDF associated with the KEM, then why would we allow multiple KDFs?",
          "createdAt": "2020-08-18T22:13:24Z",
          "updatedAt": "2020-08-18T22:13:24Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah hrm. I had thought the KEM had a KDF associated, but looks like that's not quite right. The KEM interface does not, but the DHKEM happens to internally use a KDF, which may or may not be the same as the HPKE-level one.",
          "createdAt": "2020-08-18T23:04:49Z",
          "updatedAt": "2020-08-18T23:04:49Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Right -- KEMs might not have KDFs associated with them. I think we should just use the KDF that the client picks when encrypting the ClientHello:\r\n\r\n~~~\r\n    struct {\r\n       HpkeCipherSuite cipher_suite; // <--- the KDF specified here...\r\n       opaque config_digest<0..2^16-1>; // <--- ... is used to compute this value\r\n       opaque enc<1..2^16-1>;\r\n       opaque encrypted_ch<1..2^16-1>;\r\n    } ClientEncryptedCH;\r\n~~~\r\n\r\nIt's fine that the ECHConfig has a list of KDFs. The client picks only one and tells the server which one. And I think it's reasonable for the server to be able to compute the `config_digest` (or whatever we rename it to be) with the KDF of the client's choosing.",
          "createdAt": "2020-08-19T12:43:05Z",
          "updatedAt": "2020-08-19T12:43:05Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's workable, although it does lead to a bit of a combinatorial explosion. Suppose the server has two ECH configurations, `config1` and `config`, each supporting HKDF-SHA256 and HKDF-SHA256 for the KDF, but only AES-GCM for the AEAD. To avoid trial hashing to determine which configuration to use, the server will need to store a data structure like this:\r\n```python\r\n{\r\n   config1_digest_hkdf_sha256_aes_gcm: config1,\r\n   config1_digest_hkdf_sha512_aes_gcm: config1,\r\n   config2_digest_hkdf_sha256_aes_gcm: config2,\r\n   config2_digest_hkdf_sha512_aes_gcm: config2,\r\n}\r\n```\r\n\r\nIn general, if there N configurations, each supporting k KDFs and e AEADs, then there are N * k * e entries in this table.\r\n\r\nThat said, I'd be happy with adopting @chris-wood's convention.",
          "createdAt": "2020-08-19T15:09:05Z",
          "updatedAt": "2020-08-19T15:10:30Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, there's more state on the server, but that seems to be the price of supporting multiple configurations.",
          "createdAt": "2020-08-19T15:30:01Z",
          "updatedAt": "2020-08-19T15:30:01Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> In general, if there N configurations, each supporting k KDFs and e AEADs, then there are N * k * e entries in this table.\r\n\r\nDoes the server need a separate entry for each AEAD, or just each KDF? I thought we were just extracting a hash function out, which would suggest just the KDF. (Unlike AEADs, which need to deal with the mess around AES, I think there's a lot less reason for a server to particularly care about KDF diversity.)",
          "createdAt": "2020-08-19T19:18:31Z",
          "updatedAt": "2020-08-19T19:18:31Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ohh duh :) It should be N * c, where c is the number of cipher suites.",
          "createdAt": "2020-08-19T19:26:16Z",
          "updatedAt": "2020-08-19T19:26:16Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Shouldn't it be N * h, where h is the number of distinct `HpkeKdfId`s in your `HpkeCipherSuite`s? That is, if you support AES-GCM and ChaCha20-Poly1305, but only pair them with HKDF-SHA256, you only need one hash. Although, looking at ECHConfig again, the association between AEAD and KDF is a purely ECH-level construct. So we could choose to disassociate them and then flatten:\r\n\r\n```\r\n       struct {\r\n           opaque public_name<1..2^16-1>;\r\n\r\n           HpkePublicKey public_key;\r\n           HpkeKemId kem_id;\r\n           HpkeKdfId kdf_id;\r\n           HpkeAeadId aead_ids<2..2^16-2>;\r\n\r\n           uint16 maximum_name_length;\r\n           Extension extensions<0..2^16-1>;\r\n       } ECHConfigContents;\r\n```\r\n\r\nNow there's no multiplication. That said, flattening KDFs but not AEADs assumes you believe that `HpkeKdfId` diversity is rare (personally I'd have been happy just locking all of TLS 1.3 onto HKDF-SHA256 and bumping versions for a KDF swap) while `HpkeAeadId` diversity is meaningful (the AES hardware silliness).",
          "createdAt": "2020-08-19T19:38:13Z",
          "updatedAt": "2020-08-19T20:17:45Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "That's an interesting suggestion. I don't see why one would choose a KDF other than HKDF-SHA-256, at least in the near term. ",
          "createdAt": "2020-08-19T20:09:01Z",
          "updatedAt": "2020-08-19T20:09:01Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well, the obvious thing to do in the near term is switch to a KDF that is a little faster than HKDF.\r\n\r\nThe other thing I notice here is that with this change you don't need `config_digest` to be variable-length.",
          "createdAt": "2020-08-20T00:15:29Z",
          "updatedAt": "2020-08-20T00:15:29Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "We don\u2019t yet have any standard KDFs that would fit the bill, do we?",
          "createdAt": "2020-08-20T00:19:11Z",
          "updatedAt": "2020-08-20T00:19:11Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No, but I still carry a flame for getting one.  HKDF is a rock, but it's a heavy one.",
          "createdAt": "2020-08-20T00:30:16Z",
          "updatedAt": "2020-08-20T00:30:16Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would also like to see alternatives to HKDF. There seem to be a lot of interesting alternatives floating around.",
          "createdAt": "2020-08-20T00:42:46Z",
          "updatedAt": "2020-08-20T00:42:46Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the resolution to this issue is to keep the spec as is:\r\n\r\n> config_digest                                                                                                               \r\n: Equal to `Expand(Extract(\"\", config), \"ech_config_digest\", Nh)`, where\r\n`config` is the `ECHConfig` structure and `Extract`, `Expand`, and `Nh` are as\r\nspecified by the cipher suite KDF. (Passing the literal `\"\"` as the salt is\r\ninterpreted by `Extract` as no salt being provided.)\r\n \r\nLet's close this issue if there's no objection.",
          "createdAt": "2020-08-26T21:01:44Z",
          "updatedAt": "2020-08-26T21:01:44Z"
        }
      ]
    },
    {
      "number": 280,
      "id": "MDU6SXNzdWU2ODIwMzk4Mzg=",
      "title": "When computing config_digest, use I2OSP on integer values.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/280",
      "state": "CLOSED",
      "author": "kjacobs-moz",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "`config_digest` is defined as `A cryptographic hash of the ECHConfig structure from which the ECH key was obtained, i.e., from the first byte of \"version\" to the end of the structure.`\r\n\r\nAs the struct contains integer values, those fields should first be normalized with I2OSP. Also, it's probably worth clarifying that the hash is taken over the serialized representation of the struct.",
      "createdAt": "2020-08-19T18:14:44Z",
      "updatedAt": "2020-08-19T18:45:34Z",
      "closedAt": "2020-08-19T18:45:34Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think that's right for a TLS structure. TLS already has well-defined serialization, which is what that structure uses. See https://tools.ietf.org/html/rfc8446#section-3",
          "createdAt": "2020-08-19T18:20:32Z",
          "updatedAt": "2020-08-19T18:20:32Z"
        },
        {
          "author": "kjacobs-moz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah - that's right. Coming from HPKE this looked like a gap, but I think it's well-defined in this context. Thanks.",
          "createdAt": "2020-08-19T18:33:25Z",
          "updatedAt": "2020-08-19T18:33:25Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as resolved. ",
          "createdAt": "2020-08-19T18:45:34Z",
          "updatedAt": "2020-08-19T18:45:34Z"
        }
      ]
    },
    {
      "number": 281,
      "id": "MDU6SXNzdWU2ODIwNDIxNjk=",
      "title": "ServerEncryptedCH: retry_configs vs. retry_keys",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/281",
      "state": "CLOSED",
      "author": "kjacobs-moz",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The spec uses both `retry_configs` and `retry_keys` when referring to the contents of `ServerEncryptedCH`. These should be made consistent (preferably using the former).",
      "createdAt": "2020-08-19T18:19:05Z",
      "updatedAt": "2020-08-19T22:40:49Z",
      "closedAt": "2020-08-19T22:40:49Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed -- let's unify around `retry_configs`! Would you be able to propose text?",
          "createdAt": "2020-08-19T18:45:58Z",
          "updatedAt": "2020-08-19T18:46:11Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "(`retry_keys` is a remnant of the old `ESNIKeys` name. I guess we missed a few.)",
          "createdAt": "2020-08-19T18:48:20Z",
          "updatedAt": "2020-08-19T18:48:20Z"
        }
      ]
    },
    {
      "number": 284,
      "id": "MDU6SXNzdWU2ODU1OTI5NTY=",
      "title": "Section number levels",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/284",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Purely editorial, but the layout of the TOC is a bit confusing....\r\n\r\n> 1.  Introduction\r\n> 2.  Conventions and Definitions\r\n> 3.  Overview\r\n> 3.1.  Topologies\r\n> 3.2.  Encrypted ClientHello (ECH)\r\n> 4.  Encrypted ClientHello Configuration\r\n> 4.1.  Configuration Extensions\r\n> 5.  The \"encrypted_client_hello\" extension\r\n> 6.  The \"ech_nonce\" extension\r\n> 6.1.  Incorporating Outer Extensions\r\n\r\nI think all the confusing things about this would be resolved by moving \"encrypted_client_hello\" and \"ech_nonce\" to be subsections of 4.1, instead of top-level sections in their own right.  This would make 6.1 become 4.2, and \"Incorporating Outer Extensions\" does seem like a reasonable sub-section of \"Encrypted ClientHello Configuration\".",
      "createdAt": "2020-08-25T15:42:51Z",
      "updatedAt": "2020-09-23T20:36:37Z",
      "closedAt": "2020-09-23T20:36:37Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The order is much cleaner now. It describes, in order: the ECH configuration details, extension details, client behavior, and then server behavior. @MikeBishop, I'd suggest closing this as resolved. What do you think?\r\n\r\n>   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\r\n>   2.  Conventions and Definitions . . . . . . . . . . . . . . . . .   4\r\n>   3.  Overview  . . . . . . . . . . . . . . . . . . . . . . . . . .   4\r\n>     3.1.  Topologies  . . . . . . . . . . . . . . . . . . . . . . .   4\r\n>     3.2.  Encrypted ClientHello (ECH) . . . . . . . . . . . . . . .   5\r\n>   4.  Encrypted ClientHello Configuration . . . . . . . . . . . . .   7\r\n>     4.1.  Configuration Extensions  . . . . . . . . . . . . . . . .   8\r\n>   5.  The \"encrypted_client_hello\" extension  . . . . . . . . . . .   9\r\n>     5.1.  Incorporating Outer Extensions  . . . . . . . . . . . . .  10\r\n>   6.  Client Behavior . . . . . . . . . . . . . . . . . . . . . . .  11\r\n>     6.1.  Sending an encrypted ClientHello  . . . . . . . . . . . .  11\r\n>     6.2.  Recommended Padding Scheme  . . . . . . . . . . . . . . .  13\r\n>     6.3.  Handling the server response  . . . . . . . . . . . . . .  14\r\n>       6.3.1.  Accepted ECH  . . . . . . . . . . . . . . . . . . . .  14\r\n>       6.3.2.  Rejected ECH  . . . . . . . . . . . . . . . . . . . .  14\r\n>       6.3.3.  HelloRetryRequest . . . . . . . . . . . . . . . . . .  16\r\n>     6.4.  GREASE extensions . . . . . . . . . . . . . . . . . . . .  16\r\n>   7.  Server Behavior . . . . . . . . . . . . . . . . . . . . . . .  17\r\n>     7.1.  Client-Facing Server  . . . . . . . . . . . . . . . . . .  17\r\n>     7.2.  Backend Server Behavior . . . . . . . . . . . . . . . . .  19",
          "createdAt": "2020-09-22T21:30:04Z",
          "updatedAt": "2020-09-22T21:30:04Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's probably workable.",
          "createdAt": "2020-09-23T20:36:37Z",
          "updatedAt": "2020-09-23T20:36:37Z"
        }
      ]
    },
    {
      "number": 285,
      "id": "MDU6SXNzdWU2ODU3MTE1MDU=",
      "title": "Possible to simplify interaction with session resumption?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/285",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "The current draft contains various rules around ECH and resumption.\r\n\r\n> Per {{client-behavior}} and {{server-behavior}}, implementations are required to track, alongside each PSK established by a previous connection, whether the connection negotiated this extension with the \"ech_accept\" response type. If so, this is referred to as an \"ECH PSK\". Otherwise, it is a \"non-ECH PSK\". This may be implemented by adding a new field to client and server session states.\r\n\r\n> When offering an encrypted ClientHello, the client MUST NOT offer to resume any non-ECH PSKs.\r\n\r\n> If the server resumed a session or negotiated a session that did not use a certificate for authentication, the client MUST abort the connection with an \"illegal_parameter\" alert. This case is invalid because {{send-ech}} requires the client to only offer ECH-established sessions, and {{server-behavior}} requires the server to decline ECH-established sessions if it did not accept ECH.\r\n\r\n> The server MUST ignore all PSK identities in the ClientHello which correspond to ECH PSKs. ECH PSKs offered by the client are associated with the ECH name. The server was unable to decrypt then ECH name, so it should not resume them when using the plaintext SNI name. This restriction allows a client to reject resumptions in {{auth-public-name}}.\r\n\r\n> If the server sends a NewSessionTicket message, the corresponding ECH PSK MUST be ignored by all other servers in the deployment when not negotiating ECH, including servers which do not implement this specification.\r\n\r\nThese rules date to before we started encrypting the entire ClientHello and were intended to avoid mixing up session resumptions between the public and private name, since the same pre_shared_key extension was used for both, and amount to saying implementations must add a boolean to their session state.\r\n\r\nNow that the public and private names correspond to different ClientHellos altogether, the client can (and should) only send inner name tickets in the inner ClientHello and outer name tickets in the outer ClientHello. (#270) I suspect that means we no longer need further ECH special cases here.",
      "createdAt": "2020-08-25T18:52:10Z",
      "updatedAt": "2020-10-07T23:00:44Z",
      "closedAt": "2020-10-07T23:00:44Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This seems like a good simplification, but we should probably be careful about the interaction with cross-SNI resumption.",
          "createdAt": "2020-08-26T12:44:50Z",
          "updatedAt": "2020-08-26T12:44:50Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it just composes as expected? If you offer a PSK in the outer ClientHello, cross-SNI or no, it means that you are satisfied with it as an alternative to the certificate covering the public name. If you offer a PSK in the inner ClientHello, cross-SNI or no, it means you are satisfied with it as an alternative to the certificate covering the true name. Your ClientHellos should be consistent with this, which means that servers resuming isn't an issue.\r\n\r\nTBH I forgotten some of the details for why this was here. I found this long comment I wrote, but apparently past me was just unsatisfied that a case (4) was \"weird\". So that was very unhelpful, past me. Regardless, I think the ambiguity is moot now.\r\nhttps://github.com/tlswg/draft-ietf-tls-esni/pull/124#discussion_r243055936\r\n\r\n(I also expect clients just won't offer PSKs in the outer ClientHellos. It's unlikely that you'll get any to offer anyway. And if your API has an external session cache, the caller needs to go out of their way to do two lookups.)",
          "createdAt": "2020-08-26T18:29:03Z",
          "updatedAt": "2020-08-26T18:29:03Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I was thinking about clients that might mistakenly use inner tickets for the outer name when given the cross-SNI signal. (I agree that it composes naturally.) A simple note would probably suffice. \r\n\r\nFor outer tickets, I tend to think they should just be discouraged. What's the benefit of resuming a TLS 1.3 connection you'd tear down anyway?",
          "createdAt": "2020-08-26T23:31:34Z",
          "updatedAt": "2020-08-28T20:39:34Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure I fully understand the (historical) need to distinguish between ECH-PSKs and non-ECH-PSKs. But why would a client offer PSK to a client-facing server at all? In other words, will it ever be useful to send a PSK extension in the ClientHelloOuter? It seems to me that this feature is only meaningful to the intended backend server, and so should only appear in the ClientHelloInner.\r\n\r\nThe same question applies to all other extensions. If the client-facing server terminates the connection, then the only action the client will take is to close the connection. Hence, the only functionality we will ever need for the client<->client-facing server connection is to complete a full, server-authenticated handshake. If I were implementing the client, I would restrict the contents of the ClientHelloOuter to only those extensions that are necessary to implement this functionality. I wonder if it makes sense to enforce this in the spec. Something like: \"When offering the 'ech' extension, the client MAY include the following extensions in the ClientHelloOuter: 'supported_versions', 'server_name'. 'key_shares', 'signature_algorithms', [and so on]. It MUST NOT include any other extension.\"\r\n\r\nWhat are the downsides to doing something like this? I think the upside is that it simplifies the problem of deciding what to put in the ClientHelloInner versus the ClientHelloOuter. I suppose one downside is that it potentially sticks out a bit.",
          "createdAt": "2020-08-28T20:33:29Z",
          "updatedAt": "2020-08-28T20:35:00Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Based on this week's interim, we decided it was fine to prohibit PSKs in the outer CH for ECH connections, so the current draft text prohibits \"pre_shared_key\" extensions in the outer CH. A connection using GREASE may, however, decide to resume its connection to the outer name. This gives a passive adversary a pretty easy distinguisher between GREASE and non-GREASE: if there's a ticket present, the connection is definitely GREASE. \r\n\r\nIt *seems* that if we want to maintain our current indistinguishability properties, there always needs to be some ticket. So perhaps that means:\r\n\r\n- ECH (non-GREASE) clients would generate a bogus (GREASEd) ticket\r\n- GREASE clients that don't have a ticket would generate a bogus ticket\r\n- GREASE clients that have a ticket would use it\r\n\r\n@davidben, @ghedo, @ekr, @martinthomson, @cjpatton: penny for your thoughts?",
          "createdAt": "2020-09-22T21:53:13Z",
          "updatedAt": "2020-09-22T21:53:13Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I mostly figure there won't be a ticket in the initial connection to a server, or any connections made after long time, so intolerance to ticket-less ClientHellos will likely be noticed quickly. Though it is true that probably a lot of connections offer tickets.\r\n\r\nThere may be something to be said for allowing clients to send bogus tickets if they want, but it's worth noting an active attacker can tell if the ticket is (most likely) bogus by simply trying to resume it.\r\n\r\n(A tangent: we actually saw a very old TLS 1.0 server implementation that broke with TLS 1.3 because it would take the client's session IDs and unconditionally echo it back. I'm not sure what was going on there. It didn't actually switch to a resumption handshake or implement resumption at all. It just echoed back the session ID for some reason. Only reason this didn't break before was that it never issued session IDs, so this codepath had never been tested before.)",
          "createdAt": "2020-09-22T22:02:05Z",
          "updatedAt": "2020-09-22T22:02:05Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> There may be something to be said for allowing clients to send bogus tickets if they want, but it's worth noting an active attacker can tell if the ticket is (most likely) bogus by simply trying to resume it.\r\n\r\nTrue, but that's already the case for active attackers. What I'm concerned about are passive attackers. ",
          "createdAt": "2020-09-22T22:03:49Z",
          "updatedAt": "2020-09-22T22:03:49Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this gets at a larger \"don't stick out\" problem currently only addressed in bits and pieces. Just as dummy (i.e., greased) ECH is used to provide covertext for real ECH, real-ECH connections also need to provide covertext for the real extensions offered in dummy-ECH connections. In particular, the spec should provide guidance on how to generate dummy extensions in the ClientHelloOuter.",
          "createdAt": "2020-09-22T22:33:46Z",
          "updatedAt": "2020-09-22T22:33:46Z"
        }
      ]
    },
    {
      "number": 288,
      "id": "MDU6SXNzdWU2ODYyODgxMDI=",
      "title": "config_digest doesn't need to be 2^16-1 bytes long",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/288",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "It's bound by the size o the HPKE KDF output size, which is unlikely to be larger than 32B. Let's make this:\r\n\r\n~~~\r\n       opaque config_digest<0..2^8-1>;\r\n~~~",
      "createdAt": "2020-08-26T12:42:25Z",
      "updatedAt": "2020-09-02T20:48:24Z",
      "closedAt": "2020-09-02T20:48:24Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We should also add a requirement for the HPKE ciphersuite. E.g., 'Nh <= 2^8`.",
          "createdAt": "2020-08-26T20:41:21Z",
          "updatedAt": "2020-08-26T20:41:21Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(Careful with fenceposts: `Nh < 2^8`.)\r\n\r\nIf config_digest is the output of a KDF, why could you not fix the length to something that is enough to avoid collisions (16 bytes seems ample for this) and not worry about Nh at all?",
          "createdAt": "2020-08-26T22:45:06Z",
          "updatedAt": "2020-08-26T22:45:06Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> If config_digest is the output of a KDF, why could you not fix the length to something that is enough to avoid collisions (16 bytes seems ample for this) and not worry about Nh at all?\r\n\r\nI think it makes sense to let the KDF dictate the security level, i.e., the collision probability of the config_digest.",
          "createdAt": "2020-08-27T01:13:01Z",
          "updatedAt": "2020-08-27T01:13:01Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would argue that collision probability here doesn't contribute to security.  If a config is misidentified, the result will be failure, not a reduction in security.  A failure either because the group doesn't match or because peers end up disagreeing on keys.",
          "createdAt": "2020-08-27T03:48:08Z",
          "updatedAt": "2020-08-27T03:48:08Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "True that it's an operational consideration rather than a security one. I still think it makes sense to let the length of `config_digest` be dictated by the KDF, since whether truncation is an operational risk depends on the KDF.",
          "createdAt": "2020-08-27T22:55:04Z",
          "updatedAt": "2020-08-27T22:55:04Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I assume here that a KDF is capable of producing uniform random bytes of arbitrary length, meaning that truncation isn't a factor.  That's what `L` is for, right?",
          "createdAt": "2020-08-27T23:32:22Z",
          "updatedAt": "2020-08-27T23:32:22Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That assumption holds if the input has sufficient entropy. Since the public key is public, there's no entropy from the point of view of an adversary who wants to distinguish the output from random.",
          "createdAt": "2020-08-28T00:40:19Z",
          "updatedAt": "2020-08-28T00:40:48Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(To be clear, I think truncating to something reasonable, like 16 bytes, is low risk. I would be fine with doing this.)",
          "createdAt": "2020-08-28T00:53:15Z",
          "updatedAt": "2020-08-28T00:53:15Z"
        }
      ]
    },
    {
      "number": 289,
      "id": "MDU6SXNzdWU2ODc1OTE0ODQ=",
      "title": "Rejecting ECH for unrecognized backend servers",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/289",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "The client-facing server should not attempt to accept ECH on behalf of backend servers it doesn't recognize. For example, suppose a client attempts to connect to \"example.com\" via an ECH-service provider named \"ech-provider.com\", but \"example.com\" has not authorized \"ech-provider.com\" to accept ECH on its behalf. What should the client-facing server do in this case? It could reject ECH, but this action alone doesn't convey the reason ECH was rejected. The reason is important here because the client might not know that \"example.com\" is unreachable via  \"ech-provider.com\".\r\n\r\n@Lekensteyn proposed adding the following behavior to \"Client-Facing Server Behavior\":\r\n\r\n> If the client-facing server does not have the authority to accept ECH on the backend server's behalf, e.g., it does not recognize the value of the \"server_name\" extension sent in the ClientHelloInner, then it SHOULD abort the handshake with an \"unrecognized_name\" alert.\r\n\r\nThis alert is appropriate because the situation is akin to the server getting a plaintext SNI for which it is not authoritative. I think \"SHOULD\" is more appropriate than \"MUST\" because what it means for the client-facing server to \"have the authority to accept ECH on behalf of the backend server\" is deployment-dependent. In the CDN case it's quite clear what this means: the client-facing server is only authoritative for websites on its platform. But other use cases are less clear.\r\n\r\n\r\n\r\n\r\n",
      "createdAt": "2020-08-27T22:50:07Z",
      "updatedAt": "2020-09-18T21:35:22Z",
      "closedAt": "2020-09-18T21:35:21Z",
      "comments": [
        {
          "author": "Lekensteyn",
          "authorAssociation": "CONTRIBUTOR",
          "body": "By \"authority\" I meant that the backend is not able to produce a certificate to serve the requested name in SNI (either plaintext or in encrypted form). (The difference between shared and split mode is not important for this logical distinction between \"client-facing server\" and \"backend server\".)\r\n\r\nSome more context on why rejection is not appropriate. Given a CH with the ECH extension, the server can act in some ways (based on Section 3.2):\r\n\r\n1. ECH not supported by client-facing server. Proceed as usual.\r\n2. \"ECH rejection\"\r\n   a. No ECHConfig was found for the given `config_digest`. The client-facing server rejects and sends a `retry_configs` extension.\r\n   b. A valid ECHConfig was found, but decryption fails. Server aborts with a `decrypt_error` alert. (Note an ambiguity on \"decryption failure\" - I filed #290 for that.)\r\n3. \"ECH acceptance\"\r\n  a. A valid ECHConfig was found, and the backend is authoritative for the decrypted SNI. Client-facing server accepts.\r\n  b. A valid ECHConfig was found, and the backend is not authoritative for the decrypted SNI. (This issue.)\r\n\r\nIn case (3b), rejecting as is done in (2a) is wrong because the next retried connection will fail similarly.\r\n\r\nIn the current specification, the decrypted CH is forwarded to the backend and is treated as \"ECH acceptance\". The backend could subsequently send an \"unrecognized_name\" alert instead of the Server Hello, send a default self-signed certificate, etc. Whether the backend is authoritative is invisible to the client-facing server.\r\n\r\nHowever if #283 gets implemented, ECH confirmation will be explicit and requires backend cooperation. This is not possible if the backend sends an alert before the Server Hello. Rejection on the other hand is also not valid for the reason mentioned before. Hence the explicit suggestion for an alert.\r\n\r\n\r\n",
          "createdAt": "2020-08-28T09:48:32Z",
          "updatedAt": "2020-08-28T09:48:32Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Is there a reason the behavior for an unknown encrypted server name needs to be different from seeing an unknown public server name? I would have expected the ECH logic, after decrypting the inner ClientHello, just passes it along to the same ClientHello dispatching logic as usual.\r\n\r\nThat is, the text in https://tools.ietf.org/html/rfc6066#section-3 which recommends either `unrecognized_name` or continuing with I guess a default backend. I'm not entirely sure why folks continue with default backend when the client has explicitly told you what name it wants, but whatever.\r\n\r\nIn particular, I expect TLS implementations which expose a callback for selecting certificates will just call the callback with the inner ClientHello information, and let the application continue with whatever it normally wants. That way adopting ECH requires fewer changes to server software.",
          "createdAt": "2020-08-28T20:11:49Z",
          "updatedAt": "2020-08-28T20:11:49Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Is there a reason the behavior for an unknown encrypted server name needs to be different from seeing an unknown public server name? I would have expected the ECH logic, after decrypting the inner ClientHello, just passes it along to the same ClientHello dispatching logic as usual.\r\n\r\nNope, these should be treated the same! The semantics of the \"server_name\" extension cover this. Thanks for pointing it out.\r\n\r\n(I'll close this issue once @Lekensteyn has had a chance to chime in.)",
          "createdAt": "2020-08-28T20:43:36Z",
          "updatedAt": "2020-08-28T20:43:36Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@cjpatton it might be worth noting that servers ought to treat these two the same. Perhaps we can use this issue to track that?",
          "createdAt": "2020-08-30T15:33:58Z",
          "updatedAt": "2020-08-30T15:33:58Z"
        },
        {
          "author": "Lekensteyn",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that the TLS stack should treat the unencrypted SNI and successfully decrypted SNI the same way. This could be made explicit if not already, but I still wonder how it interacts with #283 adding changes to the Server Hello (which seems to break Split Mode in any case).\r\n\r\nI would be fine closing this issue (with or without the clarification) and defer this lack of ECH acceptance signal to #283.",
          "createdAt": "2020-09-01T10:11:22Z",
          "updatedAt": "2020-09-01T10:11:22Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood \r\n\r\n> it might be worth noting that servers ought to treat these two the same.\r\n\r\nI think this is implied by the following paragraph in the spec:\r\n\r\n> Upon determining the true SNI, the client-facing server then either serves the connection directly (if in Shared Mode), in which case it executes the steps in the following section, or forwards the TLS connection to the backend server (if in Split Mode). In the latter case, it does not make any changes to the TLS messages, but just blindly forwards them.\r\n\r\nSo think mentioning this is a bit redundant. I would suggest closing this issue without changing the text.",
          "createdAt": "2020-09-18T21:33:02Z",
          "updatedAt": "2020-09-18T21:33:02Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, on reflection, you may be right. Closing.",
          "createdAt": "2020-09-18T21:35:21Z",
          "updatedAt": "2020-09-18T21:35:21Z"
        }
      ]
    },
    {
      "number": 290,
      "id": "MDU6SXNzdWU2ODc5NDI4OTU=",
      "title": "What to do on ECH decryption failure?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/290",
      "state": "CLOSED",
      "author": "Lekensteyn",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Two sections suggest to ignore the extension on decryption failure, but one suggests to send an alert. What should happen?\r\n\r\nIgnoring the extension on unrecognized `config_digest` failures sounds reasonable in order to \"not stick out\". However, it is not entirely unambiguous what to do if a valid ECHConfig is found but decryption fails.\r\n\r\n[3.2. Encrypted ClientHello (ECH)](https://tlswg.org/draft-ietf-tls-esni/draft-ietf-tls-esni.html#section-3.2) says:\r\n\r\n> Upon receiving the ClientHelloOuter, the client-facing server takes one of the following actions:\r\n> [..]\r\n> 3. If it supports ECH but cannot decrypt it, then it ignores the extension and proceeds with the handshake as usual.\r\n\r\n[7.3.2.1. Authenticating for the public name](https://tlswg.org/draft-ietf-tls-esni/draft-ietf-tls-esni.html#section-7.3.2.1) says:\r\n\r\n> When the server cannot decrypt or does not process the \"encrypted_client_hello\" extension, it continues with the handshake using the plaintext \"server_name\" extension instead (see Section 8).\r\n\r\n[8. Client-Facing Server Behavior](https://tlswg.org/draft-ietf-tls-esni/draft-ietf-tls-esni.html#section-8) says:\r\n\r\n> If the ClientEncryptedCH value matches a known ECHConfig, the server then decrypts ClientEncryptedCH.encrypted_ch, [..]\r\n> If decryption fails, the server MUST abort the connection with a \"decrypt_error\" alert.",
      "createdAt": "2020-08-28T09:30:56Z",
      "updatedAt": "2020-09-18T21:20:11Z",
      "closedAt": "2020-09-18T21:20:11Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the first two statements apply when the config_digest doesn't correspond to a known ECHConfig (i.e., \"I can't decrypt this\"); the last is when the ECHConfig is known, but decryption fails (\"I should be able to decrypt this, but the ciphertext is invalid\"). The text could be a lot clearer here.",
          "createdAt": "2020-08-28T15:16:13Z",
          "updatedAt": "2020-08-28T15:17:18Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@cjpatton Yes, your interpretation is correct. I think this is the result of a number of uncoordinated changes.",
          "createdAt": "2020-09-03T14:15:04Z",
          "updatedAt": "2020-09-03T14:15:04Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as resolved.",
          "createdAt": "2020-09-18T21:20:11Z",
          "updatedAt": "2020-09-18T21:20:11Z"
        }
      ]
    },
    {
      "number": 294,
      "id": "MDU6SXNzdWU2OTA3Mzg1MTk=",
      "title": "Questions about client behavior",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/294",
      "state": "CLOSED",
      "author": "D-Sinus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Cause I'm quite new to ECH, I'm little bit confused when reading this draft.\r\nSo I want to ask some questions...\r\n\r\nParagraph 7.1. Sending an encrypted ClientHello says...\r\n> pkR = HPKE.KEM.Unmarshal(ECHConfig.public_key)\r\n> enc, context = SetupBaseS(pkR, \"tls13-ech\")\r\n> ech_nonce_value = context.Export(\"tls13-ech-nonce\", 16)\r\n> ech_hrr_key = context.Export(\"tls13-ech-hrr-key\", 16)\r\n\r\nQ1. Is 'Unmarshal()' above equal to general meaning of unmarshalling -get public key from ECHConfig structure- ?\r\nQ2. I think 'hrr' in the fourth line is the abbreviation of 'HelloRetryRequest', is it correct? If so, could you add some explanation about that?",
      "createdAt": "2020-09-02T05:53:02Z",
      "updatedAt": "2020-09-03T13:49:24Z",
      "closedAt": "2020-09-03T13:49:24Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Q1: It should be defined in the HPKE draft, though it looks like the HPKE draft has since renamed it and it should probably say Deserialize now.\r\nhttps://cfrg.github.io/draft-irtf-cfrg-hpke/draft-irtf-cfrg-hpke.html#name-cryptographic-dependencies\r\n\r\nQ2: hrr is HelloRetryRequest, yes. The use of the key is described later on in the HelloRetryRequest section.\r\nhttps://tlswg.org/draft-ietf-tls-esni/draft-ietf-tls-esni.html#section-7.3.3",
          "createdAt": "2020-09-02T15:50:55Z",
          "updatedAt": "2020-09-02T15:50:55Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Q1. Is 'Unmarshal()' above equal to general meaning of unmarshalling -get public key from ECHConfig structure- ?\r\n\r\nThe first line appears to be pseudocode for \"interpret `ECHConfig.public_key` as a public key for the KEM algorithm identified by `ECHConfig.kem_id`. IMO we should get rid of this pseudocode and say what `pkR` is.\r\n\r\n> Q2. I think 'hrr' in the fourth line is the abbreviation of 'HelloRetryRequest', is it correct? If so, could you add some explanation about that?\r\n\r\n@davidben beat me to it!",
          "createdAt": "2020-09-02T15:52:33Z",
          "updatedAt": "2020-09-02T15:53:09Z"
        },
        {
          "author": "D-Sinus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oh, it was Deserialize()... thanks!",
          "createdAt": "2020-09-03T02:05:04Z",
          "updatedAt": "2020-09-03T02:05:04Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as resolved. ",
          "createdAt": "2020-09-03T13:49:24Z",
          "updatedAt": "2020-09-03T13:49:24Z"
        }
      ]
    },
    {
      "number": 295,
      "id": "MDU6SXNzdWU2OTExMzk0OTg=",
      "title": "Greasing to supporting servers",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/295",
      "state": "CLOSED",
      "author": "wbl",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "@cjpatton and I were sitting down and thinking and we realized the following scenario can happen:\r\n\r\n1. example.com is on hosting.com, which supports ECH\r\n1. example.com has an HTTPS record, an A record, AAAA record pointing at the IP for hosting.com\r\n1. A user of a browsers latest release that supports ECH and greases the extension is using a resolver that doesn't resolve HTTPS records\r\n\r\nThis results in an ECH request being made with SNI=example.com, and a rejection of the ECH. So now the question is what the client should do and what should servers expect?\r\n* Try again, with the outer SNI the one matching the one in the new config\r\n* Use the connection authoritatively for example.com since the connection has already revealed the issue.\r\n\r\n",
      "createdAt": "2020-09-02T15:52:47Z",
      "updatedAt": "2020-10-05T15:28:21Z",
      "closedAt": "2020-10-05T15:28:21Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "The intention was the latter, but the text could probably be clearer. I don't think there's much point in trying again since the name has already been revealed. See https://github.com/tlswg/draft-ietf-tls-esni/issues/274#issuecomment-680182501",
          "createdAt": "2020-09-02T15:57:46Z",
          "updatedAt": "2020-09-02T15:57:46Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@wbl is this still an issue now that #287 is merged?",
          "createdAt": "2020-09-22T21:30:41Z",
          "updatedAt": "2020-09-22T21:30:41Z"
        },
        {
          "author": "wbl",
          "authorAssociation": "NONE",
          "body": "I think the client behavior remains equally unspecified. In particular the lengthy argument @cjpatton and I had about server enforcement of the client behavior I think isn't changed.",
          "createdAt": "2020-09-22T22:23:42Z",
          "updatedAt": "2020-09-22T22:23:42Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Care to file a PR, presuming the latter behavior is intended?",
          "createdAt": "2020-09-22T22:36:18Z",
          "updatedAt": "2020-09-22T22:36:18Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A proposed resolution is here: #319.",
          "createdAt": "2020-10-01T01:26:41Z",
          "updatedAt": "2020-10-01T01:26:41Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@wbl, a proposed fix has been merged. See #321.",
          "createdAt": "2020-10-01T17:38:21Z",
          "updatedAt": "2020-10-01T17:38:21Z"
        },
        {
          "author": "wbl",
          "authorAssociation": "NONE",
          "body": "I think this text works.",
          "createdAt": "2020-10-05T15:28:19Z",
          "updatedAt": "2020-10-05T15:28:19Z"
        }
      ]
    },
    {
      "number": 297,
      "id": "MDU6SXNzdWU2OTEzMzQ0ODQ=",
      "title": "Proposal: Add version indication to ClientEncryptedCH",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/297",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The ECH version is negotiated as follows: the server indicates which versions of ECH it supports by advertising a configuration for each supported version, and the client selects the version by selecting a configuration. The selected configuration is currently indicated by `ClientEncryptedCH.config_digest`.\r\n\r\nThe `ClientEncryptedCH` structure is defined as follows:\r\n```\r\n      struct {\r\n          HpkeCipherSuite suite;\r\n          opaque config_digest<0..2^16-1>;\r\n          opaque enc<1..2^16-1>;\r\n          opaque encrypted_ch<1..2^16-1>;\r\n      } ClientEncryptedCH;\r\n```\r\n\r\nBecause the negotiated version is determined by the configuration, future versions of ECH that change the structure of `ClientEncryptedCH` --- in particular, the way the selected configuration is indicated--- will break backwards compatibility. Therefore, I would like to propose adding the ECH version to to this structure.",
      "createdAt": "2020-09-02T18:54:50Z",
      "updatedAt": "2020-09-18T21:32:49Z",
      "closedAt": "2020-09-18T21:32:49Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh nice catch. I agree that the versioning scheme doesn't work here, though our experience adding extension points inside extension points has not been good. Implementations keep messing them up and we lose the extension point anyway. (\"Have one joint and keep it well-oiled.\")\r\n\r\nDo we actually need the versioning scheme after the draft is done? If it weren't for the SVCB code point, I would say we should simply pick different extension code points for each deployed draft. But perhaps we should just do that for the SVCB code point too? If we did that, would we need versions in the first place?",
          "createdAt": "2020-09-02T19:00:38Z",
          "updatedAt": "2020-09-02T19:00:38Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Well, strictly speaking they will only do so if they break the first two fields, right? Because the rest can be conditioned on the config_digest.",
          "createdAt": "2020-09-03T14:13:28Z",
          "updatedAt": "2020-09-03T14:13:28Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "True, but to @davidben's point, I wonder if versioning ECHConfigContents is necessary. Would it be sufficient to update the code point for the draft whenever this changes?",
          "createdAt": "2020-09-03T14:41:41Z",
          "updatedAt": "2020-09-03T15:31:19Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Unless we advertise the version here, we're committing to the first two fields being the same in future versions. Unless we anticipate these changing, let's stick with the status quo.",
          "createdAt": "2020-09-03T18:04:37Z",
          "updatedAt": "2020-09-03T18:04:37Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Each HPKE suite has a fixed-length key encapsulation (`Nenc`), so the length field of `enc` is redundant.  If we concatenate `enc` and `encrypted_ch` into a single opaque field, that might be more future-proof.",
          "createdAt": "2020-09-04T17:01:18Z",
          "updatedAt": "2020-09-04T17:01:18Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't see how that helps, since the fields that can't change are cipher_suties and config_id.",
          "createdAt": "2020-09-04T17:10:36Z",
          "updatedAt": "2020-09-04T17:10:36Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "By way of addressing this issue, I've created a PR that \"locks\" ECHConfig.version to the extension code point. https://github.com/tlswg/draft-ietf-tls-esni/pull/303\r\n\r\nThis provides an unambiguous signal of which version of ECH is selected by the client.",
          "createdAt": "2020-09-18T21:22:37Z",
          "updatedAt": "2020-09-18T21:22:45Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure the choice of code point (ff08) is available. I picked it because it reflects the next draft (08).",
          "createdAt": "2020-09-18T21:23:22Z",
          "updatedAt": "2020-09-18T21:23:22Z"
        }
      ]
    },
    {
      "number": 300,
      "id": "MDU6SXNzdWU2OTM1OTkwNjI=",
      "title": "Proposal: remove 'length' field from ECHConfig",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/300",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The current structure is:\r\n```\r\n    struct {\r\n        uint16 version;\r\n        uint16 length;\r\n        select (ECHConfig.version) {\r\n          case 0xff07: ECHConfigContents;\r\n        }\r\n    } ECHConfig;\r\n```\r\n\r\nThe length is meant to indicate the length the (unnamed) field that follows it. But because we know how to parse the remainder of the structure based on the version, this field doesn't seem necessary to me. I'd like to suggest we drop it.\r\n```\r\n    struct {\r\n        uint16 version;\r\n        select (ECHConfig.version) {\r\n          case 0xff08: ECHConfigContents contents;\r\n        }\r\n    } ECHConfig;\r\n```\r\n\r\nNote that I've also advanced the version number and named the last field `contents`.",
      "createdAt": "2020-09-04T20:38:57Z",
      "updatedAt": "2020-09-10T12:11:27Z",
      "closedAt": "2020-09-10T12:11:27Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "The length field is necessary for an ECHConfigs (what actually goes in DNS) to be parsable. Otherwise you don't know how to skip over configs you don't recognize.\r\n\r\n```\r\n  ECHConfig ECHConfigs<1..2^16-1>;\r\n```\r\n\r\nIf we got rid of it, we'd need to switch to allocating separate SVCB code points per version, at which point the ECH-level versioning should go away altogether. (Which I would actually be in favor of, but I think people didn't like the idea of allocating SVCB code points every time we want to do a deployment snapshot or otherwise change the wire format.)",
          "createdAt": "2020-09-05T00:00:44Z",
          "updatedAt": "2020-09-05T00:00:44Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The length field is necessary for an ECHConfigs (what actually goes in DNS) to be parsable.\r\n\r\nWell, the version effectively determines the length of the next ECHConfig in the ECHConfigs, right? \r\n\r\nEDIT: What's weird about the current design is that to read the next config in the ECHConfigs, you have to first inspect the version, then you determine the length of the remainder. The length field is redundant, since the version is determines the length.\r\n\r\n> ... , at which point the ECH-level versioning should go away altogether. \r\n\r\nI'm in favor of keeping the version field in the ECHConfig, as this will make our deployment easier.",
          "createdAt": "2020-09-08T17:04:07Z",
          "updatedAt": "2020-09-08T17:17:11Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "The version determines the length, but only if you know the version. If you're consuming an ECHConfigs and want to pick a common version between you and the server, you'll need to account for versions you don't understand and correctly skip over them.",
          "createdAt": "2020-09-09T22:27:52Z",
          "updatedAt": "2020-09-09T22:27:52Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Right you are! Thanks for setting me straight.\r\n\r\nWe can close this issue.",
          "createdAt": "2020-09-09T23:32:49Z",
          "updatedAt": "2020-09-09T23:32:49Z"
        }
      ]
    },
    {
      "number": 301,
      "id": "MDU6SXNzdWU2OTU1NTMyMzc=",
      "title": "Question about encrypted_ch and encrypted_ch_inner",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/301",
      "state": "CLOSED",
      "author": "D-Sinus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "While reading the draft, I'm confused with ClientEncryptedCH structure.\r\n\r\nSection : The \"encrypted_client_hello\" extension says...\r\n\r\n~~~~\r\n    struct {\r\n       HpkeCipherSuite cipher_suite;\r\n       opaque config_id<0..255>;\r\n       opaque enc<1..2^16-1>;\r\n       opaque encrypted_ch<1..2^16-1>;\r\n    } ClientEncryptedCH;\r\n~~~~\r\n>enc : The HPKE encapsulated key, used by servers to decrypt the corresponding `encrypted_ch` field.\r\n>encrypted_ch : The serialized and encrypted ClientHelloInner structure, encrypted using HPKE as described in {{send-ech}}.\r\n\r\nand Section : Sending an encrypted ClientHello says...\r\n\r\n>The encrypted ClientHello value is then computed as:\r\n\r\n~~~~\r\n    encrypted_ch = context.Seal(\"\", ClientHelloInner)\r\n~~~~\r\n\r\nCause output of the context.Seal() function is ciphertext output of AEAD encryption (According to draft-irtf-cfrg-hpke-05),\r\nI think encrypted_ch has only ciphertext value of the ClientHelloInner, not the enc value.\r\nBut the same section also says...\r\n>encrypted_ch contains the HPKE encapsulated key (enc) and the ClientHelloInner ciphertext (encrypted_ch_inner).\r\n\r\nQ. Does encrypted_ch have enc and encrypted_ch_inner?\r\nOr it just has the ciphertext of ClientHelloInner and encrypted_ch_inner is just mistype?\r\n",
      "createdAt": "2020-09-08T05:13:32Z",
      "updatedAt": "2020-09-18T21:11:14Z",
      "closedAt": "2020-09-18T21:11:14Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Nice catch! `encrypted_ch` should just be the AEAD ciphertext. The following text is wrong:\r\n\r\n> - encrypted_ch contains the HPKE encapsulated key (enc) and the ClientHelloInner                                                                                             \r\n  ciphertext (encrypted_ch_inner).\r\n\r\nIt should be:\r\n\r\n> - encrypted_ch contains the AEAD-encrypted ClientHelloInner.\r\n\r\ncc/ @chris-wood",
          "createdAt": "2020-09-08T21:26:01Z",
          "updatedAt": "2020-09-08T21:26:01Z"
        },
        {
          "author": "D-Sinus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK, there's no `encrypted_ch_inner`.. thanks!",
          "createdAt": "2020-09-10T03:35:28Z",
          "updatedAt": "2020-09-10T03:35:28Z"
        }
      ]
    },
    {
      "number": 307,
      "id": "MDU6SXNzdWU3MDY2ODMzODU=",
      "title": "Add note on network/transport failure probability and ECH confirmation collision",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/307",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See https://github.com/tlswg/draft-ietf-tls-esni/pull/287#discussion_r492802148.",
      "createdAt": "2020-09-22T20:49:24Z",
      "updatedAt": "2020-10-07T14:35:46Z",
      "closedAt": "2020-10-07T14:35:46Z",
      "comments": []
    },
    {
      "number": 309,
      "id": "MDU6SXNzdWU3MTA0NjUyOTM=",
      "title": "Ensuring 1.3 is used when ECH is accepted",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/309",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Usage of 1.3 is enforced by the following rules.\r\n\r\n* Client (Section 6.1):\r\n    > It MUST offer to negotiate TLS 1.3 or above [in ClientHelloOuter]. [...] It MUST NOT offer to negotiate TLS 1.2 or below [in ClientHelloInner].\r\n\r\n* Client-facing server (7.1):\r\n    > Upon receiving an \"encrypted_client_hello\" extension, the client-facing server MUST check that it is able to negotiate TLS 1.3 or greater. If not, it MUST abort the connection with a \"handshake_failure\" alert.\r\n\r\n* The backend server does not enforce 1.3 usage. (At least, I couldn't find an explicit rule in the text.)\r\n\r\nRequiring that 1.3 is the only version offered in the ClientHelloInner is sufficient to ensure that 1.3 is negotiated by the client and backend server in case of acceptance. However, my sense is that the client would be easier to implement if this rule were softened to:\r\n\r\n> It MUST offer to negotiate TLS 1.3 in the ClientHelloInner.\r\n\r\nWe could then add the following behavior to the backend server (Section 7.2):\r\n\r\n> If the ClientHelloInner indicates ECH was accepted [i.e., there is an empty \"encrypted_client_hello\" extension in the ClientHello], but the client does not offer support for TLS 1.3 or above, then the backend server MUST abort the handshake with a \"[some error]\" alert.\r\n\r\nWhat do y'all think?",
      "createdAt": "2020-09-28T17:54:54Z",
      "updatedAt": "2020-10-01T15:59:12Z",
      "closedAt": "2020-09-30T16:09:48Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm happy to put together a PR if folks are happy with this change.",
          "createdAt": "2020-09-28T17:55:35Z",
          "updatedAt": "2020-09-28T17:55:35Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't feel strongly either way. I actually hadn't realized the client was already forbidden from offering TLS 1.2. The server needs to check anyway, and it's much more natural to check the negotiated version, so I don't think it helps the server in either direction. (@dmcardle since we were talking about this recently.)\r\n\r\nThere's no real reason for the client to offer TLS 1.2 in the inner ClientHello, and it could send a potentially smaller ClientHello (fewer cipher suites, omit renegotiation_info, extended_master_secret, shorter supported_versions). One footnote is a shorter supported_versions is still more bytes than a compressed supported_versions, but I think the savings elsewhere exceed that. (At least for now. Maybe 10 years from now, there will be very few TLS 1.2 ciphers and very many post-TLS-1.2 versions before TLS 1.2 is gone??)\r\n\r\nI guess the other factor is it may also be more convenient for the client not to have juggle two different min_version values around in its ClientHello construction logic. But I feel like the client should decide based on how many bytes it takes on the wire.",
          "createdAt": "2020-09-28T18:10:12Z",
          "updatedAt": "2020-09-28T18:10:12Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @davidben: The server needs to check anyway, and it's much more natural to check the negotiated version, so I don't think it helps the server in either direction.\r\n\r\nWhich server? the client-facing server or the backend server? AFAICT the backend server doesn't currently enforce the version.",
          "createdAt": "2020-09-28T18:13:47Z",
          "updatedAt": "2020-09-28T18:13:47Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I mostly do not believe in split mode, but I suppose it'd be the client-facing server. I suppose that's a little odd since the client-facing server isn't the one that negotiates a version. But either way, both the existing text and your proposed replacement discusses the negotiated version.",
          "createdAt": "2020-09-28T18:16:40Z",
          "updatedAt": "2020-09-28T18:16:40Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would favor relaxing the requirement on the client side and having the backend server abort if 1.3 isn't offered. It seems conceptually cleaner, since it reduces the amount of things one has to think about when constructing the ClientHelloInner.",
          "createdAt": "2020-09-28T21:37:23Z",
          "updatedAt": "2020-09-28T21:37:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I would favor relaxing the requirement on the client side and having the backend server abort if 1.3 isn't offered. It seems conceptually cleaner, since it reduces the amount of things one has to think about when constructing the ClientHelloInner.\r\n\r\nI would argue that this is *less* clean, since it requires us to also specify client behavior in the event of a 1.2 SH (which could maliciously be inserted by someone between the client-facing and backend server). Beyond that, I don't see why prohibiting everything below 1.3 in ClientHelloInner is cleaner. This is a protocol for TLS 1.3, so why continue adding legacy cruft where it can't possibly be used?",
          "createdAt": "2020-09-29T00:45:36Z",
          "updatedAt": "2020-09-29T00:45:36Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\r\n> I would argue that this is _less_ clean, since it requires us to also specify client behavior in the event of a 1.2 SH (which could maliciously be inserted by someone between the client-facing and backend server).\r\n\r\nGood point!\r\n\r\n> This is a protocol for TLS 1.3, so why continue adding legacy cruft where it can't possibly be used?\r\n\r\nThe idea is that it would make implementing the client easier. I don't have a strong opinion either way, so I'm happy to drop this and go with the status-quo.\r\n\r\n",
          "createdAt": "2020-09-29T15:45:29Z",
          "updatedAt": "2020-09-29T15:45:29Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In fact, @chris-wood's observations means it's probably a wash :/",
          "createdAt": "2020-09-29T15:55:09Z",
          "updatedAt": "2020-09-29T15:55:09Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing as resolved. No action taken.",
          "createdAt": "2020-09-30T16:09:48Z",
          "updatedAt": "2020-09-30T16:09:48Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "#319 made me realize there's more weird things around the version text. The client-facing server text doesn't even make sense because it's a check on the outer ClientHello, rather than the inner ClientHello. This means that actually no checks on the server side ensure we don't accidentally negotiate TLS 1.2 and leak the server name, and the client text in 6.1 is actually load-bearing.\r\n\r\nI'll upload a PR to fix up the 7.1 text. Maybe also worth an optional sanity-check in Shared Mode? Not sure.",
          "createdAt": "2020-10-01T15:59:12Z",
          "updatedAt": "2020-10-01T15:59:12Z"
        }
      ]
    },
    {
      "number": 310,
      "id": "MDU6SXNzdWU3MTA0NzY0NTY=",
      "title": "legacy_session_id should match between inner and outer",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/310",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "If the client uses TLS 1.3's [middlebox compatibility mode](https://tools.ietf.org/html/rfc8446#appendix-D.4), there are a couple subtle points:\r\n\r\n* Even though the middlebox will never see the inner ClientHello, we still need a non-empty legacy_session_id, because some servers use that value to condition the other bits.\r\n\r\n* More importantly, the inner legacy_session_id needs to match the outer legacy_session_id! Otherwise the server will echo back the wrong one and trip up all the buggy middleboxes again.\r\n\r\nAlternatively, we could say the server uses the outer ClientHello to negotiate middlebox compatibility mode. That would reduce bytes on the wire, but it'd upset all the split mode arrangements.",
      "createdAt": "2020-09-28T18:14:05Z",
      "updatedAt": "2020-09-29T00:46:06Z",
      "closedAt": "2020-09-29T00:46:06Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Good catch. I'd be fine with this matching constraint. Could you please propose text?",
          "createdAt": "2020-09-28T20:27:46Z",
          "updatedAt": "2020-09-28T20:27:46Z"
        }
      ]
    },
    {
      "number": 322,
      "id": "MDU6SXNzdWU3MTMyMzQ3MzY=",
      "title": "Tidy up all codepoints before -08",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/322",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Note to self. Let's pick a set and range that works.",
      "createdAt": "2020-10-01T22:53:36Z",
      "updatedAt": "2020-10-16T18:57:12Z",
      "closedAt": "2020-10-16T18:57:12Z",
      "comments": []
    },
    {
      "number": 323,
      "id": "MDU6SXNzdWU3MTUyMjYyMTA=",
      "title": "Re-re-visit outer ClientHello binding (saves 65 bytes)",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/323",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We previously decided not to bind the outer ClientHello to the ECH decryption, because doing so is rather a hassle. We'd need something similar to the TLS 1.3 PSK binder mess, with the added complexity of ordering relative to the PSK binders themselves. Additionally, while the binding helps with some of the don't stick out properties, there were other attacks on distinguishability anyway. So, instead, we mitigated the inner ClientHello malleability with OuterExtensions.inner_digest and left the outer ClientHello unbound.\r\n\r\nHowever, we've since decided not to allow PSKs in the outer ClientHello. Perhaps we should revisit this. Suppose the AD parameter to the ECH decryption were the entire outer ClientHello, minus the ECH extension. I believe this means we no longer need OuterExtensions.inner_digest. That would give an immediate 33-byte savings. It would then unlock a further 32 byte savings by amending #312 to say:\r\n\r\n* Client always encodes an empty legacy_session_id in ECH plaintext.\r\n* Client-facing server copies outer legacy_session_id to inner ClientHello as part of decompression.\r\n\r\n(The reason we can't do this easily right now is that, if the inner ClientHello lacks outer_extension, nothing's authenticating legacy_session_id. Since the field in TLS 1.3 is all but ignored, it's \"obvious\" that the malleability doesn't matter, but it's nicer to not need to think about such things.)\r\n\r\nFrom looking at Chrome's ClientHellos and working through what we'd send (drop 1.2-only extensions, compress most), it looks like the inner ClientHello will be maybe 130-140 bytes, plus a padded server_name. The 65 bytes above would almost halve the overhead.\r\n\r\nIn some sense what's going on here is our 16-byte tag on the AEAD in the ECH ciphertext is going to waste. We didn't authenticate everything that goes into reconstructing the inner ClientHello (outer_extensions), so instead we authenticate another hash (OuterExtensions.inner_digest) and check that afterwards. (To that end, if we do this, we probably need to say the server MUST reject encrypted_client_hello showing up in outer_extensions, that way all inputs to decompression are authenticated. Equivalently, decompression is done relative to the ECH-extension-less AD input rather than the original outer ClientHello.)",
      "createdAt": "2020-10-05T23:22:06Z",
      "updatedAt": "2020-10-16T18:57:52Z",
      "closedAt": "2020-10-16T18:57:52Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like this idea. How do you think the AD ought to be structured? The ClientHelloOuter, but with an an empty \"encrypted_client_hello\" extension?",
          "createdAt": "2020-10-07T16:46:27Z",
          "updatedAt": "2020-10-07T16:46:27Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, that's seems the simplest to me. Filling it with zeros, as @bemasc pointed out to me, requires predicting the length of the encrypted inner ClientHello. This isn't strictly impossible (ADs don't change ciphertext length), but it seems needlessly fussy and ECH is already requiring we be able re-encode ClientHellos, lengths and all.\r\n\r\nNote this assumes there are no computed PSK binders in the outer ClientHello because otherwise there's a circular dependency. (If we wanted to allow that, the AD would need to zero/trim the binders or so.)",
          "createdAt": "2020-10-07T17:50:14Z",
          "updatedAt": "2020-10-07T17:50:14Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Another benefit is it stops the attacker from probing information about compressed extensions. Currently an attacker can learn which extensions are compressed in the inner ClientHello by removing them from the outer ClientHello and seeing if the server still responds. This isn't a huge deal, as compressed extensions are assumed public, but this way we remove that vector and leave only the fuzzier signal from the ciphertext length.",
          "createdAt": "2020-10-07T21:41:00Z",
          "updatedAt": "2020-10-07T21:41:00Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> Filling it with zeros, as @bemasc pointed out to me, requires predicting the length of the encrypted inner ClientHello. This isn't strictly impossible (ADs don't change ciphertext length), but it seems needlessly fussy and ECH is already requiring we be able re-encode ClientHellos, lengths and all.\r\n\r\nOn second thought, a lot of implementations will need to do that prediction anyway. The workaround for the old F5 bug means we'll need to know the eventual size for the padding extension. (On the other hand, you can probably assume anyone doing ECH is not running those things. On the other hand, turning off the workaround would stick out.) Ah well. We did it for PSK already.\r\n\r\n(I wonder if we can do drop that workaround now that TLS 1.0 and 1.1 are gone...)",
          "createdAt": "2020-10-08T01:16:40Z",
          "updatedAt": "2020-10-08T01:16:40Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What's the \"old F5 bug\"?\r\nWhat's the value in authenticating the length of the \"encrypted_client_hello\" extension? This is authenticated by the handshake already, no?",
          "createdAt": "2020-10-08T22:23:55Z",
          "updatedAt": "2020-10-08T22:23:55Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> What's the \"old F5 bug\"?\r\n\r\nhttps://www.imperialviolet.org/2013/10/07/f5update.html\r\nhttps://mailarchive.ietf.org/arch/msg/tls/8wXwhM1d5WSmROHFSgrTyFmWN2o/\r\nIt's why we have a padding extension.\r\n\r\n> What's the value in authenticating the length of the \"encrypted_client_hello\" extension? This is authenticated by the handshake already, no?\r\n\r\nThere isn't. It's just a question of what's easier to deal with. Filling it with zeros means that, when computing the AD on the receiving side, you don't need to fully reconstruct a modified outer ClientHello with updated length prefixes. We avoided this when computing the PSK binder in RFC8446.\r\n\r\nIt's a mild hassle but not a huge deal. More importantly, we've thoroughly given up on that elsewhere in the spec. The F5 padding business also means computing this AD will likely take some length prediction anyway, but so it goes.",
          "createdAt": "2020-10-09T02:10:16Z",
          "updatedAt": "2020-10-09T02:21:18Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree, it's not a big hassle.",
          "createdAt": "2020-10-09T15:23:53Z",
          "updatedAt": "2020-10-09T15:23:53Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I like this idea. How do you think the AD ought to be structured? The ClientHelloOuter, but with an an empty \"encrypted_client_hello\" extension?\r\n\r\nRather than make the extension empty, can we just omit the `enc` and `payload` fields? (The `cipher_suite` and `config_id` should arguably be included, a la #326).",
          "createdAt": "2020-10-09T15:57:29Z",
          "updatedAt": "2020-10-09T15:57:29Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "That works, though it's even more fussy for the client to construct, since it needs to half-encode the ECH extension before fully encoding it.\r\n\r\n`cipher_suite` is already bound into HPKE itself. `config_id` is less clear, but I thought our model already said all this didn't matter? Isn't the binding here just to replace `inner_digest` and provide malleability? If there's something more going on, I'd like us to have some principled answer here, so we can answer questions like... what about the handshake transcript, which may not be empty on HRR? If we do that, what's going on with ech_hrr_key?",
          "createdAt": "2020-10-09T17:23:12Z",
          "updatedAt": "2020-10-09T17:23:12Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The principle I was following is: include as much as possible in the AD. Yeah, it's more of a pain, and we've gotten away with *no* binding whatsoever up to now, so maybe we don't need it. I'm happy to start with an empty ECH extension and then consider the other parts later, if that'll help.",
          "createdAt": "2020-10-09T18:51:55Z",
          "updatedAt": "2020-10-09T18:51:55Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't feel very strongly either way.",
          "createdAt": "2020-10-09T18:57:14Z",
          "updatedAt": "2020-10-09T18:57:14Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's just do the simpler thing now, then! :-)",
          "createdAt": "2020-10-09T21:06:07Z",
          "updatedAt": "2020-10-09T21:06:07Z"
        }
      ]
    },
    {
      "number": 324,
      "id": "MDU6SXNzdWU3MTUyNTk1NTM=",
      "title": "Clarify that CHInner ECH payload contents",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/324",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Unless I missed it, nowhere in the spec does it say that clients SHOULD/MUST send an empty ECH extension in CHInner (to trigger the confirmation signal). Should we add this?\r\n\r\ncc @davidben, @cjpatton",
      "createdAt": "2020-10-06T00:57:38Z",
      "updatedAt": "2020-10-07T16:55:04Z",
      "closedAt": "2020-10-07T16:55:04Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is covered in Section 5: \r\n> When offering the \"encrypted_client_hello\" extension in its ClientHelloOuter, the client MUST also offer an empty \"encrypted_client_hello\" extension in its ClientHelloInner, wherever applicable. (This requirement is not applicable when the extension is generated as described in Section 6.4.)",
          "createdAt": "2020-10-07T16:49:23Z",
          "updatedAt": "2020-10-07T16:49:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, thank you! Closing.",
          "createdAt": "2020-10-07T16:55:04Z",
          "updatedAt": "2020-10-07T16:55:04Z"
        }
      ]
    },
    {
      "number": 325,
      "id": "MDU6SXNzdWU3MTUyNjAxMjY=",
      "title": "Specify cross-HRR key rotation issue(s)",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/325",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "If a server implements ECH decryption via an RPC call, it's possible for the client's ECH keys to be valid for CH1 but invalid for CH2, perhaps due to a race condition that updates the server's keys across these messages. This should be exceedingly rare in practice, so failing the connection with an alert is probably fine, but we should probably be clear about this.\r\n\r\ncc @cjpatton ",
      "createdAt": "2020-10-06T00:59:13Z",
      "updatedAt": "2020-10-16T15:29:11Z",
      "closedAt": "2020-10-16T15:29:11Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There are two ways a accept-then-HRR-then-reject can happen:\r\n1. The client sends a `config_id` after HRR that differs from the `config_id` it sent before HRR.\r\n1. The `config_id` is the same, but the server no longer recognizes it.\r\n\r\nThe latter is the server's fault, and I think the only thing to do is abort with \"internal_error\". However, I think requiring that the `config_id` doesn't change is a good idea. I wonder if this is implied by the client behavior?\r\n\r\n> If the server sends a HelloRetryRequest in response to the ClientHello, the client sends a second updated ClientHello per the rules in [RFC8446]. However, at this point, the client does not know whether the server processed ClientHelloOuter or ClientHelloInner, and MUST regenerate both values to be acceptable. Note: if the inner and outer ClientHellos use different groups for their key shares or differ in some other way, then the HelloRetryRequest may actually be invalid for one or the other ClientHello, in which case a fresh ClientHello MUST be generated, ignoring the instructions in HelloRetryRequest. Otherwise, the usual rules for HelloRetryRequest processing apply.\r\n\r\nIn any case, I think we should have the server abort with \"illegal_parameter\" if the `config_id` changes over HRR.",
          "createdAt": "2020-10-07T17:01:01Z",
          "updatedAt": "2020-10-07T17:01:01Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Is this any different from, say, the server's cipher suite capabilities changing in between CH1 and CH2 and thus the server not being able to meet what they said with HRR?\r\n\r\nI guess I've always assumed that, within the context of a single \"handshake\" from the perspective of the client, we expect the server to behave self-consistently and, if it can't, I guess the server can internal_error and live with failing one or two connections across server restarts.",
          "createdAt": "2020-10-07T17:40:48Z",
          "updatedAt": "2020-10-07T17:40:48Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Is this any different from, say, the server's cipher suite capabilities changing in between CH1 and CH2 and thus the server not being able to meet what they said with HRR?\r\n\r\nI think this is a little different, since it can be triggered by changing the set of ECHConfigs the server knows, and not necessarily the set of cipher suites.\r\n\r\n> I guess I've always assumed that, within the context of a single \"handshake\" from the perspective of the client, we expect the server to behave self-consistently and, if it can't, I guess the server can internal_error and live with failing one or two connections across server restarts.\r\n\r\nI agree. And even though the situation is a bit different, I think \"internal_error\" is appropriate here as well. However, I also think the client SHOULD NOT change the ECHConfig across HRR. If it does, I think the server SHOULD abort with \"illegal_paramter\". \r\n\r\nDo you think this would be hard for the server to enforce? In particular, a QUIC server might want to handle the HRR path statelessly, and this check requires remembering the previous `config_id`.\r\n\r\n",
          "createdAt": "2020-10-08T20:08:56Z",
          "updatedAt": "2020-10-08T20:08:56Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> However, I also think the client SHOULD NOT change the ECHConfig across HRR.\r\n\r\nI think that's already true. The client can't change things across HRR unless explicitly allowed. (https://tools.ietf.org/html/rfc8446#section-4.1.2)\r\n\r\n> If it does, I think the server SHOULD abort with \"illegal_parameter\".\r\n\r\nExactly what the server enforces on HRR is... all over the place. I'm normally in favor of maximal enforcement, but enforcing all the rules of HRR is such a mess. It's especially messy for folks who do stateless HRR, because any state carried over across the two increases the size of the cookie. So I think we need to be a little careful here. Honestly, I think we didn't really get HRR right.\r\n\r\n> In particular, a QUIC server might want to handle the HRR path statelessly, and this check requires remembering the previous config_id.\r\n\r\nQUIC does not care about stateless HRR. It did in the original design, but that's been dropped. DTLS does, though. And I believe NSS always implements it statelessly? (BoringSSL currently only does stateful.)",
          "createdAt": "2020-10-09T19:04:20Z",
          "updatedAt": "2020-10-09T19:04:20Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It sounds like a weak \"MAY\" would be most appropriate.",
          "createdAt": "2020-10-09T20:34:27Z",
          "updatedAt": "2020-10-09T20:34:27Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> It sounds like a weak \"MAY\" would be most appropriate.\r\n\r\nCan you elaborate?",
          "createdAt": "2020-10-11T11:27:20Z",
          "updatedAt": "2020-10-11T11:27:20Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Looking at this again, I suspect the minimal thing that needs to be checked across CH1 and CH2 is that the server cannot change its mind on whether it used ECH in CH2 and, if using ECH, it needs to have remembered ech_hrr_key (and HPKE cipher suites?) to bind the two. Dunno if it makes sense to just also remember the config_id at that point.",
          "createdAt": "2020-10-11T15:34:35Z",
          "updatedAt": "2020-10-11T15:34:35Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> , I suspect the minimal thing that needs to be checked across CH1 and CH2 is that the server cannot change its mind on whether it used ECH in CH2 and, if using ECH, it needs to have remembered ech_hrr_key (and HPKE cipher suites?) to bind the two. \r\n\r\nI agree, but I don't think tracking the `ech_hrr_key` is sufficient. Suppose the client sends an acceptable `config_id` in CH1 but a rejecting `config_id` in CH2. In this case `ech_hrr_key` doesn't provide the binding we need, since the client-facing server won't attempt to decrypt the payload in CH2.\r\n\r\nA conservative way to ensure the server doesn't change its mind is as follows:\r\n1. Require that the `cipher_suite` does not change across HRR. If it does, then abort with \"illegal_parameter\" alert.\\**\r\n1. Require that the `config_id` does not change across HRR. If it does, then abort with \"illegal_parameter\" alert.\r\n1. If `config_id` isn't recognized after HRR --- say because of key rotation -- then abort with \"internal_error\" alert.\r\n\r\n\\** I'm not sure 1. is strictly necessary. If the `cipher_suite` isn't supported by the ECH configuration, then the server would abort with \"illegal_parameter\". (This is already specified.) Moreover, I don't think we have any agility issues here, given that the derived AEAD key is bound to the cipher suite. However, this does ensure that the server chooses the HPKE cipher suite and KEM key in the same way before and after HRR. This may turn out to be useful.",
          "createdAt": "2020-10-12T23:07:42Z",
          "updatedAt": "2020-10-12T23:07:42Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> Suppose the client sends an acceptable config_id in CH1 but a rejecting config_id in CH2. In this case ech_hrr_key doesn't provide the binding we need, since the client-facing server won't attempt to decrypt the payload in CH2.\r\n\r\nRight, this is what I mean by \"the server cannot change its mind on whether it used ECH in CH2\". If you declined ECH in CH1, you ignore ECH in CH2. If you accepted ECH in CH1, failure to handle ECH in CH2 is fatal. But, yeah, if you remember the config used, you can check a bit more accurately, so maybe we should just do that and ask stateless HRRs make an even larger cookie. (Need to be a bit careful about `config_id` itself because we allow a trial decryption flow too.)",
          "createdAt": "2020-10-13T03:15:30Z",
          "updatedAt": "2020-10-13T03:22:24Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "For what it's worth, I'm not a huge fan of CH2 having a fresh HPKE exchange in the first place. That seems an unnecessary asymmetric operation. Were it not for stateless HRR, I think I'd advocate we just make CH2's ECH payload a second pop at the HPKE context's Seal() function (next sequence number), with the rest ignored. But with stateless HRR, we need to serialize the HPKE context into the cookie, which is mildly annoying.",
          "createdAt": "2020-10-13T03:21:19Z",
          "updatedAt": "2020-10-13T03:21:33Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't see how you can avoid CH2 having a new payload.  Unless you are looking to just perform address validation (DTLS), you only send HRR to correct something in the ClientHello.",
          "createdAt": "2020-10-13T03:25:59Z",
          "updatedAt": "2020-10-13T03:25:59Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @martinthomson: I don't see how you can avoid CH2 having a new payload. Unless you are looking to just perform address validation (DTLS), you only send HRR to correct something in the ClientHello.\r\n\r\nI think what @davidben means is that the AEAD ciphertext could change without changing the encapsulating key. Hence, the ClientHelloInner can be changed without updating the HPKE shared secret.\r\n\r\n> @davidben: But with stateless HRR, we need to serialize the HPKE context into the cookie, which is mildly annoying.\r\n\r\nWouldn't this leak the HPKE encryption key? The cookie extension is transmitted in the HRR in plaintext, right?\r\n\r\n",
          "createdAt": "2020-10-13T14:23:09Z",
          "updatedAt": "2020-10-13T14:24:39Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": ">> @martinthomson: I don't see how you can avoid CH2 having a new payload. Unless you are looking to just perform address validation (DTLS), you only send HRR to correct something in the ClientHello.\r\n>\r\n> I think what @davidben means is that the AEAD ciphertext could change without changing the encapsulating key. Hence, the ClientHelloInner can be changed without updating the HPKE shared secret.\r\n\r\nSpecifically, HPKE supports multiple sequential encryption calls on a context with an internal sequence number.\r\nhttps://cfrg.github.io/draft-irtf-cfrg-hpke/draft-irtf-cfrg-hpke.html#name-encryption-and-decryption\r\n\r\n>> @davidben: But with stateless HRR, we need to serialize the HPKE context into the cookie, which is mildly annoying.\r\n>\r\n> Wouldn't this leak the HPKE encryption key? The cookie extension is transmitted in the HRR in plaintext, right?\r\n\r\nThe cookie already needs to encrypted and authenticated by the server like tickets. It certainly needs to be authenticated independent of ECH, otherwise the attacker can manipulate it anyway. And then the existing ech_hrr_key construction requires encryption too.\r\n\r\n(If you didn't encrypt the cookie for some reason and only MAC'd it, this design would allow you to, rather than serializing the HPKE encryption key, remember the expected HPKE config, redo the KEM operation, and bump the sequence number up. But if you're remembering some secret for the MAC, may as well encrypt it...)",
          "createdAt": "2020-10-13T15:39:26Z",
          "updatedAt": "2020-10-13T15:39:26Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The cookie already needs to encrypted and authenticated by the server like tickets. \r\n\r\nRight, thanks for *again* clarifying a misunderstanding of mine about the TLS spec :)\r\n\r\nIncidentally, I brought up specifying HPKE context serialization here: https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/161. There doesn't seem to be a lot of appetite for it. I suppose we could specify it in ECH, but there are so many use cases for it that I think it would be worth specifying it in the HPKE draft.",
          "createdAt": "2020-10-13T16:12:19Z",
          "updatedAt": "2020-10-13T16:12:19Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Given the uncertainty about stateless HRR pointed out in #333, let's permit the client-facing server to abort if ECH usage changes after HRR. This allows stateful-HRR servers to enforce this behavior, but leaves it as an \"OPEN ISSUE\" about how stateful-hRR servers will enforce this.\r\n\r\nI'll prepare a PR tomorrow or Thursday.",
          "createdAt": "2020-10-13T20:53:18Z",
          "updatedAt": "2020-10-13T20:53:18Z"
        }
      ]
    },
    {
      "number": 326,
      "id": "MDU6SXNzdWU3MTUyNjA1MzA=",
      "title": "Include ECH context in ClientHelloOuterAAD",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/326",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@davidben mentions possibly binding the outer CH to the ECH encryption in #323. If we don't do that, we should at least bind the encryption to the non-encrypted parts of the ECH extension (`config_id`, `suite`, and so on).\r\n\r\ncc @cjpatton ",
      "createdAt": "2020-10-06T01:00:24Z",
      "updatedAt": "2020-11-18T23:57:21Z",
      "closedAt": "2020-11-18T23:57:21Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I also like this idea :) AD is cheap.",
          "createdAt": "2020-10-07T16:48:01Z",
          "updatedAt": "2020-10-07T16:48:01Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favor of #323. We can revisit the ECH extension AD information later if desired.",
          "createdAt": "2020-10-11T11:24:54Z",
          "updatedAt": "2020-10-11T11:24:54Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Re-opening to consider adding *all* data to AAD. @davidben wrote out the flow if we did this:\r\n\r\n- Make your CHInner. This should largely be running through your usual CH assembly logic.\r\n- Encode it with the extensions you expect to compress.\r\n- Make your CHOuter, minus the ECH extension. This should largely run through your existing CH assembly logic.\r\n- Run Deserialize and SetupBaseS.\r\n- Compute CHOuterAAD with half an ECH extension.\r\n- Take EncodedCHInner and CHOuterAAD and run through the context.Seal logic to assemble the final CHOuter.\r\n\r\nSo, not great, but also not too terrible. I'd prefer we avoid falling into the \"gee, I sure wish we bound more to the encryption\" state, given the history of ECH, though I agree that this isn't cheap. \r\n\r\n@ekr, what do you think?",
          "createdAt": "2020-11-04T19:33:34Z",
          "updatedAt": "2020-11-04T19:33:34Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To be clear, the suggestion is to change AEAD encryption so that it authenticates `ClientECH.cipher_suite`, `.config_id`, and `.enc`, correct? This change seems sensible to me. One might argue that this is redundant because these parameters are incorporated into the transcript (on ECH rejection). On the other hand, ECH usage is resolved before the transcript is known! It seems like a good idea to authenticate these parameters before consuming them.",
          "createdAt": "2020-11-04T19:43:31Z",
          "updatedAt": "2020-11-04T19:47:03Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "They aren't incorporated on ECH accept, which is mildly interesting. ECH accept also doesn't negotiate with them, so it's probably okay, though there is a \"don't stick out\" failure (depending on threat model) for the optional config_id flow if we don't authenticate them.",
          "createdAt": "2020-11-04T19:48:40Z",
          "updatedAt": "2020-11-04T19:48:40Z"
        }
      ]
    },
    {
      "number": 329,
      "id": "MDU6SXNzdWU3MTc4MDk1OTY=",
      "title": "ClientHello construction order is inconsistent",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/329",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I noticed this while drafting a PR for #323. We're a little inconsistent about whether the ClientHelloInner or ClientHelloOuter is constructed first.\r\n\r\nSection 4 says inner before outer:\r\n> When a client wants to establish a TLS session with the backend server, it constructs its ClientHello as usual (we will refer to this as the ClientHelloInner message) and then encrypts this message using the public key of the ECH configuration. It then constructs a new ClientHello (ClientHelloOuter)\r\n\r\nSection 5.1 implies inner before outer:\r\n> When sending ClientHello, the client first computes ClientHelloInner, including any PSK binders, and then MAY substitute extensions which it knows will be duplicated in ClientHelloOuter.\r\n\r\nBut section 6.1 says outer before inner:\r\n> Next, the client constructs the ClientHelloOuter message just as it does a standard ClientHello, with the exception of the following rules:\r\n> ...\r\n> The client then constructs the ClientHelloInner message just as it does a standard ClientHello, with the exception of the following rules:\r\n\r\nI think inner before outer makes more sense. You certainly can't finish the outer one before you've computed the inner one. (Of course, an implementation can pick whatever order is most convenient, but I think the spec should be consistent with itself.)",
      "createdAt": "2020-10-09T02:52:06Z",
      "updatedAt": "2020-10-11T11:22:43Z",
      "closedAt": "2020-10-11T11:22:43Z",
      "comments": []
    },
    {
      "number": 331,
      "id": "MDU6SXNzdWU3MTc4MTI3NjU=",
      "title": "Encoded vs actual ClientHelloInner is a little ambiguous",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/331",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "There are two ClientHelloInners, the actual one used in the handshake, and the encoded one with outer_extensions substituted in. Both are described as ClientHelloInner, but this makes it slightly ambiguous which goes into, say, the handshake transcript.\r\n\r\n(It's late now, so I'll leave this as an issue without a PR. If we don't end up resolving this separately, I'll probably fix this as part of #323. If we decide to implicitly copy over legacy_session_id, the encryption payload becomes less and less defensibly an actual ClientHelloInner.)",
      "createdAt": "2020-10-09T03:02:34Z",
      "updatedAt": "2020-10-14T20:07:50Z",
      "closedAt": "2020-10-14T20:07:50Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In my own implementation, I've been referring to the plaintext payload as CompressedClientHelloInner. Which is terrible, but unambiguous.",
          "createdAt": "2020-10-09T16:17:34Z",
          "updatedAt": "2020-10-09T16:17:34Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Works for me. I was thinking EncodedClientHelloInner because it's shorter and still works even if you choose not to compress anything. (A no-op encoding is still an encoding.)",
          "createdAt": "2020-10-09T16:33:46Z",
          "updatedAt": "2020-10-09T16:33:46Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 to EncodedClientHelloInner, given that compression is optional. @davidben, if you have time, could you whip up a PR?",
          "createdAt": "2020-10-11T11:24:13Z",
          "updatedAt": "2020-10-11T11:24:13Z"
        }
      ]
    },
    {
      "number": 333,
      "id": "MDU6SXNzdWU3MTg4NjY1OTM=",
      "title": "Stateless HRR and split mode",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/333",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "I was thinking about #316 and the discussion on server HRR checks started by https://github.com/tlswg/draft-ietf-tls-esni/issues/325#issuecomment-705796082, and I'm not sure HRR cookies even work in split mode right now. First off, suppose we don't merge something like #316. The current text says:\r\n\r\n> Note: if the inner and outer ClientHellos use different groups for\r\n> their key shares or differ in some other way, then the HelloRetryRequest may\t\r\n> actually be invalid for one or the other ClientHello, in which case a fresh\t\r\n> ClientHello MUST be generated, ignoring the instructions in HelloRetryRequest.\t\r\n> Otherwise, the usual rules for HelloRetryRequest processing apply\r\n\r\nThis means if you get a cookied HRR only good for ClientHelloInner, there's no requirement to stick the cookie in ClientHelloOuter! But now the client-facing server can't see the cookie, so it can't be stateless. It would seem like #316 fixes this, but now we have a more fundamental problem: whose cookie?\r\n\r\nSuppose the client-facing server wishes to handle HRR statelessly. It decrypts the first ClientHelloInner and forwards it to the backend server. If the backend server responds with HRR, the client-facing server must forward the HRR as-is, or the transcript breaks. But the client-facing server has no opportunity to bind its state (ech_hrr_key) into the HRR cookie. (Perhaps there isn't even one. If there is, it's encrypted with the backend server's key anyway. Either way, it's fixed now.)\r\n\r\nThe simplest solution to all this is to only support stateful client-facing servers in split mode, unless the client-facing and backend servers can coordinate enough to share one cookie. I don't know if that would satisfy everyone. I could imagine doing something horrific to HRR.cookie, akin to what we did to ServerHello.random, but that sounds really messy.",
      "createdAt": "2020-10-11T15:59:26Z",
      "updatedAt": "2021-04-22T02:12:59Z",
      "closedAt": "2021-04-22T02:12:59Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Let's mark this as an \"OPEN ISSUE\" in the draft.",
          "createdAt": "2020-10-13T20:46:03Z",
          "updatedAt": "2020-10-13T20:46:03Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> Let's mark this as an \"OPEN ISSUE\" in the draft.\r\n\r\nDone. https://github.com/tlswg/draft-ietf-tls-esni/pull/338",
          "createdAt": "2020-10-13T20:56:31Z",
          "updatedAt": "2020-10-13T20:56:31Z"
        }
      ]
    },
    {
      "number": 342,
      "id": "MDU6SXNzdWU3MjMzMjU4NTQ=",
      "title": "Consider shortening config_id to 8 bytes",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/342",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This matches the acceptance signal length, and we've already accepted that probability of collision.",
      "createdAt": "2020-10-16T15:34:13Z",
      "updatedAt": "2020-11-03T20:52:43Z",
      "closedAt": "2020-11-03T20:52:43Z",
      "comments": []
    },
    {
      "number": 348,
      "id": "MDU6SXNzdWU3MjQ5NzgxMjY=",
      "title": "Define separate codepoint (and name) for inner ECH extension",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/348",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It is unclear how a general TLS server is supposed to react to an ECH extension. It's sometimes empty and sometimes a ClientECH. An empty extension is not a valid ClientECH extension, so a server expending ClientECH should produce a `decode_error` (and vice versa).\r\n\r\nThe spec does talk about client-facing and backend servers as separate kinds of servers, but I thought the theory behind Split Mode was that backend servers were meant to be mostly standard TLS servers. That would suggest that backend-server-specific logic should be common to all TLS server implementations that know about ECH. In that case, perhaps we should say that:\r\n\r\n* The client ECH extension is either empty or a ClientECH structure.\r\n* If you see empty, this is an inner ClientHello. Do the ServerHello.random thing and otherwise handshake normally.\r\n* If you see non-empty and have ECHConfigs, parse as a ClientECH and decode_error on parse failure as usual. Do the client-facing server thing.\r\n\r\nOr is the idea that client-facing and backend servers are completely separate beasts and everyone always knows which they are? In that case, what happens if a client-facing server sees an empty ECH extension? What happens if a backend server sees a ClientECH-carrying ECH extension. Failure to parse an extension is normally fatal, but the two categories of server believe different parses are valid. In particular, this requires a backend server *never* see a general-purpose client connection, since it'd get confused by (possibly GREASE) ClientECH extensions.",
      "createdAt": "2020-10-19T21:10:47Z",
      "updatedAt": "2020-11-19T00:06:38Z",
      "closedAt": "2020-11-19T00:06:37Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The spec does talk about client-facing and backend servers as separate kinds of servers, but I thought the theory behind Split Mode was that backend servers were meant to be mostly standard TLS servers. That would suggest that backend-server-specific logic should be common to all TLS server implementations that know about ECH. \r\n\r\nI think this is the intention, yeah. This is how I understand the spec:\r\n1. Every TLS server is a backend server. If a TLS server knows a set of ECHConfigs, then it is also a client-facing server.\r\n1. An empty ECH extension signals that the server should play the role of the backend server. (Hence, the client-facing server would skip ECH processing and proceed as if it were a backend server.)\r\n1. A non-empty ECH extension signals that the server should play the role of the client-facing server. (The server ignores the extension if it is not a client-facing server.)",
          "createdAt": "2020-10-19T23:17:36Z",
          "updatedAt": "2020-10-19T23:27:34Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, sounds like you and I are on the same page there. But I'm not sure the spec text actually supports that interpretation. Let's fix that.",
          "createdAt": "2020-10-20T00:37:53Z",
          "updatedAt": "2020-10-20T00:37:53Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed. Who wants to take the PR?",
          "createdAt": "2020-10-20T22:20:45Z",
          "updatedAt": "2020-10-20T22:20:45Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd be happy to take it, since David did a lot of the heavy lifting last week. Unless you want to take a crack at it, David?",
          "createdAt": "2020-10-20T23:18:50Z",
          "updatedAt": "2020-10-20T23:18:50Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm working on a PR.",
          "createdAt": "2020-10-21T15:49:47Z",
          "updatedAt": "2020-10-21T15:49:47Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "PR ready. Note that it also clarifies how the client's role (real or GREASE) is determined.",
          "createdAt": "2020-10-21T16:35:29Z",
          "updatedAt": "2020-10-21T16:35:29Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Another thought: we could also avoid this odd \"maybe empty, maybe not\" behavior by just using a different codepoint for the \"please give me an ECH acceptance signal\" extension. As things stand, the {{server-hrr}} text is also kinda off:\r\n\r\n> If CH1 contains the \"encrypted_client_hello\" extension but CH2 does not, or if CH2 contains the \"encrypted_client_hello\" extension but CH1 does not, then the server MUST abort the handshake with an \"illegal_parameter\" alert.\r\n\r\nThat text doesn't account for CH1 containing a ClientECH \"encrypted_client_hello\" extension and CH2 containing an empty \"encrypted_client_hello\" extension. If the two modes are different codepoints, we don't have to keep expending words to talk about the two flavors.",
          "createdAt": "2020-10-30T03:50:38Z",
          "updatedAt": "2020-10-30T03:50:38Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "The downside of two codepoints is it's now possible to construct a ClientHello with both extensions at once and we need to decide whether, on ECH reject, the client-facing server is expected to do the ServerHello.random computation, error, or ignore it. I don't care strongly there. Any of option seems fine.\r\n\r\nDoing the computation has a nice orthogonality to it. We'd just be saying:\r\n* There's this swizzle_server_random extension. If you see it in the ClientHello you process, go do the thing. Whatever.\r\n* Independently, there's an encrypted_client_hello extension. If you see it, try to decrypt it and use it.\r\n* Backend servers behind client-facing servers MUST support swizzle_server_random and the client MUST stick swizzle_server_random in ClientHelloInner. These two rules together avoid the trial decryption mess.",
          "createdAt": "2020-10-30T03:56:34Z",
          "updatedAt": "2020-10-30T03:56:34Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd support this change. Is there a downside to relaxing the client requirement to \"MAY stick swizzle_server_random in CHI\"? That would allow client implementations to bear the burden of trial decryption, if they want. (I don't think it make a difference on the server side.)\r\n\r\nIIRC a similar idea came in the long-long ago of #287 and people didn't seem to like it. I could be wrong though.",
          "createdAt": "2020-10-30T22:48:26Z",
          "updatedAt": "2020-10-30T22:48:26Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "What would be the point of allowing that? Having two ways to do something adds complexity to the protocol and ecosystem. (E.g. a client that does trial decrypt instead will fail to ensure backend servers implement their requirements.) We should add options in the protocol as a last resort when we really need it, not because we can.\r\n\r\n(Elsewhere, TLS 1.2 session tickets specified two different ways to check something. We ended up with random downstream protocol picking the wrong one and a security vulnerability in OpenSSL.)",
          "createdAt": "2020-10-30T23:25:54Z",
          "updatedAt": "2020-10-30T23:25:54Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed, just wanted to confirm.",
          "createdAt": "2020-10-30T23:45:38Z",
          "updatedAt": "2020-10-30T23:45:38Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@davidben, can we merge #350 before we consider changing the codepoint of the inner ECH extension?",
          "createdAt": "2020-11-02T17:05:04Z",
          "updatedAt": "2020-11-02T17:19:23Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh sorry, missed that was waiting on me. Looking.",
          "createdAt": "2020-11-02T18:35:36Z",
          "updatedAt": "2020-11-02T18:35:36Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I landed #350. We can spin up a PR with separate codepoints now, if desired. (I also like the idea!)",
          "createdAt": "2020-11-03T21:04:45Z",
          "updatedAt": "2020-11-03T21:04:45Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@cbartle891 is going to take a stab at this!",
          "createdAt": "2020-11-12T01:59:42Z",
          "updatedAt": "2020-11-12T01:59:42Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that this seems like the right direction. Haven't reviewed the PR.",
          "createdAt": "2020-11-17T06:42:48Z",
          "updatedAt": "2020-11-17T06:42:48Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #360. Closing.",
          "createdAt": "2020-11-19T00:06:37Z",
          "updatedAt": "2020-11-19T00:06:37Z"
        }
      ]
    },
    {
      "number": 349,
      "id": "MDU6SXNzdWU3MjYwOTQxMzA=",
      "title": "Avoid computing a new HPKE contexts on HRR?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/349",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "ECH currently adds an ECDH operation on *both* the first and second ClientHello. That's extra asymmetric operations, and if folks end up offloading those keys, it's two RPCs. Given that we need to bind the two decryptions together anyway, and HPKE supports multiple encrypted messages (it has an internal sequence number), perhaps it's better to just use that.\r\n\r\nHere's a possibility: the first ClientHello makes a new HPKE context and calls context.Seal on it. The second ClientHello simply calls context.Seal on the same context, which internally increments the sequence number. Probably we copy over the first ClientHello's cipher_suite, config_id, and enc, even though they don't really do anything.\r\n\r\nThe server, if stateful, just calls context.Open to mirror the client behavior. If stateless, probably the simplest thing is to pickle the AEAD key inside the cookie. [Edit: I accidentally wrote \"ticket\" earlier.] It probably could also recompute the HPKE context and bump the sequence number up by one, maybe checking the selected ECHConfig and enc values didn't change. (The text already requires checking the former.)",
      "createdAt": "2020-10-21T03:12:01Z",
      "updatedAt": "2020-11-17T23:21:00Z",
      "closedAt": "2020-11-17T23:21:00Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "EDITED: s/ticket/cookie/\r\n\r\nI like this suggestion overall. A few comments:\r\n1. It's not sufficient to store only the key in the cookie: minimally we'll need the key and the initialization vector (called \"nonce\" in the HPKE spec, unfortunately). We may also end up needing the exporter secret as well, although this is currently only used in ECH to compute the HRR PSK for `SetupPSKS()` and this call would go away if we decided to adopt this change.\r\n1. In case of ECH acceptance, the backend server stores the key/IV in the cookie. This is a problem for \"Split Mode\": as you previously pointed out, there is currently no way for the client-facing server to convey cookie content to the backend server. Perhaps a solution to #333 is a prerequisite to this?\r\n1. HPKE does not specify serialization of the HPKE context. This use case makes me think it should.",
          "createdAt": "2020-10-21T16:53:17Z",
          "updatedAt": "2020-10-21T19:55:28Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "(I think you want to s/ticket/cookie/g since ticket is the resumption thing. That was my bad. I wrote ticket instead of cookie too.)\r\n\r\n> It's not sufficient to store only the key in the ticket:\r\n\r\nGood catch. Yes, we need to store both derived values. Although the difference between storing one short byte string or two short byte strings is largely one of semantics. (You can just as easily concatenate them and store the one resulting short byte string.) You could also store the root secret and rederive it. Whichever.\r\n\r\n> We may also end up needing the exporter secret as well, although this is currently only used in ECH to compute the HRR PSK for SetupPSKS() and this call would go away if we decided to adopt this change.\r\n\r\nWe wouldn't need the exporter secret or SetupPSK in this design.\r\n\r\n> In case of ECH acceptance, the backend server stores the key/IV in the ticket. [...] Perhaps a solution to #333 is a prerequisite to this?\r\n\r\nI don't think this introduces a new problem, so there's no need to block on #333. Though we need to deal with that too. In both this design and the status quo, the client-facing server needs to either be stateful or store *something* secret in the cookie. Right now it's ech_hrr_key. In this design it's the key/IV. (Though this design introduces the alternate strategy of storing a less secret thing, where you just remember the client's public bits and recompute the HPKE context.)\r\n\r\n> HPKE does not specify serialization of the HPKE context. This use case makes me think it should.\r\n\r\nThe serialization doesn't need to be standard or anything. A TLS server might want to keep its cookie small by observing it doesn't need the exporter secret. But some guidance might be useful, sure.\r\n\r\n(The only thing that needs to consume the cookie is the server, who also produced it. Just as TLS doesn't (and shouldn't) specify session state serialization, yet every TLS implementation has a session state serialization. I could also implement TLS by, rather than keeping connection state in memory, write it to disk and read it back out on every packet. Even an in-memory representation is a serialization.)",
          "createdAt": "2020-10-21T17:11:31Z",
          "updatedAt": "2020-10-21T17:11:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This is an interesting consideration. On one hand, I agree that it's simpler to simply reuse the existing context, though on the other hand it seems to run against the general desire to use primarily CH2 for \"everything.\" That said, ECH annoyingly requires binding between the two CHs, which we currently address by tying them together with a PSK, and this proposal is arguably simpler. \r\n\r\n(Anecdotally, I recall some server stacks verifying PSK binders on CH1 and then ignoring them on CH2, which was a situation that wasn't carefully analyzed in the formal analyses. I think that was fixed, though I don't recall how: are binders verified for both CHs, or only for the latter? And if verifying a binder involves a public key operation, why would ECH be any different?)",
          "createdAt": "2020-10-21T23:54:20Z",
          "updatedAt": "2020-10-21T23:54:20Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "The \"use CH2 for everything\" theory mostly assumes you don't negotiate very many parameters on CH1, whereas you need to resolve ECH early to even get at CH1. And, as you note, we need to bind the two. So I think we're pretty stuck with having ECH resolved at CH1 rather than CH2 anyway.\r\n\r\nVerifying a binder doesn't require a public key operation. It's mostly an HMAC. If you resolved the PSK at CH1, you've got the PSK available for CH2 and can compute the binder easily enough. If you resolved the PSK at CH2[*], then you just do it normally.\r\n\r\n[*] As an aside, you only sort of are able to do this. If your stack implements psk_ke, which thankfully most folks didn't, you need to resolve PSK at CH1 to know if you need a key share at all. Whereas if you know you only support psk_dhe_ke, then you can proceed assuming you need a key share and defer sorting out the PSK to later.",
          "createdAt": "2020-10-22T00:17:37Z",
          "updatedAt": "2020-10-22T00:17:37Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> The \"use CH2 for everything\" theory mostly assumes you don't negotiate very many parameters on CH1, whereas you need to resolve ECH early to even get at CH1. And, as you note, we need to bind the two. So I think we're pretty stuck with having ECH resolved at CH1 rather than CH2 anyway.\r\n\r\nYeah, I think that's right.\r\n\r\n> Verifying a binder doesn't require a public key operation. It's mostly an HMAC. If you resolved the PSK at CH1, you've got the PSK available for CH2 and can compute the binder easily enough. If you resolved the PSK at CH2[*], then you just do it normally.\r\n\r\nWhat if the key is inside a ticket? Doesn't that require a public key operation? (I should have clarified that I was referring to the whole process, involving getting the key and then using it to verify the binder. Sorry!)",
          "createdAt": "2020-10-22T00:38:06Z",
          "updatedAt": "2020-10-22T00:38:06Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> What if the key is inside a ticket? Doesn't that require a public key operation? (I should have clarified that I was referring to the whole process, involving getting the key and then using it to verify the binder. Sorry!)\r\n\r\nI guess it depends on how you do your tickets. They're typically just encrypted with a symmetric key, but I've also seen folks use asymmetric stuff. But, in any case, if you decrypt the ticket at CH1, by CH2 you've already gotten the decrypted ticket so you just compute the binder and don't redo the ticket business. If you decrypt the ticket at CH2, you only have the one ticket decryption by construction.",
          "createdAt": "2020-10-22T12:34:07Z",
          "updatedAt": "2020-10-22T12:34:07Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "PR in #352.",
          "createdAt": "2020-10-30T04:40:44Z",
          "updatedAt": "2020-10-30T04:40:44Z"
        }
      ]
    },
    {
      "number": 354,
      "id": "MDU6SXNzdWU3MzQ5NTAyMzA=",
      "title": "\"Don't stick out\" considerations for ECH",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/354",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The primary \"don't stick out\" [RFC8744] consideration for ECH is to ensure that the new extension does not trigger middlebox misbehavior. To accomplish this, the draft specifies two protocol variants: in the \"real-ECH\" protocol the client offers the ECH extension, which is processed by the server; in the \"grease-ECH\" protocol, the client generates a dummy ECH extension, which is ignored or rejected by the server. Grease-ECH is designed to look enough like real-ECH so that middleboxes do not differentiate the latter from the former, the idea being that if grease-ECH can be deployed without triggering middlebox misbehavior, then real-ECH ought to be deployable, too.\r\n\r\nBut what do we mean when we say grease-ECH should \"look like\" real-ECH? In ECH-08 the stated goal is \"to hide, to some extent, **(a)** whether or not a specific server supports ECH and **(b)** whether or not ECH was accepted for a particular connection\" [ECH-08, [Sec.10.1](https://tools.ietf.org/html/draft-ietf-tls-esni-08#section-10.1)]. These goals are hard to meet. First, an attacker can violate **(a)** by simply running grease-ECH with the server to see if it returns retry configs. Second, there are a number of ways to distinguish real-ECH from grease-ECH, thereby violating **(b)**:\r\n1. @huitema's [client-reaction attack](https://mailarchive.ietf.org/arch/msg/tls/EAeKCNq7JAFm8DFaoe2MwSslZTQ/).\r\n1. If the ECH config is known to the attacker, then it can use ClientECH.config_id to distinguish real-ECH from grease-ECH. \r\n1. The outer SNI must match ECHConfig.public_name. Hence, for connections to a given backend server, the outer SNI will be different in real-ECH than in grease-ECH.\r\n1. The client and server must negotiate TLS 1.3 when ECH is accepted, but may otherwise negotiate an earlier version. In particular, it is valid for a client to run grease-ECH but not indicate support for 1.3.\r\n1. PSK must not be offered in the outer CH in real-ECH, but may be offered in grease-ECH. In general, the set of extensions negotiated may depend on whether ECH was accepted.\r\n1. The client-facing server must not request client authentication when rejecting ECH, but the backend server may request client authentication when ECH was accepted.\r\n1. Whether or not an HRR message is issued by the server may depend on ECH acceptance.\r\n1. There are a few active distinguisher attacks that exploit the HRR codepath.\r\n\r\nSome of these distinguishers can be mitigated by careful implementation, while mitigating others would require changes to the specification. (E.g., #353.) However, it's unlikely that _all_ implementations will mitigate _all_ of these distinguishers. Moreover, future extensions are likely to change the shape of TLS in a way that leads to yet more distinguishers.\r\n\r\nGiven all of this, I wonder if indistinguishability (of real-ECH from grease-ECH) is the right way to think about this problem. It seems to me that it's stronger than strictly necessary, since the existence of a distinguisher does not necessarily imply that some feature of real-ECH will trigger middlebox misbehavior that would not otherwise be triggered by grease-ECH. For example, while the outer SNI might be a dead give away of likely ECH usage, this value is unlikely to impact middlebox behavior. Similarly, the absence of the PSK extension in real-ECH is unlikely to cause issues.\r\n\r\nIf it were possible to enumerate the set of properties that impact middlebox behavior, then ensuring that middleboxes don't differentiate between real-ECH and grease-ECH may simply be a matter of ensuring that this set of properties does not vary. This approach would be roughly analogous to the design of \"Middlebox Compatibility Mode\" in TLS 1.3, which makes the handshake \"look like\" a particular mode of 1.2 that middleboxes are known to tolerate. Of course, a curious adversary (e.g., a censor) can easily distinguish between these, but experience suggests that middleboxes do not treat them differently.\r\n\r\nThis leaves us the daunting task of deciding what features are known to impact the behavior of existing middleboxes. Here's a preliminary list of things that might fit in this category. For the sake of discussion, let's call them **differentiable features**:\r\n1. The set of extensions that appear to be negotiated;\r\n1. Visible alerts, e.g., \"bad_record_mac\";\r\n1. Number of round trips in a given transport context (e.g., TCP connection);\r\n1. Packet size, or the number of packets comprising a single message;\r\n1. Timing;\r\n1. ...\r\n\r\nI think we should set the following goals for ECH-09 (or some draft that follows it).\r\n1. If we can agree on a set of differentiable features, then we should ensure that this set does not vary between real-ECH and grease-ECH.\r\n1. ECH-08 aims only to mitigate **passive** \"don't stick out\" attacks, but there is a lot of evidence that middleboxes exhibit **active** behavior. (For example, middleboxes have been observed removing CH extensions they don't recognize or adding their own.) Thus, we should aim to thwart attacks that change the set of differentiable features in real-ECH vs. grease-ECH. This includes @huitema's attack in particular: see #353.\r\n1. To the greatest extent possible, the spec should allow for implementations to aim for the strongest possible notion of security. For example, we might consider relaxing the requirement that the outer SNI matches ECHConfig.public_name, so long as this change doesn't impact interoperability.\r\n",
      "createdAt": "2020-11-03T01:28:48Z",
      "updatedAt": "2021-04-21T15:42:54Z",
      "closedAt": "2021-04-21T15:42:54Z",
      "comments": [
        {
          "author": "kjacobs-moz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For the PSK extension specifically, I think we have two distinguishers to consider:\r\n\r\n- GREASE ECH + PSK extension in a Client Hello identifies GREASE ECH, due to PSKs being disallowed in CHOuter.\r\n- Real ECH + resumption (or any accepted PSK) identifies accepted ECH. CHOuter contains no PSK extension, but SH will contain the pre_shared_key extension (selected_identity).\r\n\r\n\r\n\r\n",
          "createdAt": "2020-11-24T21:29:50Z",
          "updatedAt": "2020-11-24T21:29:50Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "Due to assertions stated in IETF meetings that ECH isn't an anti-censorship tool, and the literally innumerable difficulties in making real ECH indistinguishable from GREASE ECH (as mentioned above), I propose dropping the \"do not stick out\" goal. The primary aim of ECH is to make the SNI private, and it's possible to keep the SNI private while telegraphing that we're using ECH.\r\n\r\nWe can, however, still use GREASE to make sure middleboxes are prepared to handle the code point and the larger size of the ClientHello.",
          "createdAt": "2020-12-10T20:55:25Z",
          "updatedAt": "2020-12-10T20:55:25Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with cjpatton's analysis.\r\n\r\nI don't think anyone is asking that these things be \"indistinguishable\" to a determined active intermediary in the common case.  That is clearly impossible (e.g. cjpatton's attack 2).  Instead, the goal is to minimize barriers to deployment of ECH.  If ECH isn't reliable in practice, it won't be widely deployed, and so will not keep the SNI private.\r\n\r\nIn my view, the minimum threshold is: a passive intermediary with only per-connection state must not be able to distinguish ECH from GREASE with confidence for a typical client and server configuration.  Defenses for less common protocol uses and low-grade active intermediaries (e.g. simple replay) are good to have but we shouldn't delay the protocol if they prove difficult.\r\n\r\nI think the only remaining issue to reach this level is Real ECH + resumption (kjacobs second attack).  All the other attacks (a) only affect a subset of GREASE (e.g. resumption GREASE), (b) require the intermediary to be active (emitting or modifying packets), or (c) require the intermediary to have per-server state (e.g. a DNS database or a persistent server profile).  We should build defenses for those cases too where we can, but some are intractable, and that's OK.",
          "createdAt": "2020-12-11T16:40:59Z",
          "updatedAt": "2020-12-11T16:40:59Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It is kind of sad, but I agree with the analysis. The sticking out starts with the definition of ECH as an extension, which already provides a differentiation from standard TLS. The theory that grease will fix that by making it hard to distinguish \"real\" and \"fake\" ECH is most probably wrong, except if the middlebox is really naive. That means the only sure way to grease the ECH function is to actually use it, even when the inner SNI is the same as the outer ECH -- only a real ECH is undistinguishable from a real ECH.",
          "createdAt": "2020-12-11T17:23:57Z",
          "updatedAt": "2020-12-11T17:23:57Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with @bemasc. The ECH goals in the document mostly align with this proposed minimum threshold. I think we should close this with no action, or tweak language to make this more clear, assuming we have consensus.\r\n\r\n@ekr, @davidben, @martinthomson, @kazuho: what do you think?",
          "createdAt": "2020-12-11T17:47:00Z",
          "updatedAt": "2020-12-11T17:50:46Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think action is needed at this point, but I think we should keep the issue open until we're closer to RFC. We're pretty close to interop, and we should expect real-world experiments to follow shortly thereafter. Those experiments will reveal if we missed anything, and it will be useful to have this issue as a reference.",
          "createdAt": "2020-12-11T18:08:22Z",
          "updatedAt": "2020-12-11T18:08:22Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "> In my view, the minimum threshold is: a passive intermediary with only per-connection state must not be able to distinguish ECH from GREASE with confidence for a typical client and server configuration.\r\n\r\nThis seems like a reasonable objective for avoiding operational/ossification issues.",
          "createdAt": "2020-12-11T18:15:21Z",
          "updatedAt": "2020-12-11T18:15:21Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@bemasc's description sounds right. I would note that this seems to actually make #353 unnecessary, right? Not saying we necessarily need to not do it, but...\r\n\r\n",
          "createdAt": "2020-12-13T00:13:38Z",
          "updatedAt": "2020-12-13T00:13:56Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Just to see about sharpening @bemasc's description: if an attacker needs to interfere with a connection in such a way that it would cause a failure in that connection in order to determine whether ECH is in use, that's out of scope, right?",
          "createdAt": "2020-12-13T00:15:24Z",
          "updatedAt": "2020-12-13T00:15:24Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> if an attacker needs to interfere with a connection in such a way that it would cause a failure in that connection in order to determine whether ECH is in use, that's out of scope, right?\r\n\r\nYes, that seems like a higher threshold than the one I proposed (purely passive).  I'm not sure about \"out of scope\".  For example, I fully support #353.  I think that when we run into problems like this, we should solve them if we have a solution available, but not delay the protocol if we have to go searching for one.",
          "createdAt": "2020-12-13T21:07:55Z",
          "updatedAt": "2020-12-13T21:07:55Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": ">  I think that when we run into problems like this, we should solve them if we have a solution available, but not delay the protocol if we have to go searching for one.\r\n\r\nI disagree. I think that if a particular threat model is out of scope, it's out of scope, and any mitigations of them shouldn't be in the document. There's no point in half-measures that ultimately won't be sufficient for addressing certain types of attackers but will add complexity.",
          "createdAt": "2020-12-15T00:42:31Z",
          "updatedAt": "2020-12-15T00:42:31Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> if an attacker needs to interfere with a connection in such a way that it would cause a failure in that connection in order to determine whether ECH is in use, that's out of scope, right?\r\n\r\nAn interesting detail on this one: interfering with the bytes and observing either client or server's response will break that connection, but observing the server's response is a little different from observing the client. One can often make a second connection to the server. (Perhaps a \"passive and a half\" attack.)\r\n\r\nThat is, suppose the server sent decrypt_failure on bad ECH decryptions. (It no longer does.) You can determine whether ECH is in use by flipping a bit in the ciphertext and seeing if the server notices. That breaks the connection, but you could make a second connection to the server, send your perturbed ClientHello, and not interfere with the original connection.\r\n\r\nWhereas, if your attack involves probing the client's behavior, you'd need to induce the client to start a second connection and not notice the first. Systems do tend to retry on failure, so this isn't _entirely_ implausible, but harder than the first attack.",
          "createdAt": "2020-12-17T21:44:29Z",
          "updatedAt": "2020-12-17T21:44:52Z"
        }
      ]
    },
    {
      "number": 356,
      "id": "MDU6SXNzdWU3MzcyNzIzNzg=",
      "title": "Clients should send consistent GREASE ECH extensions between CH1 and CH2",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/356",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I'll try to put together a PR for this later, but filing this now so I don't forget. (@dmcardle FYI) The draft currently says you randomize this both times, which won't work.\r\n\r\nAlso \"MUST check the extension syntactically\" appears to have been a little ambiguous, since how deeply you parse ECHConfigs gets a little complicated. I'll adjust that too.",
      "createdAt": "2020-11-05T21:12:25Z",
      "updatedAt": "2020-11-17T23:21:00Z",
      "closedAt": "2020-11-17T23:21:00Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I'll try to put together a PR for this later, but filing this now so I don't forget. (@dmcardle FYI) The draft currently says you randomize this both times, which won't work.\r\n\r\nWhat fields are suggesting to not randomize?",
          "createdAt": "2020-11-06T15:59:55Z",
          "updatedAt": "2020-11-06T15:59:55Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "`cipher_suite`. The draft doesn't quite say to randomize it, but it does say to vary it. (I'm not sure that's correct, actually. It depends on how much variation to expect in server ECHConfigs. If everyone does the AES-GCM / ChaCha20 pair, as they should, then the client will always pick one matching its cipher preference.)\r\n\r\nAdditionally, after #352, `enc` also should not be re-randomized on CH2.",
          "createdAt": "2020-11-06T16:07:00Z",
          "updatedAt": "2020-11-06T16:07:17Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@davidben what is the concern here?",
          "createdAt": "2020-11-06T17:21:52Z",
          "updatedAt": "2020-11-06T17:21:52Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Just that GREASE and ECH should be consistent in which fields get copied over and the text doesn't say that right now.",
          "createdAt": "2020-11-06T17:34:34Z",
          "updatedAt": "2020-11-06T17:34:34Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh, apparently I already thought of this in #352 and included some text about this:\r\n\r\n> When sending a second ClientHello in response to a HelloRetryRequest, the\r\n> client copies the \"cipher_suite\", \"config_id\", and \"enc\" fields. It generates a\r\n> new \"payload\" field, using the length of a padded second EncodedClientHelloInner\r\n> for L.\r\n\r\nSo I'll just mark #352 as closing this too but leave this open just in case we decide not to do #352.",
          "createdAt": "2020-11-06T21:11:30Z",
          "updatedAt": "2020-11-06T21:11:30Z"
        }
      ]
    },
    {
      "number": 358,
      "id": "MDU6SXNzdWU3MzgwNDIzNTY=",
      "title": "ECH contradicts second ClientHello consistency requirements in RFC8446",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/358",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "I just noticed this as I was pondering our various HRR issues. RFC8446, section 4.1.2 says:\r\n\r\n> [...] The client will also send a ClientHello when the server has responded to its ClientHello with a HelloRetryRequest.  In that case, the client MUST send the same ClientHello without modification, except as follows:\r\n>\r\n> * [...various cases regarding existing extensions...]\r\n>\r\n> *  Other modifications that may be allowed by an extension defined in the future *and present in the HelloRetryRequest*.\r\n\r\nhttps://tools.ietf.org/html/rfc8446#section-4.1.2\r\n\r\nThe \"and present in the HelloRetryRequest\" portion is fun. In RFC8446 as written, we're not allowed to change the `encrypted_client_hello` extension on the second ClientHello unless the server sent `encrypted_client_hello` in HelloRetryRequest, which it doesn't. With the protocol as-is, it seems we'll at least need some text to deal with the contradiction.\r\n\r\nThe impact is practice is thankfully limited. If the servers does not enforce consistency between the two ClientHellos, it doesn't matter. (They're not required to, but they're not explicitly forbidden from it either, and a stateless server may need to enforce some minimum consistency to avoid getting into a broken state.) If a server does, ECH's behavior on HRR will break it. Such a server is supposed to handshake with ClientHelloOuter, so it just affects the retry flow. That's maybe okay, but mildly annoying. Administrators using server software that checks need to know to first upgrade to a version that doesn't check before trying to deploy ECH.\r\n\r\nWe can also add an ECH extension to HRR. Then, on ECH-reject + HRR, the server perhaps wouldn't send the extension and the client would be required to replay the extension. This is a waste in many ways, but would work. This would break don't stick out, but some threat models, don't stick out with HRR is hopeless anyway. (See https://github.com/tlswg/draft-ietf-tls-esni/pull/352#issuecomment-721824226.) It would also be weirdly asymmetric between ECH and SH.\r\n\r\nThat said, this constraint is also pretty obnoxious. For instance, #313 currently adds a new padding extension codepoint, because the old one isn't defined for other messages. However, the RFC8446 allowance only works for the existing padding code point, so you don't want to send any other code points in ClientHello, lest the server force you to keep it unchanged in ClientHello2. So maybe we should confirm no servers did the fully strict check and undo that constraint? (Although, for #313, I personally favor the padding message strategy anyway.)",
      "createdAt": "2020-11-06T21:05:33Z",
      "updatedAt": "2021-06-11T22:21:00Z",
      "closedAt": "2021-06-11T22:21:00Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "@cjpatton points out the Go implementation does check CH1 and CH2 consistency. Fortunately, it only checks known extensions, so it's still compatible with the ECH draft.\r\nhttps://golang.org/src/crypto/tls/handshake_server_tls13.go#L457\r\n\r\nChecking only know extensions is basically saying we should strike \"and present in the HelloRetryRequest\" in rfc8446bis and make sure everyone knows not to check this.",
          "createdAt": "2020-11-10T23:28:39Z",
          "updatedAt": "2020-11-10T23:28:39Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think we can *just* strike this text because the point of that text was that you couldn't like change your KeyShares if the HRR didn't tell you to. But I agree we can sharpen this in some sensible way.",
          "createdAt": "2020-11-17T06:44:40Z",
          "updatedAt": "2020-11-17T06:44:40Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I figured that case was covered by \"defined in the future\", which I'm not proposing we delete. key_share isn't defined in the future, so it falls under existing rules. The existing rules (bullet points over that one) only let you change key_share \"[i]f a \"key_share\" extension was supplied in the HelloRetryRequest\". But perhaps that's a little roundabout. The rules I'm thinking of are (changes *emphasized*):\r\n\r\n* Each extension gets to define how it reacts to HRR.\r\n* It typically is sensitive the corresponding HRR extension, *but doesn't have to be*.\r\n* RFC8446(bis) defines the rules for all existing extensions.\r\n* Future extensions define their own rules. (And probably if they don't say anything, we assume they don't get to change.)\r\n* As a server, you can make assumptions based on the rules for extensions you know about. *You have to tolerate random changes in extensions you don't know about, because you don't know their rules.*\r\n\r\nI'm running a probe on a bunch of servers to see how they react to changes in cipher suites, curves, and a random extension. It seems most don't notice. Some (I'm guessing Go) notice cipher suites and curves. None notice a random extension. That suggests the change will be compatible.",
          "createdAt": "2020-11-17T07:03:50Z",
          "updatedAt": "2020-11-17T07:03:50Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'm running a probe on a bunch of servers to see how they react to changes in cipher suites, curves, and a random extension. It seems most don't notice. Some (I'm guessing Go) notice cipher suites and curves. None notice a random extension. That suggests the change will be compatible.\r\n\r\nI spoke too soon. LibreSSL breaks if you change an extension they don't recognize. :-(",
          "createdAt": "2020-11-17T07:39:08Z",
          "updatedAt": "2020-11-17T07:39:08Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "So draft-09 isn't tied up with this, I've uploaded https://github.com/tlswg/draft-ietf-tls-esni/pull/361 as a bandaid for the potential compatibility issue.\r\n\r\n(I say potential because it's only a problem if the server checks unknown extensions *and* has different enough key share preferences from the client that it needs HRR. HRR is pretty rare, so it may not actually be an issue. For Chrome, at least, I don't think the particular servers I found actually trigger HRR. But it is still a risk for clients or servers with different configurations.)",
          "createdAt": "2020-11-18T00:10:23Z",
          "updatedAt": "2020-11-18T00:10:23Z"
        }
      ]
    },
    {
      "number": 359,
      "id": "MDU6SXNzdWU3NDI1ODk5NDQ=",
      "title": "Transcript hash construction",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/359",
      "state": "CLOSED",
      "author": "kylon94",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "I heard about Encrypted Client Hello recently. Looks like a good idea. I have been thinking about implementing and suggest a clarification in the draft.\r\n\r\nIt needs to specify which ClientHello the client should use to compute the transcript hash. I assume if the connection to the backend server is successful it should use the ClientHelloInner, Else, if it authenticates to the public name it should use the ClientHelloOuter.\r\n\r\nMight be kind of obvious, but explicit > implicit. Maybe some text extending Section 4.4.1 of RFC8446 should be added.",
      "createdAt": "2020-11-13T16:36:25Z",
      "updatedAt": "2021-09-09T15:12:04Z",
      "closedAt": "2021-06-11T22:30:09Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @kylon94! We'll try and clarify this.",
          "createdAt": "2020-11-16T16:48:47Z",
          "updatedAt": "2020-11-16T16:48:47Z"
        },
        {
          "author": "kylon94",
          "authorAssociation": "NONE",
          "body": "Looking at section 5.1, I think some clarification would be helpful. It makes sense that the full ClientHelloInner with the outer extensions should be included in the hash but this isn't clear. In particular highlighting the change in message length between the ClientHelloInner and EncodedClientHelloInner would help. Like the issue above, not a big deal but it could trip up a developer.",
          "createdAt": "2020-12-10T15:12:55Z",
          "updatedAt": "2020-12-10T15:12:55Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "@kylon94 Why would highlighting the change in message length help with this?",
          "createdAt": "2020-12-15T00:27:07Z",
          "updatedAt": "2020-12-15T00:27:07Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "Blocked on the issues discussed in https://github.com/tlswg/draft-ietf-tls-esni/issues/373.",
          "createdAt": "2020-12-16T18:01:38Z",
          "updatedAt": "2020-12-16T18:01:38Z"
        },
        {
          "author": "kylon94",
          "authorAssociation": "NONE",
          "body": "> @kylon94 Why would highlighting the change in message length help with this?\r\n\r\nBecause the ClientHello encoding process is new for ECH, a developer might use the wrong message length in the transcript hash even if they used the correct content. Being clear about using the full ClientHelloInner with outer extensions is more important, but mentioning the length too might help out some developers.",
          "createdAt": "2020-12-21T13:35:29Z",
          "updatedAt": "2020-12-21T13:35:29Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe this is fixed as part of #423, so closing. Please reopen if further clarifications are desired!",
          "createdAt": "2021-06-11T22:30:08Z",
          "updatedAt": "2021-06-11T22:30:08Z"
        },
        {
          "author": "kylon94",
          "authorAssociation": "NONE",
          "body": "This text is clearer now, but I don't think this has been fully resolved. In sections 6.1.5 and 6.1.6, being explicit about what is and isn't included in the transcript hash would help. Highlighting that the EncodedClientHelloInner is not used and the difference in length should prevent developers making those mistakes.",
          "createdAt": "2021-09-09T15:12:04Z",
          "updatedAt": "2021-09-09T15:12:04Z"
        }
      ]
    },
    {
      "number": 369,
      "id": "MDU6SXNzdWU3NTAxMDMzMzA=",
      "title": "Potential SNI leak via cross-ECH resumption",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/369",
      "state": "CLOSED",
      "author": "kjacobs-moz",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Martin pointed out a potential SNI leak via resumption under the following conditions:\r\n1. A client connects to server \"A\" without ECH, and receives a session ticket.\r\n2. The client later resumes the connection to server \"A\" using ECH. An observer can see that a PSK was accepted (via SH containing pre_shared_key). \r\n4. If any of the hosts previously visited by the client are known, an attacker can do a lookup of each for a config_id matching the resumed session. \r\n\r\nThis effectively reduces the size of the anonymity set for a particular client/victim.\r\n\r\nWhile it's true that the hostname is already leaked by the first connection without ECH, this seems to violate the security goals as they are written. We used to require separation between non-ECH and ECH PSKs, but it was removed in #285.",
      "createdAt": "2020-11-24T22:08:33Z",
      "updatedAt": "2020-12-16T16:25:37Z",
      "closedAt": "2020-12-16T16:25:37Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah fun. I agree that observing a resumption does increase the probability the connection was one of the previous non-ECH connections the client made, when server just deployed ECH. (Though the client could also be visiting someone else in the anonymity set for a second time.) I'm not sure I follow what's going on in (3) though. Is that just checking if one of the previously-visited hosts shares a client-facing server with the connection under attack? That seems like something the attacker can regardless. (With or without resumption, one would expect a client's visited sites pre-ECH-deployment to somewhat predict with the ones post-ECH-deployment.)\r\n\r\nAs an aside, even if SH.pre_shared_key was hidden, the observer can infer resumption based on whether the server responded with a lot of data (it sent a certificate in there), or very little data (it sent no certificate in there). Unless the server adds some truly wasteful padding on resumption connections.",
          "createdAt": "2020-11-25T19:30:57Z",
          "updatedAt": "2020-11-25T19:30:57Z"
        },
        {
          "author": "kjacobs-moz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(3) just provides additional evidence that the SNI guess is correct (by further constraining set of possible hostnames). ",
          "createdAt": "2020-11-30T20:47:34Z",
          "updatedAt": "2020-11-30T20:47:34Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To mitigate this, it ought to be sufficient to have the client track whether a given PSK was established ruing a ECH handshake or a non-ECH handshake. It seems like this would be a lot more involved for a server to manage.",
          "createdAt": "2020-11-30T21:57:50Z",
          "updatedAt": "2020-11-30T21:57:50Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Is it actually additional evidence? It doesn't seem to narrow the usual ECH anonymity set, just identifies it. If I understand you correctly, (3) is:\r\n\r\n* The attacker observes a connection from the client with some config_id and some secret SNI A.\r\n* The attacker queries DNS or the recovery flow[*] for the cleartext SNIs that the client previously visited and sees if one of them, B, has an ECHConfig with matching config_id.\r\n* If there is a match, the attacker learns that B was in the same anonymity set as A.\r\n\r\nThe attacker learns this whether or not the connection resumes. The attacker also hasn't expanded the anonymity sent. In fact, they didn't even need to query sites the client previously visited. They could just as easily query the top N sites or a list of popular hosting providers known to support ECH. I think this information is part of the baseline for our security goals.\r\n\r\nIt is true that a client which, before ECH, leaked that it visited A many times is more likely to visit A again in the future. That seems fundamental. I think the interesting thing is that (2) tells the observer that it is *some* repeat visit, which increases the chance it's A. (But doesn't guarantee it. Maybe I've found a new site in the anonymity set that I like.)\r\n\r\nI don't think PSK separation even mitigates this. Repeat post-ECH visits still reveal whether resumption happened in ServerHello. And even if we fixed that, depending on how much padding the client is willing to add, the ClientHello size will reveal whether the client had a ticket to offer. I think the only thing PSK separation mitigates is that _immediately_ after the client/server pair deploys ECH, you get to reset the repeat visit counter. But once you count to 2 again, you've got the same signal as before.\r\n\r\n[*] Although there's no actual requirement that the recovery flow use the same ECHConfig as the long-lived DNS config...",
          "createdAt": "2020-11-30T22:02:45Z",
          "updatedAt": "2020-11-30T22:05:20Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "> In fact, they didn't even need to query sites the client previously visited.\r\n\r\nWell no, but since they have that information, they can further reduce the anonymity set. (The attacker doesn't need to consider the sites the user never visited.)\r\n\r\nAs soon as you involve non-ECH in a session, the security guarantees just don't hold. I'm fine with just being explicit about that in the draft.",
          "createdAt": "2020-12-10T04:22:34Z",
          "updatedAt": "2020-12-10T04:22:34Z"
        },
        {
          "author": "kjacobs-moz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > In fact, they didn't even need to query sites the client previously visited.\r\n> \r\n> Well no, but since they have that information, they can further reduce the anonymity set. (The attacker doesn't need to consider the sites the user never visited.)\r\n> \r\n> As soon as you involve non-ECH in a session, the security guarantees just don't hold. I'm fine with just being explicit about that in the draft.\r\n\r\nThat's probably the best way to resolve this, given the impracticality and constraints (to time of deployment or enablement). I'll have a PR up by the end of the week. \r\n",
          "createdAt": "2020-12-10T15:36:14Z",
          "updatedAt": "2020-12-10T15:36:14Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "That works for me. Thanks, @kjacobs-moz!",
          "createdAt": "2020-12-10T15:58:34Z",
          "updatedAt": "2020-12-10T15:58:34Z"
        }
      ]
    },
    {
      "number": 373,
      "id": "MDU6SXNzdWU3Njg0MTg1MDQ=",
      "title": "CHI vs. CHO when HRR is sent",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/373",
      "state": "CLOSED",
      "author": "cbartle891",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "While attempting to draft a change for https://github.com/tlswg/draft-ietf-tls-esni/issues/359, I was confused by this part of section 6.1.4:\r\n\r\n\"If the server sends a HelloRetryRequest in response to the ClientHello, the client sends a second updated ClientHello per the rules in [RFC8446]. However, at this point, the client does not know whether the server processed ClientHelloOuter or ClientHelloInner\"\r\n\r\nWhen does the client learn whether the server processed ClientHelloOuter or ClientHelloInner? If the client sees that the last 8 bytes of ServerHello.random were set to the first 8 bytes of `accept_confirmation`, does it just assume that the first ClientHello that the server processed was a ClientHelloInner? That seems like a big assumption. Couldn't the following happen?:\r\n\r\n```\r\nClient                           Client-facing server             Backend server\r\n              CHO(CHI)\r\n           ------------->\r\n                                   (processes CHO)\r\n                HRR\r\n           <-------------\r\n              CHO(CHI)\r\n           ------------->\r\n                                                          CHI\r\n                                                      ----------->\r\n                                                                  (processes CHI)\r\n                            SH\r\n          <-----------------------------------------------------\r\n\r\n```\r\n\r\nIf this can happen, the client will assume, after it receives the SH, that the server processed the first ClientHelloInner, but this is in fact not the case, and the transcript will break. I mean, I guess that's okay if you don't want this behavior to succeed, but AFAICT, the draft doesn't explicitly say that the client-facing server shouldn't do this. Should it?\r\n\r\n(Sorry if this is in fact already resolved somewhere in the draft. Also I'm pretty sure it's a different issue from https://github.com/tlswg/draft-ietf-tls-esni/issues/333.)",
      "createdAt": "2020-12-16T03:35:19Z",
      "updatedAt": "2021-06-11T22:21:00Z",
      "closedAt": "2021-06-11T22:21:00Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, this is one of the HRR headaches. :-) We don't know until SH whether CHO or CHI was used, so the second ClientHello needs to evaluate _both_ CHO and CHI against HRR. #316 patched the worst of the headache (what if evaluating HRR is an error for CHO but not for CHI?), but it's a really awkward solution.\r\n\r\n(I still need to write up the two HRRs solution we've been muttering about.)",
          "createdAt": "2020-12-16T16:38:12Z",
          "updatedAt": "2020-12-16T16:38:12Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "Why can't the backend server just set HelloRetryRequest.random the way it sets ServerHello.random? I believe it'll be a different value in the HRR vs SH if we still care about sticking out, which we don't. ;-) (Or is that one of the two solutions?)",
          "createdAt": "2020-12-16T16:53:12Z",
          "updatedAt": "2020-12-16T16:56:00Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "(Oh sorry, by \"two HRRs solution\" I didn't mean two solutions for HRR, but a single solution involving two HRRs. :-) )\r\n\r\nAs part of the middlebox compatibility goofiness, a HelloRetryRequest message is encoded as a ServerHello message with a special fixed value for ServerHello.random. It's kind of a mess.\r\n\r\nI suppose we could declare that the HRR indicator is now actually 24 bytes instead of 32 and then reapply the SH.random trick? I dunno, given #358, I figure this ought to look like a HelloRetryRequest.encrypted_client_hello extension (as sticking out in HRR flows is hopeless). That then gives us room to solve #333 and then... yeah that is basically the solution I need to write up. :-)",
          "createdAt": "2020-12-16T17:05:01Z",
          "updatedAt": "2020-12-16T17:05:01Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "> (Oh sorry, by \"two HRRs solution\" I didn't mean two solutions for HRR, but a single solution involving two HRRs. :-) )\r\n\r\nOh haha. Read that too fast. Where is this solution described? I don't see it in the open HRR issues.\r\n\r\n> As part of the middlebox compatibility goofiness, a HelloRetryRequest message is encoded as a ServerHello message with a special fixed value for ServerHello.random. It's kind of a mess.\r\n\r\nOh. Is that an implementation detail or part of the spec? I don't see that in section 4.1.4 of RFC 8446.\r\n",
          "createdAt": "2020-12-16T18:00:54Z",
          "updatedAt": "2020-12-16T18:00:54Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> Oh haha. Read that too fast. Where is this solution described? I don't see it in the open HRR issues.\r\n\r\nNowhere yet. :-( It's the thing we mumbled about at our last sync and I still need to write up a description.\r\n\r\n> Oh. Is that an implementation detail or part of the spec? I don't see that in section 4.1.4 of RFC 8446.\r\n\r\nLooks like it's spread out a bit. 4.1.4 says:\r\n\r\n> As discussed in Section 4.1.3, the HelloRetryRequest\r\n>   has the same format as a ServerHello message, and the legacy_version,\r\n>   legacy_session_id_echo, cipher_suite, and legacy_compression_method\r\n >  fields have the same meaning.  However, for convenience we discuss\r\n>   \"HelloRetryRequest\" throughout this document as if it were a distinct\r\n>   message.\r\n\r\nAnd then 4.1.3 says:\r\n\r\n>   For reasons of backward compatibility with middleboxes (see\r\n>   Appendix D.4), the HelloRetryRequest message uses the same structure\r\n>   as the ServerHello, but with Random set to the special value of the\r\n>   SHA-256 of \"HelloRetryRequest\":\r\n>\r\n>     CF 21 AD 74 E5 9A 61 11 BE 1D 8C 02 1E 65 B8 91\r\n>     C2 A2 11 16 7A BB 8C 5E 07 9E 09 E2 C8 A8 33 9C\r\n>\r\n>   Upon receiving a message with type server_hello, implementations MUST\r\n>   first examine the Random value and, if it matches this value, process\r\n>   it as described in Section 4.1.4).",
          "createdAt": "2020-12-16T18:07:37Z",
          "updatedAt": "2020-12-16T18:07:37Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "Agh, thanks.\r\n\r\n> I suppose we could declare that the HRR indicator is now actually 24 bytes instead of 32 and then reapply the SH.random trick?\r\n\r\nWouldn't that break middleboxes?\r\n\r\n> I figure this ought to look like a HelloRetryRequest.encrypted_client_hello extension\r\n\r\nSGTM",
          "createdAt": "2020-12-16T18:26:05Z",
          "updatedAt": "2020-12-16T18:26:05Z"
        }
      ]
    },
    {
      "number": 374,
      "id": "MDU6SXNzdWU3NzA0MzUwMDI=",
      "title": "Proposal: Introduce HelloRetryRequestOuter/Inner",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/374",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "I wanted to jot this down before the holidays, in advance of writing a more rigorous PR. This is a proposal to go fix all our HRR problems in one swoop (#233, #373, #358, and #333).\r\n\r\nFirst, whatever our \"don't stick out\" goals are (#354), sticking out on true HRR flows is pretty much hopeless if the attacker is allowed to make a second connection and probe server behavior: replay the first ClientHello and then perturb the second ClientHello's ciphertext. The server can't change its mind after the fact. So I'm going to intentionally give up on that, which means fixing #358 is possible. The proposal is thus:\r\n\r\n* The client sends ClientHelloOuter1 and ClientHelloInner1 as in the current document.\r\n* If client-facing server accepts ECH, it forwards ClientHelloInner1 to the backend server, as before.\r\n* If the backend server sends HelloRetryRequest in response, call this HelloRetryRequestInner.\r\n* The backend server constructs HelloRetryRequestOuter containing the following:\r\n  * An encrypted_client_hello extension with the HelloRetryRequestInner, encrypted with the HPKE context (see open questions).\r\n  * Optionally, a cookie extension with the outer cookie (fixes #333)\r\n  * No other extensions are allowed, though future extensions, if solicited by ClientHelloOuter1 may change this. (See open questions.)\r\n* HelloRetryRequests signals to the client whether ECH was accepted or not (fixes #373, avoids #316) by the presence of the encrypted_client_hello extension:\r\n* If there is no encrypted_client_hello extension, the client computes ClientHello2 based on ClientHelloOuter1 and HelloRetryRequest. There is no more ClientHelloInner2. We're not doing ECH, and HRR may not even be valid for CHI2 (the #316 mess). Instead, it blindly copies over ClientHelloOuter1's extension. This is a waste of bytes, but fixes #358.\r\n* If there is an encrypted_client_hello extension...\r\n  * First, the client decrypts HelloRetryRequestInner. If it fails, it sends decrypt_failure and aborts. GREASE ECH is considered to always fail to decrypt and always sends decrypt_failure.\r\n  * Otherwise, the client computes ClientHelloInner2 based on HelloRetryRequestInner in the usual way, handling errors in the usual way.\r\n  * The client constructs ClientHelloOuter2 containing the encrypted ClientHelloInner2 and HelloRetryRequestOuter.cookie. We know the server is accepting ECH at this point, so there is no need to send much of any other fields. See open questions below.\r\n* HRR or not, the ServerHello is required to have an ECH acceptance confirmation as usual. The client processes it as follows:\r\n  * If there was no HRR, do what the document currently says and figure out ECH acceptance here.\r\n  * If there was an HRR, you already know ECH accept or reject. If ECH reject, move and and complete the outer handshake without any fuss. The inner handshake terminated too early to compute handshake_secret anyway. If ECH accept, check the acceptance confirmation and send illegal_parameter or so if it's wrong. (See open questions below)\r\n\r\nI believe this solves our various HRR problems:\r\n\r\n* The client-facing server can send an HRR cookie without coordinating with the inner handshake (#333).\r\n* The client does not need to evaluate one HRR against two different ClientHellos, so the two ClientHellos can have arbitrarily different preferences (#233, #316).\r\n* The client knows ECH accept at the first server response, so it does not need to construct two different second ClientHellos (#373).\r\n* The ECH extension only changes when solicited (#358).\r\n\r\nThoughts?\r\n\r\n### Open questions\r\n\r\n#### How and should we encrypt HelloRetryRequestInner?\r\n\r\nThe above sketch encrypts HRRInner, but HPKE only allows the sender to encrypt. This is easy to specify though: use the exporters to derive another AEAD key and toss it into the HPKE cipher suite's AEAD.\r\n\r\nAs for why encrypt it, things should still work if we stick it in the clear. But we may want to for two reasons:\r\n\r\n1. Like backend server tickets, backend server cookies are, today, not particularly constrained w.r.t. what they reveal. A ticket or cookie from one TLS implementation may be different from the other, and Split Mode servers may have multiple backend implementations in their anonymity set. It may also vary for other reasons. NewSessionTicket is encrypted, as is the pre_shared_key extension, so we've solved it for tickets. ClientHello.cookie is also encrypted, which leaves HRR.cookie. Encrypting HRRInner fills that in.\r\n2. If HRRInner is not authenticated by the HPKE context, an attacker can try to distinguish GREASE by sending a fake cleartext HRRInner and seeing how the client responds. Authenticating HRRInner means you cannot spoof an inner HRR flow.\r\n\r\nWhether the second property is worthwhile is unclear (https://github.com/tlswg/draft-ietf-tls-esni/issues/354#issuecomment-743924431), but I think the first property is valuable, at which point we get the second anyway.\r\n\r\n#### Other HelloRetryRequestOuter extensions? What is ClientHelloOuter2?\r\n\r\nThis design avoids #316 by assembling a cursory ClientHelloOuter2, rather than actually trying to continue the outer handshake. We would need to decide how to do that. I can think of a few possibilities:\r\n\r\n1. Simply specify throwaway values for all the non-extension fields and declare ClientHelloOuter2 contains exactly two extensions, an optional cookie and encrypted_client_hello. EncodedClientHelloInner2 does not bother with outer_extensions because there is nothing to compress.\r\n2. Make up a new message type to avoid the throwaway fields.\r\n3. ~~Compute an actual ClientHelloOuter2, following RFC8446, based on ClientHelloOuter1 and HelloRetryRequestOuter. If HelloRetryRequestOuter wants to request new key_shares, that's fine. it's just pointless.~~\r\n\r\nI don't like option 3. It's conceptually kinda clever, but adds unnecessary fuss to the protocol. Consider a client which sends CHO1.key_share == CHI1.key_share and compresses them. Key share preferences are rarely secret and this avoids doubling up potentially large post-quantum values.\r\n\r\nThe backend server now requests HRR because it wanted a different key share. So CHI2.key_share != CHI1.key_share and is based on HRRI.key_share. But the client-facing server probably did the straightforward thing and didn't send HRRO.key_share because there's no point. It'll never process CHO2.\r\n\r\nOption 3 would then require that CHO2.key_share == CHO1.key_share because HRRO did not request a change. That means CHO2.key_share != CHI2.key_share and the client must waste a lot of bytes sending two of them. In contrast, options 1 and 2 say that CHO2.key_share doesn't exist anyway, so we only ever send one key share.\r\n\r\nIt also adds implementation complexity to the client, which now needs to evaluate two different full-featured HRRs in one handshake, despite it being unused.\r\n\r\nOption 1 and 2 are basically equivalent, though it's worth noting that HRRO and CHO2 do not _quite_ have the same rules as anymore, so whether we want to stick them in the same message type is interesting...\r\n\r\n#### SH.random acceptance signal after HRR?\r\n\r\nAfter HRR, the SH.random acceptance signal doesn't do anything. We could just as easily omit it, because the client has already gotten the signal. The above sketch keeps it in, mostly for consistency's sake: right now we require that backend servers support the ech_is_inner extension. Getting this wrong will be noticed because the client will not successfully complete the connection. If we omit the acceptance signal in HRR flows, the client will no longer consistently notice. As long as we have this requirement, enforcing it uniformly is more robust, so I'm thinking we keep it in there.\r\n\r\n#### Copy or omit CH2.encrypted_client_hello on reject?\r\n\r\nThis sketch says to copy CH2.encrypted_client_hello on ECH reject. This is a waste of bytes but retains compatibility with RFC8446's rules. In particular, we know of a compatibility issue in #358. It seemed from the WG discussion we generally think the RFC8446 rules are wrong, so we could intentionally break them and drop the extension.\r\n\r\nMy inclination is we should try to get the rule changed and implementations fixed, but maybe that should happen separately from ECH and we copy it for now.",
      "createdAt": "2020-12-17T22:58:11Z",
      "updatedAt": "2021-06-11T22:21:00Z",
      "closedAt": "2021-06-11T22:21:00Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "@ekr, I'm curious what your thoughts are. I remember you said at the WG meeting you wanted to avoid #316 in the final design.",
          "createdAt": "2020-12-17T23:04:00Z",
          "updatedAt": "2020-12-17T23:04:00Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'll need to stew on this for a bit, but I support this idea overall. One request: It seems like some design decisions are aimed at reducing the communication overhead compared to ECH-09. For now, I would prefer we leave out of t he PR any such optimization that adds implementation complexity. In particular, I think the client should compute a real ClientHelloOuter2 as usual (as in option (3.) above) rather than do something different (as in option (1.) or (2.)). The alternatives seem somewhat invasive; and if their only benefit is improved communication overhead, then given how rare the HRR code path is in practice, I don't think it's worth doing.\r\n\r\nAlso, I'm sold on the privacy benefits of encrypting HRRInner. However, I think we should punt this to a future PR. Two reasons. First, I think this privacy consideration is orthogonal to the issue at hand. Second, the details aren't straight-forward; we'll have to agree on how to pick the nonce, associated data, how to pad, and so on. I think we'll do ourselves a big favor by untangling these things :)",
          "createdAt": "2020-12-18T17:50:48Z",
          "updatedAt": "2020-12-18T17:50:48Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "The issue with option 3 isn't just communication overhead. It's also implementation cost in mocking out an outer handshake on the client, even though we already know that it will be ignored. Either of options 1 or 2 would be *dramatically* simpler to implement and carry lower risk of mishaps from the complexity.",
          "createdAt": "2020-12-19T20:39:33Z",
          "updatedAt": "2020-12-19T20:39:33Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I've updated the description in the PR to make this clearer. The only benefit of option 3 is as a conceptual reference or perhaps something to profile down from. As an actual protocol, it's a not a good option.",
          "createdAt": "2020-12-19T20:42:24Z",
          "updatedAt": "2020-12-19T20:43:50Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "> After HRR, the SH.random acceptance signal doesn't do anything. We could just as easily omit it, because the client has already gotten the signal.\r\n\r\nI don't really understand this. Sure, the client gets the signal that the backend server sent the HRR, but without SH.random, how can the client be sure the client-facing server didn't send the SH? The handshake will ultimately fail because the transcripts won't match, but not until then. Isn't it better if the client is able to terminate immediately after receiving the SH?\r\n\r\n> The backend server now requests HRR because it wanted a different key share. So CHI2.key_share != CHI1.key_share and is based on HRRI.key_share. But the client-facing server probably did the straightforward thing and didn't send HRRO.key_share because there's no point. It'll never process CHO2.\r\n\r\nWait why would the client-facing server send anything at all in this case? Doesn't the backend server send the HRR to the client without (ideally) any modification from the client-facing server?",
          "createdAt": "2021-01-09T04:19:39Z",
          "updatedAt": "2021-01-09T04:19:39Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": ">> After HRR, the SH.random acceptance signal doesn't do anything. We could just as easily omit it, because the client has already gotten the signal.\r\n>\r\n> I don't really understand this. Sure, the client gets the signal that the backend server sent the HRR, but without SH.random, how can the client be sure the client-facing server didn't send the SH? The handshake will ultimately fail because the transcripts won't match, but not until then. Isn't it better if the client is able to terminate immediately after receiving the SH?\r\n\r\nDo you mean a malicious or well-behaved client-facing server? A well-behaved client-facing server doesn't get to change its mind about whether ECH was accepted partway through. If we've got an HRR from the backend server, the SH will be from the backend server too.\r\n\r\nIf it's a malicious client-facing server, yeah, we're relying on how TLS defends against network attackers, including how it uses the transcript. But that's true of TLS in general. If we're worried about when the client notices, the transcript figures into handshake encryption, CertificateVerify, and Finished, which are all in the same flight as ServerHello. (Plus the SH.random signal is all of 8 bytes, so it's not especially cryptographically significant.)\r\n\r\n(But I don't think we should omit it anyway. Just observing that we could.)\r\n\r\n>> The backend server now requests HRR because it wanted a different key share. So CHI2.key_share != CHI1.key_share and is based on HRRI.key_share. But the client-facing server probably did the straightforward thing and didn't send HRRO.key_share because there's no point. It'll never process CHO2.\r\n>\r\n> Wait why would the client-facing server send anything at all in this case? Doesn't the backend server send the HRR to the client without (ideally) any modification from the client-facing server?\r\n\r\nRight. I'm saying I don't like option 3 because it _allows_ the client-facing server to send HRROuter.key_share. That means the client must have code to handle it. And then we need to reason about how this mess interacts with not wanting to waste bytes in the second ClientHello sending two key shares. And, despite all that complexity, the client-facing server doesn't actually care, so we made everything a mess for nothing.\r\n\r\nThus, option 3 is a useful conceptual reference, but I don't think we should actaully do it.",
          "createdAt": "2021-01-11T19:53:53Z",
          "updatedAt": "2021-01-11T19:54:17Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "> If we're worried about when the client notices, the transcript figures into handshake encryption, CertificateVerify, and Finished, which are all in the same flight as ServerHello. (Plus the SH.random signal is all of 8 bytes, so it's not especially cryptographically significant.)\r\n\r\n> (But I don't think we should omit it anyway. Just observing that we could.)\r\n\r\nOk, cool.\r\n\r\n> I'm saying I don't like option 3 because it allows the client-facing server to send HRROuter.key_share. That means the client must have code to handle it.\r\n\r\nAha, ok.\r\n",
          "createdAt": "2021-01-11T21:15:02Z",
          "updatedAt": "2021-01-11T21:15:10Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "This sounds good to me then. I'm sold on encrypting the HRRInner to prevent cookie fingerprinting.",
          "createdAt": "2021-01-11T21:25:00Z",
          "updatedAt": "2021-01-11T21:25:00Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm sold as well. I'd say this issue is ready for text.",
          "createdAt": "2021-01-19T19:06:04Z",
          "updatedAt": "2021-01-19T19:06:04Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@davidben, when do you think you can get to a PR for this? ",
          "createdAt": "2021-02-24T04:34:31Z",
          "updatedAt": "2021-02-24T04:34:31Z"
        }
      ]
    },
    {
      "number": 375,
      "id": "MDU6SXNzdWU3OTM4NTc0NTM=",
      "title": "Replace config_id with a server-chosen key_id",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/375",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "After very useful discussion with many folks, it seems now is the time to remove config_id. There are a couple reasons to do this:\r\n\r\n- Servers need to know the correct hash function to use when computing the ID, and possibly need to compute multiple IDs for a given public key (since a config can have multiple hash-based KDFs), which is somewhat annoying and redundant.\r\n- The entire ECHConfig is already authenticated, so using a hash to prove that the client made a determination based on the correct config contents is unnecessary.\r\n- Servers will likely only ever have a small handful of keys in motion at any point in time, so anything more than a couple of bits to identify one of said keys is excessive.\r\n- ... there are probably more.\r\n\r\nThe original design [had a server-chosen label, but we removed it](https://github.com/tlswg/draft-ietf-tls-esni/pull/43). (Oops!) It seems we're now in a better position to bring this back, but with some simplifications. ",
      "createdAt": "2021-01-26T01:46:27Z",
      "updatedAt": "2021-02-15T20:08:01Z",
      "closedAt": "2021-02-15T20:08:01Z",
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\nHiya,\n\nOn 26/01/2021 01:46, Christopher Wood wrote:\n> After very useful discussion with many folks, \n\nCan you send a pointer to those discussions? (Sorry, I seem\nto have missed 'em;-)\n\nTa,\nS.\n",
          "createdAt": "2021-01-26T01:56:13Z",
          "updatedAt": "2021-01-26T01:56:13Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Can you send a pointer to those discussions? (Sorry, I seem to have missed 'em;-)\r\n\r\nSorry -- these were informal conversations off-list.\r\n",
          "createdAt": "2021-01-26T02:29:02Z",
          "updatedAt": "2021-01-26T02:29:02Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 26/01/2021 02:29, Christopher Wood wrote:\n>> Can you send a pointer to those discussions? (Sorry, I seem to have missed 'em;-)\n> \n> Sorry -- these were informal conversations off-list.\n\nAh. That's a recurring problem. And even this exchange is\nactually off-list.\n\nCan we please fix that? I think I've whined about that a\nfew times now, and would hope that continual whining is\nnot a requirement;-)\n\nS.\n\n\n> \n> \n",
          "createdAt": "2021-01-26T02:35:03Z",
          "updatedAt": "2021-01-26T02:35:03Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "> Can we please fix that? I think I've whined about that a\r\nfew times now, and would hope that continual whining is\r\nnot a requirement;-)\r\n\r\nFix what? A few of us had a private conversation about some ideas and came to the conclusion that it would be better to replace the hash with a key_id. Then Chris and Martin brought it to a Github issue. This is precisely in line with the WG consensus to use Github issue discussion mode, as documented in 8874 S 5.3. \r\n",
          "createdAt": "2021-01-26T02:38:24Z",
          "updatedAt": "2021-01-26T02:38:48Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 26/01/2021 02:38, ekr wrote:\n> \n> Fix what? A few of us had a private conversation about some ideas \n\nI'm guessing that was a private discussion amongst what could\nwell be described as the usual suspects or an old-boys club\n(or are a few of you \"many folks?\"). Correct me if I'm wrong\nbut that had zero visibility and zero traceability and zero\naccountability for anyone who isn't one of those old boys.\n\nAnd yet we're zapping a field in a PDU from what was declared\nas an \"implementation draft\" a day or so after one major\ndeployment declared they had an interop target. To me, that\nsmells of disrespect for outsiders tbh.\n\nYou can probably guess what I think about that state of\naffairs:-)\n\n> and\n> came to the conclusion that it would be better to replace the hash\n> with a key_id. Then Chris and Martin brought it to a Github issue.\n> This is precisely in line with the WG consensus to use Github issue\n> discussion mode, as documented in 8874 S 5.3.\nI don't buy that tbh. Chris' mail was presented as a\nconclusion, from a wg-chair following a private discussion\nthat for sure excluded some implementers. (Me being one,\nalbeit a not very good one:-)\n\nAnd you yourself are an ex WG-chair so I'd guess you ought\nalso care about exclusivity here. What gain is there from\nthat kind of behaviour? I don't see it myself.\n\nIMO, there is no need nor benefit from being so exclusive\nwrt this spec, yet that is what is happening and has been\nfor a few years. I'd encourage those of you who may be\n\"old-boys\" to consider whether or not that is really the\nbest way to proceed. IMO - it is not, you lose way more than\nyou might think you gain, almost all the time.\n\nCheers,\nS.\n\nPS: I don't disagree with the outcome, though have opinions\non what -10 might contain. I do very much dislike the awful\nprocess, which is my point here.\n\n\n",
          "createdAt": "2021-01-26T03:02:46Z",
          "updatedAt": "2021-01-26T03:02:46Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@sftcd I would completely agree with you had the proposed PR been merged and the associated issue been closed. That has not happened. Further, it appears that you might be reading a bit more into Chris' issue summary than is really there. He is not acting in his WG chair capacity here because he is an author; I know he knows that and I really hope you can give him the benefit of the doubt here so that we do not have to suffer the \"no WG chair hat on\" in every message/post.\r\n\r\nThe process, as I see it, is pretty darn near normal. Somebody files an issue and optionally (but preferably) files a PR to address said issue. Discussion ensues amd if substantive it's taken to the list. The PR may or may not be modified based on that discussion. If consensus is reached, the PR is merged and the issue is closed.\r\n\r\nWe are at the discussion point. Can we do that now?",
          "createdAt": "2021-01-28T16:56:39Z",
          "updatedAt": "2021-01-28T16:56:39Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 28/01/2021 16:56, Sean Turner wrote:\n> @sftcd I would completely agree with you had the proposed PR been\n> merged and the associated issue been closed. That has not happened.\n> Further, it appears that you might be reading a bit more into Chris'\n> issue summary than is really there. He is not acting in his WG chair\n> capacity here because he is an author; I know he knows that and I\n> really hope you can give him the benefit of the doubt here so that we\n> do not have to suffer the \"no WG chair hat on\" in every\n> message/post.\n\nPerhaps it'd be better to not start a mail with \"After very\nuseful discussion with many folks, it seems now is the time to remove \nconfig_id.\" in cases where that discussion was\npurely private? I can understand it being hard to keep track\nwith the various tools, but for me, that still reads as a\ndecision being announced even if that was not the intent.\n\nSorry for being over-sensitive to this but IMO there is a\nhistory and ongoing tendency with this spec for a subset of\npeople to act as if they and not the IETF/WG have change\ncontrol. I fully accept that they are not deliberately\naiming to avoid having to garner WG consensus but consider\nthat ongoing instances of carelessness such as the above\ndemonstrate that there is an insider/outsider thing going\non here.\n\nS.\n\n> \n> The process, as I see it, is pretty darn near normal. Somebody files\n> an issue and optionally (but preferably) files a PR to address said\n> issue. Discussion ensues amd if substantive it's taken to the list.\n> The PR may or may not be modified based on that discussion. If\n> consensus is reached, the PR is merged and the issue is closed.\n> \n> We are at the discussion point. Can we do that now?\n> \n",
          "createdAt": "2021-01-28T17:20:43Z",
          "updatedAt": "2021-01-28T17:20:43Z"
        }
      ]
    },
    {
      "number": 378,
      "id": "MDU6SXNzdWU4MDI1NDE2MDg=",
      "title": "Naive outer_extensions decoding is a DoS risk",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/378",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "A naive implementation of decoding the inner ClientHello can easily go quadratic when processing outer_extensions. Thus far, nothing in TLS has required searching for O(N) extensions, only O(implemented extensions). It's likely a lot of TLS implementations handle the extensions list linearly most of the time.\r\n\r\nouter_extensions is now the first time you have to search for extensions you may not have implemented. A naive implementation would then go quadratic, which is a server DoS risk. It doesn't need to go quadratic (for instance, you can sort ClientHelloOuter's extensions and then binary search per lookup), but it's probably worth at least calling this out, if not switching to a simpler decoding scheme.\r\n\r\n(For a simpler decoder, we already require CHInner group the compressed extensions consecutively. We could do the same with CHOuter, at which point we only need to reference one byte slice, be it by offset/length or some goofier scheme.)",
      "createdAt": "2021-02-05T23:33:28Z",
      "updatedAt": "2021-06-14T21:01:31Z",
      "closedAt": "2021-06-14T21:01:31Z",
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 05/02/2021 23:33, David Benjamin wrote:\n> A naive implementation of decoding the inner ClientHello can easily\n> go quadratic when processing outer_extensions. Thus far, nothing in\n> TLS has required searching for O(N) extensions, only O(implemented\n> extensions). It's likely a lot of TLS implementations handle the\n> extensions list linearly most of the time.\n> \n> outer_extensions is now the first time you have to search for\n> extensions you may not have implemented. A naive implementation would\n> then go quadratic, which is a server DoS risk. It doesn't need to go\n> quadratic (for instance, you can sort ClientHelloOuter's extensions\n> and then binary search per lookup), but it's probably worth at least\n> calling this out, if not switching to a simpler decoding scheme.\n\nSwitching to a simpler scheme: yes please. Just dropping the\ncompression idea entirely: even better:-)\n\nGiven this optimisation is really mostly for PQ schemes, I'd\nargue it'd be better to just drop the current idea and have\na more constrained one, e.g. using a bit mask as the value\nof outer_extensions, so implementation know exactly which\nextensions can ever be copied from the outer CH.\n\nAnd I'd further argue we can leave defining all of that\nuntil later too.\n\nThe current scheme also imposes quite a testing burden.\nAt least with OpenSSL most extensions have some side-effect\nand testing that all combinations of those are handled\ncorrectly for the inner CH isn't trivial. (That's partly\ndown to old code being a bit awful but I guess won't be\nsimple for any code base.)\n\nCheers,\nS.\n\n\n\n> \n> (For a simpler decoder, we already require CHInner group the\n> compressed extensions consecutively. We could do the same with\n> CHOuter, at which point we only need to reference one byte slice, be\n> it by offset/length or some goofier scheme.)\n> \n",
          "createdAt": "2021-02-06T00:01:19Z",
          "updatedAt": "2021-02-06T00:01:19Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Not sure I follow the concern with side effects. Are you processing the extensions as part of decompression?\r\n\r\nIn order to make the handshake work, you'd have to construct the ClientHello by bytes anyway. Thus it seems the natural implementation would be to resolve ECH early, before ClientHello processing, then compute the inner ClientHello as bytes, then run the handshake with the resulting ClientHello. This aligns nicely with the model in split mode, etc.\r\n\r\nThe issue I have in mind is simply that the decoding process, a pure function from a pair of byte strings to a byte string, is easy to accidentally make inefficient.",
          "createdAt": "2021-02-06T03:35:41Z",
          "updatedAt": "2021-02-06T03:35:41Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> We could do the same with CHOuter, at which point we only need to reference one byte slice, be it by offset/length or some goofier scheme.\r\n\r\nIt occurs to me this might cause some conflicts between wanting ECH-ful and ECH-less ClientHellos to look similar (don't stick out) and pressures on ClientHello extension order. The order *should* be irrelevant, but compat concerns have cropped up before. (If only we required extensions be sorted...)\r\n\r\nAnother possibility for a simpler decode would be if outer_extensions listed indexes into the extension list, rather than extension IDs. Though we would need to answer silly questions like whether it's an index into ClientHelloOuter or ClientHelloOuterAAD.",
          "createdAt": "2021-02-08T22:51:32Z",
          "updatedAt": "2021-02-08T22:51:32Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "Since this is more of an implementation detail, let's just add a warning to handle this responsibly (i.e. the sort and binary search).",
          "createdAt": "2021-02-16T21:37:31Z",
          "updatedAt": "2021-02-16T21:37:31Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yet another way to address this is with a simple hash map, e.g.: https://github.com/cloudflare/go/blob/cf/src/crypto/tls/ech.go#L652-L768.\r\n\r\nMy vote is to leave the encoding scheme as-is and simply leave a warning.",
          "createdAt": "2021-02-18T20:14:07Z",
          "updatedAt": "2021-02-18T20:14:07Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "\ud83d\udc4d @cjpatton, @cbartle891, could one of you please propose text for that warning?",
          "createdAt": "2021-02-18T23:13:12Z",
          "updatedAt": "2021-02-18T23:13:12Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Another DoS risk to be careful of: implementations typically enforce size limits on TLS messages so they aren't forced to buffer 2^24 bytes. Whatever size limit is enforced on ClientHello needs to also be enforced on the inner ClientHello *before* allocating memory for it.\r\n\r\nIn particular, if ClientHelloOuter has a single giant extension, and it is referenced multiple times in OuterExtensions, you can blow up the server's resource usage. (Though I can't think of any case without repeating an extension where the resulting size grows dramatically.)",
          "createdAt": "2021-02-20T23:11:45Z",
          "updatedAt": "2021-02-20T23:11:45Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "Is there any valid reason why an extension would appear multiple times in a ClientHello? If not, maybe we should specify that the server must abort if OuterExtensions references an extension more than once.",
          "createdAt": "2021-02-22T17:18:47Z",
          "updatedAt": "2021-02-22T17:18:47Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Seems reasonable. I think the combination of \"no duplicate extensions\" and \"no referencing the ECH extension\" imply that sizeof(ClientHelloInner) < sizeof(ClientHelloOuter).",
          "createdAt": "2021-02-22T19:50:41Z",
          "updatedAt": "2021-02-22T19:50:41Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Keeping this opening to track @davidben's and @sftcd's comments on CH sizes. @sftcd, could you please send a PR if you have cycles?",
          "createdAt": "2021-02-23T01:37:42Z",
          "updatedAt": "2021-02-23T01:44:33Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed in 110: Will propose text to address the second vector and then close this issue.",
          "createdAt": "2021-03-08T16:51:11Z",
          "updatedAt": "2021-03-08T16:51:11Z"
        }
      ]
    },
    {
      "number": 379,
      "id": "MDU6SXNzdWU4MDQwMjE1NjY=",
      "title": "Consider a shorter config ID length",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/379",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Assuming #376 lands, we need to decide how long we want this server-chosen identifier to be. There are various operational and privacy considerations at play. For example, shorter identifiers mean that GREASE clients may produce colliding values with higher probability, and the cost of trial decryption on the server may be an overly expensive operational cost for some deployments. Longer identifiers may also mean that using keys as a tracking vector is easier. (But as @ekr has pointed out, ECH does not assume DNS answer integrity, so there are other tracking mechanisms at play.) Let's use this issue to sort out this question. \r\n\r\ncc @davidben, @cjpatton, @martinthomson ",
      "createdAt": "2021-02-08T22:27:58Z",
      "updatedAt": "2021-03-23T20:23:07Z",
      "closedAt": "2021-03-23T20:23:07Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "(This may just be me misinterpreting what you wrote.) Why would a GREASE/real ID collision be expensive operationally? I could see being concerned about perf costs (the connection needs 1 HPKE op instead of 0), but I'm not sure I see the operational concern.",
          "createdAt": "2021-02-08T22:33:57Z",
          "updatedAt": "2021-02-08T22:33:57Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Why would a GREASE/real ID collision be expensive operationally? \r\n\r\nIf GREASE collides with a real key ID, then the server attempts decryption to only see that it fails, and then falls back. (The chances of that collision happening are pretty high with a 1-byte ID.) So, yeah, \"expensive operationally\" is \"1 HPKE operation instead of 0.\" Whether or not that's an issue seems server-specific.",
          "createdAt": "2021-02-08T23:48:09Z",
          "updatedAt": "2021-02-08T23:48:09Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, okay. I interpreted \"expensive operationally\" to mean there was some operational challenge, but you just mean it might not perform well in some deployments.",
          "createdAt": "2021-02-08T23:52:18Z",
          "updatedAt": "2021-02-08T23:52:18Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Although, presumably no less well than connections that actually enable ECH.",
          "createdAt": "2021-02-08T23:53:11Z",
          "updatedAt": "2021-02-08T23:53:11Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "From my perspective, I am totally comfortable with a 1/64 (approximately) chance of hitting that 1 bogus HPKE operation.  A server that offers ECH has to be prepared for every connection it receives to use ECH.\r\n\r\nBut I don't operate a server, so take that position with that in mind.",
          "createdAt": "2021-02-09T00:06:19Z",
          "updatedAt": "2021-02-09T00:06:19Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> From my perspective, I am totally comfortable with a 1/64 (approximately) chance of hitting that 1 bogus HPKE operation.  A server that offers ECH has to be prepared for every connection it receives to use ECH.\n\nLikewise. I see little reason for anything longer than a byte here.",
          "createdAt": "2021-02-09T00:29:58Z",
          "updatedAt": "2021-02-09T00:29:58Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I also am not worried about a non-negligible probability of a greased config_id colliding with a real config_Id. I think a more important consideration that came up in #376 is dealing with two real configs having the same config_id. In particular, I think the spec should make it easy for servers to avoid collisions altogether. That way the server doesn't have to resort to trial decryption in case of a collision.\r\n\r\nAt the same time, we need to make it easy for clients to grease. As has been suggested, if we want a 1-byte config_id, I think we should mandate the config_id be chosen at random, but permit rejection sampling in order to allow the server to avoid collisions. This seems like a funky requirement to put in a spec, but also seems perfectly fine from a technical perspective.\r\n\r\n",
          "createdAt": "2021-02-09T20:08:32Z",
          "updatedAt": "2021-02-09T20:12:14Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd be fine with that as the RECOMMENDED way to generate these identifiers. Perhaps the text could say something like the following?\r\n\r\n> The RECOMMENDED technique for generating a new ECHConfig.config_id is to choose a random byte. This process should be repeated if this config_id matches that of any existing and valid ECHConfig.\r\n\r\nOf course, clients can't validate that servers do this, so the best we can do is recommend some best practice here.",
          "createdAt": "2021-02-09T21:43:31Z",
          "updatedAt": "2021-02-09T21:43:46Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That seems like a reasonable outcome.  It require coordination, but at a level at which I think is reasonable (you don't want independent processes feeding ECH keys into the system, that is a recipe for failure).",
          "createdAt": "2021-02-10T00:26:49Z",
          "updatedAt": "2021-02-10T00:26:49Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Works for me!",
          "createdAt": "2021-02-10T16:36:04Z",
          "updatedAt": "2021-02-10T16:36:04Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "NONE",
          "body": "Can we use an arbitrary length, up to some length, but with a recommendation to use one byte where possible?  There are a number of deployment environments where it may be preferable to use longer config_ids (eg, using a 8-byte config_id would allow for using a hash of a public key as the config_id without needing to do trial-decryption or demuxing).  Server operators who want to abuse this could just not enable ECH or could use a large number of IP addresses.",
          "createdAt": "2021-03-08T16:31:20Z",
          "updatedAt": "2021-03-08T16:31:20Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed in 110: Poll suggested most folks were in favor of 1 byte. We'll move ahead with this plan.",
          "createdAt": "2021-03-08T16:39:39Z",
          "updatedAt": "2021-03-08T16:40:02Z"
        }
      ]
    },
    {
      "number": 380,
      "id": "MDU6SXNzdWU4MDc2MDc5OTI=",
      "title": "Related Privacy Leaks suggests too strong of a correlation across resumption",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/380",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "(Filing this as a separate ticket so I don't forget to propose new text.)\r\n\r\n#371 added this text:\r\n\r\n> Attacks that rely on non-ECH traffic to infer server identity in an ECH connection are \r\n> out of scope for this document. For example, a client that connects to a particular host \r\n> prior to ECH deployment may later resume a connection to that same host after ECH \r\n> deployment, thereby linking the resulting ECH connection to the original non-ECH \r\n> connection.\r\n\r\nI think this statement is a bit strong and overstates the issue. It reads as if resuming connections across ECH and non-ECH links the two connections.\r\n\r\nIf we're talking about someone other than the server, this isn't true. Tickets are issued encrypted and, in ECH, even sent encrypted. Even if they were sent in the clear, TLS 1.3's [single-use tickets](https://tools.ietf.org/html/rfc8446#appendix-C.4) protects against such correlations. Rather, the correlation in #369 is a much weaker one: based on either the size of the ClientHello or whether the server accepted the ticket, you learn a single bit for whether it was *some* previous connection made by that client. You don't know which previous connection it was, and you don't know if it was an ECH connection or a non-ECH connection. In fact what you learn... more-or-less aligns with the anonymity set. See https://github.com/tlswg/draft-ietf-tls-esni/issues/369#issuecomment-736083162.\r\n\r\n(If we're talking about the server, yes, resuming allows the server to link the two connections. That's fundamental to resumption and is in the purview of https://github.com/tlswg/tls13-spec/pull/1205. I don't think most applications would consider ECH vs non-ECH a correlation boundary w.r.t. the server itself.)",
      "createdAt": "2021-02-12T23:17:13Z",
      "updatedAt": "2021-02-17T20:20:55Z",
      "closedAt": "2021-02-17T20:20:55Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The original text doesn't necessarily imply that on-the-wire tickets are the linking factor. Rather that the shape of the handshake, time it takes to complete, etc, can be a proxy for whether or not resumption occurred. I don't think we need to change anything here. (But I also would not object to someone else sending a PR!) ",
          "createdAt": "2021-02-15T17:06:58Z",
          "updatedAt": "2021-02-15T17:07:17Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "(This came up in a discussion between me and @dmcardle.)\r\n\r\nSo, the current text says \"For example, a client that [does X] may [do Y], thereby linking the resulting ECH connection to the original non-ECH connection\". That implies that doing X and Y allows linking the two connections together.\r\n\r\nYou're right that tickets may not be the only linking factor, but the other channels don't let you link connections, only, as you say, *whether or not resumption occurred*. That single boolean doesn't tell you which non-ECH connection corresponded to the ECH connection, or what the name was. It only tells you that it's the same name as *some* previous connection to the anonymity set. It might be a non-ECH one (but you don't know which) or it might be an ECH one.",
          "createdAt": "2021-02-16T21:48:07Z",
          "updatedAt": "2021-02-16T21:48:07Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Feel free to suggest text to reword this. I think the example was meant to be general enough to suggest that side channels exist. I definitely do not feel strongly about the exact wording here. ",
          "createdAt": "2021-02-16T23:30:17Z",
          "updatedAt": "2021-02-16T23:30:17Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that the text as-is overstates the issue.",
          "createdAt": "2021-02-17T01:11:45Z",
          "updatedAt": "2021-02-17T01:11:45Z"
        }
      ]
    },
    {
      "number": 384,
      "id": "MDU6SXNzdWU4MTEzOTk0OTM=",
      "title": "PSK usage sticks out",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/384",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "As discussed in #354, there are two real-ECH/grease-ECH differentiators related to the PSK extension we may wish to address.\r\n\r\n1. Real ECH disallows the PSK extension in ClientHelloOuter, whereas grease ECH permits PSK in ClientHello.\r\n2. Real ECH allows PSK in ClientHelloInner. In case of acceptance, the backend server may respond with PSK in ServerHello. The response would appear to be unsolicited. something that would not happen in a grease-ECH or vanilla handshake.\r\n\r\nThe question we will ask ourselves here is if/how to mitigate these differentiators. We might simply say that clients MAY (or SHOULD?) send a dummy PSK in the ClientHello(Outer). This ought to provide sufficient cover.",
      "createdAt": "2021-02-18T19:38:54Z",
      "updatedAt": "2021-04-12T20:22:30Z",
      "closedAt": "2021-04-12T20:22:30Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't mind a MAY on sending a dummy PSK in case (2), though I don't think it's a good idea for case (1). The case that really matters here is when the outer and inner ClientHello both lack PSKs:\r\n\r\nSuppose the buggy network is sensitive to (1) and only allows ECH extensions when the outer ClientHello has a PSK because it knows those can't be ECH. That network has effectively broken _all_ connections because the only way for the client to get a PSK is to have connected to the server without a PSK at some point.\r\n\r\nSuppose instead the buggy network is sensitive to (2) and breaks if the inner ClientHello has a PSK but the outer does not. The connect will fail, but between single-use tickets and bounded client session caches, the client will quickly exhaust its tickets and get out of case (2). This is a performance issue, but the connections still work. (Though, yeah, adding the option to send a dummy one might help there. *shrug*)",
          "createdAt": "2021-02-18T22:23:58Z",
          "updatedAt": "2021-02-18T22:23:58Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not following the following point. Could you elaborate?\r\n\r\n> Suppose the buggy network is sensitive to (1) and only allows ECH extensions when the outer ClientHello has a PSK because it knows those can't be ECH. That network has effectively broken _all_ connections because the only way for the client to get a PSK is to have connected to the server without a PSK at some point.\r\n\r\nIn any case, the case to mitigate (2) seems more compelling than the case to mitigate (1), since (2) would look like non-compliance to an ECH-ignorant network. Would be curious to see what others think.\r\n\r\n\r\n\r\n",
          "createdAt": "2021-02-19T16:21:25Z",
          "updatedAt": "2021-02-19T16:21:25Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "So I think the benefit of GREASE-like strategies is that broader breakages now are more noticeable than focused breakage later. More noticeable breakage is more likely to be fixed, and less likely to make it to the ecosystem in the first place. This applies to ECH GREASE by saying we want all ClientHellos to look like ECH was deployed, so the network is less likely to develop intolerances.\r\n\r\nDifferences between GREASE ECH and actual ECH thus matter because the network be intolerant to something that we failed to simulate. (1) says that, in actual ECH, all outer ClientHellos have no PSK. In GREASE ECH, some outer ClientHellos have a PSK while some do not. If we were to translate that to actual intolerance, it would mean the network rejects outer ClientHellos without a PSK. But that would break everything, ECH or non-ECH, anyway because clients don't send PSKs the first time[*] they connect to a server. Clients only have PSKs to send the second time, and you can't connect a second time if you didn't connect a first time. Thus, even though (1) is a difference, it doesn't seem that difference prevents us from noticing intolerance.\r\n\r\nAgreed that mitigating (2) is more compelling than mitigating (1).\r\n\r\n[*] First time overall, first time after a restart (if sessions aren't persisted), or first time after a long break (sessions expired).",
          "createdAt": "2021-02-19T19:35:14Z",
          "updatedAt": "2021-02-19T19:37:14Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that (2) is more important. And I'm fine with a \"MAY/SHOULD send an outer dummy PSK if you are using ECH and have an inner PSK.\" @davidben, if we were to append on a dummy PSK, what do you think would be a suitable length? (Bikeshedding over that should be fun.)\r\n\r\nAs an aside, I wanted to drill in on this point:\r\n\r\n> If we were to translate that to actual intolerance, it would mean the network rejects outer ClientHellos without a PSK. But that would break everything, ECH or non-ECH,\r\n\r\nThis seems true, if we're assuming the the intolerance is \"break the connection,\" which I think is the right interpretation. But it occurs to me that there's a slightly weaker form of misbehavior thats's possible with (1): a network may learn information about when a given client uses ECH. This seems out of scope, but maybe something to keep in mind?",
          "createdAt": "2021-02-20T01:41:56Z",
          "updatedAt": "2021-02-20T01:41:56Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Re length, I dunno leave it to the client to choose? \"Probably not very long.\"\r\n\r\nMaking that in scope sounds exceedingly difficult. For instance, for a given server, you might know that tickets issued today start with 12345 (maybe the ID of today's key), but synthesized dummy tickets won't match that.",
          "createdAt": "2021-02-22T23:26:36Z",
          "updatedAt": "2021-02-22T23:26:36Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Making that in scope sounds exceedingly difficult. \r\n\r\nYep, no argument there. ",
          "createdAt": "2021-02-22T23:27:35Z",
          "updatedAt": "2021-02-22T23:27:35Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed in 110: Will submit a PR that says \"clients MAY send a dummy PSK if the inner CH uses a PSK.\" ",
          "createdAt": "2021-03-08T16:24:27Z",
          "updatedAt": "2021-03-08T16:24:27Z"
        }
      ]
    },
    {
      "number": 386,
      "id": "MDU6SXNzdWU4MTI0NzQ2NjQ=",
      "title": "Fixed-length values should probably be fixed-length",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/386",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In the `ECHConfigContents` struct, we have the following:\r\n\r\n```\r\n    opaque HpkePublicKey<1..2^16-1>;\r\n    ...\r\n\r\n    struct {\r\n        ...\r\n        HpkeKemId kem_id;\r\n        HpkePublicKey public_key;\r\n        ...\r\n    } HpkeKeyConfig;\r\n```\r\n\r\n`HpkeKeyConfig.public_key` is a serialized HPKE public key. However, these keys have a fixed length (`Npk`). We can remove the length prefix around this value and simple define `HpkePublicKey` like so:\r\n\r\n```\r\nopaque HpkePublicKey[Npk];\r\n```\r\n\r\nParsing shouldn't be an issue, since consuming clients first parse the `HpkeKeyConfig.kem_id`. If this corresponds to an unknown KEM, they can't use the `HpkeKeyConfig` or parent `ECHConfigContents`, and can move onto the next `ECHConfig` in the list to check. \r\n\r\nWe may also do this for `ClientECH`, which length-prefixes the `enc` field (of fixed length `Nenc`), but that might complicate  trial decryption use cases. \r\n\r\nNote that [KeyShareEntry keys](https://tools.ietf.org/html/rfc8446#section-4.2.8) are length-prefixed, but I don't think we need to follow that guidance here. HPKE exposed fixed-length keys for a reason. :-) \r\n\r\ncc @martinthomson ",
      "createdAt": "2021-02-20T01:30:11Z",
      "updatedAt": "2021-03-08T16:45:45Z",
      "closedAt": "2021-03-08T16:45:45Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed in 110: Makes general purpose parsers more difficult. Closing as a result.",
          "createdAt": "2021-03-08T16:45:45Z",
          "updatedAt": "2021-03-08T16:45:45Z"
        }
      ]
    },
    {
      "number": 387,
      "id": "MDU6SXNzdWU4MTI0Nzc5NDc=",
      "title": "Update to HPKE-08",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/387",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [
        "ready-for-text"
      ],
      "body": "This new version of the draft removes the version-vector dependency, so this should be the last time we update the pinned version.",
      "createdAt": "2021-02-20T01:45:52Z",
      "updatedAt": "2021-02-24T18:05:13Z",
      "closedAt": "2021-02-24T18:05:13Z",
      "comments": []
    },
    {
      "number": 388,
      "id": "MDU6SXNzdWU4MTQwMDMyMDg=",
      "title": "Include changelog going forward",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/388",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "Since -09 is the first \"official\" interop target, we should make it easy going forward to track deltas between versions. Let's add a changelog for each revision of the draft to help implementers out.",
      "createdAt": "2021-02-23T01:09:13Z",
      "updatedAt": "2021-03-08T18:54:58Z",
      "closedAt": "2021-03-08T18:54:58Z",
      "comments": []
    },
    {
      "number": 389,
      "id": "MDU6SXNzdWU4MTQxNDU1MjM=",
      "title": "Public name rewriting",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/389",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Is there any sense in having the server validate the value of the server name indication extension in the outer ClientHello?  It seems like it might help avoid a trivial attack on DNS that might otherwise pass without notice or alarm.  That is, an attack that copies the DNS QNAME in the public_name field.  \r\n\r\nThere are various ways in which this might fail, but none of the scenarios that I can think of result in anything that a client or server might recognize as being alarming.\r\n\r\nIt is easy to detect and prevent this sort of interference: the client-facing server checks that the SNI matches the value it expects from the ECHConfig that has been selected.  If the config might have changed, such that multiple values are valid, then the server can allow for that, but generally there will be just one valid value.",
      "createdAt": "2021-02-23T06:08:09Z",
      "updatedAt": "2021-03-01T04:32:07Z",
      "closedAt": "2021-03-01T04:32:07Z",
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\nHiya,\n\nOn 23/02/2021 06:08, Martin Thomson wrote:\n> Is there any sense in having the server validate the value of the\n> server name indication extension in the outer ClientHello?  \n\nI think that check ought, at best, be a MAY, and not a\nMUST. The reason being to support non-browser clients,\nand as a possible additional hedge for circumvention\ntools (that may also be non-browser clients). I also\nsuspect, but don't know, that omitting such checks might\nimprove some hosting scenarios that could otherwise be\na pain - where the hoster's lookup of any sni value\nis an expensive DB access to load the right key pair\nand cert. (Sure, that could be optimised but then we'd\nbe adding yet more complexity to ECH deployment, which\nis worse than even all the complexity we've added to\nimplementation;-)\n\nFor example, when we've done work on curl, we allow\nan optional name on the command line that then overrides\nthe ECHConfig.public_name. I don't see any reason to\nprevent that TBH. And I reckon it could enable some\npossibly interesting use-cases there's no reason for\nus to prevent.\n\n> It seems\n> like it might help avoid a trivial attack on DNS that might otherwise\n> pass without notice or alarm.  That is, an attack that copies the DNS\n> QNAME in the public_name field.\n\nI'd have no problem if we said \"if outerCH.sni==innerCH.sni\"\nthen ignore the innerCH, or something similar. But it ought\nbe valid, and maybe even encouraged, to ignore the sni from\nthe outerCH, when the innerCH works.\n\n> There are various ways in which this might fail, but none of the\n> scenarios that I can think of result in anything that a client or\n> server might recognize as being alarming.\n> \n> It is easy to detect and prevent this sort of interference: the\n> client-facing server checks that the SNI matches the value it expects\n> from the ECHConfig that has been selected.  If the config might have\n> changed, such that multiple values are valid, then the server can\n> allow for that, but generally there will be just one valid value.\n\nAgain, I don't see sufficient benefit, so would rather keep\nthe flexibility and easier deployment of omitting that.\n\nCheers,\nS.\n\n\n",
          "createdAt": "2021-02-23T13:05:34Z",
          "updatedAt": "2021-02-23T13:05:34Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "The entire ECHConfig is also bound into the decryption, so if the DNS is messing with ECHConfigs, you won't end up negotiating ECH. Copying the QNAME into the public name probably will successfully bounce ECH off via the recovery flow, but the DNS could just as easily have dropped the ECHConfig itself.",
          "createdAt": "2021-02-23T15:13:14Z",
          "updatedAt": "2021-02-23T15:13:14Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson can you elaborate on the attack you had in mind? @davidben notes that the entire ECHConfig is now authenticated, so any disagreement between client and server will cause ECH negotiation failure. ",
          "createdAt": "2021-02-27T02:37:38Z",
          "updatedAt": "2021-02-27T02:37:38Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I should have responded earlier (thought I did...).  The fact that the configuration is covered prevents this from being a problem.  I missed that.",
          "createdAt": "2021-03-01T04:32:07Z",
          "updatedAt": "2021-03-01T04:32:07Z"
        }
      ]
    },
    {
      "number": 395,
      "id": "MDU6SXNzdWU4MjUwMjgxNTg=",
      "title": "Add some more structure to \"Offering ECH\"",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/395",
      "state": "CLOSED",
      "author": "sayrer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "I think a brief summary at the top of the section might help a lot. It could just be a list with links to subsections containing the text that's already there.\r\n\r\nAs an example, I wrote this brief summary for Rustls collaborators.\r\n\r\n```\r\nThe client steps are as follows:\r\n\r\n- Create a ClientHelloInner (just a ClientHello with some restrictions)\r\n- Create an \u201cEncodedClientHelloInner\u201d that can be a no-op for now, since we won\u2019t deduplicate anything in the ClientHelloOuter for now.\r\n- Create a ClientHelloOuter for the EncodedClientHelloInner (a ClientHello with some other restrictions).\r\n- The ClientHelloOuterAAD is computed to created \u201cAdditional authenticated data\u201d for HPKE by serializing the entire ClientHelloOuter less the last extension (which is ECH)\r\n- The encrypted_client_hello extension (ECH) is computed using choices from the ECHConfig (done for -09) and the ClientHelloOuterAAD.\r\n```",
      "createdAt": "2021-03-08T22:44:46Z",
      "updatedAt": "2023-10-09T23:20:57Z",
      "closedAt": "2023-10-09T23:20:57Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like this idea. Send a PR?",
          "createdAt": "2021-03-23T20:24:15Z",
          "updatedAt": "2021-03-23T20:24:15Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sayrer I think this has been overcome by events with the latest structure of the Offering ECH section. We now describe the steps that clients follow in linear fashion. I'm going to close this as having been overcome by events.",
          "createdAt": "2023-10-09T23:20:57Z",
          "updatedAt": "2023-10-09T23:20:57Z"
        }
      ]
    },
    {
      "number": 396,
      "id": "MDU6SXNzdWU4MjgzODQzMjE=",
      "title": "A MUST for inclusion of public_name in outer SNI seems wrong",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/396",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "For at least command line clients (e.g. curl) and perhaps for censorship circumvention tools it makes sense to allow the outer SNI to contain nothing or something that is not the public_name from the SVCB RR. It's possible that any tool that acquires an ECHConfig from a non-DNS source would benefit from that option too.\r\n\r\nThe offending (for me:-) text is in section 6.1, 2nd list, bullet 7 where it says: 'The value of ECHConfig.contents.public_name MUST be placed in the \"server_name\" extension.'\r\n\r\nThere may be clients that do need the above. I'm not sure how to chacterise those in a short phrase, but that's likely possible. At the IETF-110 TLS session mention was made of clients that need to fallback but I'm not sure what reference would be correct for that if e.g. we appended something like \"....for clients that need to be able to fallback. [ref]\"",
      "createdAt": "2021-03-10T21:55:49Z",
      "updatedAt": "2021-06-14T21:01:49Z",
      "closedAt": "2021-06-14T21:01:49Z",
      "comments": [
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "> and perhaps for censorship circumvention tools \r\n\r\nCensorship circumvention isn't one of the stated goals of ECH.\r\n\r\n> It's possible that any tool that acquires an ECHConfig from a non-DNS source would benefit from that option too.\r\n\r\nEven if an ECHConfig is acquired from a non-DNS source, it still has the ECHConfig.contents.public_name field, which, as specified in 6.1.3.3, is necessary because:\r\n\r\n\"The client MUST verify that the certificate is valid for ECHConfig.contents.public_name. If invalid, it MUST abort the connection with the appropriate alert.\"\r\n",
          "createdAt": "2021-03-10T22:12:35Z",
          "updatedAt": "2021-03-10T22:12:35Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe we should keep this as-is. Fallback is for the server's benefit and the client has no way of knowing whether it will be needed.",
          "createdAt": "2021-03-10T22:34:26Z",
          "updatedAt": "2021-03-10T22:34:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 -- for robustness reasons, I believe we should keep this as-is.",
          "createdAt": "2021-03-10T22:44:30Z",
          "updatedAt": "2021-03-10T22:44:30Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I also found this requirement odd. Is it really necessary with the changes to config_id in draft -10? If someone could explain why this should be mandatory, that would be fine. I just don't understand the requirement.",
          "createdAt": "2021-03-10T23:08:14Z",
          "updatedAt": "2021-03-10T23:08:14Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "When there is a mismatch between DNS and the server configuration, the server will handshake with the outer ClientHello. The expectation when that happens is that the connection is authenticated for the public name, which gives an authenticated recovery signal. That means the server needs to, e.g., select a certificate that covers the public name. Thus, the outer SNI selection.",
          "createdAt": "2021-03-10T23:13:11Z",
          "updatedAt": "2021-03-10T23:13:11Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK, and a server that didn't need the outer SNI name would be identifiable by IP address anyway. Makes sense.",
          "createdAt": "2021-03-10T23:38:13Z",
          "updatedAt": "2021-03-10T23:38:13Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 10/03/2021 23:13, David Benjamin wrote:\n> When there is a mismatch between DNS and the server configuration,\n> the server will handshake with the outer ClientHello. The expectation\n> when that happens is that the connection is authenticated for the\n> public name, which gives an authenticated recovery signal. That means\n> the server needs to, e.g., select a certificate that covers the\n> public name. Thus, the outer SNI selection.\n\nSure - the right outer.sni MUST be valid for the client\nto act upon failed ECH. I don't see that that implies that\nthe ech.public_name MUST be sent though.\n\nS.\n\n\n\n",
          "createdAt": "2021-03-11T11:43:29Z",
          "updatedAt": "2021-03-11T11:43:29Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\nHiya,\n\nOn 10/03/2021 22:12, Carrick Bartle wrote:\n>> and perhaps for censorship circumvention tools\n> \n> Censorship circumvention isn't one of the stated goals of ECH.\n\nI understand the sensitivities there but nor are we forced to\nmake life harder for those who develop such applications.\n(Separately, I don't recall there being any consensus call\nrelated to whether or not that is or is not a goal.)\n\n>> It's possible that any tool that acquires an ECHConfig from a\n>> non-DNS source would benefit from that option too.\n> \n> Even if an ECHConfig is acquired from a non-DNS source, it still has\n> the ECHConfig.contents.public_name field, which, as specified in\n> 6.1.3.3, is necessary because:\n> \n> \"The client MUST verify that the certificate is valid for\n> ECHConfig.contents.public_name. If invalid, it MUST abort the\n> connection with the appropriate alert.\"\n> \n\nA requirement for the client to verify the outer.sni vs. the\npresented cert does not need to involve the public_name. I'm\nfine that the client MUST (as always) verify the presented\ncert vs. the outer.sni if ECH didn't work.\n\nI'd also be fine with a SHOULD send here, or with a \"MUST\ndefault to send public_name in outer.sni\" but an absolute\nMUST is not necessary afaics.\n\nThe issue for me is for a generic library - in that case\nbeing able to override the public_name seems like it may\nsometimes be useful and since there's no need to require\nlibrary developers to enforce the MUST, it's a bad plan\nI think.\n\nCheers,\nS.\n\n\n\n\n\n\n",
          "createdAt": "2021-03-11T11:43:30Z",
          "updatedAt": "2021-03-11T11:43:30Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\nHiya,\n\nOn 10/03/2021 22:34, ekr wrote:\n> I believe we should keep this as-is. Fallback is for the server's \n> benefit and the client has no way of knowing whether it will be \n> needed.\n\nNot convinced.\n\nFor a web browser talking to a web server given a sensible\nset of DNS RRs, I do agree with you. For any random TLS\nclient/server pair, I'm not yet convinced. Hence I still\nconsider an absolute MUST OTT/wrong.\n\nS.\n\n\n\n",
          "createdAt": "2021-03-11T11:43:35Z",
          "updatedAt": "2021-03-11T11:43:35Z"
        },
        {
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One oddity of this requirement is that it presents a GREASE distinguisher when the client is connecting to an IP address with no server name.  In the GREASE case, the ClientHelloOuter.server_name is absent because [SNI only supports host names](https://tools.ietf.org/html/rfc6066#section-3). In the real-ECH case, ClientHelloOuter.server_name is present and contains ECHConfig.public_name.\r\n\r\nHowever, why use ECH at all if the IP address uniquely identifies the desired service? I think I support keeping the requirement for the sake of the fallback/retry mechanism.\r\n\r\nWas there some other scenario you're thinking of?",
          "createdAt": "2021-03-11T18:15:14Z",
          "updatedAt": "2021-03-11T18:15:14Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "(The outer name pretty fundamentally interacts with GREASE because the distribution of true SNIs is different from the distribution of cleartext ones, but the fact that IP addresses don't get SNIs is an insignificant component of that, given how rare they are. Any reasonable model of GREASE distinguishability would need to be a bit more subtle.)",
          "createdAt": "2021-03-11T18:26:30Z",
          "updatedAt": "2021-03-11T18:26:30Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If possible, I'd like to see if we can drill down on where folks disagree.\r\n* **Fact 1:** The public name specifies the name that the client expects the client-facing server to verify in case of ECH rejection.\r\n* **Fact 2:** The outer SNI specifies the name the client expects the client-facing server to verify, regardless of whether ECH was offered.\r\n\r\nIt seems like the point of disagreement is how these two extensions --- ECH and SNI --- are meant to be composed. It seems to me that @davidben believes that SNI takes precedence: if we allowed public name != outer SNI, then this would violate the rules of the SNI extension, It seems like @sftcd believes that ECH can take precedence: allowing public name != outer SNI is OK because the client already knows what name the client-facing server will verify. Am I understanding this all correctly?",
          "createdAt": "2021-03-23T22:20:02Z",
          "updatedAt": "2021-03-23T22:20:02Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm very confused what facts 1 and 2 are trying to say.\r\n\r\nThe server_name extension, in any ClientHello, is the name of the server you're trying to contact with that ClientHello. This figures into certificate selection, and you could even imagine a protocol which uses it in lieu of an in-band Host header for virtual hosting. (Although HTTP does it in-band and doesn't care much about the server_name.)\r\n\r\nIn the ClientHelloInner, you are trying to contact the true name, so you put the true name in server_name.\r\nIn the ClientHelloOuter, you are trying to contact the public name, so you put the public name in server_name.\r\n\r\nIndependent of ECH, if you have external knowledge that such-and-such field will be interpreted in a different way and the server doesn't need the server_name, then you can go against the spec. If that external knowledge applies to the ClientHelloOuter, then you can apply that to the ClientHelloOuter. But that's not how the field is meant to work, so the spec should describe the intended semantics.",
          "createdAt": "2021-03-23T22:37:13Z",
          "updatedAt": "2021-03-23T22:37:13Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Independent of ECH, if you have external knowledge that such-and-such field will be interpreted in a different way and the server doesn't need the server_name, then you can go against the spec. If that external knowledge applies to the ClientHelloOuter, then you can apply that to the ClientHelloOuter. But that's not how the field is meant to work, so the spec should describe the intended semantics.\r\n\r\nThis seems to advocate that a SHOULD, rather than a MUST, is appropriate in choosing what name goes in ClientHelloOuter, right? In particular, the spec does not accommodate external knowledge about what goes in the field. It requires it be set to ECHConfig.public_name.",
          "createdAt": "2021-03-23T22:44:21Z",
          "updatedAt": "2021-03-23T22:44:21Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 23/03/2021 22:44, Christopher Wood wrote:\n> This seems to advocate that a SHOULD, rather than a MUST, \n\nI think a SHOULD is correct.\n\nCheers,\nS.\n",
          "createdAt": "2021-03-23T22:49:10Z",
          "updatedAt": "2021-03-23T22:49:10Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I'm very confused what facts 1 and 2 are trying to say.\r\n\r\nFact 1 says that public_name is the name of the server when ECH is rejected (i.e., the client-facing server). Fact 2 says that server_name is the name of the server. My point was merely that these facts appear to contradict one another if public_name != CHOuter.server_name. Hence, we need to decide how to compose ECH with SNI in a way that resolves the contradiction.\r\n\r\nThe answer might simply be that public_name MUST equal CHOuter.server_name. Or, we might do say something else.",
          "createdAt": "2021-03-23T23:02:36Z",
          "updatedAt": "2021-03-23T23:04:34Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "(I don't particular care about MUST vs. SHOULD. Whatever we say elsewhere for server_name I guess.)\r\n\r\n@cjpatton I'm not following. I think talking about public_name != CHOuter.server_name is getting causality the wrong way around.\r\n\r\nCHOuter is a construct we are inventing in ECH. That means we get to define the semantics. The semantics we've defined are that CHOuter, along with the result of handshaking with CHOuter, is intended for the ECH rejection case. How does the client know how the ECH rejection case works? Well, we also need to define that in ECH. Our definition is that you handshake against ECHConfig.public_name. Finally, server_name is a construct that has already been defined. What goes in there? RFC6066 and RFC8446 tell you. It's the name of the server you are trying to contact.\r\n\r\nWith all that, what do you put in CHOuter.server_name? Well, you put the rules together. It's the name of the server you are trying to contact in the ECH rejection case, which is ECHConfig.public_name.",
          "createdAt": "2021-03-24T19:09:00Z",
          "updatedAt": "2021-03-24T19:10:23Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 24/03/2021 19:09, David Benjamin wrote:\n> (I don't particular care about MUST vs. SHOULD. Whatever we say\n> elsewhere for server_name I guess.)\n\nI do:-) SHOULD seems correct to me. A MUST over-constrains\ngeneric libraries.\n\n> \n> @cjpatton I'm not following. I think talking about public_name !=\n> CHOuter.server_name is getting causality the wrong way around.\n\nI agree with the above but will quibble with some text\nbelow...\n\n> CHOuter is a construct we are inventing in ECH. That means we get to\n> define the semantics. \n\nNot really - CHOuter has to be a \"working\" CH with semantics\ndefined by 8446, so we're a lot more constrained in reality.\n\n> The semantics we've defined are that CHOuter,\n> along with the result of handshaking with CHOuter, is intended for\n> the ECH rejection case. \n\nYep.\n\n> How does the client know how the ECH\n> rejection case works, well we also need to define that. Our\n> definition is that ECHConfig.public_name tells you the name to\n> handshake against. \n\nThat's too absolute IMO. ECHConfig.public_name tells you *a*\nname that should work for the CHOuter fallback. There will be\nmany situations where another name can work as well, though\nusing ECHConfig.public_name is a fine default/SHOULD.\n\nCheers,\nS.\n",
          "createdAt": "2021-03-24T19:44:44Z",
          "updatedAt": "2021-03-24T19:44:44Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> Not really - CHOuter has to be a \"working\" CH with semantics defined by 8446, so we're a lot more constrained in reality.\r\n\r\nOh sure. I wasn't suggesting CHOuter and the resulting handshake get to ignore 8446. But the parameters to that handshake are not set and that's what ECH get to define.\r\n\r\n> That's too absolute IMO. ECHConfig.public_name tells you *a* name that should work for the CHOuter fallback. There will be many situations where another name can work as well, though using ECHConfig.public_name is a fine default/SHOULD.\r\n\r\nHrm, in which link of the chain were you looking to add flexibility? There's:\r\n* The implementation wants to set server_name to some value other than the name they are contacting\r\n* The implementation wants to set the name they are contacting to some value other than ECHConfig.public_name\r\n\r\nWeakening the first to SHOULD is perhaps plausible, especially if 6066 and 8446 already are less prescriptive. Weakening the second to SHOULD is much more dangerous because you lose the chain of authenticity up from the TLS handshake through X.509 to the name specified by the ECHConfig.",
          "createdAt": "2021-03-24T20:57:31Z",
          "updatedAt": "2021-03-24T20:57:48Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\nLet me try another way to justify a SHOULD.\n\nConsider SMTP/TLS. There can be >1 MX RR value for a domain.\nWhen forwarding a mail to ***@***.*** it may (or may not)\nbe that the correct way to handle ECH for SMTP/TLS is to look\nfor an SVCB at example.com or at one of the MX names that we\nfind at example.com. It may (or may not) be the case that\nsome or all of the server-side TLS endpoints for those MX\nnames share the same ECHConfig private values at a given\nmoment. It may (or may not) be the case that the DNS answers\nfor type65 at all those MX names and example.com are well\nmanaged and always in sync. It may (and it will:-) be the\ncase that multiple MX name type65 RRs and multiple SVCB RR\nvalues including future new SVCB or ECHConfig extensions\ninteract in ways the TLS WG can't now forsee.\n\nI think there could in future be a real use-case for ECH in\nSMTP/TLS, and that it'd be wrong for the TLS WG to decide now\nwith a MUST how ECHConfig.public_name ought be handled in all\ncases. I reckon many other protocols using TLS might also\neach have a pile of wrinkles we can't analyse.\n\nSo I argue that at least generic libraries for TLS ought\nnot be prohibited from having some kind of override that\nresults in outer.sni != ECHConfig.public_name. (And for at\nleast some generic libraries, contravening such a MUST\nwould I think be a reason why upstream might reject an\noffered PR.)\n\nAll that said, using ECHConfig.public_name SHOULD work in\nalmost all cases so is a good default and one to probably\nencourage.\n\nHope that helps,\nS.\n\nPS: As an aside: some MX names expose what we'd like to\nput in inner.sni, whereas some will not, and a simple sub-\nstring match won't always catch that. But that's an issue for\nsome mail folks to consider later, if it's a real issue. (It\nprobably isn't for TLS, but maybe is for how MTAs might use\nmultiple DoX queries.)\n\n\n",
          "createdAt": "2021-03-25T04:11:18Z",
          "updatedAt": "2021-03-25T04:11:18Z"
        }
      ]
    },
    {
      "number": 397,
      "id": "MDU6SXNzdWU4MjgzOTAzMzY=",
      "title": "Including the client's ephemeral public key in the AAD precludes use of a single-shot HPKE API",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/397",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "This isn't critical but I think it might be better to allow use of a single-shot HPKE API that doesn't need to first and separately generate a public/private pair before calling Seal(). The downside of forcing two HPKE calls is perhaps mostly that someone will be tempted to re-use that key pair for something else or a 2nd attempt with maybe bad effects. If someone ever did HPKE in h/w there might also be a security difference. \r\n\r\nI'm also not entirely sure what we're protecting by including that public value (\"enc\") in the AAD as well so that could be better documented at least, if we keep things as-is, but perhaps including that field is really a bit of overkill?",
      "createdAt": "2021-03-10T22:01:59Z",
      "updatedAt": "2021-06-11T22:31:22Z",
      "closedAt": "2021-06-11T22:31:22Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "A single-shot HPKE already isn't viable because of HRR. You need to keep the second HPKE context around in case you need to encrypt second ClientHello.\r\n\r\nThat said, I'm perfectly happy with omitting it. (Or including it.) This dates to https://github.com/tlswg/draft-ietf-tls-esni/pull/362 and https://github.com/tlswg/draft-ietf-tls-esni/issues/326. Of the added fields, `cipher_suite` and `enc` are already incorporated into HPKE itself anyway, so we shouldn't need to redo it in ECH.\r\n\r\nThat leaves `config_id`, which is... almost redundant.  It's part of ECHConfig which is already authenticated, *except* in the [optional-`config_id` mode](https://tlswg.org/draft-ietf-tls-esni/draft-ietf-tls-esni.html#name-optional-configuration-iden), where it is otherwise unauthenticated. But it's also ignored in that mode so...  \u00af\\\\\\_(\u30c4)\\_/\u00af",
          "createdAt": "2021-03-11T00:46:30Z",
          "updatedAt": "2021-03-11T00:47:05Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 11/03/2021 00:46, David Benjamin wrote:\n> A single-shot HPKE already isn't viable because of HRR. You need to\n> keep the second HPKE context around in case you need to encrypt\n> second ClientHello.\n\nI've not done anything specific yet wrt HRR, and I'm guessing\nthose details are still in-play to some extent, so not sure.\nBut yeah, if the 2nd CH has to use the same keying then that\nmay be the case.\n\n> That said, I'm perfectly happy with omitting it or including it. This\n> dates to https://github.com/tlswg/draft-ietf-tls-esni/pull/362 and\n> https://github.com/tlswg/draft-ietf-tls-esni/issues/326. Of the added\n> fields, `cipher_suite` and `enc` are already incorporated into HPKE\n> itself anyway, so we shouldn't need to redo it in ECH.\n\nI agree. If there's a good reason to include it in the AAD\nthat'd be fine, but I'm puzzled as to what that reason may\nbe.\n\nCheers,\nS.\n\n> \n> That leaves `config_id`, which is... almost redundant.  It's part of\n> ECHConfig which is already authenticated, *except* in the\n> [optional-`config_id`\n> mode](https://tlswg.org/draft-ietf-tls-esni/draft-ietf-tls-esni.html#name-optional-configuration-iden),\n> where it is otherwise unauthenticated. But it's also ignored so...\n> \u00af\\\\\\_(\u30c4)\\_/\u00af\n> \n\n\n",
          "createdAt": "2021-03-11T11:43:55Z",
          "updatedAt": "2021-03-11T11:43:55Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> That said, I'm perfectly happy with omitting it. (Or including it.) \r\n\r\n@davidben what is \"it\" here? The AAD? That seems orthogonal to whether or not the HPKE context (and shared KEM secret) are reused for CH2. ",
          "createdAt": "2021-03-23T01:11:49Z",
          "updatedAt": "2021-03-23T01:11:49Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry, yeah, that was unclear. By \"it\" I mean `enc` in AAD.",
          "createdAt": "2021-03-23T02:29:22Z",
          "updatedAt": "2021-03-23T02:29:22Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The reason to authenticate these things was to be as conservative as possible. Of course, we don't have any formal analysis that tells us whether or not it's strictly necessary. But given that single-shot HPKE isn't viable in this application, I'd suggest we keep it as-is. (Unless another reason to change this comes along :)",
          "createdAt": "2021-03-23T19:24:55Z",
          "updatedAt": "2021-03-23T19:24:55Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sftcd given that this is needed for HRR to avoid two KEM operations, are you comfortable closing this?",
          "createdAt": "2021-03-30T18:35:51Z",
          "updatedAt": "2021-03-30T18:35:51Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n(I almost missed this in today's torrent of githubbery...)\n\nOn 30/03/2021 19:36, Christopher Wood wrote:\n> @sftcd given that this is needed for HRR to avoid two KEM operations,\n> are you comfortable closing this?\n\nNot sure. Given that HRR is rare and only needed because no\ngood group was chosen, (and hence involves more D-H stuff\nin any case), I'm not clear that saving a KEM operation (in\nthe group for ECH) is a convincing target.\n\nIs there a pointer anywhere to the analysis that such a\nsaving is not a premature optimisation? It may be an ok\ndesign of course, but I wonder if a simpler yet less CPU\nefficient design might exist and be overall better.\n\nS.\n\nPS: It also strikes me that if anyone ever designs a TLS\nextension that contains a value (e.g. a time value) that\nneeds to be within an RTT of something external to the h/s,\nthen we're maybe breaking that before it's been invented.\n\n\n\n",
          "createdAt": "2021-03-30T21:33:44Z",
          "updatedAt": "2021-03-30T21:33:44Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Reusing the context is not just about performance. It also avoids a host of complexity and weird corner cases when ECH decryptions are RPC calls. It also reduces server complexity by not needing to check for the client picking a different ECHConfig the second time, etc. I would oppose regressing those complexity improvements.",
          "createdAt": "2021-03-30T21:40:21Z",
          "updatedAt": "2021-03-30T21:40:48Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 30/03/2021 22:40, David Benjamin wrote:\n> Reusing the context is not just about performance.\n\nFair enough.\n\n> It also avoids a\n> host of complexity and weird corner cases when ECH decryptions are\n> RPC calls.\n\nWell, HRR+ECH seems to be it's own weirdly complex corner\ncase as a result though. But, that may be unavoidable.\n\n> It also reduces server complexity by not needing to reason\n> through what happens if the client picks a different ECHConfig the\n> second time, etc. I would oppose regressing those complexity\n> improvements.\n\nI'll re-read the HRR proposal before the interim but if that\nrequires re-tx'ing the same set of inner extension values\n(possibly other than inner.key-share?) then that itself may\nbe the cause of corner cases. (And break some putative\nyet to be defined extensions maybe.)\n\nAnyway, I think it makes sense to leave this issue open until\nwe're a bit more settled on HRR handling.\n\nCheers,\nS.\n\n\n",
          "createdAt": "2021-03-30T22:06:16Z",
          "updatedAt": "2021-03-30T22:06:16Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "#352 is the PR that switched it, by the way. Also some discussion in #349.",
          "createdAt": "2021-03-31T03:51:46Z",
          "updatedAt": "2021-03-31T03:51:46Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sftcd, now that #423 is merged, which reuses the HPKE context for HRR, which accepts that HRR must be dealt with in the protocol, along with [@davidben's comment](https://github.com/tlswg/draft-ietf-tls-esni/issues/397#issuecomment-810595817), I'd like to propose closing this. Any objections?",
          "createdAt": "2021-06-11T22:29:10Z",
          "updatedAt": "2021-06-11T22:29:10Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 11/06/2021 23:29, Christopher Wood wrote:\n> @sftcd, now that #423 is merged, which reuses the HPKE context for HRR, which accepts that HRR must be dealt with in the protocol, along with ***@***.***'s comment](https://github.com/tlswg/draft-ietf-tls-esni/issues/397#issuecomment-810595817), I'd like to propose closing this. Any objections?\n> \n\nReluctant acceptance here:-)\n\nS\n",
          "createdAt": "2021-06-11T22:30:39Z",
          "updatedAt": "2021-06-11T22:30:39Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds good -- thanks!",
          "createdAt": "2021-06-11T22:31:22Z",
          "updatedAt": "2021-06-11T22:31:22Z"
        }
      ]
    },
    {
      "number": 398,
      "id": "MDU6SXNzdWU4MjgzOTY3MzU=",
      "title": "Is the outer compression really worthwhile?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/398",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "(I'd suggest we resolve this issue after or with #378)\r\nHaving implemented it, I don't think the compression is worthwhile  and would be better omitted from the first RFC version of ECH. My reasons:\r\n- Needless complexity\r\n- it doesn't save enough to be worth it until there are some PQ KEMs (which is not today)\r\n- It adds a huge burden in testing if we want to be confident that no combination is problematic\r\n- There is no sensible way for a client to decide what to compress in general\r\n- The set of compressed or not things may be a new fingerprint \r\n- For OpenSSL, which supports custom extensions, it could be dangerous if there are extension handlers that interact\r\n- There isn't really a sensible api that a library could offer to generic client applications to control this in a useful and simple manner\r\n\r\nSo my suggestion: drop it entirely for now and consider again what to do once we have some PQ KEM that's too big and when we have some real experience with ECH. ",
      "createdAt": "2021-03-10T22:08:35Z",
      "updatedAt": "2021-04-13T21:20:38Z",
      "closedAt": "2021-04-13T21:20:38Z",
      "comments": [
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> There is no sensible way for a client to decide what to compress in general\r\n\r\nIn Rustls, I've found that there are some extensions that depend only on the general configuration. The API has an \"extra_exts\" field for things actually supplied by the caller.\r\n\r\nhttps://github.com/ctz/rustls/blob/32a143fe7ff69c9f42ca2d42ec7b122e9667541c/rustls/src/client/hs.rs#L250\r\n",
          "createdAt": "2021-03-10T22:46:50Z",
          "updatedAt": "2021-03-10T22:47:20Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> it doesn't save enough to be worth it until there are some PQ KEMs (which is not today)\r\n\r\nThat's not entirely true. We have had code in BoringSSL for an experimental PQ KEM for some time. I would be very supportive of ideas to simplify it, but dropping it altogether would be a non-starter for us.\r\nhttps://www.imperialviolet.org/2018/04/11/pqconftls.html\r\nhttps://www.imperialviolet.org/2018/12/12/cecpq2.html\r\n\r\n> There is no sensible way for a client to decide what to compress in general\r\n\r\nI listed a couple likely strategies here:\r\nhttps://mailarchive.ietf.org/arch/msg/tls/dJemdTEuQxMMfxtqoU93NFd8W08/\r\n\r\n> For OpenSSL, which supports custom extensions, it could be dangerous if there are extension handlers that interact\r\n\r\nI think any custom extensions APIs will need to ponder what to do ECH no matter what. Even without compression, you fundamentally need to decide what you put in the outer vs. inner ClientHello on the client.\r\n\r\n* Is the ClientHello extension dependent on sensitive data? Put it in just the inner ClientHello.\r\n* Is the ClientHello extension is public and you want to your ECH/non-ECH wire images to match here? Put it in both.\r\n* Is it sensitive but you still want an outer value? The API will need to somehow construct both values and help the application process the server response correctly.\r\n* Is the application assuming that all handshakes are offered this extension? You'll need to put something in both, one way or another, since the server may handshake either ClientHello.\r\n\r\nNone of these decisions are related to compression. They're fundamental to the whole outer vs. inner ClientHello design of ECH.\r\n\r\nOnce you've made that decision, whether to compress follows naturally.\r\n\r\n* If you only put it in the inner ClientHello, this is moot.\r\n* If you put it in both and they were publicly equal, may as well compress it.\r\n* If you put it in both and they were not publicly equal, don't compress it.\r\n\r\nAs an aside, I don't think such custom extensions APIs are a good idea. There's no guarantee that future TLS versions won't change how extensions are used, which means they're very hard to make backwards-compatible. ECH changes extension-handling on the client, and TLS 1.3 changed it dramatically across the board.",
          "createdAt": "2021-03-10T23:31:42Z",
          "updatedAt": "2021-03-10T23:31:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> So my suggestion: drop it entirely for now and consider again what to do once we have some PQ KEM that's too big and when we have some real experience with ECH.\r\n\r\nI agree that it's not trivial, but we seem to have found a general design that works reasonably well. So putting aside the complexity (of implementation and testing) point temporarily, the other reasons listed seem to fall into one of three categories: YAGNI, library integration challenges (choosing what to compress, how to expose it, and how it interacts with custom extension handlers), and increased fingerprinting. \r\n\r\n1. YAGNI: David's comments and links to PQ KEMs coming down the pipe seem to suggest this isn't a case of YAGNI.\r\n2. Library integration: This seems mostly an issue for the library in question, and less so a problem that applies to all implementations. For example, not all TLS stacks have custom extension support anymore. (IIRC, BoringSSL had it at one point, but it was long ago removed. @davidben can confirm.) On the API point, too, it's not clear to me that exposing this as a general purpose API is something that stacks should do. Implementations can probably make reasonable decisions about what to compress and what not to compress, as David points out, without consulting the application.\r\n3. Increased fingerprinting: This is a good point, and something we specifically have in the TLS WG charter to as a goal to mitigate. \r\n\r\nGiven the above, would a reasonable (and simpler?) alternative be to *only* compress the key share extension?",
          "createdAt": "2021-03-23T01:09:35Z",
          "updatedAt": "2021-03-23T01:09:35Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Key share de-duplication will be essential, operationally. It also seems likely that the future will bring other extensions we will want to de-duplicate. In my view, the \"ech_outer_extensions\" mechanism needs to have as much generality as it currently supports. I'd be opening to re-designing it, if someone has a suggestion for a simpler design. However, the current mechanism has been through a few design cycles (e.g., https://github.com/tlswg/draft-ietf-tls-esni/issues/262), and it seems to work pretty well.\r\n\r\nIt's also important to note that the added complexity is optional. In my experience, the client bears most of the implementation complexity, since it must decide if/how to compress extensions. The server bits are fully specified and fairly straightforward to implement properly.\r\n",
          "createdAt": "2021-03-23T19:20:09Z",
          "updatedAt": "2021-03-23T19:20:09Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Indeed, and for the record, I'm happy to keep what we have now absent some other simplifying proposal. It works and is sufficiently general for future use cases. I merely offer an alternative for consideration if we want to remove generality. ",
          "createdAt": "2021-03-23T19:49:00Z",
          "updatedAt": "2021-03-23T19:49:00Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Per [the interim](https://codimd.ietf.org/notes-ietf-interim-2021-tls-01-tls), closing this for now. If someone comes up with something simpler, please share it!",
          "createdAt": "2021-04-13T21:20:38Z",
          "updatedAt": "2021-04-13T21:20:38Z"
        }
      ]
    },
    {
      "number": 399,
      "id": "MDU6SXNzdWU4Mjg0MTU4Mjg=",
      "title": "The serverhello.random trick is ugly and might interact with ticket handling...",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/399",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "Encoding the \"ECH worked\" signal in the SH.random lower octets is, at best, ugly. It also arguably causes violation of internal API designs  in at least the OpenSSL code. And I'm not sure if there might be some interaction between that and ticket handling (just from the look of some code I've yet to understand really.)\r\n\r\nDo we really need such a hacky solution?  Given the ECH sticks out in the CH, we could just define a non-encrypted extension in the SH to include the confirmation value maybe (though even that is pretty hacky).\r\n ",
      "createdAt": "2021-03-10T22:28:14Z",
      "updatedAt": "2021-04-19T13:45:43Z",
      "closedAt": "2021-04-19T13:45:43Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I have some sympathy for this, but the point of this signal design was to make it difficult to distinguish GREASE from non-GREASE ECH.",
          "createdAt": "2021-03-10T22:35:11Z",
          "updatedAt": "2021-03-10T22:35:11Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Could you elaborate on the concern with ticket handling? I'm not sure I see how tickets would relate to this.",
          "createdAt": "2021-03-10T23:34:29Z",
          "updatedAt": "2021-03-10T23:34:29Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 10/03/2021 23:34, David Benjamin wrote:\n> Could you elaborate on the concern with ticket handling? I'm not sure\n> I see how tickets would relate to this.\n\nSorry for being slow - should get to looking again at that\nbit of code in a few days.\n\nS\n\n",
          "createdAt": "2021-03-17T01:18:55Z",
          "updatedAt": "2021-03-17T01:18:55Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Just to synchronize the discussion across list/GitHub a bit, this was discussed a bit in https://mailarchive.ietf.org/arch/msg/tls/pBjQDWT4ZvkATFKZ04rKZQ6Zvi4/. I agree with @sftcd now that there's some fiddly interactions from two ClientHellos and ServerHello.\r\n\r\nI sketched out a possible change sketched out in https://mailarchive.ietf.org/arch/msg/tls/gpVj4FSmHQ2XQTKpQY07IDcD40I/. We could compute ClientHelloInner...ServerHelloECHConf as in the draft right now. But then rather than feed that into the handshake secret computation, just rely on that transcript containing a secret ClientHello.random and computing F(transcript). (Hash it down, KDF it with zero secret, whatever.)\r\n\r\nOne observation is that, while this relies oddly on a secret ClientHello.random, the existing construction does too. An attacker constructing a ServerHello gets to pick ServerHello.key_share and, with knowledge of ClientHello.key_share, compute the resulting shared secret.",
          "createdAt": "2021-03-30T21:09:07Z",
          "updatedAt": "2021-03-30T21:09:27Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One further observation here is that if the client uses the same shares for CHInner and CHOuter, the double key derivation piece doesn't really need to apply.",
          "createdAt": "2021-04-01T19:10:06Z",
          "updatedAt": "2021-04-01T19:10:06Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For my own reference, I just wanted to flag something that we've discussed on the list: the current acceptance signal interacts with PSK in a way that could easily cause a bug in an implementation that hasn't carefully vetted this interaction.",
          "createdAt": "2021-04-01T23:07:54Z",
          "updatedAt": "2021-04-01T23:07:54Z"
        }
      ]
    },
    {
      "number": 400,
      "id": "MDU6SXNzdWU4Mjg0MTc0ODg=",
      "title": "Hard to imagine ECH handling in constant time - ponder and document?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/400",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "ready-for-text",
        "editorial"
      ],
      "body": "Given all the complexity and options it's hard to imaging ECH handling ever being contstant-time. It'd probably be no harm to ponder that at least and maybe add some security considerations text before we're done.",
      "createdAt": "2021-03-10T22:29:58Z",
      "updatedAt": "2023-10-12T15:16:47Z",
      "closedAt": "2023-10-12T15:16:47Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "That seems like a fine thing to note in the security considerations. @sftcd, will you have cycles to prepare a PR?",
          "createdAt": "2021-03-23T00:51:00Z",
          "updatedAt": "2021-03-23T00:51:00Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As long as the runtime doesn't depend on secrets, I don't see that this is an issue. I wonder, is constant-time handshaking (modulo secrets) a security consideration for TLS?",
          "createdAt": "2021-03-23T19:33:38Z",
          "updatedAt": "2021-03-23T19:33:38Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Well, I think the question is what do you want to protect in under the constant-time threat model. Certainly it'd be a disaster if ECH caused us to leak some values that TLS *already* considered secret under that model. We also shouldn't leak any cryptographic secrets like the ECH keys.\r\n\r\nAt the same time, the goal of ECH *is* to hide sensitive fields in the ClientHello, and we're definitely not meeting the constant-time threat model for those fields. I don't think this has anything to do with the complexity though. It just seems mostly implausible in the first place. It'd require you pick and handshake as your selected backend server, in time and memory access patterns independent of which backend server you chose.",
          "createdAt": "2021-03-23T19:46:03Z",
          "updatedAt": "2021-03-23T19:46:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "It's entirely possible for the runtime to vary based on the contents of the inner CH. Different domains may have different configurations (ciphersuites, signature algorithms, etc), and any variance caused by those may leak information. (This doesn't seem different from the fact that different configurations might also have on-the-wire differences [absent padding], so I'm comfortable just noting it.)",
          "createdAt": "2021-03-23T19:47:41Z",
          "updatedAt": "2021-03-23T19:47:41Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Yup, exactly. I don't think meeting the constant-time threat model is plausible here.",
          "createdAt": "2021-03-23T19:50:06Z",
          "updatedAt": "2021-03-23T19:50:06Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 23/03/2021 19:47, Christopher Wood wrote:\n> It's entirely possible for the runtime to vary based on the contents\n> of the inner CH. Different domains may have different configurations\n> (ciphersuites, signature algorithms, etc), and any variance caused by\n> those may leak information. (This doesn't seem different from the\n> fact that different configurations might also have on-the-wire\n> differences [absent padding], so I'm comfortable just noting it.)\n\nYeah, I think that's the best we may be able to do.\n\nTiming will almost certainy reveal whether we're dealing\nwith a shared or split mode case so that likely deserves\nto be noted.\n\nHowever, I think it'd be worth thinking a little about\nwhether timing could fingerprint a set of inner CH choices,\nand whether that in turn could reveal e.g. inner.SNI in\nsome cases, if the inner CH for very few names used some\nrare combination of choices.\n\nPeople do seem to get rather smart about such things over\ntime;-)\n\nCheers,\nS.\n\n\n",
          "createdAt": "2021-03-23T19:55:15Z",
          "updatedAt": "2021-03-23T19:55:15Z"
        }
      ]
    },
    {
      "number": 401,
      "id": "MDU6SXNzdWU4Mjg0MTkwNjM=",
      "title": "ECH complexity",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/401",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "pre-wglc"
      ],
      "body": "Overall, having implemented and gotten interop for draft-09, ECH is very complex. This issue just requests people consider whether or not there are ways to simplify ECH given the TLS WG plan to have a bunch of interim meetings on the topic. I'd hope that now we have 3 or 4 implementations it might be possible to see ways to make 'em usefully simpler, if that's possible.",
      "createdAt": "2021-03-10T22:31:36Z",
      "updatedAt": "2023-11-06T08:53:01Z",
      "closedAt": "2023-11-06T08:53:01Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for flagging! I'm tagging this as something to keep open up and top of mind as we progress towards something shippable. When all other issues are resolved and we can't figure out how to make things simpler, it's probably time to close this.",
          "createdAt": "2021-03-23T00:50:18Z",
          "updatedAt": "2021-03-23T00:50:18Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing per discussion at IETF 118.",
          "createdAt": "2023-11-06T08:53:01Z",
          "updatedAt": "2023-11-06T08:53:01Z"
        }
      ]
    },
    {
      "number": 402,
      "id": "MDU6SXNzdWU4MzE0NTYwNzc=",
      "title": "Not all of CHOuter is authenticated",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/402",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The position of the ECH extension is not authenticated as part of ClientHelloOuterAAD.  This means that it is possible to construct multiple different ClientHello messages that will all be accepted.\r\n\r\nThis probably isn't that interesting, but it might be worth noting.",
      "createdAt": "2021-03-15T06:10:38Z",
      "updatedAt": "2021-04-12T20:23:27Z",
      "closedAt": "2021-04-12T20:23:27Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "If we want to fix this (I don't care either way), we can remove the fields prepended to ClientHelloOuterAAD, leave the ECH extension in, and say the AAD is computed by replacing ClientECH.payload with the empty string.",
          "createdAt": "2021-03-15T15:09:51Z",
          "updatedAt": "2021-03-15T15:10:08Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "That seems like a reasonable proposal. @martinthomson, what do you think? (@sftcd might also have thoughts on this.)",
          "createdAt": "2021-03-23T00:47:44Z",
          "updatedAt": "2021-03-23T00:47:56Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I can live with either a placeholder or text in the draft that explains the limitation.  Extension order doesn't carry any semantics, so I don't see malleability as a real risk.  I'd lean toward the placeholder, but only slightly.  More so if we were planning to change the AAD anyway.",
          "createdAt": "2021-03-23T02:31:31Z",
          "updatedAt": "2021-03-23T02:31:31Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This seems like a good idea to me.",
          "createdAt": "2021-03-23T21:39:07Z",
          "updatedAt": "2021-03-23T21:39:07Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "> If we want to fix this (I don't care either way)\r\n\r\n> I don't see malleability as a real risk\r\n\r\nIf we don't really care about this issue, why specify it? Does this add complexity or reduce it?",
          "createdAt": "2021-03-30T19:05:47Z",
          "updatedAt": "2021-03-30T19:05:47Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> If we don't really care about this issue, why specify it? Does this add complexity or reduce it?\r\n\r\nWe don't know of any way this can be a problem, but that doesn't mean there is none. Plus, malleability is generally not great. I don't think this moves the complexity needle in a meaningful way.",
          "createdAt": "2021-03-30T19:11:54Z",
          "updatedAt": "2021-03-30T19:11:54Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I guess it exposes an active distinguishing attack, though I suspect this style of attack has plenty of vectors:\r\n\r\n* Attacker rewrites CH to move the ECH extension to another spot and forwards to server\r\n* Server responds with SH..Finished. Attacker forwards that to client unmodified\r\n* If this was negotiating CHOuter, this would break the transcript and the client would reject. If this was negotiating CHInner, the client won't notice and proceed",
          "createdAt": "2021-03-31T15:11:34Z",
          "updatedAt": "2021-03-31T15:11:34Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yep, nice! Let's definitely make this change, then.",
          "createdAt": "2021-03-31T16:16:14Z",
          "updatedAt": "2021-03-31T16:16:14Z"
        }
      ]
    },
    {
      "number": 403,
      "id": "MDU6SXNzdWU4MzE0NTg5MDE=",
      "title": "public_name and maximum_name_length could be smaller",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/403",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I think that we're committed now to public_name being a DNS name (there is no way to indicate the type of name (like in RFC 6066).  So I have to assume that the only type of name that is permitted is a DNS name.  And a DNS name can't be longer the 255 bytes.\r\n\r\nTherefore, ECHConfig could be:\r\n\r\n```tls\r\n    struct {\r\n        HpkeKeyConfig key_config;\r\n        uint8 maximum_name_length;\r\n        opaque public_name<1..255>;\r\n        Extension extensions<0..2^16-1>;\r\n    } ECHConfigContents;\r\n```",
      "createdAt": "2021-03-15T06:15:07Z",
      "updatedAt": "2021-04-12T20:23:47Z",
      "closedAt": "2021-04-12T20:23:47Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This seems like a sensible change.",
          "createdAt": "2021-03-23T21:38:18Z",
          "updatedAt": "2021-03-23T21:38:18Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "Why is there is no way to indicate the type of name?",
          "createdAt": "2021-03-30T19:01:18Z",
          "updatedAt": "2021-03-30T19:01:18Z"
        },
        {
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@cbartle891: Are you referring to the `NameType` enum from RFC6066? This seems to be part of the spec that is already ossified. At least BoringSSL believes so; see this comment in [extract_sni()](https://source.chromium.org/chromium/chromium/src/+/master:third_party/boringssl/src/ssl/handshake_server.cc;l=519-525;drc=c295935a9bf345acb597ffefb69f7e095c3eee72).",
          "createdAt": "2021-03-30T19:20:39Z",
          "updatedAt": "2021-03-30T19:20:39Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "I wasn't referring to anything other than Martin's comment, but that BoringSSL comment answers my question (modulo the whole underscore business, which isn't officially documented anywhere).",
          "createdAt": "2021-03-30T19:35:16Z",
          "updatedAt": "2021-03-30T19:42:15Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Re the BoringSSL comment, we sent this mail to the TLSWG way back:\r\nhttps://mailarchive.ietf.org/arch/msg/tls/1t79gzNItZd71DwwoaqcQQ_4Yxc/",
          "createdAt": "2021-03-30T19:39:48Z",
          "updatedAt": "2021-03-30T19:39:48Z"
        }
      ]
    },
    {
      "number": 404,
      "id": "MDU6SXNzdWU4Mzg4NzE2ODM=",
      "title": "[Question] Is there any public-facing setups that currently support ECH?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/404",
      "state": "CLOSED",
      "author": "cj-filip-savin",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hello. Thank you for your work on ESNI/ECH.\r\n\r\nWith ECH gaining momentum, are there any public functional sites that publish `echconfig` via DNS and able to perform TLS handshake with ECH? I see Firefox already adding ECH support, but I haven't found any site where I can do testing. Please share this information (if there are any).",
      "createdAt": "2021-03-23T15:54:09Z",
      "updatedAt": "2021-04-06T16:16:53Z",
      "closedAt": "2021-03-23T16:39:14Z",
      "comments": [
        {
          "author": "TheDGOfficial",
          "authorAssociation": "NONE",
          "body": "Only Cloudflare and Firefox currently, however, they use old draft version\nas far as I know.\n\nYou can check it from these sites:\n\nhttps://www.cloudflare.com/ssl/encrypted-sni/\n\nhttps://esnicheck.com/\n\nIt will be implemented on all major web browsers and servers once the draft\nis finalized I think.\n",
          "createdAt": "2021-03-23T16:08:03Z",
          "updatedAt": "2021-03-23T16:08:03Z"
        },
        {
          "author": "cj-filip-savin",
          "authorAssociation": "NONE",
          "body": "Thanks for quick reply! Well, encrypted SNI (ESNI, older drafts) is very different from ECH (current). That old Cloudflare ESNI checker based on DNS `_esni.*` TXT records. That concept was abandoned in favor of encrypting ClientHello using `echconfig` retrieved from DNS. But I see in TLSWG mailing list message from Stephen Farrell:\r\n\r\n> I've just got my OpenSSL code \"working\" for draft-09. \r\nThe s_client and s_server talk to one another and do \r\nECH; NSS's tstclnt talks to my s_server and does ECH \r\nand my s_client talks to **cloudflare's test server** and \r\ndoes ECH. \r\n\r\nSo at least Cloudflare has a testing server, would be great to know which exactly.",
          "createdAt": "2021-03-23T16:17:09Z",
          "updatedAt": "2021-03-23T16:17:09Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 23/03/2021 16:17, Filip wrote:\n> So at least Cloudflare has a testing server, would be great to know which exactly.\n\nIt's crypto.cloudflare.com\n\nI just re-tested with my s_client and that seems to\nstill be running draft-09. That should change to\ndraft-10 (a breaking change) sometime soon, but we\nprobably need to wait for CF to say when and if they\nare going to use the same name.\n\nCheers,\nS.\n\n\n",
          "createdAt": "2021-03-23T16:27:13Z",
          "updatedAt": "2021-03-23T16:27:13Z"
        },
        {
          "author": "cj-filip-savin",
          "authorAssociation": "NONE",
          "body": "@sftcd, thank you very much, sir!\r\n\r\nI think this issue is resolved.",
          "createdAt": "2021-03-23T16:39:14Z",
          "updatedAt": "2021-03-23T16:39:14Z"
        },
        {
          "author": "cj-filip-savin",
          "authorAssociation": "NONE",
          "body": "@sftcd just in case you are interested in more sites for testing: take a look at HTTPS RRs of these sites:\r\n\r\n* app-site-association.g.aaplimg.com\r\n* clientflow.g.aaplimg.com\r\n* pancake.g.aaplimg.com\r\n\r\nIn `svcparams` they have key `key32768` which seems to be the replacement for `echconfig` in Apple's experiments with ECH. Google knows nothing about that key. ",
          "createdAt": "2021-04-06T16:16:30Z",
          "updatedAt": "2021-04-06T16:16:53Z"
        }
      ]
    },
    {
      "number": 405,
      "id": "MDU6SXNzdWU4NDEyMzIxODQ=",
      "title": "public_name edge cases and client checks",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/405",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "Some edge cases around the public_name:\r\n\r\n1. What if the public name is some random string which is not a valid DNS name? (What's the right terminology here? Same from RFC6066?) Does the client reject the ECHConfig? My feeling is yes. Imagine you have some random service accessible on a private address. Today, it can assume it'll never see `\\\"\\r\\n;DROP TABLES` in the server_name field. Even if an attacker pointed `evil.example` at that private address, the attacker is constrained by valid DNS strings. But the public name is never directly queried in DNS.\r\n\r\n2. Is a server deployment allowed to use an IP certificate for the ECH rejection identity? (That was actually the original idea for the fallback flow.) If so, how do they specify it? Do they use the ASCII serialization of the IPv4 or IPv6 address? Note that IP addresses do not go in server name, so the client would need to recognize this and leave server_name empty.\r\n\r\n@dmcardle ",
      "createdAt": "2021-03-25T19:14:10Z",
      "updatedAt": "2021-06-14T21:02:45Z",
      "closedAt": "2021-06-14T21:02:45Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I imagined the outer name would be set from the config similar to how an application sets the inner name. That is, one provides a string to `set_server_name(char *)` and, internally, the library determines whether or not that string is a valid domain name (and thus goes in the server name) or is an IP address (and thus is used to verify the IP-based cert that might come back from the server). ASCII serialization of addresses seems fine here, if one just takes that string and passes it to the `set_server_name(char *)` function (or equivalent). ",
          "createdAt": "2021-03-30T13:45:35Z",
          "updatedAt": "2021-03-30T13:45:35Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Well, OpenSSL and derivatives have a lower-level API and just take the server name as an opaque string. :-) But yeah, that seems a reasonable model. Whatever we pick, we should write it down.\r\n\r\nWhat do you think should happen if the public name is neither a valid DNS name, nor a valid IP address? Like `\\\"\\r\\n;DROP TABLES`. ECHConfig parse error would be my inclination.",
          "createdAt": "2021-03-30T15:33:56Z",
          "updatedAt": "2021-03-30T15:34:22Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> What do you think should happen if the public name is neither a valid DNS name, nor a valid IP address? Like \\\"\\r\\n;DROP TABLES. ECHConfig parse error would be my inclination.\r\n\r\nYeah, that seems like a configuration error on behalf of the server. ",
          "createdAt": "2021-03-30T16:11:32Z",
          "updatedAt": "2021-03-30T16:11:32Z"
        },
        {
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Today, it can assume it'll never see \\\"\\r\\n;DROP TABLES in the server_name field. Even if an attacker pointed evil.example at that private address, the attacker is constrained by valid DNS strings. But the public name is never directly queried in DNS.\r\n\r\nThat seems like it's already an unsafe assumption, right? Malicious clients could send SQL-injection strings to vulnerable servers without ECH.\r\n\r\nI suppose ECH introduces some asymmetry; one malicious DNS server could cause N clients to send the malicious payload.\r\n\r\n",
          "createdAt": "2021-03-30T16:31:06Z",
          "updatedAt": "2021-03-30T16:31:06Z"
        },
        {
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Backing up a step, if we care to protect applications from malicious/malformed DNS hostnames, it seems prudent to validate all incoming server_name values on the server, whether they came from ClientHelloInner/ClientHelloOuter or even a non-ECH ClientHello. (Assuming we're using the RFC6066 HostName definition.)",
          "createdAt": "2021-03-30T16:39:22Z",
          "updatedAt": "2021-03-30T16:39:22Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@dmcardle yeah, that's basically what I was thinking the `set_server_name()` function would do. Would you have cycles to prep a PR to resolve this issue?",
          "createdAt": "2021-03-30T16:41:49Z",
          "updatedAt": "2021-03-30T16:41:49Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> That seems like it's already an unsafe assumption, right? Malicious clients could send SQL-injection strings to vulnerable servers without ECH.\r\n\r\nIt depends. Services listening on private addresses often make a lot of assumptions. These assumptions are pretty questionable, but we put in effort to [protect them](https://wicg.github.io/private-network-access/) anyway because that is reality.\r\n\r\n> Backing up a step, if we care to protect applications from malicious/malformed DNS hostnames, it seems prudent to validate all incoming server_name values on the server, whether they came from ClientHelloInner/ClientHelloOuter or even a non-ECH ClientHello.\r\n\r\nYes, any server listening on a network should tolerate arbitrary input and behave well. Nonetheless, the reality is private services are often buggy. Where we break soft assumptions that might have previously (mostly) worked, we should at least think about it. Here, it seems there's no point in breaking the assumption.",
          "createdAt": "2021-03-30T17:09:32Z",
          "updatedAt": "2021-03-30T17:11:36Z"
        },
        {
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, servers at private addresses was not even on my radar. I support client validation of ECHConfig.public_name at parse time AND server validation of all ClientHello* server_name extensions.\r\n\r\n@chris-wood: Happy to do a PR. \r\n",
          "createdAt": "2021-03-30T18:19:40Z",
          "updatedAt": "2021-03-30T18:19:40Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "(I don't think the ECH spec should say anything about server validation here. The server looks at whichever ClientHello it selects and does whatever it would normally do with the server name in the selected one.)",
          "createdAt": "2021-03-30T18:25:13Z",
          "updatedAt": "2021-03-30T18:25:13Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "> What if the public name is some random string which is not a valid DNS name? (What's the right terminology here? Same from RFC6066?) \r\n\r\nThere doesn't seem to be a standard that reflects actual current practice. Chrome and Firefox accept SNIs with underscores, which are not allowed in valid DNS names (https://bugs.chromium.org/p/chromium/issues/detail?id=463410).",
          "createdAt": "2021-03-30T18:38:48Z",
          "updatedAt": "2021-03-30T18:38:48Z"
        },
        {
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yep, thanks for raising that, Carrick. Perhaps we should make hostname validation a SHOULD rather than MUST?",
          "createdAt": "2021-03-30T18:44:41Z",
          "updatedAt": "2021-03-30T18:44:41Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "The issue doesn't sound like a MUST vs. a SHOULD but rather what they SHOULD or MUST do. I guess we could say \"do whatever you usually do with the SNI.\"",
          "createdAt": "2021-03-30T18:46:44Z",
          "updatedAt": "2021-03-30T18:46:44Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh and yeah, SHOULD seems like a better idea than MUST since there are conflicting opinions about the right way to go about it.",
          "createdAt": "2021-03-30T18:49:42Z",
          "updatedAt": "2021-03-30T18:49:42Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "It's a little tricky due to what layers we're talking about. Chrome doesn't particularly validate the SNI at the TLS level. Rather, we leave that to URL parsing and DNS logic earlier in the pipeline. If we've gotten far enough to make a TLS connection, we assume we're happy with the string we're passing to SNI and certificate validation. I imagine this is reasonably common: OpenSSL likewise treats the set_server_name API as an opaque byte string.\r\n\r\nECH breaks this assumption by bypassing all the earlier layers. Suddenly a TLS-level construct (ECHConfig) is fabricating a DNS name on its own, and now TLS needs to pick up all the validation.",
          "createdAt": "2021-03-30T18:52:04Z",
          "updatedAt": "2021-03-30T18:52:04Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "Technically couldn't DNS logic validate the DNS name in the ECHConfig?",
          "createdAt": "2021-03-30T18:54:24Z",
          "updatedAt": "2021-03-30T18:54:24Z"
        },
        {
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi folks, PR #413 is a little more complete now, if you get a chance :)",
          "createdAt": "2021-03-31T17:08:26Z",
          "updatedAt": "2021-03-31T17:29:31Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> Technically couldn't DNS logic validate the DNS name in the ECHConfig?\r\n\r\nTo close the loop on this: it could, but we're treating the ECH parts of SVCB as opaque to DNS. [edit: I miswrote \"opaque to TLS\" at first] I think that's desirable because TLS may introduce new ECH extensions or ECH versions that the DNS stack may not be aware of. Also, any validation on the URL parsing / DNS query path happens in the process of making a request to the DNS server at all, whereas any validation here would be a check afterwards on the result. Whatever we do, it'll end up looking like someone, DNS or TLS, implementing a check we need to write down.",
          "createdAt": "2021-04-01T14:54:58Z",
          "updatedAt": "2021-04-01T14:59:43Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> 2\\. Is a server deployment allowed to use an IP certificate for the ECH rejection identity? (That was actually the original idea for the fallback flow.) If so, how do they specify it? Do they use the ASCII serialization of the IPv4 or IPv6 address? Note that IP addresses do not go in server name, so the client would need to recognize this and leave server_name empty.\r\n\r\nTo come back to this: because SNI does not support IP addresses, IP certs must be the server's default-cert, i.e. they must be served to requests that omit the SNI.  Thus, we merely need a way to tell clients to omit `ClientHelloOuter.server_name`.\r\n\r\nMy suggestion is to allow `ECHConfigContents.public_name` to be empty, meaning \"omit outer SNI\".",
          "createdAt": "2021-04-01T18:23:37Z",
          "updatedAt": "2021-04-01T18:23:37Z"
        },
        {
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Keeping in mind that the client uses `public_name` to authenticate the server's `retry_configs`, the client now needs to be aware of which IP address it's connecting to. I suppose this isn't a protocol concern, but it's more ergonomic when the ECHConfig contains all the information TLS needs to do ECH.",
          "createdAt": "2021-04-01T18:54:04Z",
          "updatedAt": "2021-04-01T18:54:04Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK.  As I mentioned yesterday, I think `public_name` should probably be an X.509 [`GeneralName`](https://tools.ietf.org/html/rfc5280#section-4.2.1.6).",
          "createdAt": "2021-04-02T15:31:46Z",
          "updatedAt": "2021-04-02T15:31:46Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I do not think GeneralName will work. There's somewhat a mismatch between what the application thinks of as identities and how those identities are encoded into X.509. GeneralName is part of the latter. What does a browser certificate verifier, which only believes in things that fit in a URL, do if it's told the identity is now an EDIPartyName? What SNI, etc., does that translate into, given that our identity-to-TLS-config algorithm takes an HTTPS origin, not an X.509 name? (Note that the type field in SNI is fiction. There is and will be [only one name type](https://mailarchive.ietf.org/arch/msg/tls/1t79gzNItZd71DwwoaqcQQ_4Yxc/).)\r\n\r\nMore importantly, this glomming too many things into an already overloaded issue. If you want to pursue this, can you please fork GeneralName into a separate topic? The status quo in the existing text is that the public name is clearly only good for DNS or DNS+IP, depending on how much you believe in URL syntax. We already have a need to better specify that case, including client validation. Let's fix that, and then we can separate tackle more complex cases.",
          "createdAt": "2021-04-02T16:06:54Z",
          "updatedAt": "2021-04-02T16:10:29Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 02/04/2021 16:32, Benjamin M. Schwartz wrote:\n> OK.  As I mentioned yesterday, I think `public_name` should probably\n> be an X.509\n> [`GeneralName`](https://tools.ietf.org/html/rfc5280#section-4.2.1.6).\n\nStrongly disagree. GeneralName was a reasonable guess at a\nthing to do 20 years ago but is no longer a structure that\nought be leveraged - we have no need for EDI nor X.400 names\nfor ECH and even tempting someone to write code for ORAddress\nhandling is risky - there's >1 can of worms there all of\nwhich are best avoided.\n\nS.\n\n",
          "createdAt": "2021-04-02T17:57:00Z",
          "updatedAt": "2021-04-02T17:57:00Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": "Agree with Stephen. Using GeneralName is like hunting butterflies with an elephant gun. :)",
          "createdAt": "2021-04-03T14:36:31Z",
          "updatedAt": "2021-04-03T14:36:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed in #456, closing.",
          "createdAt": "2021-06-14T21:02:44Z",
          "updatedAt": "2021-06-14T21:02:44Z"
        }
      ]
    },
    {
      "number": 406,
      "id": "MDU6SXNzdWU4NDEyMzgzMTg=",
      "title": "Server enforcement of ClientHelloInner invariants",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/406",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We currently have a number of invariants on the ClientHelloInner that the client must follow:\r\n\r\n* ClientHelloInner must include ech_is_inner\r\n* ClientHelloInner may not offer TLS 1.2 and below\r\n* ClientHelloInner may not include encrypted_client_hello (somewhat implicit from the first rule and section 7)\r\n\r\nBut, syntactically, the client could violate this. How is the server expected to respond? In particular, a shared mode server directly observes all invariants, and it seems a little weird to ask it to send something it knows is inconsistent. But if we say to enforce, we either have a shared/split difference, or we put all the enforcement at the client-facing server (not wrong...) because the backend server doesn't have enough information to check these.\r\n\r\n* If ClientHelloInner lacks ech_is_inner, should the server just accept ECH without reporting the confirmation signal, or should it report an error?\r\n* If we end up negotiating TLS 1.2 with ClientHelloInner, is that an error or do we just proceed, without reporting the confirmation signal and sending a cleartext certificate?\r\n* If ClientHelloInner contains another encrypted_client_hello extension, one possible implementation strategy would report retry keys, since backend server halves that see encrypted_client_hello typically assume the extension wasn't decrypted. Is that correct, or do you omit retry keys?\r\n\r\n@dmcardle ",
      "createdAt": "2021-03-25T19:22:53Z",
      "updatedAt": "2021-04-12T20:21:28Z",
      "closedAt": "2021-04-12T20:21:28Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "These are just bugs in the client, so I have no qualms with requiring the server to reject the connection when it can.  A split mode server might not see all of this.  If the fronting server fails to validate the inner CH, all of this might slip through.  Especially when the backend isn't able to require ECH on every connection, which seems plausible.\r\n\r\nSo I think we're OK with hard rejection.  Failure here in shared mode requires client bugs and the shared mode server can report those.  Failure in split mode might not always be detected, but it requires the same client bugs and a lack of diligence on the part of the fronting server (for this to be detectable, ech_is_inner is all they need to check).",
          "createdAt": "2021-03-25T22:25:39Z",
          "updatedAt": "2021-03-25T22:25:39Z"
        }
      ]
    },
    {
      "number": 408,
      "id": "MDU6SXNzdWU4NDM1NjA5NzI=",
      "title": "Early data and ClientHelloOuter interaction",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/408",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Here's a fun case. Suppose the client talks to a 0-RTT-capable, ECH-capable server. It'll send early_data + pre_shared_key in ClientHelloInner, wrap that in _some_ ClientHelloOuter, and follow it up with early data records.\r\n\r\nNow the server rejects ECH and handshakes with the ClientHelloOuter. But the client has already sent early data, so the server needs to know to skip past it. I believe this means we need to require the client mirror ClientHelloInner.early_data in ClientHelloOuter, even though it's not actually offering to resume anything. Sending early_data without pre_shared_key is slightly weird (if tolerated at all), so we might even want to recommend a fake outer pre_shared_key.\r\n\r\nWe _almost_ don't care about this: the client may as well stop the handshake at server Finished and skip the client Finished flight anyway, for purposes of the recovery flow. However:\r\n\r\n* What's not what the draft currently says\r\n* If the server rejects ECH, handshakes with ClientHelloOuter, *and* sends HelloRetryRequest, we do care about the client's second flight getting through.\r\n\r\nThat second case is extra fun because the client-facing server must look for the second ClientHello too.",
      "createdAt": "2021-03-29T16:45:44Z",
      "updatedAt": "2021-04-19T13:47:49Z",
      "closedAt": "2021-04-19T13:47:49Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Sending early_data without pre_shared_key is slightly weird (if tolerated at all), so we might even want to recommend a fake outer pre_shared_key.\r\n\r\nWasn't this already the outcome from #384? (That is, if the inner CH has a PSK, then the outer one ought have a dummy PSK, too.) \r\n\r\nAs for mirroring early_data, why can the server not just ignore the application data (as if it received early_data and decided to ignore it)? Taking a quick look back at RFC8446, the server behavior where clients send application data without early_data is not defined, so are you concerned about that, or something else?\r\n\r\n",
          "createdAt": "2021-03-30T13:56:55Z",
          "updatedAt": "2021-03-30T13:56:55Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Well, I think we only got as far as MAY in #384, but yeah I think this is another reason.\r\n\r\nRegarding ignoring application data, our server implementation only skips early data if there was an early_data extension that we rejected. I believe that matches RFC8446 since it doesn't say to skip application data in general, just that case. And, yeah, that's the concern.",
          "createdAt": "2021-03-30T14:22:20Z",
          "updatedAt": "2021-03-30T14:22:20Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> And, yeah, that's the concern.\r\n\r\nSince this is behavior for the client-facing server, which supports ECH, can't we specify the desired behavior in this spec? That is, we might say that a client-facing server which rejects ECH MUST ignore any early data sent by the server, or something. Would that work?",
          "createdAt": "2021-03-30T14:34:32Z",
          "updatedAt": "2021-03-30T14:34:32Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "We could, but then it'd break the nice property that a plain RFC8446 server will handshake ClientHelloOuter without any fuss. This property is great for rollback safety. (Otherwise any ECH server deployment needs to be two-stage, and introduces a lower bound that you cannot rollback beyond.) And elsewhere we've tried to avoid contradicting RFC8446.\r\n\r\nYet another option would be to tell the client to retry on certain kinds of errors if it offered 0-RTT in ClientHelloInner, but that's a bit more fuss since retries are often outside the TLS stack.\r\n\r\n(Besides, the fact that you offer 0-RTT in ClientHelloInner is all but public anyway. While we don't have a cleartext 0-RTT marker[*], it's pretty obvious from timing that some post-ClientHello record came before ServerHello.)\r\n\r\n[*] In TCP... I want to say QUIC does, but I could be misremembering.",
          "createdAt": "2021-03-30T14:43:59Z",
          "updatedAt": "2021-03-30T14:43:59Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> We could, but then it'd break the nice property that a plain RFC8446 server will handshake ClientHelloOuter without any fuss. This property is great for rollback safety. (Otherwise any ECH server deployment needs to be two-stage, and introduces a lower bound that you cannot rollback beyond.) And elsewhere we've tried to avoid contradicting RFC8446.\r\n\r\nTrue! This _is_ fun. :-)",
          "createdAt": "2021-03-30T14:58:16Z",
          "updatedAt": "2021-03-30T14:58:16Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "> We could, but then it'd break the nice property that a plain RFC8446 server will handshake ClientHelloOuter without any fuss. This property is great for rollback safety. (Otherwise any ECH server deployment needs to be two-stage, and introduces a lower bound that you cannot rollback beyond.) And elsewhere we've tried to avoid contradicting RFC8446.\r\n\r\nI'm not sure why ignoring stuff is fuss. What's the alternative? To terminate the handshake if the server receives early data? Wouldn't that be more fuss?\r\n\r\nIf RFC8446 doesn't specify what to do in this situation, I'm not sure why specifying it is in *contradiction* to RFC8446 (as opposed to expanding on it).",
          "createdAt": "2021-03-30T17:50:53Z",
          "updatedAt": "2021-03-30T17:50:53Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I think RFC8446 does say what to do in this situation. Section 5.2 says at the bottom:\r\n>    If the decryption fails, the receiver MUST terminate the connection\r\n>   with a \"bad_record_mac\" alert.\r\n\r\nhttps://tools.ietf.org/html/rfc8446#section-5.2\r\n\r\nThe default for the record layer is that decryption errors are fatal (as it should be). Early data skipping is an exception to this described in section 4.2.10, and the exception only applies when the server declines an early_data extension.\r\n\r\n> I'm not sure why ignoring stuff is fuss. What's the alternative? To terminate the handshake if the server receives early data? Wouldn't that be more fuss?\r\n\r\nOh no, the goal is to ignore stuff. That's what makes the recovery flow work. The issue is that, in RFC8446, servers only ignore the early data *if there was an early_data extension in ClientHello which they declined*. Otherwise, it's just a fatal decryption error. In order to meet that condition, ClientHelloOuter needs the early_data extension whenever ClientHelloInner does.",
          "createdAt": "2021-03-31T20:42:13Z",
          "updatedAt": "2021-03-31T20:42:13Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "ACK -- thanks for closing the loop! ",
          "createdAt": "2021-03-31T20:49:16Z",
          "updatedAt": "2021-03-31T20:49:16Z"
        }
      ]
    },
    {
      "number": 412,
      "id": "MDU6SXNzdWU4NDUwMDU2OTE=",
      "title": "Describe ECH chronologically rather than all client behavior then all server behavior",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/412",
      "state": "CLOSED",
      "author": "cbartle891",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Imo, it's very confusing to describe all the client behavior and then all the server behavior as opposed to describing the steps in the order in which they happen. I'm constantly flipping back and forth from one section to the other to understand the series of events. \r\n\r\n@cjpatton [suggested](https://github.com/tlswg/draft-ietf-tls-esni/pull/407#discussion_r604270551) that the current method of organization might be easier for implementers, but I'm not so sure. It seems to me that the first step in implementing something is understanding it, and it's more difficult to understand ECH in its current format than if it were explained in the order in which things happen.\r\n\r\n@dmcardle do you think that would be more confusing or less so?",
      "createdAt": "2021-03-30T18:15:29Z",
      "updatedAt": "2023-07-25T17:28:16Z",
      "closedAt": "2023-07-25T17:28:16Z",
      "comments": [
        {
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I can second that experience \u2014 I've found myself flipping back-and-forth between the behavior sections.  On the other hand, I've also found it useful to step through just the server behavior section and compare it with my server-only patch.\r\n\r\nI'm slightly concerned that weaving the sections together would add a lot of verbal overhead when switching between the client and server. But I wouldn't object if you or someone else wanted to try to refactor it :) ",
          "createdAt": "2021-03-30T21:25:54Z",
          "updatedAt": "2021-03-30T21:25:54Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as complete. Please reopen if necessary!",
          "createdAt": "2023-07-25T17:28:16Z",
          "updatedAt": "2023-07-25T17:28:16Z"
        }
      ]
    },
    {
      "number": 424,
      "id": "MDU6SXNzdWU4NjEzNDMyODM=",
      "title": "Should IP addresses be allowed for the client-facing server?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/424",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "design"
      ],
      "body": "In #413, there's been a lot of discussion around how and whether or not IP addresses should be allowed as a reference identity of the client-facing server. This issue tracks sorting this particular question out. \r\n\r\n- @bemasc suggested [allowing the SNI be empty](https://github.com/tlswg/draft-ietf-tls-esni/issues/405#issuecomment-812088744) in the case the reference identity is an IP address. (Whether or not this address is in the ECHConfig is separate.)\r\n- @martinthomson suggested [prohibiting IP addresses in the ECHConfig](https://github.com/tlswg/draft-ietf-tls-esni/pull/413#issuecomment-822089084). (Whether or not this allows the outer SNI to be empty is separate.)\r\n\r\nSo there seems to be two questions we need to sort out, in relation to #396:\r\n\r\n1. Should the ECHConfig be allowed to supply IP addresses? And if so, how do client stacks validate them?\r\n2. Should clients be allowed to validate servers using IP addresses as a reference identity? (If yes, then the ClientHelloOuter.SNI must be allowed to be empty/omitted.)\r\n\r\nI think (2) should be 'yes', given that's currently possible today introduces no new complexity. I think it should be feasible to spell out the requirements to make (1) feasible, so I also think that should be 'yes'.\r\n\r\nWhat do others think?",
      "createdAt": "2021-04-19T14:01:11Z",
      "updatedAt": "2021-06-14T21:02:10Z",
      "closedAt": "2021-06-14T21:02:10Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes and yes.\r\n\r\nRFC 8738 [fits the square peg in the round hole](https://tools.ietf.org/html/rfc8738#section-6) using reverse-IP notation, which seems like a halfway-reasonable option.  An \"empty\" public name seems a little more flexible (doesn't require servers to carry certificates for each other's IP addresses), and ought to be easy enough to support on clients.",
          "createdAt": "2021-04-19T14:32:43Z",
          "updatedAt": "2021-04-19T14:32:43Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@bemasc to clarify this:\r\n\r\n> An \"empty\" public name seems a little more flexible (doesn't require servers to carry certificates for each other's IP addresses), and ought to be easy enough to support on clients.\r\n\r\nYou're suggesting that if ECHConfig is empty then the client should use the IP address of the client-facing server as the reference identity, right? That seems like a reasonable way around the language we might need to specify what is a valid address in ECHConfig. (If the reference identity is not empty, then it MUST be a name, otherwise it's the IP address, and clients should connect and validate based on that identity accordingly.)",
          "createdAt": "2021-04-19T14:37:24Z",
          "updatedAt": "2021-04-19T14:37:24Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood Correct.  @dmcardle previously raised a concern that this could complicate client implementations: the TLS stack can no longer make use of a connected socket given solely on the ECHConfig and inner reference identity; it also needs the remote IP in some cases.  This is true, but I think the remote IP is essentially always \"at hand\" so perhaps it can be passed in unconditionally without too much difficulty.",
          "createdAt": "2021-04-19T14:41:16Z",
          "updatedAt": "2021-04-19T14:42:47Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think that's true when the client is using a proxy, depending on how much of DNS is done on the client and how much is done on the proxy. If the client does the SVCB lookup itself but asks the proxy to look up TargetName, as the SVCB draft [itself suggests](https://github.com/MikeBishop/dns-alt-svc/blob/master/draft-ietf-dnsop-svcb-https.md#clients-using-a-proxy), the client won't have the remote IP of the client-facing server available.\r\n\r\n(Are there weird networks that rewrite addresses at the DNS level? That would also break with this idea.)",
          "createdAt": "2021-04-19T14:58:26Z",
          "updatedAt": "2021-04-19T14:58:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "To try and sharpen @davidben's point: will the client always have access to the client-facing server IP? I don't see how this _won't_ always be true, since the client connects to _something_, but maybe I'm misunderstanding the proxy scenario. ",
          "createdAt": "2021-04-19T15:16:10Z",
          "updatedAt": "2021-04-19T15:16:10Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@davidben is correct about the behavior when using a SOCKS5 or HTTP CONNECT proxy in domain-oriented mode.  The proxy performs A/AAAA resolution and TCP connection establishment, and does not provide this information back to the client, so the client doesn't know which server IP it is using.  That does suggest that \"empty\" `public_name` won't work.",
          "createdAt": "2021-04-19T15:21:31Z",
          "updatedAt": "2021-04-19T15:21:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh! I see. The proxy is the one establishing the transport connection. \ud83d\udc4d ",
          "createdAt": "2021-04-19T15:27:38Z",
          "updatedAt": "2021-04-19T15:27:38Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> domain-oriented mode\r\n\r\nThere's probably at least three modes here, if not more:\r\n\r\n1. Proxy gets the origin DNS name and takes over the whole DNS lookup. Client doesn't do SVCB at all. The only way to salvage SVCB-based features is to invent a header for the proxy to tell the client what SVCB path it followed in the CONNECT response.\r\n2. Client does SVCB lookup and gives TargetName to the proxy.\r\n3. Client does the whole lookup and gives the IP address to the proxy.\r\n\r\nThe one that breaks empty names is (2). Though, given that proxies today are often used to access internal services (i.e. without the proxy, you may not even be able to resolve the name), I expect (1) to be the default for existing schemes. Whereas (3) might make sense for other kinds of proxy use cases. (I'm actually not entirely sure when you'd want (2) despite the spec recommendation... maybe if you're relying on the proxy to rewrite IPs, but the proxy needs to a DNS name to do so?)",
          "createdAt": "2021-04-19T16:33:10Z",
          "updatedAt": "2021-04-19T16:33:10Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is presumably not the right forum for this topic, but mode (2) is the one that gives you correct Happy Eyeballs, geo-DNS, etc.",
          "createdAt": "2021-04-19T16:41:03Z",
          "updatedAt": "2021-04-19T16:41:03Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 19/04/2021 15:58, David Benjamin wrote:\n> (Are there weird networks that rewrite addresses at the DNS level?\n> That would also break with this idea.)\nI seem to recall some DNS IPv6 transition thing that maybe\nhas that property.\n\nS.\n\n",
          "createdAt": "2021-04-19T20:26:06Z",
          "updatedAt": "2021-04-19T20:26:06Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, there are transition technologies that rewrite addresses.  Clients get a v6 address because they only have v6, but the server address is v4.\r\n\r\nAs for the general proxy problem, there is no value in any design that does not involve the client having the ECHConfig.  It can't use the public IP (because it doesn't know it always), but it can still populate server_name according to the value of public_name.  I might have missed something there though.\r\n\r\nFrom David's [options](https://github.com/tlswg/draft-ietf-tls-esni/issues/424#issuecomment-822608586), option 1 is a bit silly (it adds unnecessary latency), but it also gives you the best locality if your goal is to use the proxy egress as the client network location (option 2 as Ben [suggests](https://github.com/tlswg/draft-ietf-tls-esni/issues/424#issuecomment-822613850) only works if you care about the network location of the client, at which point you might as well not use a proxy).  The only difference between 2 and 3 there is whether the proxy needs to perform its own name resolution, which might differ from the client (and cause problems as a result; but that's mostly just a case of insisting that clients don't choose option 2).\r\n\r\nI don't understand why it's so hard to require the use of a domain name.  It shouldn't be \"[why not](https://github.com/tlswg/draft-ietf-tls-esni/pull/413#issuecomment-822488984)\".  Adding other forms of reference identity adds complexity to what is already a morass of horrifying complexity, so we should insist on justification for every addition.  And I'm not seeing any concrete arguments in favour of the complex option.\r\n\r\nSo my answer is No to both questions.",
          "createdAt": "2021-04-20T00:27:02Z",
          "updatedAt": "2021-04-20T00:27:02Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't agree with Martin's characterization of the proxy behaviors, but I don't think this is the place to discuss that topic anyway.\r\n\r\n> I don't understand why it's so hard to require the use of a domain name.\r\n\r\nTo me, the main advantage of supporting IP reference identities is for origins that are not using a large-scale hosting provider, and thus cannot rely on a widely shared `public_name`.  Domain names are typically more closely linked to an organization than IP addresses (especially with VM hosting), and more expensive to change.\r\n\r\nAn IP address `public_name` ensures that the client does not populate the outer SNI, and supports a configuration where the default certificate only contains an IP address SAN.  This minimizes the information visible to an adversary unless they can also identify the service that runs on this IP address (e.g. by scanning the whole DNS).\r\n\r\nAn alternative to IP address in `public_name` would be a flag in the ECHConfig indicating that the specified reference identity is in the default certificate (which is implicitly true for IP reference identities).  This would allow clients to omit the SNI, improving small services' privacy against a passive adversary, but active adversaries could fetch the default certificate to learn the `public_name`.",
          "createdAt": "2021-04-20T02:23:59Z",
          "updatedAt": "2021-04-20T02:23:59Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "For everyone's consideration, we now have #426 as an alternate solution to this problem (thanks to @davidben) which does two things: (1) avoids overloading a single field for two types of values (names and addresses), and (2) punts IP address validation to a future change. While I sympathize with Martin's view, it seems overly restrictive to just prohibit IP addresses outright. This change allows us to sort that out in a future change, and should make everyone happy. \r\n\r\nThoughts?",
          "createdAt": "2021-04-20T14:50:13Z",
          "updatedAt": "2021-04-20T14:50:13Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Re #426, the idea is largely me going \"oops, I'm sorry for the mess\". :-) When I filed #405, I was mostly interested in the client validation. But most places with DNS strings have a semi-overlap with IP literal syntax, and RFC6066 already prohibits of IP literals. (Without declaring an actual syntax being prohibited!) So it seemed hard to resolve those questions without going one way or another on IPs. So I brought up that question too as a seemingly minor (hah) side question on the main issue.\r\n\r\nThat side question has turned out to be _way_ more messy than I anticipated. Since there isn't a strong need for IPs as public identities, but also unease to completely close that door, I propose we tweak the encoding so it's easy enough to add later (reuse the extension mechanism we're already putting in), but not actually bother in this draft.",
          "createdAt": "2021-04-20T15:31:56Z",
          "updatedAt": "2021-04-20T15:31:56Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Isn't it the case that the extension scheme would allow us to add IP addresses later, even without #426?",
          "createdAt": "2021-04-20T23:29:15Z",
          "updatedAt": "2021-04-20T23:29:15Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Isn't it the case that the extension scheme would allow us to add IP addresses later, even without #426?\r\n\r\nThere's lots of different ways we can accomplish this, and it'll come down to personal taste. For example:\r\n\r\n- Make public_name optional in the main ECHConfig (and waste the two byte length field), and allow an extension to specify the IP address.\r\n- Move public_name to a mandatory extension (as 426 does), and allow future extensions to specify addresses override the name.\r\n- etc.\r\n\r\nGiven the bikeshed that's happening here, it seems prudent to at least separate these things (names and addresses). If we can agree on that, then we just need to decide where we put those bits. #426 does the job one way. If someone wants to propose an alternative PR to put the bits somewhere else, please do so!",
          "createdAt": "2021-04-20T23:47:11Z",
          "updatedAt": "2021-04-20T23:47:11Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If we're really talking about a bikeshed, then the \"no change\" option works for me.  It's fewer bits on the wire (by 4), it is less complicated to enforce it being mandatory, and we already have it implemented.\r\n\r\nI do think that public_name being optional has some impact here.  It means that you don't have a reference identity for fallback handling.  I think that's probably legitimate.  There might be cases where fallback is not needed.",
          "createdAt": "2021-04-20T23:56:48Z",
          "updatedAt": "2021-04-20T23:56:48Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I do think that public_name being optional has some impact here. It means that you don't have a reference identity for fallback handling. I think that's probably legitimate. There might be cases where fallback is not needed.\r\n\r\nHmm... how do you see this working if a future extension wants to specify IP addresses as a fallback but the public_name is not allowed to be optional?\r\n\r\nI agree that there will be cases where fallback is not needed. DNS-SD is one of them. And in that case, removing the public_name field (or allowing it to be empty, or whatever) will be needed. I think #426 addresses that pretty nicely. ",
          "createdAt": "2021-04-21T00:09:23Z",
          "updatedAt": "2021-04-21T00:09:23Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ahh, I misunderstood.  It's not that the extension is mandatory to use, but it is mandatory to understand when present.  Let's be really crisp about the words we use.\r\n\r\nOf course, an empty value is an equally good way to indicate that the value isn't operative.  It's one byte in the less-common case to save 4 bytes in the common case.\r\n\r\nThe question occurs to me: is there any possibility that you could have both a public_name extension and this hypothetical ip_reference_identity extension?  What would that mean?\r\n\r\nI want to be really open about my priors here: I think that extensibility along this axis is an anti-feature for ECH.  The mandatory-to-understand extensions are part of what really confirmed that for me.  I think that the current format would be improved by removing the extensions block.",
          "createdAt": "2021-04-21T00:22:59Z",
          "updatedAt": "2021-04-21T00:22:59Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> The question occurs to me: is there any possibility that you could have both a public_name extension and this hypothetical ip_reference_identity extension? What would that mean?\r\n\r\nUnclear -- I think it'd be up to the hypothetical extension to define how those things interact. \r\n\r\n> I want to be really open about my priors here: I think that extensibility along this axis is an anti-feature for ECH. The mandatory-to-understand extensions are part of what really confirmed that for me. I think that the current format would be improved by removing the extensions block.\r\n\r\nI hear you. If we didn't care about IP addresses for the fallback certificate, much of this would be simplified. (And admittedly the desire to remove the extensions block would increase for me, too.) I'm going to take this to the list, since we don't seem to be getting anywhere without consensus on that point. ",
          "createdAt": "2021-04-21T00:28:35Z",
          "updatedAt": "2021-04-21T00:28:35Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> Ahh, I misunderstood. It's not that the extension is mandatory to use, but it is mandatory to understand when present. Let's be really crisp about the words we use.\r\n\r\nThe draft already defines a notion of \"mandatory\". Although #426 does both (let's call the other one \"required\"?), which I think is the minimal encoding change because...\r\n\r\n> I do think that public_name being optional has some impact here. It means that you don't have a reference identity for fallback handling. I think that's probably legitimate. There might be cases where fallback is not needed.\r\n\r\nI don't think we should open that can of worms. Even though not having a fallback flow is really the server's decision, I think the client has a stake in this too. It's useful to nudge the ecosystem towards things that work well. If a server deploys without fallback, underestimating the predictability of DNS caching, it will break rarely in some clients. That sort of thing is bad UX and increases the pressure for clients to adopt insecure fallbacks. Unless there is a clear need, I don't think we should allow that. (Otherwise not setting it up is deceptively attractive for a naive server since they make fewer decision.)\r\n\r\nThe extensibility story for ECH is a little funny. You send an ECHConfigList and the client ignores any ECHConfigs it can't understand. So if we say today's ECH clients require a public_name extension, future ECH clients can still support a public_ip extension that relaxes the public_name requirement. Today's ECH clients will just ignore the public_ip-using configs, which is the desired behavior.\r\n\r\nBut I should say I have no stake in this IP mess and do not care whether we allow those. Just pick something that everyone's happy with, please. #426 was an attempt to punt this out of the draft while keeping all the existing semantics unchanged (hence required extension; the correct reading is that it is *purely* an encoding change).",
          "createdAt": "2021-04-21T05:04:34Z",
          "updatedAt": "2021-04-21T05:04:34Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That point about making it hard NOT to provide a fallback makes me more inclined to reject #426.  If the effect is just a change in encoding, it's a less efficient encoding and one that is harder to validate properly.  If the effect is to make it optional under certain conditions, you have just argued effectively for why that has negative consequences.",
          "createdAt": "2021-04-21T06:47:54Z",
          "updatedAt": "2021-04-21T06:47:54Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\nIt's really a different point and maybe deserves it's own\nissue but since I'm not logged into github and email works...\n\nOn 21/04/2021 06:04, David Benjamin wrote:\n> The extensibility story for ECH is a little funny. You send an\n> ECHConfigList and the client ignores any ECHConfigs it can't\n> understand.\nThe \"critical\" bit in x.509 extensions IMO didn't work. IIRC\nwe really designed it for the basicConstraints extension, as\nthat had to be understood by relying parties, but the result\nwas that we more or less only had one shot at introducing any\ncritical extensions - unless I'm forgetting stuff (which is\nentirely possible:-) pretty much all later attempts to add\nnew critical extensions failed as they'd break deployed\nclients. We'd have been better off adding the is-a-ca flag\nand anything else we knew to be critical the TBSCertificate.\n(Again IIRC, we put both critical and non-critical stuff into\nextensions because the *UniqueID fields in TBSCertificate\nthat were added in x.509v2 hadn't been useful so there was\na reluctance to put new fields in there at that point.)\n\nI don't see why criticality is different for ECH extensions.\nMy bet is that any new critical extension will need a new TLS\nextension code point once the first ECH RFC is issued.\n\nSo I'd remove the extensions fields we've defined and if not\nthen at least get rid of the idea of criticality.\n\nCheers,\nS.\n\n\n",
          "createdAt": "2021-04-21T09:40:24Z",
          "updatedAt": "2021-04-21T09:40:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sftcd I filed #427 to discuss ECHConfig.extensions -- let's try and keep this issue focused on the IP address question(s).",
          "createdAt": "2021-04-21T15:02:56Z",
          "updatedAt": "2021-04-21T15:02:56Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed in #456, closing.",
          "createdAt": "2021-06-14T21:02:10Z",
          "updatedAt": "2021-06-14T21:02:10Z"
        }
      ]
    },
    {
      "number": 427,
      "id": "MDU6SXNzdWU4NjM5ODY2ODI=",
      "title": "Extensibility",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/427",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "design",
        "parked"
      ],
      "body": "The topic of ECH extensions has come up a number of times. I can't remember if we ever had a consensus call on whether or not to keep them, so this issue tracks that point. ",
      "createdAt": "2021-04-21T15:01:59Z",
      "updatedAt": "2023-11-06T08:55:10Z",
      "closedAt": "2023-11-06T08:55:09Z",
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\nHiya,\n\nOn 21/04/2021 16:02, Christopher Wood wrote:\n> The topic of ECH extensions has come up a number of times. I can't\n> remember if we ever had a consensus call on whether or not to keep\n> them, so this issue tracks that point.\n\nThanks for re-directing my comment on that other issue.\n\nLet me try summarise what I think is the case against\nextensions and criticality.\n\nIn the main we already have sufficient extensibility outside\nof ECHConfig:\n\n- A new RRTYPE could be used, though that's a high barrier\n   so wouldn't be desirable.\n- A new SvcParamKey can be defined easily and that is a\n   designed-in extension point. We're already changing the\n   label for echconfig to ech and nobody seems very upset.\n   (Well, some of the DNS people were a bit:-) I doubt\n   defining a new code point would be a problem if needed.\n- ECHConfig has a version number, so we can just bump that\n   as needed, possibly alongside a TLS extension code point\n   bump to avoid problems.\n- Those already implementing are used to bumping the version\n   but afaik have no real code for extensions. (I do have some\n   code to embed random file content in an ECHConfig but have\n   not really tried it out.)\n- We can use multi-valued RRs to handle the case where we\n   need both an \"old\" and \"new\" form with different version\n   encodings.\n\nWriting code to produce, consume, test, fuzz etc. extensions\nwhen we have no current real uses for extensions is wasted\neffort. The extension consuming code is likely to be less\nwell tested over time and hence represent a risk. If we don't\nneed to take that risk, we ought not.\n\nSeparately on criticality, I'll just repeat what I said in\nthe other issue/thread:\n\nThe \"critical\" bit in x.509 extensions IMO didn't work. IIRC\nwe really designed it for the basicConstraints extension, as\nthat had to be understood by relying parties, but the result\nwas that we more or less only had one shot at introducing any\ncritical extensions - unless I'm forgetting stuff (which is\nentirely possible:-) pretty much all later attempts to add\nnew critical extensions failed as they'd break deployed\nclients. We'd have been better off adding the is-a-ca flag\nand anything else we knew to be critical to TBSCertificate.\n(Again IIRC, we put both critical and non-critical stuff into\nextensions because the *UniqueID fields in TBSCertificate\nthat were added in x.509v2 hadn't been useful so there was\na reluctance to put new fields in there at that point.)\n\nI don't see why criticality is different for ECH extensions.\nMy bet is that any new critical extension will need a new TLS\nextension code point once the first ECH RFC is issued.\n\nSo I'd remove the extensions fields we've defined and if not\nthen at least get rid of the idea of criticality.\n\nCheers,\nS.\n",
          "createdAt": "2021-04-21T21:11:47Z",
          "updatedAt": "2021-04-21T21:11:47Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "> we have no current real uses for extensions\r\n\r\nIsn't the point of extensions to allow things to be added in the future that we currently don't need or foresee needing?",
          "createdAt": "2021-04-27T18:27:11Z",
          "updatedAt": "2021-04-27T18:27:11Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 27/04/2021 19:27, Carrick Bartle wrote:\n>> we have no current real uses for extensions\n> \n> Isn't the point of extensions to allow things to be added in the\n> future that we currently don't need or foresee needing?\n\nYes, but...\n\n- we have many other extension points that can be used, in\n   particular ECHConfig.version\n- extensions without real uses seem IMO wasteful and will\n   lead to untested code and maybe affect interop if people\n   develop proprietary extensions\n- complexity: we're already doing enough of that:-)\n\nNot every PDU needs to be internally generically extensible,\nif there's already an equally good extension point.\n\nCheers,\nS.\n\n> \n",
          "createdAt": "2021-04-27T20:01:32Z",
          "updatedAt": "2021-04-27T20:01:32Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": "I also prefer not to have an extensions field.  If in the future some people develop an extension, it can either be a new ECHConfig type, or even a new TLS extension.\r\n",
          "createdAt": "2021-04-27T20:03:38Z",
          "updatedAt": "2021-04-27T20:03:38Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\r\n> Yes, but... - we have many other extension points that can be used, in particular ECHConfig.version - extensions without real uses seem IMO wasteful and will lead to untested code and maybe affect interop if people develop proprietary extensions - complexity: we're already doing enough of that:-) Not every PDU needs to be internally generically extensible, if there's already an equally good extension point.\r\n\r\nFrom draft-07 until now, the value of ECHConfig.version has been locked to the extension codepoint so that we can interop between drafts. I wouldn't want to overload ECHConfig.version for extensions as well. I suppose we could do so post-RFC. In the meantime, I vote we leave extensions language as-is until we're absolutely sure we don't need it.",
          "createdAt": "2021-04-27T22:55:29Z",
          "updatedAt": "2021-04-27T22:55:29Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Voting or not, [draft-iab-use-it-or-lose-it](https://intarchboard.github.io/draft-use-it-or-lose-it/draft-iab-use-it-or-lose-it.html) says all that needs to be said on this topic.  The extension codepoint is a well-tested extension point that gives us adequate opportunity to revise or extend as needed.\r\n\r\nExtensions to ECH should not be undertaken lightly.  Insisting on a new extension codepoint is appropriately momentous.",
          "createdAt": "2021-04-28T05:50:16Z",
          "updatedAt": "2021-04-28T05:50:16Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "We have ample experience that \"version\" is a bad extension point and ample\nexperience that extensions are a powerful one. I am not in favor of\nremoving it.\n\n-Ekr\n\n\nOn Tue, Apr 27, 2021 at 1:01 PM sftcd ***@***.***> wrote:\n\n>\n>\n> On 27/04/2021 19:27, Carrick Bartle wrote:\n> >> we have no current real uses for extensions\n> >\n> > Isn't the point of extensions to allow things to be added in the\n> > future that we currently don't need or foresee needing?\n>\n> Yes, but...\n>\n> - we have many other extension points that can be used, in\n> particular ECHConfig.version\n> - extensions without real uses seem IMO wasteful and will\n> lead to untested code and maybe affect interop if people\n> develop proprietary extensions\n> - complexity: we're already doing enough of that:-)\n>\n> Not every PDU needs to be internally generically extensible,\n> if there's already an equally good extension point.\n>\n> Cheers,\n> S.\n>\n> >\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/issues/427#issuecomment-827891174>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAIPLINCCITLSXDLXV2URZLTK4J3DANCNFSM43KRJ3HQ>\n> .\n>\n",
          "createdAt": "2021-04-29T19:17:33Z",
          "updatedAt": "2021-04-29T19:17:33Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 29/04/2021 20:17, ekr wrote:\n> We have ample experience that \"version\" is a bad extension point \n\nI don't think that's comparing like with like.\n\nECHconfig.version is really a content type with no well\ndefined sequencing - at least that's how it's been treated.\nAnd so far, nothing in the spec that I recall says that one\nought prefer any particular ECHConfig.version over any other.\n\nI wonder would we all be happy with something like:\n\n  s/ECHCOnfig.version/ECHConfig.type/\n\nS.\n\n\n> \n> -Ekr\n> \n> \n> On Tue, Apr 27, 2021 at 1:01 PM sftcd ***@***.***> wrote:\n> \n>>\n>>\n>> On 27/04/2021 19:27, Carrick Bartle wrote:\n>>>> we have no current real uses for extensions\n>>>\n>>> Isn't the point of extensions to allow things to be added in the\n>>> future that we currently don't need or foresee needing?\n>>\n>> Yes, but...\n>>\n>> - we have many other extension points that can be used, in\n>> particular ECHConfig.version\n>> - extensions without real uses seem IMO wasteful and will\n>> lead to untested code and maybe affect interop if people\n>> develop proprietary extensions\n>> - complexity: we're already doing enough of that:-)\n>>\n>> Not every PDU needs to be internally generically extensible,\n>> if there's already an equally good extension point.\n>>\n>> Cheers,\n>> S.\n>>\n>>>\n>>\n>> \u2014\n>> You are receiving this because you are subscribed to this thread.\n>> Reply to this email directly, view it on GitHub\n>> <https://github.com/tlswg/draft-ietf-tls-esni/issues/427#issuecomment-827891174>,\n>> or unsubscribe\n>> <https://github.com/notifications/unsubscribe-auth/AAIPLINCCITLSXDLXV2URZLTK4J3DANCNFSM43KRJ3HQ>\n>> .\n>>\n> \n> \n",
          "createdAt": "2021-04-29T19:25:11Z",
          "updatedAt": "2021-04-29T19:25:11Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "On Thu, Apr 29, 2021 at 12:25 PM sftcd ***@***.***> wrote:\n\n>\n>\n> On 29/04/2021 20:17, ekr wrote:\n> > We have ample experience that \"version\" is a bad extension point\n>\n> I don't think that's comparing like with like.\n>\n> ECHconfig.version is really a content type with no well\n> defined sequencing - at least that's how it's been treated.\n> And so far, nothing in the spec that I recall says that one\n> ought prefer any particular ECHConfig.version over any other.\n>\n> I wonder would we all be happy with something like:\n>\n> s/ECHCOnfig.version/ECHConfig.type/\n>\n\nThe issue is not about sequencing. It is about accreting a large number of\nindependent parameters under a single code point.\n\n-Ekr\n\n\n> S.\n>\n>\n> >\n> > -Ekr\n> >\n> >\n> > On Tue, Apr 27, 2021 at 1:01 PM sftcd ***@***.***> wrote:\n> >\n> >>\n> >>\n> >> On 27/04/2021 19:27, Carrick Bartle wrote:\n> >>>> we have no current real uses for extensions\n> >>>\n> >>> Isn't the point of extensions to allow things to be added in the\n> >>> future that we currently don't need or foresee needing?\n> >>\n> >> Yes, but...\n> >>\n> >> - we have many other extension points that can be used, in\n> >> particular ECHConfig.version\n> >> - extensions without real uses seem IMO wasteful and will\n> >> lead to untested code and maybe affect interop if people\n> >> develop proprietary extensions\n> >> - complexity: we're already doing enough of that:-)\n> >>\n> >> Not every PDU needs to be internally generically extensible,\n> >> if there's already an equally good extension point.\n> >>\n> >> Cheers,\n> >> S.\n> >>\n> >>>\n> >>\n> >> \u2014\n> >> You are receiving this because you are subscribed to this thread.\n> >> Reply to this email directly, view it on GitHub\n> >> <\n> https://github.com/tlswg/draft-ietf-tls-esni/issues/427#issuecomment-827891174\n> >,\n> >> or unsubscribe\n> >> <\n> https://github.com/notifications/unsubscribe-auth/AAIPLINCCITLSXDLXV2URZLTK4J3DANCNFSM43KRJ3HQ\n> >\n> >> .\n> >>\n> >\n> >\n>\n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/issues/427#issuecomment-829525450>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAIPLIM6EHNFGTW22NJKTTDTLGXCZANCNFSM43KRJ3HQ>\n> .\n>\n",
          "createdAt": "2021-04-29T20:56:03Z",
          "updatedAt": "2021-04-29T20:56:03Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 29/04/2021 21:56, ekr wrote:\n> The issue is not about sequencing. \n\nWell, it would be if this were a version number. Those\nincrease. Maybe we agree that this isn't a version number\nat all.\n\n> It is about accreting a large number of\n> independent parameters under a single code point.\n\nWhere large == 0 ? (Being the number of extensions defined\nas of now.)\n\nSeriously though, if it turns out there's a need for two\nextensions for ECHConfig that can be mixed and matched,\nthen we could just define an ECHConfig type that allows\nthat either via two optional fields or a more generic\nextension mechanism. With zero extensions as of now, it's\ncheaper to punt on that decision to when it's needed and\nnot speculate now as to which design might be better.\n(That's just another long-winded way of restating that\nwe already have sufficient extensibility though, so I\nshould probably shut up for a bit in this thread:-)\n\nS.\n",
          "createdAt": "2021-04-29T21:23:36Z",
          "updatedAt": "2021-04-29T21:23:36Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "On Thu, Apr 29, 2021 at 2:23 PM sftcd ***@***.***> wrote:\n\n>\n>\n> On 29/04/2021 21:56, ekr wrote:\n> > The issue is not about sequencing.\n>\n> Well, it would be if this were a version number. Those\n> increase. Maybe we agree that this isn't a version number\n> at all.\n>\n\nNo, it's a version number. My opinion just doesn't depend on that.\n\n\n> > It is about accreting a large number of\n> > independent parameters under a single code point.\n>\n> Where large == 0 ? (Being the number of extensions defined\n> as of now.)\n>\n\nThe future is bigger than the past. I understand this isn't your view,\nbut we just have a philosophical difference at this point.\n\n-Ekr\n",
          "createdAt": "2021-04-29T21:58:50Z",
          "updatedAt": "2021-04-29T21:58:50Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 29/04/2021 22:59, ekr wrote:\n> The future is bigger than the past. I understand this isn't your view,\n\nThat misrepresents my view quite a bit.\n\nMy view is that we have sufficient extensibility already, not\nthat we don't need it.\n\nI think I've stated that a couple of times.\n\nS\n",
          "createdAt": "2021-04-29T22:09:13Z",
          "updatedAt": "2021-04-29T22:09:13Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "On Thu, Apr 29, 2021 at 3:09 PM sftcd ***@***.***> wrote:\n\n>\n>\n> On 29/04/2021 22:59, ekr wrote:\n> > The future is bigger than the past. I understand this isn't your view,\n>\n> That misrepresents my view quite a bit.\n>\n> My view is that we have sufficient extensibility already, not\n> that we don't need it.\n>\n\n> I think I've stated that a couple of times.\n>\n\nI'm sorry if I misrepresented your view.\n\nWith that said, if you look at the text that I was responding to (which you\nhave trimmed), it reads:\n\n\"Where large == 0 ? (Being the number of extensions defined\nas of now.)\"\n\nMy point is that I expect there to eventually be a significant number of\nextensions, so the fact that the current number is 0 is not very\ninteresting.\n\n-Ekr\n",
          "createdAt": "2021-04-29T22:18:21Z",
          "updatedAt": "2021-04-29T22:18:21Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 29/04/2021 23:18, ekr wrote:\n> My point is that I expect there to eventually be a significant number of\n> extensions, so the fact that the current number is 0 is not very\n> interesting.\n\nMy expectation is that we're more likely to cycle through a\nnumber of TLS extension code points as we learn more how to\ndo ECH and as we deal with adversaries who block such. But\nI don't see that happening very often.\n\nI also don't see any ECH-specific evidence for either of\nour expectations.\n\nAnd the number zero is always interesting:-)\n\nS.\n\n\n",
          "createdAt": "2021-04-29T22:34:36Z",
          "updatedAt": "2021-04-29T22:34:36Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing per discussion at IETF 118.",
          "createdAt": "2023-11-06T08:55:09Z",
          "updatedAt": "2023-11-06T08:55:09Z"
        }
      ]
    },
    {
      "number": 429,
      "id": "MDU6SXNzdWU4Nzc5OTA0NjY=",
      "title": "Clarify handling of transcript at client?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/429",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I suspect this is editorial, but it would be helpful to clarify exactly how the client computes its transcript when it generates its keys, based on the permutations of who gets what. IIUC:\r\n\r\n* If the server authenticates the inner SNI, the client must construct the client hello as seen by the back-end server, including any OuterExtensions compression, and uses it in the transcript.\r\n* If the server authenticates the public SNI, the client uses the entire client hello in the hash as-is, including the (unreadable) encrypted_client_hello extension.\r\n\r\nA server that combines the client-facing and back-end functions also has to duplicate this logic, since it can see everything but maybe shouldn't use it all, and has to go through the motions of formally constructing a proper client hello to a back-end server.\r\n\r\nI found this all quite subtle to work out and asked some questions of one of the authors to fully understand. I'll leave it to the editors as to whether the draft needs some text to make this clearer.\r\n\r\n[Aside: is it computationally feasible to add some sort of \"checksum\" that would neutralize the difference in the hashes? That would make this a little less tricky, IMO]",
      "createdAt": "2021-05-06T20:27:01Z",
      "updatedAt": "2021-08-02T16:19:58Z",
      "closedAt": "2021-08-02T16:19:58Z",
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 06/05/2021 21:27, martinduke wrote:\n> I suspect this is editorial, but it would be helpful to clarify\n> exactly how the client computes its transcript when it generates its\n> keys, based on the permutations of who gets what\n+1 and test vectors would be good too\n",
          "createdAt": "2021-05-06T20:31:10Z",
          "updatedAt": "2021-05-06T20:31:10Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, agree. This is really tricky: \"The client presumes acceptance if the last 8 bytes of ServerHello.random are equal to the first 8 bytes of accept_confirmation as defined in Section 7.2. Otherwise, it presumes rejection.\"",
          "createdAt": "2021-05-20T00:17:38Z",
          "updatedAt": "2021-05-20T00:17:38Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Here's what I ended up writing after I solved this:\r\n\r\n\"This issue is that the ECH transcript needs to be calculated from an unsent inner ClientHello message, which differs in a few ways from the EncodedClientHelloInner used in HPKE. Upon ECH acceptance, the transcript from the ClientHelloOuter is discarded, then substituted with one calculated from the unsent inner ClientHello message, and the client random is changed to the inner random value. After that, the ServerHello message is added to the transcript as normal. The transcript used for ECH acceptance is separate from the normal transcript.\"",
          "createdAt": "2021-05-22T19:34:06Z",
          "updatedAt": "2021-05-22T19:34:06Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the way to think about this is that there are two possible handshakes here, joined at the first message. Either we handshake with ClientHelloOuter, or we handshake with ClientHelloInner. Whichever, we handshake with, we follow the usual RFC8446 rules, including incorporating the chosen ClientHello into the transcript. Indeed on the server, the protocol even supports a client-facing vs. backend server split where the connection is actually rewritten to use ClientHelloInner.\r\n\r\nEncodedClientHelloInner, per the name, is just an encoding. We don't want to send two copies of things like key shares. The actual ClientHello being conveyed is still ClientHelloInner. (This is important since the transcript needs to reflect all inputs to TLS parameter negotiation.)\r\n\r\nBut, yes, on the client this gets a little fun because the client needs to offer these two somewhat related ClientHellos, learn which was to used a message later, and then complete the handshake accordingly.",
          "createdAt": "2021-05-22T21:34:56Z",
          "updatedAt": "2021-05-22T21:35:21Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> But, yes, on the client this gets a little fun because the client needs to offer these two somewhat related ClientHellos, learn which was to used a message later, and then complete the handshake accordingly.\r\n\r\nPerhaps there's missing text in \"6.1.4.1. Accepted ECH\", where client transcript handling could be addressed.\r\n\r\nMy feedback is that it was possible to construct a conformant EncodedClientHelloInner and enclosing ClientHelloOuter from reading the spec as a non-author, but I had to test with other implementations to discover what I was supposed to do with the ClientHelloInner. If you get this part wrong, then you just hit a decryption error after ServerHello. \r\n\r\nI did understand that I had to update the transcript, but I initially thought I should do it with an EncodedClientHelloInner added to the ClientHelloOuter transcript. Once I discovered that was not the case, I had to construct a ClientHelloInner that still had the fields that are compressed in EncodedClientHelloInner. That doesn't cross anything in the text, but it wasn't obvious to me.",
          "createdAt": "2021-05-22T21:56:01Z",
          "updatedAt": "2021-05-22T22:13:47Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "NONE",
          "body": "I think we're in agreement here, but is the encoding of ClientHelloInner\ndeterministic enough that the client-facing server can't possibly express\nthe expanded ClientHelloInner in a way that breaks the transcript?\n\nOn Sat, May 22, 2021 at 2:35 PM David Benjamin ***@***.***>\nwrote:\n\n> I think the way to think about this is that there are two possible\n> handshakes here, joined at the hip. Either we handshake with\n> ClientHelloOuter, or we handshake with ClientHelloInner. Whichever, we\n> handshake with, we follow the usual RFC8446 rules, including incorporating\n> the chosen ClientHello into the transcript. Indeed on the server, the\n> protocol even supports a client-facing vs. backend server split where the\n> connection is actually rewritten to use ClientHelloInner.\n>\n> EncodedClientHelloInner, per the name, is just an encoding. We don't want\n> to send two copies of things like key shares. The actual ClientHello being\n> conveyed is still ClientHelloInner. (This is important since the transcript\n> needs to reflect all inputs to TLS parameter negotiation.)\n>\n> But, yes, on the client this gets a little fun because the client needs to\n> offer these two somewhat related ClientHellos, learn which was to used a\n> message later, and then complete the handshake accordingly.\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/issues/429#issuecomment-846466291>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AF2EYEKN74QFCPWQXGFLL2LTPAPQZANCNFSM44H3KOZQ>\n> .\n>\n",
          "createdAt": "2021-05-24T19:45:06Z",
          "updatedAt": "2021-05-24T19:45:06Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "It's decode, not encode, that needs to be deterministic. And yes, it is deterministic.",
          "createdAt": "2021-05-24T19:52:05Z",
          "updatedAt": "2021-05-24T19:52:05Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Here's what I ended up writing to get this working. I don't have HRR support done yet, so I expect these comments will change a little bit:\r\n\r\n```Rust\r\n    pub fn confirm_ech(\r\n        &self,\r\n        ks: &mut KeyScheduleHandshake,\r\n        server_hello: &ServerHelloPayload,\r\n        suite: &SupportedCipherSuite,\r\n    ) -> Result<([u8; 32], HandshakeHash), Error> {\r\n        // The ClientHelloInner prior to encoding.\r\n        let m = self\r\n            .inner_message\r\n            .as_ref()\r\n            .ok_or_else(|| Error::General(\"No ClientHelloInner\".to_string()))?;\r\n\r\n        // A confirmation transcript calculated from the ClientHelloInner and the ServerHello,\r\n        // with the last 8 bytes of the server random modified to be zeros.\r\n        let conf = confirmation_transcript(m, server_hello, suite.get_hash());\r\n\r\n        // Derive a secret from the current handshake and the confirmation transcript.\r\n        let derived = ks.server_ech_confirmation_secret(&conf.get_current_hash());\r\n\r\n        // Check that first 8 digits of the derived secret match the last 8 digits of the original\r\n        // server random. This match signals that the server accepted the ECH offer.\r\n        if derived.into_inner()[..8] != server_hello.random.get_encoding()[24..] {\r\n            return Err(Error::General(\"ECH didn't match\".to_string()));\r\n        }\r\n\r\n        // Since the ECH offer was accepted, the handshake will move forward with a fresh transcript\r\n        // calculated from the ClientHelloInner, and the handshake should also use the client random\r\n        // from the ClientHelloInner. The ServerHello is added to the transcript next, whether or\r\n        // not the ECH offer was accepted.\r\n        let mut inner_transcript = HandshakeHash::new();\r\n        inner_transcript.start_hash(suite.get_hash());\r\n        inner_transcript.add_message(m);\r\n        Ok((self.inner_random, inner_transcript))\r\n    }\r\n```",
          "createdAt": "2021-05-27T19:53:32Z",
          "updatedAt": "2021-05-28T17:56:25Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Which transcript is used should be better clarified now that #480 landed. Closing as such. (If we want to track test vectors for ECH, let's open a new issue.)",
          "createdAt": "2021-08-02T16:19:57Z",
          "updatedAt": "2021-08-02T16:19:57Z"
        }
      ]
    },
    {
      "number": 430,
      "id": "MDU6SXNzdWU4OTA1Mzk0Nzk=",
      "title": "Make it easy to reference EncodedClientHelloInner decoding concerns",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/430",
      "state": "CLOSED",
      "author": "sayrer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "https://tools.ietf.org/id/draft-ietf-tls-esni-10.html#section-5.1-9\r\n\r\nThis should have its own section or sub-section. The projects I work on generally refer to RFC sections at the most, so as not to repeat the text of the or RFC or I-D (which may grow out of date).",
      "createdAt": "2021-05-12T22:39:14Z",
      "updatedAt": "2023-10-09T21:54:13Z",
      "closedAt": "2023-10-09T21:54:13Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This section [now exists](https://tlswg.org/draft-ietf-tls-esni/draft-ietf-tls-esni.html#name-clienthelloinner-packet-amp)! Closing as a result.",
          "createdAt": "2023-10-09T21:54:13Z",
          "updatedAt": "2023-10-09T21:54:13Z"
        }
      ]
    },
    {
      "number": 431,
      "id": "MDU6SXNzdWU4OTA1NzE2MjQ=",
      "title": "Should psk_key_exchange_modes also be omitted from ClientHelloOuter?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/431",
      "state": "CLOSED",
      "author": "sayrer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I don't know the answer to this question, but, from the TLS 1.3 RFC:\r\n\r\n```\r\n   -  \"pre_shared_key\" is REQUIRED for PSK key agreement.\r\n\r\n   -  \"psk_key_exchange_modes\" is REQUIRED for PSK key agreement.\r\n```\r\n\r\nI noticed this while testing with a pre-baked ClientHello that had both extensions. The ECH draft clearly required that the `pre_shared_key` extension be removed, but I wondered about `psk_key_exchange_modes`.",
      "createdAt": "2021-05-12T23:49:46Z",
      "updatedAt": "2021-05-13T16:52:33Z",
      "closedAt": "2021-05-13T16:52:33Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Given https://github.com/tlswg/draft-ietf-tls-esni/issues/408, https://github.com/tlswg/draft-ietf-tls-esni/pull/414, and https://github.com/tlswg/draft-ietf-tls-esni/pull/415, I'd say quite the opposite.",
          "createdAt": "2021-05-13T16:28:08Z",
          "updatedAt": "2021-05-13T16:28:08Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, I see text has been added saying it must appear in the ClientHelloOuter. Thanks for the references. I was working from draft-10.",
          "createdAt": "2021-05-13T16:52:33Z",
          "updatedAt": "2021-05-13T16:52:33Z"
        }
      ]
    },
    {
      "number": 433,
      "id": "MDU6SXNzdWU4OTE0MzUxMjY=",
      "title": "Embedded ClientHello padding complicates whole-input padding schemes",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/433",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Filing this as a topic for discussion. I think \"we don't like these padding strategies\" or \"that's not too complicated\" are perfectly plausible answers.\r\n\r\nSo, we need to pad the ECH payload to avoid revealing information via length. It seems to me there are two plausible strategies for padding, and you could do one or both of them. (You could do both by applying the first, then applying the second.)\r\n\r\n_NB: I don't know what the overall consensus is on padding strategies. My assumption has been that there isn't one and we're building flexibility into protocols so we can figure it out. The below is a summary of my current thinking, but there are probably lots of well-established ideas I don't know._ \r\n\r\n**Pad particular fields you are trying to hide**\r\nThere may be a particular field in your message with a length distribution you would like to hide. Perhaps some anonymity set has server name lengths up to 96 bytes. So you arrange for the client to know this, and the client adds 96 - len(server_name) extra bytes to the ClientHello somewhere. This is easy to reason about in isolation, but only considers individual fields. Information about other fields still leaks.\r\n\r\n**Generically reduce the range of possible lengths**\r\nYou may also just try to generically reduce the range of the function. Maybe you round to a multiple of 32, or round to the next power of some R > 1. This may still leak information: padding a multiple of 32 still distinguishes (big server name, big ALPN list) and (small server name, small ALPN list) when the variance is more than 32 bytes. But it pretty uniformly reduces the information leaked in general, which can help increase anonymity sets. For example, an HTTP client will always sends an ALPN of {h2, http/1.1}, but a tiny amount of overall padding can help combine HTTP ClientHellos with a non-HTTP client that might have a slightly different ALPN set. It can also mitigate mistakes. For instance, TLS tickets often embed the server name. If the server forgets to pad that when minting the ticket, the first strategy alone will leak this.\r\n\r\nThe recommended padding scheme currently only does the first kind. We add padding for server_name and largely ignore the other fields. Suppose some client wanted to additionally use the second strategy. The order of operations here is fussy and interleaves bits of ClientHelloInner and EncodedClientHelloInner:\r\n\r\n* EncodedClientHelloInner has a PSK binder\r\n* ...which depends on the non-PSK extensions of ClientHelloInner\r\n* ...which includes the padding extension\r\n* ...which depends on the length of the non-padding extensions of EncodedClientHelloInner\r\n* ...which depends on the length of the PSK binder, the non-PSK non-padding extensions of ClientHelloInner, which of them will be compressed\r\n\r\nThis is not actually a circular dependency. But it's a place the ClientHelloInner and EncodedClientHelloInner are awkward linked together. Probably the way to do it is to maintain a count of how much smaller EncodedClientHelloInner will be and subtract that from the ClientHelloInner as you construct and pad it.\r\n\r\n*If* we think this is a problem, the fix is pretty straightforward: add padding to EncodedClientHelloInner itself. Something like:\r\n\r\n```\r\nstruct {\r\n  ClientHello client_hello;\r\n  opaque padding<0..2^16-1>;\r\n} EncodedClientHelloInner;\r\n```\r\n\r\nNow the ClientHelloInner no longer depends on the length of the EncodedClientHelloInner. Is this worth doing?",
      "createdAt": "2021-05-13T22:31:28Z",
      "updatedAt": "2021-06-28T13:47:02Z",
      "closedAt": "2021-06-28T13:47:02Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Forgot to mention: Another reason to round the overall payload is that GREASE will likely be much more effective if the space of common lengths is dense.",
          "createdAt": "2021-05-20T17:32:10Z",
          "updatedAt": "2021-05-20T17:32:10Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@davidben thanks for filing! This seems reasonable, and probably avoids future one-off padding changes when we discover certain extensions are sensitive to their length. I suppose one could also include the padding extension on ClientHelloInner, but that becomes weird when you consider the ticket/binder example you raise. In general, the current draft text here does seem to be an artifact of the pre-ECH padding story. Since we're now covering multiple things in the ClientHello, applying padding more broadly seems right. I think it boils down to where we put those bits. (Your suggestion seems perfectly fine, and shouldn't be too onerous to implement. It should work fairly nicely with [our current implementation](https://github.com/cloudflare/go/blob/71ba4a16b1db8a2b5f2b0f857142fc1938134a1e/src/crypto/tls/ech.go#L464).)\r\n\r\n@cjpatton, what do you think?",
          "createdAt": "2021-05-26T21:20:55Z",
          "updatedAt": "2021-05-26T21:20:55Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\nI need to catch up on this discussion, but FWIW, I wrote up\nsome notes on the padding I've done so far at [1]. I'll be\nfine with changing that later if/as better ideas emerge, so\nam not that invested in it as of now but it might be useful\nas an input here.\n\nCheers,\nS.\n\n[1] \nhttps://github.com/sftcd/openssl/blob/ECH_UPFRONT_DEC/esnistuff/padding-notes.md\n",
          "createdAt": "2021-05-26T21:49:59Z",
          "updatedAt": "2021-05-26T21:49:59Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1, this seems like a good idea to me.",
          "createdAt": "2021-05-26T22:57:59Z",
          "updatedAt": "2021-05-26T22:57:59Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Wrote up some text for this https://github.com/tlswg/draft-ietf-tls-esni/pull/443.",
          "createdAt": "2021-06-04T03:28:44Z",
          "updatedAt": "2021-06-04T03:28:44Z"
        }
      ]
    },
    {
      "number": 434,
      "id": "MDU6SXNzdWU4OTE0MzYxMzk=",
      "title": "Fate of Early Data",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/434",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The only reference I see to early data in the draft is in a discussion of alternate designs.\r\n\r\nIf the client-facing server is unable to decode the inner client hello, an early-data extension (and PSK) might be in the inner or outer client hello.\r\n\r\nIf in the inner client hello, the server can't see it but will get application records. It should not throw the error that it otherwise might.\r\n\r\nIf in the outer client hello, this is essentially garbage being delivered to the wrong target, which it is unlikely to even be decryptable in split mode.\r\n\r\nI don't have strong feelings about what text should be in the draft about this. This simplest thing would probably be that the early_data extension MUST NOT be in the outer CH, and that the server should simply ignore early data application data records if it can't decode the inner hello and doesn't observe the necessary extensions.",
      "createdAt": "2021-05-13T22:33:04Z",
      "updatedAt": "2021-05-14T18:09:44Z",
      "closedAt": "2021-05-14T18:07:17Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is #408. (The fix is in GitHub, but I don't think there's been a draft-11 yet.)",
          "createdAt": "2021-05-13T23:00:47Z",
          "updatedAt": "2021-05-13T23:00:47Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "NONE",
          "body": "Ack, will close.\r\n\r\nOne semi-related quibble:\r\n> We almost don't care about this: the client may as well stop the handshake at server Finished and skip the client Finished flight anyway, for purposes of the recovery flow.\r\n\r\nIs this accurate? Don't we need to have at least some data with the session keys to verify that the transcripts agree?",
          "createdAt": "2021-05-14T18:07:17Z",
          "updatedAt": "2021-05-14T18:07:17Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> Is this accurate? Don't we need to have at least some data with the session keys to verify that the transcripts agree?\r\n\r\nThe client checks the server agreed with server CertificateVerify and server Finished. Then the server checks the client agreed with client CertificateVerify and client Finished. For purposes of the recovery flow, the server doesn't care, only the client. The client is going to discard the connection as soon as it's authenticated the new config.",
          "createdAt": "2021-05-14T18:09:43Z",
          "updatedAt": "2021-05-14T18:09:43Z"
        }
      ]
    },
    {
      "number": 437,
      "id": "MDU6SXNzdWU5MDQzOTE2OTc=",
      "title": "Example unsupported mandatory Configuration Extension",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/437",
      "state": "CLOSED",
      "author": "sayrer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "From the section on ECH configuration extensions: \"Clients MUST parse the extension list and check for unsupported mandatory extensions. If an unsupported mandatory extension is present, clients MUST ignore the ECHConfig.\"\r\n\r\nIs there an always-invalid extension specified for testing? This section references RFC8446, so maybe I'm missing something in that RFC.",
      "createdAt": "2021-05-27T23:43:56Z",
      "updatedAt": "2021-06-11T22:24:21Z",
      "closedAt": "2021-06-11T22:24:21Z",
      "comments": [
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am not sure this is purely editorial, although it's not very technically interesting. Should there be an IANA reservation for it?",
          "createdAt": "2021-06-11T20:53:06Z",
          "updatedAt": "2021-06-11T20:53:06Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I also filed #451 which covers reserving some always-invalid extensions.",
          "createdAt": "2021-06-11T20:58:14Z",
          "updatedAt": "2021-06-11T20:58:14Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK, let's just go with #451.",
          "createdAt": "2021-06-11T22:24:19Z",
          "updatedAt": "2021-06-11T22:24:19Z"
        }
      ]
    },
    {
      "number": 440,
      "id": "MDU6SXNzdWU5MTA4NDc5OTE=",
      "title": "Mitigate HRR when possible",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/440",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "parked"
      ],
      "body": "This issue tracks any changes to the ECH specification that can mitigate or minimize the probability of HRR in the context of ECH. Note that it is not meant to disable ECH when HRR occurs, but rather to make this case unlikely. This may mean, for example, giving guidance on how to construct ClientHellos based on server hints in the HTTPS record, though this is somewhat orthogonal to ECH. \r\n\r\ncc @sftcd, @ekr, @martinthomson, @davidben, @cjpatton ",
      "createdAt": "2021-06-03T20:58:08Z",
      "updatedAt": "2023-10-09T21:39:26Z",
      "closedAt": "2023-10-09T21:39:25Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "As you say, this seems orthogonal to ECH. I suspect anything we do here will want to be separate work, where we can give it the time it deserves. (Should be solvable, but I'd want us to work through the downgrade implications.)",
          "createdAt": "2021-06-03T21:29:57Z",
          "updatedAt": "2021-06-03T21:29:57Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\nHiya,\n\nOn 03/06/2021 22:30, David Benjamin wrote:\n> As you say, this seems orthogonal to ECH. \n\nI'm not so sure. ECH gives the client more information as it\nidentifies a DH group that the frontend implements and that\nthe backend knows about. That allows us to e.g. state that\nif all 3 support key shares with that group then HRR ought\nnot happen. We can also avoid a potential leak if the\nserver-chosen key share group didn't have a key share in the\nouter CH, but only in the inner, e.g. by saying \"don't do\nthat\":-)\n\nI'd also argue that there are some similar statements we\ncould make about potential leaks, e.g. pointing out that if\nthe server-chosen ciphersuite is in both inner and outer CH\nthen we avoid a possible leak.\n\nMaybe a \"footguns to avoid\" section in the spec?\n\n> I suspect anything we do\n> here will want to be separate work, where we can give it the time it\n> deserves. (Should be solvable, but I'd want us to work through the\n> downgrade implications.)\n\nSounds fair. Though I think I'd prefer we (try to) stick to\nguidance and not further complicate SVCB if that's at all\npossible.\n\nCheers,\nS.\n\n> \n",
          "createdAt": "2021-06-03T22:08:44Z",
          "updatedAt": "2021-06-03T22:08:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'm not so sure. ECH gives the client more information as it\r\nidentifies a DH group that the frontend implements and that\r\nthe backend knows about. \r\n\r\nThe HPKE group is not necessarily the same as the TLS group, for better or worse, so it's not clear to me that one can infer the backend supports x25519 _for TLS_ just because the client-facing server supports the x25519-based DHKEM.",
          "createdAt": "2021-06-03T22:10:32Z",
          "updatedAt": "2021-06-03T22:10:32Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 03/06/2021 23:10, Christopher Wood wrote:\n>> I'm not so sure. ECH gives the client more information as it\n> identifies a DH group that the frontend implements and that the\n> backend knows about.\n> \n> The HPKE group is not necessarily the same as the TLS group, for\n> better or worse, so it's not clear to me that one can infer the\n> backend supports x25519 _for TLS_ just because the client-facing\n> server supports the x25519-based DHKEM.\n\nSure. But we can say that if they do all support it, then\nHRR isn't likely (I think), and maybe even RECOMMEND that\nservers try ensure that's the case?\n\nUntil we hit the fun of hybrid PQC stuff, that ought be\nfairly easy for a lot of servers to do, and tooling could\nbe developed to check it works ok, e.g. while setting up\nECH and rolling keys. I'm sure there'd be issues with load\nbalancing and out-of-whack server configs, but we can still\nsay that it's a better setup I hope.\n\nS.\n\n",
          "createdAt": "2021-06-03T22:16:20Z",
          "updatedAt": "2021-06-03T22:16:20Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Indeed our implementation supports a bunch of NIST curves for TLS due to TLS's long legacy, but we have no plans to support them in ECH. We _already_ support a hybrid PQC group in TLS (CECPQ2), but we are not yet putting it in ECH and HPKE. (Someday, maybe, but those keys are kinda big and there are enough problems to solve with ECH as it is.)\r\n\r\nThe configurations also have very different deployment characteristics. ECH groups come from ECH keys, which are long-lived and integrated into a whole key rotation, DNS, and TLS config pipeline. TLS groups can be changed unilaterally be a single server instance with no coordination elsewhere in the fleet. Moreover, in Split Mode ECH, the ECH keys are a property of the client-facing server, while the TLS configuration is a property of the backend server. These two may have nothing to do with each other.\r\n\r\nDivining TLS configuration directly from ECH keys is really a non-starter.",
          "createdAt": "2021-06-03T22:30:42Z",
          "updatedAt": "2021-06-03T22:31:51Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 03/06/2021 23:30, David Benjamin wrote:\n> Divining TLS configuration directly from ECH keys is really a non-starter.\n\nWell, \"divining\" is a slightly pejorative term here though.\n\nI think there are likely to be many setups where its entirely\npractical to ensure the ECH group works for all relevant TLS\nservers and don't see why we ought not recommend that that\nbe done where possible.\n\nI'm sure in the most complex cases of the biggest fleets it's\nharder than for a small hoster, but I'd argue we ought try do\nour best for the latter as well as the former.\n\nS.\n\n",
          "createdAt": "2021-06-03T22:36:13Z",
          "updatedAt": "2021-06-03T22:36:13Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "NSS has a similar to what @davidben describes.  We have no plan to support P-256 in HPKE, for instance.  PQ support is very much TBD as well, but I expect one to move independent of the other.\r\n\r\nThe only option I see here is an extension to ECH configurations that signals group support.  But I mostly don't want to have extensions.  The existing measures we use for avoiding HRR are working and I see no reason to fortify those.",
          "createdAt": "2021-06-03T22:37:27Z",
          "updatedAt": "2021-06-03T22:37:27Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I also do not believe we should do anything as part of ECH, for several\nreasons.\n\nFirst, it's unnecessary to deploy ECH.  Given that we're going to have HRR,\nwe have to bear that design burden anyway.\n\nSecond, it's orthogonal in the sense that one might want to have group\nsignaling w/o ECH, even if you used the same record.\n\nThird, it's not necessarily straightforward to design a mechanism like this\nwithout introducing downgrade attacks. Recall that ECHConfig is not\nauthenticated and so any signal received is untrustworthy. As a concrete\nexample, in the current design, each ECH key is a separate ECHConfig, and\nthe server has no way of knowing the entire set of keys the client saw. So\nwhat happens if the client and server both have the preference order A, B\nfor both ECH and TLS key establishment and the attacker strips A from\nECHConfig. If the client relies on this, you will end up with B, even\nthough TLS 1.3 would normally negotiate A. It's possible you can fix this,\nfor instance by folding the entire set of ECHConfigs into the transcript,\nbut the point here is that this needs real design and analysis, and it\nwould be inappropriate to recommend that clients us ECH as a hint absent\nthat analysis.\n\nAs MT notes, this seems like a natural place for extensions.\n\n-Ekr\n\n\nOn Thu, Jun 3, 2021 at 3:37 PM Martin Thomson ***@***.***>\nwrote:\n\n> NSS has a similar to what @davidben <https://github.com/davidben>\n> describes. We have no plan to support P-256 in HPKE, for instance. PQ\n> support is very much TBD as well, but I expect one to move independent of\n> the other.\n>\n> The only option I see here is an extension to ECH configurations that\n> signals group support. But I mostly don't want to have extensions. The\n> existing measures we use for avoiding HRR are working and I see no reason\n> to fortify those.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/issues/440#issuecomment-854230605>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAIPLII5MBJUEFUGNNK37HLTQ773HANCNFSM46BQDQQA>\n> .\n>\n",
          "createdAt": "2021-06-04T13:07:36Z",
          "updatedAt": "2021-06-04T13:07:36Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks to @davidben's [new draft](https://datatracker.ietf.org/doc/draft-davidben-tls-key-share-prediction/) I think we can safely punt this issue. (Thanks, David!)",
          "createdAt": "2023-10-09T21:39:26Z",
          "updatedAt": "2023-10-09T21:39:26Z"
        }
      ]
    },
    {
      "number": 441,
      "id": "MDU6SXNzdWU5MTA4NTAwNDY=",
      "title": "Reconsider non-HRR ECH acceptance signal",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/441",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "design",
        "parked"
      ],
      "body": "Currently, we reuse some bytes of SH.random to signal ECH acceptance when HRR does not occur. Based on [discussion within the context of the HRR design team](https://github.com/tlswg/draft-ietf-tls-esni/wiki/HRR-Design-Team), it may be fruitful to reconsider where this signal goes. Should it in a cleartext extension? Note that this was previously discussed in the context of the original [trial decryption issue](https://github.com/tlswg/draft-ietf-tls-esni/issues/274). It may be worth revisiting this signal's placement as it pertains to the longterm viability of HRR. \r\n\r\ncc @sftcd, @ekr, @martinthomson, @davidben, @cjpatton ",
      "createdAt": "2021-06-03T21:01:35Z",
      "updatedAt": "2023-11-06T08:54:40Z",
      "closedAt": "2023-11-06T08:54:39Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Trying to align them is attractive for consistency, but I think they're actually doing slightly different things. The HRR and SH flows have a fundamental difference to what kind of \"don't stick out\" goals are feasible. (HRR being some bytes rather than a boolean seems to mostly be an HRR-injection mitigation.)\r\nhttps://github.com/tlswg/draft-ietf-tls-esni/issues/450#issuecomment-859667016\r\n\r\nThough this is unsatisfying and maybe I'm missing a way this difference isn't actually fundamental.",
          "createdAt": "2021-06-11T15:42:49Z",
          "updatedAt": "2021-06-11T15:42:49Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "Making ECH acceptance an extension instead of SH.random seems like a good idea if it'll reduce the likelihood of issues with HRR.\r\n\r\n> passively inferring whether a server is capable of ECH. (Note that whether or not a server is capable of ECH depends on the attacker\u2019s ability to actively probe, and active attackers are consistent with the ECH threat model.)\r\n\r\nI don't think this is a big deal since an attacker can always just try to get the HTTPS RR from DNS to see if the server supports ECH. It's not passive, but it's easy.",
          "createdAt": "2021-06-22T01:00:24Z",
          "updatedAt": "2021-06-22T01:00:24Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this is a question we might try to answer in the initial deployment. Something browsers might consider doing is exercise the ECH codepoint in the server's response by triggering HRR in the inner handshake for some fraction of connection attempts. If these handshake fail at a significantly higher rate then other handshakes, then we know we might have a problem.",
          "createdAt": "2021-06-22T14:52:23Z",
          "updatedAt": "2021-06-22T14:52:23Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "When I raised this, my reasoning here was about 70% aesthetic and 30% practical. The practical side is that if we always use an extension than it lowers the risk of ossification due to a \"Does SH have an ECH extension\" filtering. In particular, it seems dangerous to have only SH have the SH.Random hack as we may then discover HRR is broken.",
          "createdAt": "2021-07-02T20:58:50Z",
          "updatedAt": "2021-07-02T20:58:50Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think we should make this change. I don't buy it will decrease the likelihood of issues with HRR. Rather, it seems it will increase the likelihood of issues with ECH as a whole.\r\n\r\nThere are already a lot of TLS 1.3 servers out there, and none of them send ECH extensions in SH. While those servers can and perhaps will eventually be updated, compatibility for _particular_[*], defined extensions is an early stage risk. Once an extension is wildly deployed, it's already part of selection pressures. Servers may deploy this greasing mechanism faster than ECH itself, but it's an added risk and inefficiency.\r\n\r\nFor HRR, we're stuck with that risk (and more, because HRR greasing isn't as effective, per https://github.com/tlswg/draft-ietf-tls-esni/issues/450#issuecomment-859667016). For SH, we're not. It doesn't make sense to intentionally take on more risk on SH when it doesn't affect the HRR risk. The incentives are also different here because HRR is so rare.\r\n\r\nIn particular, if we're worried about the ecosystem allowing ECH + SH, but not ECH + HRR, using the same mechanism won't help. SH and HRR extensions do not use the same syntax, so whether an ecosystem tolerates an extension SH has no relation to whether it tolerates it in HRR. We need to counter the fact that HRR is rare, with strategies like https://crbug.com/677254 (which we have not implemented).\r\n\r\nI agree that, aesthetically, the difference is weird. But, I think, practically, the current arrangement is better.\r\n\r\n[*] If we're worried about the ecosystem tolerating unknown extensions, we need something like https://mailarchive.ietf.org/arch/msg/tls/Yl1IUMwkNlJmB9wldkRJy9Mr2Do/",
          "createdAt": "2021-07-13T17:29:39Z",
          "updatedAt": "2021-07-13T17:30:26Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm with @davidben on this.  I can greatly discount the contribution of aesthetics here, leaving very little reason to change and some good reasons not to change forming the bulk of the balance.",
          "createdAt": "2021-07-14T00:37:54Z",
          "updatedAt": "2021-07-14T00:37:54Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I can live with this outcome.",
          "createdAt": "2023-11-06T06:52:17Z",
          "updatedAt": "2023-11-06T06:52:17Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing per discussion at IETF 118.",
          "createdAt": "2023-11-06T08:54:40Z",
          "updatedAt": "2023-11-06T08:54:40Z"
        }
      ]
    },
    {
      "number": 448,
      "id": "MDU6SXNzdWU5MTM3NzQ3MzE=",
      "title": "Acceptance signal may not be pseudorandom",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/448",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "We currently use the all-zero string as the PRK input of KDF-Expand-Label(). This usage of this function isn't generically safe, as PRK is required to be pseudorandom (see RFC5869). In particular, although the transcript contains a pseudorandom string  (ClientHelloInner.random), passing the hash of the transcript as the info string may not be sufficient to guarantee that the output OKM is pseudorandom (or even unpredictable).",
      "createdAt": "2021-06-07T17:15:41Z",
      "updatedAt": "2021-06-11T22:23:26Z",
      "closedAt": "2021-06-11T22:23:26Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Here's the change that I think is appropriate: #449. Note that this matches what we had in draft-08.",
          "createdAt": "2021-06-07T17:17:40Z",
          "updatedAt": "2021-06-07T17:17:40Z"
        }
      ]
    },
    {
      "number": 450,
      "id": "MDU6SXNzdWU5MTM4MDcyNzg=",
      "title": "Grease HRR acceptance signal?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/450",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "parked"
      ],
      "body": "With #423 we will send an explicit signal of whether ECH was accepted prior to HRR. The mechanism for this is an ECH extension sent by the backend server that contains a pseudorandom string derived from the inner handshake. We need to decide if/how to grease this extension.",
      "createdAt": "2021-06-07T17:57:48Z",
      "updatedAt": "2023-11-06T08:54:51Z",
      "closedAt": "2023-11-06T08:54:51Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "One way is to say:\r\n\r\n* If the ECH client sees an HRR ECH extension whose value is wrong (or, if ECH GREASE, all values are wrong), ignore it. This was an ECH reject. Don't update the ECH extension, and handshake with ClientHelloOuter.\r\n* If a backend server sees a ClientHelloOuter (i.e. has encrypted_client_hello extension pre #422 and has an encrypted_client_hello with type=outer post #422), it sticks a random string into HRR.\r\n\r\nEdit: Actually, \"Don't update the ECH extension\" probably doesn't work. I think you do need to perturb the ECH extension.",
          "createdAt": "2021-06-08T18:11:52Z",
          "updatedAt": "2021-06-11T15:32:01Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Should the client-facing server grease this as well?",
          "createdAt": "2021-06-08T20:09:42Z",
          "updatedAt": "2021-06-08T20:09:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Should the client-facing server grease this as well?\r\n\r\nIf we go with #441, then we probably should for parity. ",
          "createdAt": "2021-06-08T20:28:18Z",
          "updatedAt": "2021-06-08T20:28:18Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Er, right, I always forget whether our phrasing believes it's the backend or client-facing server responding on ECH reject.\r\n\r\nIn order for ECH GREASE to work, we need ClientHelloOuter(ech=undecryptable, server_name=A) and ClientHelloOuter(ech=ClientHelloInner(server_name=A)) to result in equivalent handshakes. We could formulate that by saying the client-facing server is purely a ClientHello dispatcher and, reject or accept, it's a backend server you're talking to. Or we could say that, in ECH reject, you're talking to the client-facing server and we assume client-facing server and backend server respond equivalently to server_name=A. If it's the latter then, yeah, this should apply to the client-facing server as well.",
          "createdAt": "2021-06-08T21:13:02Z",
          "updatedAt": "2021-06-08T21:13:02Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\nHiya,\n\nOn 08/06/2021 22:13, David Benjamin wrote:\n> Er, right, I always forget whether our phrasing believes it's the\n> backend or client-facing server responding on ECH reject.\n> \n> In order for ECH GREASE to work, we need\n> ClientHelloOuter(ech=undecryptable, server_name=A) and\n> ClientHelloOuter(ech=ClientHelloInner(server_name=A)) to result in\n> equivalent handshakes. We could formulate that by saying the\n> client-facing server is purely a ClientHello dispatcher and, reject\n> or accept, it's a backend server you're talking to. Or we could say\n> that, in ECH reject, you're talking to the client-facing server and\n> we assume client-facing server and backend server respond\n> equivalently to server_name=A. If it's the latter then, yeah, this\n> should apply to the client-facing server as well.\n\nI'm not claiming to know the right answer here but I've\nstarted to look at haproxy and split-mode. IIUC (and I\nmay not) haproxy doesn't want to act as an http server\nin any case, so no DocRoot nor any equivalent. (It can\nterminate TLS of course but I don't think it ever emits\nan HTTP response of it's own creation.)\n\nThat may mean, in the event of failed ECH decryption,\n(incl. GREASE) or when no ECH key pair is configured\nit may make more sense for haproxy to pass on the outer\nCH to what it calls a \"backend\" which is an http server.\n\nLike I say, this is v. preliminary and maybe wrong but\nat least for me, I'd not previously considered that the\nclient-facing server might not be an http server at all.\n\nPut another way - it could be the thing with the ECH\nprivate key is not the thing with the private key that\ngoes with ECH.public_name.\n\nIOW, I think the kind of description suggested by\nDavid might be a good direction to explore a bit.\n\nCheers,\nS.\n\n\n> \n",
          "createdAt": "2021-06-08T21:27:34Z",
          "updatedAt": "2021-06-08T21:27:34Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> Don't update the ECH extension\r\n\r\nSorry, this part of my suggestion above doesn't work. I think you need the client to refresh it, otherwise you determine if ECH was accepted just by looking at whether the client changed the extension.\r\n\r\nThat said, GREASEing this may not be all that useful. It's not too difficult to tell if a server that sent HRR did so with ECH or not, if you're willing to probe the server's behavior on a parallel connection. First, there's this pretty straightforward version:\r\n\r\n1. Observe ClientHello and HelloRetryRequest pair from a client and server. Note this only happens if the (client, server) pair would naturally negotiate HRR.\r\n2. Replay ClientHello to that server on a separate connection. You should get HelloRetryRequest with the same parameters because the server's parameter selection is deterministic. (Let's suppose the server did not need to sporadically request a cookie.)\r\n3. See if HelloRetryRequest.ech contained the exact same bytes or not.\r\n\r\nHRR contains no server entropy, replaying an ECH ClientHello will give you something consistent, while a naive GREASED implementation will give you different values. We could fix this in one of two ways:\r\n\r\n* HRR GREASE should, instead of random bytes, do something deterministic like KDF(server_secret, client_hello), or\r\n* Change ECH confirmation to be a concatenation of some server entropy and the signal computed over the entropy.\r\n\r\nBut, for that fuss, it doesn't plug the more fundamental distinguisher, which is probably hopeless:\r\n\r\n1. Observe ClientHello and HelloRetryRequest pair from a client and server again.\r\n2. Replay ClientHello to that server on a separate connection. You should get HelloRetryRequest with the same parameters again.\r\n3. Second a second ClientHello with a plausible ClientHelloOuter2 and random bytes for the encrypted payload.\r\n4. If the server accepted ECH, it will attempt to decrypt the random bytes, fail, and abort the connection. If the server rejected ECH, it will ignore the payload and handshake with ClientHelloOuter2.\r\n\r\nThis one seems pretty much fundamental. Deciding ECH at ServerHello sets up handshake secrets at the same time. But deciding ECH at HRR means the server has committed to looking at ClientHelloOuter vs. ClientHelloInner too early. (This is true whether we have an acceptance signal at the client or not. Even in the \"apply HRR to both ClientHellos\" model, the server has already made a decision, because it needed to in order to decide on HRR at all. That model just had the client learn the decision late.)",
          "createdAt": "2021-06-11T15:38:33Z",
          "updatedAt": "2021-06-11T15:38:33Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "> Er, right, I always forget whether our phrasing believes it's the backend or client-facing server responding on ECH reject.\r\n\r\n> In order for ECH GREASE to work, we need ClientHelloOuter(ech=undecryptable, server_name=A) and ClientHelloOuter(ech=ClientHelloInner(server_name=A)) to result in equivalent handshakes. We could formulate that by saying the client-facing server is purely a ClientHello dispatcher and, reject or accept, it's a backend server you're talking to. Or we could say that, in ECH reject, you're talking to the client-facing server and we assume client-facing server and backend server respond equivalently to server_name=A. If it's the latter then, yeah, this should apply to the client-facing server as well.\r\n\r\nIt only makes sense to me for the client-facing server to be responding on ECH reject. If ECH is rejected, how can it even be expected to know what backend server the client is trying to talk to?",
          "createdAt": "2021-06-21T21:52:56Z",
          "updatedAt": "2021-06-21T21:52:56Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "I think not sticking out is a lost cause (and adds too much complexity), so I don't think it matters whether any GREASE-ing is deterministic or random.",
          "createdAt": "2021-06-22T00:46:12Z",
          "updatedAt": "2021-06-22T00:47:04Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> It only makes sense to me for the client-facing server to be responding on ECH reject. If ECH is rejected, how can it even be expected to know what backend server the client is trying to talk to?\r\n\r\nThe outer ClientHello contains a server name. If you believe the client-facing server is just a dispatcher, then maybe you just dispatch. In particular, if `example.com`'s DNS points to some IP address A and ECH keys, a client that didn't support that ECH cipher, didn't support ECH, or otherwise couldn't get the DNS record would connect to A without offering ECH. But it may still send ECH GREASE, trigger the client-facing server logic, and hit the decryption failure case to handshake ClientHelloOuter.\r\n\r\nAlthough arguably this is already covered by the existing text:\r\n\r\n> Otherwise, if all candidate ECHConfig values fail to decrypt the extension, the client-facing server MUST ignore the extension and proceed with the connection using ClientHelloOuter. This connection proceeds as usual, except [...]\r\n\r\nhttps://tlswg.org/draft-ietf-tls-esni/draft-ietf-tls-esni.html#section-7.1-12\r\n\r\nPresumably for most deployments, \"as usual\" would cover whatever name-based dispatch it's happy to do on ClientHelloOuter.\r\n\r\n> I think not sticking out is a lost cause (and adds too much complexity), so I don't think it matters whether any GREASE-ing is deterministic or random.\r\n\r\nI think I agree that HRR sticking out is hopeless. But then why even bother GREASE-ing here?",
          "createdAt": "2021-06-23T20:09:58Z",
          "updatedAt": "2021-06-23T20:09:58Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think I agree that HRR sticking out is hopeless. But then why even bother GREASE-ing here?\r\n\r\nThe usual reason: to prevent the ossification of middleboxes.",
          "createdAt": "2021-06-24T21:35:56Z",
          "updatedAt": "2021-06-24T21:35:56Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "> Presumably for most deployments, \"as usual\" would cover whatever name-based dispatch it's happy to do on ClientHelloOuter.\r\n\r\nAh, right. It's the back-end server then (unless the client-facing server has the name in the CHO, but then you could consider the client-facing server to also be playing the role of a backend server).",
          "createdAt": "2021-06-24T22:09:16Z",
          "updatedAt": "2021-06-24T22:09:16Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I thought we had generally agreed that:\r\n\r\n(1) We weren't going to worry about parallel connections\r\n\r\n```\r\n   achieve stronger security where possible.  Minimally, real ECH is\r\n   designed to be indifferentiable from GREASE ECH for passive\r\n   adversaries with following capabilities: 1.  The attacker does not\r\n   know the ECHConfigList used by the server. 1.  The attacker keeps\r\n   per-connection state only.  In particular, it does not track\r\n   endpoints across connections. 1.  ECH and GREASE ECH are designed so\r\n   that the following features do not vary: the code points of\r\n   extensions negotiated in the clear; the length of messages; and the\r\n   values of plaintext alert messages.\r\n```\r\n(2) We probably couldn't really provide HRR greasing that would work against someone willing to introspect into the connection.\r\n\r\nThis reasoning is how we got to the extension. I think if we *are* going to do the extension, we probably should have the client-facing server grease to avoid people just filtering connections with ECH in the HRR. But I don't think it has to be very good given the above threat model.\r\n\r\n",
          "createdAt": "2021-07-02T20:56:38Z",
          "updatedAt": "2021-07-02T20:56:38Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing per discussion at IETF 118.",
          "createdAt": "2023-11-06T08:54:51Z",
          "updatedAt": "2023-11-06T08:54:51Z"
        }
      ]
    },
    {
      "number": 451,
      "id": "MDU6SXNzdWU5MTM4NjEwMzI=",
      "title": "Reserve some code points for GREASE",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/451",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "pre-wglc"
      ],
      "body": "We should reserve a few extension and ECH version code points for GREASE (perhaps just the same ?a?a pattern). The reserved non-mandatory code points can just be included in valid ECHConfigs, to ensure clients ignore them. The mandatory ones and the reserved versions can be included in ECHConfigLists, to ensure clients can skip over them.",
      "createdAt": "2021-06-07T18:50:42Z",
      "updatedAt": "2023-10-18T14:28:18Z",
      "closedAt": "2023-10-18T14:28:18Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@davidben, would you mind preparing a PR for this?",
          "createdAt": "2023-10-09T22:47:47Z",
          "updatedAt": "2023-10-09T22:47:47Z"
        }
      ]
    },
    {
      "number": 453,
      "id": "MDU6SXNzdWU5MTU2Mzg5Nzc=",
      "title": "Provide a link to this repo in the draft",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/453",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "There's a trick that might help here:\r\n\r\n```\r\nmake -f lib/setup.mk .note.xml\r\n# check .note.xml\r\ngit add .note.xml\r\n```",
      "createdAt": "2021-06-08T23:33:51Z",
      "updatedAt": "2021-06-11T22:22:40Z",
      "closedAt": "2021-06-11T22:22:39Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed directly on the main branch. Closing.",
          "createdAt": "2021-06-11T22:22:39Z",
          "updatedAt": "2021-06-11T22:22:39Z"
        }
      ]
    },
    {
      "number": 454,
      "id": "MDU6SXNzdWU5MTU2NDAxOTk=",
      "title": "Make the definition of key protocol elements easier to find",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/454",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "It took me AGES just now to find where ech_outer_extensions was defined.\r\n\r\nThe table of contents should be useful for finding important things like what to do (the current structure works OK for this, though it might be better) and to learn what the format and semantics of protocol elements is.\r\n\r\nA careful reorganization of content is probably well overdue.",
      "createdAt": "2021-06-08T23:36:55Z",
      "updatedAt": "2023-10-09T22:41:34Z",
      "closedAt": "2023-10-09T22:41:34Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson the document underwent significant refactoring for linear flow with references for improved readability. I'm going to close this issue with the understanding that if there are still significant editorial changes we think need to be made, they can be surfaced during WGLC (and fixed as part of processing that WGLC feedback).",
          "createdAt": "2023-10-09T22:41:34Z",
          "updatedAt": "2023-10-09T22:41:34Z"
        }
      ]
    },
    {
      "number": 463,
      "id": "MDU6SXNzdWU5Mjc1NzI1NjQ=",
      "title": "Changes for draft-12 (was \"Value of ECHConfig.version in draft-11?\")",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/463",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "ECHConfig is defined as\r\n\r\n> ```\r\n>       struct {\r\n>           uint16 version;\r\n>           uint16 length;\r\n>           select (ECHConfig.version) {\r\n>             case 0xfe0a: ECHConfigContents contents;\r\n>           }\r\n>       } ECHConfig;\r\n> ```\r\n\r\nbut the text below it says\r\n\r\n>   Beginning with draft-08, the version is the same as the code point\r\n>    for the \"encrypted_client_hello\" extension.  Clients MUST ignore\r\n>    any \"ECHConfig\" structure with a version they do not support.\r\n\r\nThe intention was to bump ECHConfig.version from 0xfe0a to 0xfe0b for draft-11, but this got missed by https://github.com/tlswg/draft-ietf-tls-esni/pull/458. (I wrote the PR, so I apologize for my part in missing this.) How do folks think we should resolve this? Do we need to cut a new draft with the ambiguity fixed?",
      "createdAt": "2021-06-22T19:39:27Z",
      "updatedAt": "2021-06-28T23:50:19Z",
      "closedAt": "2021-06-28T23:50:18Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh whoops, nice catch! Using `0xfe0a` definitely won't work since the format and corresponding ClientECH extension has changed. I suppose all the implementors could just agree to mentally fix this typo when reading the draft, but may as well cut draft-12. Draft numbers are cheap.",
          "createdAt": "2021-06-22T19:43:41Z",
          "updatedAt": "2021-06-22T19:43:41Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We could try to pick up some editorial changes, too, like those suggested in #454.",
          "createdAt": "2021-06-22T19:46:15Z",
          "updatedAt": "2021-06-22T19:46:15Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd also personally be pretty happy to have #443 in there, but also fine to skip it for what's supposed to be a small bugfix draft snapshot.",
          "createdAt": "2021-06-22T19:50:43Z",
          "updatedAt": "2021-06-22T19:50:43Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 22/06/2021 20:43, David Benjamin wrote:\n> Oh whoops, nice catch! Using `0xfe0a` definitely won't work since the\n> format and corresponding ClientECH extension has changed. I suppose\n> all the implementors could just agree to mentally fix this typo when\n> reading the draft, but may as well cut draft-12. Draft numbers are\n> cheap.\n\n+1\n\nI've not checked recent editorial changes but they're\nprobably fine too.\n\nS\n\n> \n",
          "createdAt": "2021-06-22T19:59:21Z",
          "updatedAt": "2021-06-22T19:59:21Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd be happy to take #443 in draft-12 as well, though I'm inclined to think this should strictly be a bugfix/editorial draft. I'd say let's wait until Chris W. gets off back from PTO and let him make the call. Unless we're in a hurry, in which case we could ping one of the other authors to merge our changes and cut a draft.\r\n",
          "createdAt": "2021-06-22T20:33:07Z",
          "updatedAt": "2021-06-22T21:31:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as resolved.",
          "createdAt": "2021-06-28T23:50:18Z",
          "updatedAt": "2021-06-28T23:50:18Z"
        }
      ]
    },
    {
      "number": 466,
      "id": "MDU6SXNzdWU5Mjg2MDA1NjQ=",
      "title": "Client behavior if the HRR signal is wrong",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/466",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "{{client-hrr}} says the client assumes ECH was accepted if the signal matches, but it doesn't say what to do if the signal doesn't match. Is it an error, or do you ignore it?\r\n\r\nRelated to #450, though whether we decide to do that, we need to write down *something* in the meantime.",
      "createdAt": "2021-06-23T20:10:27Z",
      "updatedAt": "2021-07-07T19:59:40Z",
      "closedAt": "2021-07-07T19:59:40Z",
      "comments": [
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "Seems reasonable to presume rejection, as if the extension weren't present at all, particularly if we end up GREASEing the extension.",
          "createdAt": "2021-06-25T00:17:37Z",
          "updatedAt": "2021-06-25T00:17:37Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Right now the server's not supposed to send it at all. Normally if the peer sends invalid things, we make it an error. But, yeah, allowing it and presuming rejection is plausible when we GREASE it. But that's not currently in the draft, and I'm not sure how coherent GREASEing it actually is. Right now, draft-11 as currently published is ambiguous, which makes implementing it hard.",
          "createdAt": "2021-06-25T20:50:09Z",
          "updatedAt": "2021-06-25T20:50:09Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree we need to say something here. The way I interpreted it in my implementation is: presume ECH acceptance if the ECH extension is present and its payload matches the acceptance signal; otherwise, presume rejection. I think we should try to spell this behavior in a way that make sense.",
          "createdAt": "2021-06-25T21:31:57Z",
          "updatedAt": "2021-06-25T21:31:57Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 to assuming rejection, since this is exactly what we do in the non HRR case. @davidben, will you be able to prep a PR for this today? We can include this clarification in -12. (Clarifying that clients should abort if the extension contents are malformed, e.g., of the wrong length, seems fine. But if the signal doesn't match, then I think we should just assume rejection, since that would admit greasing the signal.)",
          "createdAt": "2021-06-28T15:32:51Z",
          "updatedAt": "2021-06-28T15:36:01Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry, was OOO yesterday and today was weekend email catchup. I might have time tomorrow?\r\n\r\nAlright, sounds like everyone else prefers presuming rejection, so presuming rejection it is. :-) I feel weird doing that in advance of thinking about GREASE, but I guess folks want to do that too, so okay.",
          "createdAt": "2021-06-29T20:56:00Z",
          "updatedAt": "2021-06-29T20:56:24Z"
        }
      ]
    },
    {
      "number": 474,
      "id": "MDU6SXNzdWU5NDQyMzUzMTE=",
      "title": "Clarification of section 8.2. Middleboxes",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/474",
      "state": "CLOSED",
      "author": "mosterdt",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hello,\r\n\r\nWhile reading this specification, section 8.2. states that \"MITM proxies\" are required to remove any extensions they do not understand. \r\n\r\n> A more serious problem is MITM proxies which do not support this\r\n   extension.  [RFC8446], Section 9.3 requires that such proxies remove\r\n   any extensions they do not understand.  The handshake will then\r\n   present a certificate based on the public name, without echoing the\r\n   \"encrypted_client_hello\" extension to the client.\r\n\r\nHowever, looking at RFC 8446 Section 9.3, the first section you encounter on forwarding middleboxes explicitly states the opposite: the middlebox is not allowed to change or modify any parameters in the handshake and subsequent traffic if it doesn't understand some parameter in the ClientHello:\r\n\r\n> A middlebox which forwards ClientHello parameters it does not\r\n   understand MUST NOT process any messages beyond that ClientHello.\r\n   It MUST forward all subsequent traffic unmodified.  Otherwise, it\r\n   may fail to interoperate with newer clients and servers.\r\n\r\nReading further, we find the bullet point the warning in section 8.2 refers to:\r\n\r\n> A middlebox which terminates a TLS connection MUST behave as a\r\n   compliant TLS server (to the original client), including having a\r\n   certificate which the client is willing to accept, and also as a\r\n   compliant TLS client (to the original server), including verifying\r\n   the original server's certificate.  In particular, it MUST\r\n   generate its own ClientHello containing only parameters it\r\n   understands, and it MUST generate a fresh ServerHello random\r\n   value, rather than forwarding the endpoint's value.\r\n\r\nHere, the middlebox isn't so much required to \"remove any extension they do not understand\", but to \"generate its own ClientHello containing only parameters it understands\". After carefully reading over these sections multiple times, I do get the message, but I feel like it could be better worded as not to create confusion. The words \"MITM proxy\" could refer to the forwarding middlebox as well. Changing the wording in, for example, the following way makes the reference more clear in my opinion:\r\n\r\n> A more serious problem is MITM proxies which do not support this\r\nextension.  [RFC8446], Section 9.3 requires that such proxies generate\r\ntheir own ClientHello containing only parameters they understand. The\r\nmiddlebox will then present a certificate based on the public name to\r\nthe client, without echoing the \"encrypted_client_hello\" extension.\r\n\r\nWhat do you think about this?",
      "createdAt": "2021-07-14T09:34:15Z",
      "updatedAt": "2021-07-26T21:02:04Z",
      "closedAt": "2021-07-26T21:02:04Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> While reading this specification, section 8.2. states that \"MITM proxies\" are required to remove any extensions they do not understand.\r\n\r\nYes. Or, more accurately, it's required to send a ClientHello only containing things it supports. Whether it choses to base its capabilities on the original ClientHello is its business. Though, of course, there are security implications for either option and more reason why MITM proxies are a terrible idea.\r\n\r\nEither way, if you are a MITM proxy, you are terminating TLS, which means there are two TLS handshakes and, in one of them, you are a client. When acting as a client, you cannot send things you don't understand. Otherwise the server will respond in a way that confuses you.\r\n\r\n> However, looking at RFC 8446 Section 9.3, the first section you encounter on forwarding middleboxes explicitly states the opposite: the middlebox is not allowed to change or modify any parameters in the handshake and subsequent traffic if it doesn't understand some parameter in the ClientHello:\r\n\r\nRFC 8446 does not discuss \"forwarding middleboxes\" at all. That section talks about a \"middlebox which forwards ClientHello parameters _it does not understand_\". Any middlebox that does this cannot terminate TLS in the first place (i.e. not a MITM proxy) because anyone terminating TLS is limited to only sending things it understands.\r\n\r\nRather, this section is talking about non-terminating proxies that attempt to inspect the cleartext portions of TLS anyway. We ran into quite a lot of those in the process of deploying TLS 1.3 and most of them were broken. This text clarifies that TLS promises no continuity of syntax after the ClientHello. A non-terminating proxy gets to assume it can parse the ClientHello and nothing else.\r\n\r\n> The words \"MITM proxy\" could refer to the forwarding middlebox as well. \r\n\r\nSee above. If you're forwarding things you understand, you cannot terminate TLS. The section doesn't apply to what this draft refers to as \"MITM proxy\" at all. (Well, there are some weird things that try to selectively proxy TLS. There are [quite a lot of problems](https://www.imperialviolet.org/2018/03/10/tls13.html) with this approach, but in that case which rules apply depends on which choice the proxy made. Additionally, the proxy cannot violate the forwarding middlebox rule in the process of making the decision. This basically boils down to saying you cannot make your decision based on anything after the ClientHello because, after that point, you cannot parse anything.)\r\n\r\nProbably we should change this draft to match RFC 8446 in terminology and replace \"MITM proxies\" with \"TLS-terminating proxies\".\r\n\r\n> Section 9.3 requires that such proxies generate their own ClientHello containing only parameters they understand.\r\n\r\nYeah, I think that change is a good one.",
          "createdAt": "2021-07-14T14:55:58Z",
          "updatedAt": "2021-07-14T14:55:58Z"
        },
        {
          "author": "mosterdt",
          "authorAssociation": "NONE",
          "body": "Thank you for your detailed reply. I do understand the reasons for being this strict about middlebox behaviour. I certainly don't think there is anything wrong. It's just that the terminology is somewhat confusing. After careful reading, it's indeed clear that the section on non-terminating proxies is not really relevant for ESNI, but due to the wording used in this RFC, it looks at first glance that 8.2 is referring to that section:\r\n> Section 9.3 requires that such proxies remove any extensions they do not understand\r\n\r\nvs\r\n\r\n> A middlebox which forwards ClientHello parameters it does not understand MUST NOT process any messages beyond that ClientHello.\r\n\r\nIt's a small detail, and not really that important. But I think it would make it more clear if the wording is changed slightly. I do like \"TLS-terminating proxies\" as well. Thanks for the hard work!",
          "createdAt": "2021-07-15T08:07:44Z",
          "updatedAt": "2021-07-15T08:07:44Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "How does https://github.com/tlswg/draft-ietf-tls-esni/pull/475 look?",
          "createdAt": "2021-07-15T16:29:12Z",
          "updatedAt": "2021-07-15T16:29:12Z"
        },
        {
          "author": "mosterdt",
          "authorAssociation": "NONE",
          "body": "Looks good to me! Thank you for taking the time to look at this.\n\nOn Thu, 15 Jul 2021, 18:29 David Benjamin, ***@***.***> wrote:\n\n> How does #475 <https://github.com/tlswg/draft-ietf-tls-esni/pull/475>\n> look?\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/issues/474#issuecomment-880842255>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/ACE3QJM22SXAMILF4TG5C5TTX4EGHANCNFSM5ALCNE2Q>\n> .\n>\n",
          "createdAt": "2021-07-15T21:30:47Z",
          "updatedAt": "2021-07-15T21:30:47Z"
        }
      ]
    },
    {
      "number": 476,
      "id": "MDU6SXNzdWU5NTAyMzU2OTQ=",
      "title": "Feature Request: `ECHConfigList.permit_plaintext`",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/476",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "parked"
      ],
      "body": "@davidben \r\n\r\nCurrently, if all the `ECHConfig`s in the `ECHConfigList` are rejected by the client, the client always falls back to sending the ClientHello in plaintext.  This is normally appropriate, but it may not always be.  Once ECH is well-established, secretive servers may prefer for clients to fail the connection rather than revealing the server's SNI by connecting without ECH, especially if the server only accepts ECH ClientHellos.\r\n\r\nUnfortunately, an `ECHConfig` extension cannot be used to express this preference, because extensions are scoped to a specific `ECHConfig`, and we are discussing the case where all `ECHConfig`s have been rejected.\r\n\r\nA boolean field in `ECHConfigList` (e.g. `permit_plaintext`, `ech_only`) would be sufficient to encode this instruction.",
      "createdAt": "2021-07-22T01:59:52Z",
      "updatedAt": "2023-10-09T21:38:10Z",
      "closedAt": "2023-10-09T21:38:10Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Is this better as an ECH extension, or as a separate SVCB extension (for example)?  That would allow the assertion to apply more broadly.  If you could put that on an AliasMode record, that might have interesting applications.",
          "createdAt": "2021-07-22T04:09:34Z",
          "updatedAt": "2021-07-22T04:09:34Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is something we should defer. As @martinthomson says, we can still do this as a SVCB extension if needed. I expect we can also manage an `ECHConfig` extension by tweaking the `ECHConfigList` rules slightly, even if it's a bit janky.\r\n\r\nIndeed, the case where all `ECHConfig`s are rejected is another reason to defer it. Every draft protocol is doomed to die, which means that no server can, right now, produce a stable ECH deployment. They are guaranteed that some future ECH-capable clients will reject their `ECHConfigList`.\r\n\r\nAnd from the client's perspective, I would be very uncomfortable implementing this mechanism before we understand a bit better how ECH works in practice. How likely are rollbacks? How stale of DNS do we see in practice? How much of a concern are users who switch back and forth from a TLS-terminating middlebox, with all the problems that comes with?\r\n\r\nFinally, is changing the outer `ECHConfigList` structure even an option at this point? Didn't you all have a lot of troubles with renaming the SvcParam, and that didn't even affect the wire format? Changing `ECHConfigList` would _actually_ be a wire-format change. (If changing that is on the table, I kinda regret the two-byte length prefix in front...)",
          "createdAt": "2021-07-22T06:35:28Z",
          "updatedAt": "2021-07-22T06:36:24Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 22/07/2021 07:35, David Benjamin wrote:\n> I think this is something we should defer.\n\n+1\n\nI wonder would it be useful to see if the TLS WG\nhad consensus on something like \"no more changes\nfor ECH for now, (except security fixes if needed)\"\nmaybe with an additional \"the WG will revisit ECH\na year or so after publication-requested to see\nwhat changes based on deployment experience might\nbe good\"\n\nS.\n\n",
          "createdAt": "2021-07-22T10:02:40Z",
          "updatedAt": "2021-07-22T10:02:40Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "To add to the chorus above, this can be dealt with via an extension. Please propose it via a new draft! I'm closing this based on that recommendation.",
          "createdAt": "2023-10-09T21:38:10Z",
          "updatedAt": "2023-10-09T21:38:10Z"
        }
      ]
    },
    {
      "number": 512,
      "id": "MDU6SXNzdWU5NjIyNzgzMTQ=",
      "title": "Lessen possibility of client implementation choices undermining GREASE cover",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/512",
      "state": "CLOSED",
      "author": "pkelsey",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "parked"
      ],
      "body": "Section 10.9.4 (Do Not Stick Out) indicates plans \"to deploy GREASE ECH widely enough to disincentivize differential treatment of the real ECH protocol by the network\".  This implies that successfully bootstrapping ECH deployment will necessarily involve significant amounts of GREASE ECH from TLS stacks being operated in a GREASE-only mode, driven by applications that do not have a concept of how they'd configure real ECH.\r\n\r\nGuidance on the construction of GREASE ECH is given in Section 6.2, and it involves selecting the length of the payload field based on \"the size of the EncodedClientHelloInner the client would compute when offering ECH\".  What is the length that the client might compute when offering (real) ECH for clients that may have no sophisticated notion of offering real ECH?  It seems there is plenty of room for implementations to arise which generate GREASE payload lengths that are susceptible to effective differentiation by heuristics simple enough to be within reach of the very lazy attacker of 10.9.4.  Perhaps such implementations use a fixed size 'prototype ClientHello' concept, or use something highly self-similar (e.g., verbatim non-ECH ClientHello contents), or [insert other debacle].  Absent additional guardrails for GREASE ECH construction, there appears to be a risk that knowledge of the extant implementations may be sufficient to provide differentiation capabilities to an attacker who employs only single-connection passive traffic analysis.",
      "createdAt": "2021-08-05T23:54:33Z",
      "updatedAt": "2023-10-13T23:15:27Z",
      "closedAt": "2023-10-13T23:15:26Z",
      "comments": [
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure what additional guardrails would suffice for a client who is already content to ignore the current guidance on constructing ECH GREASE.",
          "createdAt": "2021-08-06T03:41:58Z",
          "updatedAt": "2021-08-06T03:41:58Z"
        },
        {
          "author": "pkelsey",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The concern is not so much about clients that are ignoring the current GREASE construction guidance, but rather about the potential for clients following that guidance to wind up filling in the blanks that exist in the absence of a real ECH context in such a way that it becomes a GREASE fingerprint.\r\n\r\nOne thing that falls under this topic that isn't specifically extra guidance on GREASE construction would be requiring that when the client includes the encrypted_client_hello extension, it is placed last in the ClientHelloOuter extensions list.  Doing so provides maximum ambiguity of reference for potential use of ech_outer_extensions in the EncodedClientHelloInner, which in turn prevents emergence of a future GREASE fingerprint based on the appearance of GREASE ECH earlier in the ClientHelloOuter extensions list than extensions that become commonly referenced by ech_outer_extensions in real ECH.",
          "createdAt": "2022-11-09T03:53:50Z",
          "updatedAt": "2022-11-09T03:53:50Z"
        }
      ]
    },
    {
      "number": 513,
      "id": "MDU6SXNzdWU5NjI5Njc5OTE=",
      "title": "Split mode correlation attacks",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/513",
      "state": "CLOSED",
      "author": "pkelsey",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "(Originating at #509)\r\n\r\nThere appears to be nothing in the document concerning an attacker with a presence on both side of the client-facing server in split mode defeating ECH privacy by correlating connections across the client-facing server.\r\n\r\nConsider an attacker present on both sides of a client-facing server whose goal is to uncover which backend server(s) specific ECH-using clients are accessing.  By virtue of its position in the network, this attacker:\r\n\r\n1. Can, through passive observation of the traffic on the client side of the client-facing server, maintain a list of ECH connections initiated by each client identity of interest to the client-facing server (client identity based on the available information: transport addressing, ClientHelloOuter parameters that are in the plain, protocol timing...).\r\n2. Can, through passive observation of the traffic on the backend-server side of the client-facing server, maintain a list of ECH connections initiated from the client-facing server to the backend servers along with their corresponding SNI values, as at this point ClientHello is ClientHelloInner in the plain. \r\n3. Can uncover the SNI value being used by a particular client connection in list (1) if it can match it to its corresponding connection in list (2).\r\n4. Does not necessarily have to perform this matching in any particular temporal relation to the evolution of the connection in order to achieve its goal.\r\n\r\nAttacks:\r\n\r\n1. Passive flow tagging using time dilation:  At one position, the attacker chooses a target ECH connection and introduces a time dilation between two events (by delaying packets) whose relative timing otherwise has statistics stable enough to reliably detect the injected outlier at the attacker's other position.  The attacker annotates the connection in the list on the side the dilation is inserted with the time of the operation, and annotates the connection list at its other position with the time that outlier timing for that event was detected.  Later, connections are matched when recorded time values for a pair of entries (one from each connection list) are suitably related (the arithmetic left as an exercise for the reader).  One event pair might be observed ClientHello -> ServerHello timing.  Or it could be something more opportunistic, such as the arrival time of two successive records in a large backend server initial flight.  The attacker may be able to enhance the capacity of this attack by using multiple distinguishable dilation values, which would allow it to be applied to multiple connections within the same time window.\r\n2. Non-destructive active flow tagging I: On the client side, the attacker picks a target ECH connection from the client and inserts a change_cipher_spec record consisting of the single byte value 0x1 following ClientHello, and annotates the connection in the client-side list with the time at which the operation was performed.  On the backend-server side, the attacker annotates the entry in its list for the connection on which such a change_cipher_spec is observed with the time at which it is observed.  The attacker controls the interval at which it employs the attack such that given the path delay characteristics and clock synchronization limits, it can successfully match the annotated list entries.  The attacker can enhance the capacity of this attack by employing multiple differentiable time delay values between the ClientHello and the change_cipher_spec it inserts, enabling its use on multiple connections within the same time window.  Such change_cipher_spec records may also be employed by the client for their intended purpose, but the attacker can likely filter them out to protect the fidelity of its attack (and if necessary, unconditionally reinsert them at its position on the other side), as it is unlikely that the client-facing server and the infrastructure behind it require them for correct operation.  Deployed TLS 1.3 implementations that tolerate multiple such change_cipher_spec records would provide an expanded capacity to the attacker as being able to insert a variable number of records would further expand the concurrency space.  This attack could also be run in the other direction.  This attack only requires an active position on one side.\r\n3. Non-destructive active flow tagging II: On any given ECH connection on the client side, after the client-facing server enters forwarding mode, the attacker inserts a fake record whose payload contains a tag identifying it to its other position as such a record as well as indicating an attacker-assigned connection ID.  The client-facing server dutifully forwards the fake record, after which the attacker receives it at its backend-server side position, identifies the tag in the payload, removes the record from the flow, and annotates the associated entry in its connection list with the connection ID.  This could also be implemented as a length extension of otherwise legitimate records, with the additional payload removed at the second position.  This attack could also be run in the other direction.  This attack requires an active position on both sides.\r\n4. Destructive active flow tagging: Once the client-facing server has entered forwarding mode for a given ECH connection, the attacker can overwrite a portion of the payload of an existing record with the tag described in (3), with the same processing of the tag content at the attacker's other position.  As this will cause the connection to be aborted, it would only be useful on a sampling basis.  The attacker may be able to reduce the observability of this attack by opportunistically applying it to alerts it detects through traffic analysis.  This attack could be applied in either direction.  This attack only requires an active position on one side.\r\n\r\n\r\n",
      "createdAt": "2021-08-06T18:47:40Z",
      "updatedAt": "2023-10-13T22:59:43Z",
      "closedAt": "2023-10-13T22:59:43Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think (2-4) need to be quite so complicated. If you're assuming that the client-facing server <-> split mode channel is both unencrypted and visible to the attacker, they can just use the fact that every unmodified bit of ciphertext will identify the connection.\r\n\r\nI think, for purposes of split mode, we have to assume that the attacker cannot observe traffic between the client-facing and backend server, either due to visibility (in the shared mode cases, this \"traffic\" doesn't even go over the network) or due to them having their own encrypted channel. Although the latter is still a little fuzzy due to timing, depending on how much traffic goes into the client-facing server.",
          "createdAt": "2021-08-06T18:55:31Z",
          "updatedAt": "2021-08-06T18:55:31Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 06/08/2021 19:55, David Benjamin wrote:\n> I don't think (2-4) need to be quite so complicated. If you're\n> assuming that the client-facing server <-> split mode channel is both\n> unencrypted and visible to the attacker, they can just use the fact\n> that every unmodified bit of ciphertext will identify the\n> connection.\n> \n> I think, for purposes of split mode, we have to assume that the\n> attacker cannot observe traffic between the client-facing and backend\n> server, either due to visibility (in the shared mode cases, this\n> \"traffic\" doesn't even go over the network) or due to them having\n> their own encrypted channel. Although the latter is still a little\n> fuzzy due to timing, depending on how much traffic goes into the\n> client-facing server.\n\nI agree. I forget if we already note the basic vulnerability\nor not (we should I guess) but HOWTO secure client-facing to\nbackend traffic is properly work for another day I think. It\ndoes need a pile of work but better that we get started on\nclient to client-facing server experiments first.\n\nS.\n\n\n",
          "createdAt": "2021-08-06T19:03:34Z",
          "updatedAt": "2021-08-06T19:03:34Z"
        },
        {
          "author": "pkelsey",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I don't think (2-4) need to be quite so complicated. If you're assuming that the client-facing server <-> split mode channel is both unencrypted and visible to the attacker, they can just use the fact that every unmodified bit of ciphertext will identify the connection.\r\n> \r\n> I think, for purposes of split mode, we have to assume that the attacker cannot observe traffic between the client-facing and backend server, either due to visibility (in the shared mode cases, this \"traffic\" doesn't even go over the network) or due to them having their own encrypted channel. Although the latter is still a little fuzzy due to timing, depending on how much traffic goes into the client-facing server.\r\n\r\nThe assumption currently is that the backend channel in split mode is both unencrypted and visible to the attacker, as that's how the document currently reads, and it was expressed to me in #509 that the security model includes the attacker being located there.  (2-4) are the product of going down a rabbit hole of obtaining purely deterministic results.  I agree that correlation via sampling not-overly-many bytes of ciphertext at the same semantic position in the exchanges seen on both sides would probably be considered by most interested parties to be deterministic-enough.\r\n\r\nI do think it would be helpful to update the document to note that it currently assumes the attacker has no visibility to the client-facing server <-> backend server traffic in split mode.\r\n\r\nRegarding your comment above about dependence of security properties in split mode on traffic load at the client-facing server, for the benefit of those evaluating whether they can rely on ECH in their circumstances, I think the document should be clear as to whether there are scenarios where the assurance of privacy depends on being part of a big enough school of fish.\r\n",
          "createdAt": "2021-08-06T20:25:31Z",
          "updatedAt": "2021-08-06T20:25:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> The assumption currently is that the backend channel in split mode is both unencrypted and visible to the attacker, as that's how the document currently reads, and it was expressed to me in #509 that the security model includes the attacker being located there.\r\n\r\nSorry, to clarify, the assumption is that the attacker is _present_ on that link, but cannot _read_ data on that link, perhaps because it's encrypted. How that boundary is maintained is a deployment consideration specific to split mode. (As @davidben points out, split doesn't really work at all if the attacker has plaintext access to this link.)\r\n\r\n> I do think it would be helpful to update the document to note that it currently assumes the attacker has no visibility to the client-facing server <-> backend server traffic in split mode.\r\n\r\nThis would be fine, but it is different from saying the attacker is not present there. Any deployment of split mode can't just assume the attacker isn't there. Rather, it should assume the attacker is there, and make sure the client-facing<>backend communication is protected accordingly. (I hope that clarifies my mental model.)",
          "createdAt": "2021-08-06T20:46:30Z",
          "updatedAt": "2021-08-06T20:48:58Z"
        },
        {
          "author": "pkelsey",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\r\n> Sorry, to clarify, the assumption is that the attacker is _present_ on that link, but cannot _read_ data on that link, perhaps because it's encrypted. How that boundary is maintained is a deployment consideration specific to split mode. (As @davidben points out, split doesn't really work at all if the attacker has plaintext access to this link.)\r\n> \r\n> > I do think it would be helpful to update the document to note that it currently assumes the attacker has no visibility to the client-facing server <-> backend server traffic in split mode.\r\n> \r\n> This would be fine, but it is different from saying the attacker is not present there. Any deployment of split mode can't just assume the attacker isn't there. Rather, it should assume the attacker is there, and make sure the client-facing<>backend communication is protected accordingly. (I hope that clarifies my mental model.)\r\n\r\nAppreciate the clarification on the thinking here.  I agree there is an important difference between not-present and no-visibility, and I'm not advocating for an assumption that the attacker is not on the backend link - #509 was language to highlight the state of the model as currently written.\r\n",
          "createdAt": "2021-08-06T21:17:34Z",
          "updatedAt": "2021-08-06T21:17:34Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Appreciate the clarification on the thinking here. I agree there is an important difference between not-present and no-visibility, and I'm not advocating for an assumption that the attacker is not on the backend link - #509 was language to highlight the state of the model as currently written.\r\n\r\nUnderstood! We could reopen #509 and rephrase it slightly to highlight this difference, and then perhaps say that it can be realized either (1) with encryption, assuming the attacker is everywhere, or (2) by changing network topology such that the attacker is really only present on the client<>client-facing path, as noted by @ekr. \r\n\r\n@pkelsey, what do you think? Would you be willing to refactor that PR to match?",
          "createdAt": "2021-08-06T21:39:52Z",
          "updatedAt": "2021-08-06T21:39:52Z"
        },
        {
          "author": "pkelsey",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood I'd be happy to reopen #509 with new tweaks to the language, but I don't think it's yet clear what those tweaks should be.  If we pursue (1), it seems something more would need to be said than simply that the link between the client facing server and the backend server achieves \"no-visibilty\" via encryption, at the very least to head off interpretation of \"via encryption\" to mean direct forwarding of the ciphertexts.  Is (2) really on the table?  I'm not sure what the context of the reference to \"as noted by @ekr\" as I'm not aware of where that note was made, so I'd need some help filling in the blank if there was more to it.\r\n\r\nAside from figuring out the above, I think at this point there is one clear residue of this discussion, which is that client facing servers operating in split mode should be required to drop all RFC 8446 middlebox compatibility change_cipher_spec messages received from the client in order to deprive active attackers of this easy-access connection labeling tool.  Such messages should have no reason to exist on the link between a client facing server and a backend server.  I haven't yet attempted a full survey of extant implementations, but it does appear OpenSSL, in a TLS 1.3 handshake, will ignore up to 32 of them appearing consecutively between handshake records, which looks like quite a bit of leeway for exploitation.",
          "createdAt": "2022-11-09T03:51:08Z",
          "updatedAt": "2022-11-09T03:51:08Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Can you please elaborate on this CCS-based attack? Are you envisioning that the communication channel between frontend and backend would somehow be protected but still reveal the record type?",
          "createdAt": "2022-11-09T11:12:10Z",
          "updatedAt": "2022-11-09T11:12:10Z"
        },
        {
          "author": "pkelsey",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think the record type necessarily has to be revealed on the backend link for this to be a concern, as this is a tool for an active attacker to adjust the size of data forwarded between frontend and backend in a connection-specific way that otherwise has no effect on the evolution of the targeted connection(s).",
          "createdAt": "2022-11-09T11:31:38Z",
          "updatedAt": "2022-11-09T11:31:38Z"
        }
      ]
    },
    {
      "number": 515,
      "id": "MDU6SXNzdWU5NjQyODk0NDI=",
      "title": "Improve guidance for Second ClientHello construction in the event of HRR",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/515",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "This was PR #497 but we're punting on that for now.",
      "createdAt": "2021-08-09T19:10:02Z",
      "updatedAt": "2023-10-09T23:09:18Z",
      "closedAt": "2023-10-09T23:09:18Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The document has been significantly improved to add more guidance around how HRR is processed, specifically in [Section 6.1.5](https://tlswg.org/draft-ietf-tls-esni/draft-ietf-tls-esni.html#name-handshaking-with-clienthell). @sftcd, please reopen if you feel this guidance is inadequate (and ideally clarify how it's inadequate so we can craft a PR to fix!).",
          "createdAt": "2023-10-09T23:09:18Z",
          "updatedAt": "2023-10-09T23:09:18Z"
        }
      ]
    },
    {
      "number": 516,
      "id": "MDU6SXNzdWU5NjQ4NTY4NDg=",
      "title": "split-mode may be more a three-way thing than a two-way thing",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/516",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "(This doesn't need any action for esni-draft-13, we can come back to it or ignore it after people have played some more with deployments of that.)\r\n\r\nTL;DR - maybe split-mode should be described as involving three possibly independent private key holders rather than described as involving two entities (client-facing and backend) - my initial haproxy split-mode implementation maps better to the former.\r\n\r\nI did some initial work to integrate my ECH-capable OpenSSL build with haproxy. Shared-mode had nothing much interesting about it (mostly similar to nginx, apache, lighttpd) but split-mode threw up what was for me a new thing. (My notes on that are [here](https://github.com/sftcd/openssl/blob/ECH_UPFRONT_DEC/esnistuff/haproxy.md#split-mode).)\r\n\r\nThe main thing is that, in split-mode, haproxy will decrypt the ECH fine and can then pass on the inner CH and allow the TLS h/s to continue between client and backend, but haproxy can't act as the server for the public_name as it goes out of its way to avoid being a web server. That wasn't a hard problem to handle though as I just route e.g. all non-decrypted TLS sessions to yet another external web server instance, that has the private key corresponding to ECHConfig.public_name, and which is only ECH-special in that it has to be able to answer GREASEd CH's. (But it is a bit ECH special in answering GREASE while not being a full shared-mode instance which needed a few tweaks in my server code to handle having an ECHConflg but no private key.)\r\n\r\nSo all that worked ok, and isn't really visible to the client, but if other deployments are similar we might want to recast the description of split mode to note this three-way aspect. In particular, I guess this kind of setup allows for a situation where we have could have many different public_name values for one or a small number of ECH public_key values, independent of the size of the anonymity set of will-be-encrypted SNI names protected via the ECH public_key values. I guess that's not likely what a CDN might want to do (as it probably only wants/needs to use one or a few public_name values) but maybe it'd be useful for some reason, not sure. (Looking at the mega-flexibility of the haproxy config, I'm guessing haproxy has already been deployed in many unexpected ways;-)\r\n\r\nThe three-way thing might also be relevant for security analyses, not sure.\r\n\r\nLastly, that three-way aspect means that we'd better not change the protocol in any way that assumes that the ECH private key holder has access to information only known to the public_name private key holder. So far that's fine and will likely stay so, but it's a maybe non-obvious invariant we should keep.\r\n",
      "createdAt": "2021-08-10T11:00:50Z",
      "updatedAt": "2023-10-09T23:19:00Z",
      "closedAt": "2023-10-09T23:19:00Z",
      "comments": [
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW, I'm not convinced the Topologies section deserves such prominent placement. It's barely mentioned in the text, and sort of borders on being implementation advice for client-facing servers. I think it might be better to move it down near sections 10-11, where it is mentioned a few times.",
          "createdAt": "2021-09-19T19:54:05Z",
          "updatedAt": "2021-09-19T19:54:05Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the intent here is to say that there's basically three keys floating around: (1) the ECH private keys, (2) the client-facing server public_name private key, and (3) the backend server private key. Is that correct? If so, I don't think this is unique to split mode, as these three keys still need to exist in shared mode. I'm inclined to keep the document as-is on that observation, and given how much time has elapsed here, I'm going to close as this having been overcome by events. However, please do reopen and surface on the mailing list if you feel like this still warrants a text change.",
          "createdAt": "2023-10-09T23:19:00Z",
          "updatedAt": "2023-10-09T23:19:00Z"
        }
      ]
    },
    {
      "number": 517,
      "id": "MDU6SXNzdWU5OTIzNTg3ODc=",
      "title": "Question on Section 10.2",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/517",
      "state": "CLOSED",
      "author": "kylon94",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Section 10.2 of the draft suggests the use of DoH/DPRIVE when querying for the ECH record to protect against attacks on the local network. Should ECH be used for this DoH/DPRIVE query too? \r\n\r\nSome guidance on whether or not to use it would be helpful for developers. For example covering how the ECH key should be provisioned if it is used.",
      "createdAt": "2021-09-09T15:27:55Z",
      "updatedAt": "2023-10-09T21:51:04Z",
      "closedAt": "2023-10-09T21:51:04Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Since this is specific to how ECH is bootstrapped, I suggest filing an issue to discuss this on the related [DNS bootstrapping](https://github.com/tlswg/draft-ietf-tls-svcb-ech) draft.",
          "createdAt": "2023-10-09T21:51:04Z",
          "updatedAt": "2023-10-09T21:51:04Z"
        }
      ]
    },
    {
      "number": 519,
      "id": "I_kwDOB-yxNc5ANq2r",
      "title": "Anonymity set definition should include behavior",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/519",
      "state": "CLOSED",
      "author": "klinvill",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The current version of the spec mentions that: \r\n\r\n> Co-located servers with consistent externally visible TLS configurations, including supported versions and cipher suites, form an anonymity set.\r\n\r\nYet decisions a server makes during the handshake (such as which cipher suite it selects from a proposed list) can also be used to distinguish connection establishment to one server from another.  In the most extreme case, this would result in anonymity sets being restricted to servers using the same TLS implementation and configuration. I'm not sure where text describing this should go (maybe a section on anonymity set considerations? maybe just update the definition to read \"Co-located servers with consistent externally visible TLS configurations, [...], and behavior...\") but I think it's worth a mention in the spec.",
      "createdAt": "2021-12-11T00:07:54Z",
      "updatedAt": "2023-10-13T23:04:11Z",
      "closedAt": "2023-10-13T23:04:11Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The intent of \"TLS configuration\" was to capture everything from algorithm choice to server behavior, but it doesn't hurt to additionally note behavior. ",
          "createdAt": "2023-10-09T21:57:00Z",
          "updatedAt": "2023-10-09T21:57:00Z"
        }
      ]
    },
    {
      "number": 520,
      "id": "I_kwDOB-yxNc5ASMq-",
      "title": "HRR rejection and ECH contents",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/520",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The spec hints at the expected behavior (copy contents of CH1.encrypted_client_hello into CH2), but isn't entirely clear.",
      "createdAt": "2021-12-13T13:09:11Z",
      "updatedAt": "2023-10-09T22:17:09Z",
      "closedAt": "2023-10-09T22:17:09Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This now seems clear based on [this section](https://tlswg.org/draft-ietf-tls-esni/draft-ietf-tls-esni.html#name-handshaking-with-clienthell).",
          "createdAt": "2023-10-09T22:17:09Z",
          "updatedAt": "2023-10-09T22:17:09Z"
        }
      ]
    },
    {
      "number": 521,
      "id": "I_kwDOB-yxNc5A5Fbj",
      "title": "Mistake on Section 10.2",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/521",
      "state": "CLOSED",
      "author": "cherinyy",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "https://github.com/tlswg/draft-ietf-tls-esni/blob/058aedcdc6ebefcbee81201dcb4ec960bdcafccc/draft-ietf-tls-esni.md#L1663-L1672\r\nhttps://github.com/tlswg/draft-ietf-tls-esni/blob/058aedcdc6ebefcbee81201dcb4ec960bdcafccc/draft-ietf-tls-esni.md?plain=1#L1663-L1672\r\n\r\nCurrently there are only two entries.",
      "createdAt": "2021-12-26T06:08:16Z",
      "updatedAt": "2022-01-04T20:54:43Z",
      "closedAt": "2022-01-04T20:54:43Z",
      "comments": []
    },
    {
      "number": 524,
      "id": "I_kwDOB-yxNc5GU9QJ",
      "title": "How to retry in ECH is ambiguous",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/524",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Not sure what the right answer is, or whether this belongs in this draft, or some upper layer document. (Alas, though I'm not even sure whether those upper layer documents exist... SVCB? Part of HTTP?) When the recovery flow triggers, we are supposed to \"retry the handshake with a new transport connection\".\r\n\r\nThe transport connection is mostly out of TLS's scope, but _somewhere_ we should decide whether this means...\r\n\r\n* Do you connect with the exact same IP?\r\n* Do you connect with the same SVCB record, but other IPs within that route are in scope?\r\n* Do you connect anew and we just say, meh, this is a recovery mechanism so our aim is just to work most of the time?\r\n* Or maybe we'll learn this is a problem and we need to jam the retry in the same connection (big protocol change, shifts some complexity from upper layers into TLS)\r\n* What happens with proxies, which typically make DNS queries for you? Should we ever decide to integrate SVCB fetching into HTTP CONNECT, the answer here will have implications for that scheme.\r\n\r\nHopefully, with initial experiments, we'll understand this better. But filing this now so we don't forget to address it later.",
      "createdAt": "2022-03-24T18:35:30Z",
      "updatedAt": "2023-10-16T13:26:33Z",
      "closedAt": "2023-10-16T13:26:33Z",
      "comments": [
        {
          "author": "orangepizza",
          "authorAssociation": "NONE",
          "body": "I don't think it's in scope of this but TLS 1.3 itself(rfc8446)?",
          "createdAt": "2022-03-30T11:55:15Z",
          "updatedAt": "2022-03-30T11:55:15Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Why RFC 8446? RFC 8446 and this document both have the same opinions about how to set up the transport connection, which is to say, none. It also cannot usefully talk about ECH retries, because ECH retries don't exist before this extension.",
          "createdAt": "2022-03-30T13:14:46Z",
          "updatedAt": "2022-03-30T13:14:46Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@davidben I think the most we can say in this document is option (3), which is to say that it's recovery and implementations can do what they want with the guidance to make things work the best they can. It might be helpful to have a higher-level document describing behavior that has emerged in Firefox and Chrome (cc @dennisjackson), but that seems orthogonal and much more involved than what we can probably reasonable accomplish here.",
          "createdAt": "2023-10-09T22:27:20Z",
          "updatedAt": "2023-10-09T22:27:20Z"
        },
        {
          "author": "dennisjackson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd prefer to have some 'SHOULD' guidance here for implementers and a pointer to the advice in [draft-ietf-tls-svcb-ech](https://datatracker.ietf.org/doc/draft-ietf-tls-svcb-ech/). It would be good to clarify the interaction between retry ECHConfigs and alternative ECHConfigs+IP hints for example. Something like: \r\n\r\n* When provided with an ECHConfig via a TLS retry extension, you SHOULD use the same IP. \r\n* If the retry fails, follow draft-ietf-tls-svcb-ech (if in use). ",
          "createdAt": "2023-10-11T08:40:34Z",
          "updatedAt": "2023-10-11T08:40:34Z"
        }
      ]
    },
    {
      "number": 537,
      "id": "I_kwDOB-yxNc5NbNhY",
      "title": "0xfe0d to decimal",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/537",
      "state": "CLOSED",
      "author": "AAGiron",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hi,\r\n\r\njust a small fix, section 5. states:\r\n```\r\n      enum {\r\n          encrypted_client_hello(0xfe0d), (65535)\r\n       } ExtensionType;\r\n```\r\nBut instead of 65535 it should be 65037.",
      "createdAt": "2022-07-08T12:47:38Z",
      "updatedAt": "2022-09-12T13:56:43Z",
      "closedAt": "2022-09-12T13:56:43Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "65535 is correct, though it is a bit confusing if unfamiliar with the syntax. This isn't the deceimal version but a separate value. The extra untagged value specifies the field width.\r\nhttps://www.rfc-editor.org/rfc/rfc8446.html#section-3.5\r\n\r\nStrictly speaking, the field width is determined by the smallest that'll fit all values. Since 0xfe0d already implies a 2-byte value, we don't actually need it here. But typically we write down the maximum possible value to be explicit. See how the RFC 8446 definition also has a `(65535)`.\r\nhttps://www.rfc-editor.org/rfc/rfc8446.html#section-4.2\r\n\r\nAnd likewise otherdocuments which extend the enum tend to do as this draft does.\r\nhttps://www.rfc-editor.org/rfc/rfc6066.html#section-1.1",
          "createdAt": "2022-09-07T17:01:18Z",
          "updatedAt": "2022-09-07T17:01:18Z"
        },
        {
          "author": "AAGiron",
          "authorAssociation": "NONE",
          "body": "Hi!\r\nThanks for the clarification. I will close this now.",
          "createdAt": "2022-09-12T13:56:43Z",
          "updatedAt": "2022-09-12T13:56:43Z"
        }
      ]
    },
    {
      "number": 538,
      "id": "I_kwDOB-yxNc5P_6VT",
      "title": "Expiration",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/538",
      "state": "CLOSED",
      "author": "JonSnowWhite",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The official draft expired today. Is there a version bump planned?",
      "createdAt": "2022-08-17T18:56:23Z",
      "updatedAt": "2022-08-26T13:09:26Z",
      "closedAt": "2022-08-26T13:09:26Z",
      "comments": [
        {
          "author": "taoso",
          "authorAssociation": "NONE",
          "body": "Expired \ud83d\ude22 ",
          "createdAt": "2022-08-24T07:17:24Z",
          "updatedAt": "2022-08-24T07:17:24Z"
        },
        {
          "author": "letrhee",
          "authorAssociation": "NONE",
          "body": "I remember seeing a video about submitting a paper to CCS at IETF-113.\r\nPerhaps there will be document changes after the CCS2022 decisions on submitted papers?",
          "createdAt": "2022-08-25T15:48:59Z",
          "updatedAt": "2022-08-25T15:48:59Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Since an expired draft can still be referenced, we'll update the draft when there are non-trivial changes to land. As of now, there are no changes staged.",
          "createdAt": "2022-08-26T13:09:26Z",
          "updatedAt": "2022-08-26T13:09:26Z"
        }
      ]
    },
    {
      "number": 540,
      "id": "I_kwDOB-yxNc5TEbrc",
      "title": "Status of this draft?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/540",
      "state": "CLOSED",
      "author": "kovalensky",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The last update was in February and IETF draft is expired, what happened?",
      "createdAt": "2022-10-02T07:21:30Z",
      "updatedAt": "2022-10-03T14:12:00Z",
      "closedAt": "2022-10-02T13:04:32Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "There have been no changes that warranted an update. The draft will be resurrected when changes land.",
          "createdAt": "2022-10-02T13:04:26Z",
          "updatedAt": "2022-10-02T13:04:26Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": "It is not uncommon to post a new version, a refresh, just to keep things from falling out of sight. Expired drafts do not show up in the datatracker \"active documents\" list, for example.\n\n\nMessage ID: ***@***.***>\n",
          "createdAt": "2022-10-02T13:10:19Z",
          "updatedAt": "2022-10-02T13:10:19Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "While a refresh is permitted and commonplace, this is a great example of why I think that the expiration system isn't helpful.  Please don't refresh the draft until there is a reason, other than inane rules.",
          "createdAt": "2022-10-02T19:39:28Z",
          "updatedAt": "2022-10-02T19:39:28Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I had an outstanding PR to update some security considerations with a paper citation, and that seemed worthy of a new version.",
          "createdAt": "2022-10-03T14:11:59Z",
          "updatedAt": "2022-10-03T14:11:59Z"
        }
      ]
    },
    {
      "number": 541,
      "id": "I_kwDOB-yxNc5UoLvg",
      "title": "Use Session ID in Client Hello to transfer enctypred SNI",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/541",
      "state": "CLOSED",
      "author": "0x391F",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Is it possible to use Session ID in Client Hello to transfer enctypred SNI? If it looks random enough, attacker could't distinguish Session ID is encrypted SNI or not. \r\n\r\nBy the way, how to join the mailing list? ",
      "createdAt": "2022-10-23T14:50:39Z",
      "updatedAt": "2023-07-25T17:47:35Z",
      "closedAt": "2023-07-25T17:47:34Z",
      "comments": [
        {
          "author": "0x391F",
          "authorAssociation": "NONE",
          "body": "It may have some restrictions, for example, the SNI maybe couldn't longer than Session ID (32 bytes). ",
          "createdAt": "2022-10-23T14:55:33Z",
          "updatedAt": "2022-10-23T14:55:33Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi @0x391F -- you may join the mailing list [here](https://www.ietf.org/mailman/listinfo/tls). I recommend you propose your idea there for further discussion.",
          "createdAt": "2023-07-25T17:47:34Z",
          "updatedAt": "2023-07-25T17:47:34Z"
        }
      ]
    },
    {
      "number": 542,
      "id": "I_kwDOB-yxNc5V6Oil",
      "title": "Use of MAY in section 5 needs to be fixed up",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/542",
      "state": "CLOSED",
      "author": "pkelsey",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In section 5, it says\r\n\r\n```\r\n   When a client offers the outer version of an \"encrypted_client_hello\"\r\n   extension, the server MAY include an \"encrypted_client_hello\"\r\n   extension in its EncryptedExtensions message, as described in\r\n   Section 7.1, with the following payload:\r\n\r\n       struct {\r\n          ECHConfigList retry_configs;\r\n       } ECHEncryptedExtensions;\r\n```\r\n\r\nHowever, in Section 7.1, there is no scenario where the use of this encrypted_client_hello payload is \"truly optional\" per RFC 2119.  The intention here appears to be to describe that the server \"might\" do this.  Fixing the wording here might be considered to overlap with #454.",
      "createdAt": "2022-11-09T03:56:45Z",
      "updatedAt": "2023-10-09T22:45:15Z",
      "closedAt": "2023-10-09T22:45:15Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "It's my fault for not responding to this comment sooner, but I'm not sure what version of the document this comment refers to. [Section 7.1](https://tlswg.org/draft-ietf-tls-esni/draft-ietf-tls-esni.html#name-client-facing-server_) does have the following text: \r\n\r\n~~~\r\n* If sending a HelloRetryRequest, the server MAY include an \"encrypted_client_hello\" extension with a payload of 8 random bytes; see [Section 10.9.4](https://tlswg.org/draft-ietf-tls-esni/draft-ietf-tls-esni.html#dont-stick-out) for details.[\u00b6](https://tlswg.org/draft-ietf-tls-esni/draft-ietf-tls-esni.html#section-7.1-13.1)\r\n\r\n* If the server is configured with any ECHConfigs, it MUST include the \"encrypted_client_hello\" extension in its EncryptedExtensions with the \"retry_configs\" field set to one or more ECHConfig structures with up-to-date keys. Servers MAY supply multiple ECHConfig values of different versions. This allows a server to support multiple versions at once.[\u00b6](https://tlswg.org/draft-ietf-tls-esni/draft-ietf-tls-esni.html#section-7.1-13.2)\r\n~~~\r\n\r\nThe former condition is the case where the server MAY include this extension, so I think the requirement language is consistent. I'm going to close on the basis of that understanding, but please do reopen if you feel I misunderstood this issue.",
          "createdAt": "2023-10-09T22:45:15Z",
          "updatedAt": "2023-10-09T22:45:15Z"
        }
      ]
    },
    {
      "number": 543,
      "id": "I_kwDOB-yxNc5WbMok",
      "title": "RFC9180 recommended max for info is too short for ECH",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/543",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "HPKE (RFC9180) section 7.2.1 recommends 64 octets as a max for info. That's too short for ECH which requires 8+len(ECHConfig) and ECHConfig is extensible. Suggest adding at least a note about that in ECH, section 7.1. Not sure what value would be reasonable for guidance and/or selecting an HPKE implementation to use. My HPKE code supports up to 1024 for now which seems to work in ECH tests.\r\n\r\nhttps://www.rfc-editor.org/errata/eid7251 is related, but also needs an edit to handle this.",
      "createdAt": "2022-11-15T15:28:36Z",
      "updatedAt": "2023-10-09T21:26:22Z",
      "closedAt": "2023-10-09T21:26:21Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The HPKE limit was written with the intent of helping implementations that allocate on the stack choose some reasonable size. I don't know if we need to note anything here given that the HPKE construction doesn't technically impose such a limit, though I'd be happy to review text. I'm going to close this on that basis, but please feel free to reopen with a PR that suggests text for review.",
          "createdAt": "2023-10-09T21:26:21Z",
          "updatedAt": "2023-10-09T21:26:21Z"
        }
      ]
    },
    {
      "number": 544,
      "id": "I_kwDOB-yxNc5XfxnE",
      "title": "What does ECH acceptance mean in Split Mode?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/544",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In Shared Mode, when a client receives ECH accept confirmation and the handshake successfully completes, the client knows that sensitive extensions such as SNI were hidden from observers, regardless of how DNS is configured. This is because we can assume that the owner of the ECH private key is the owner of the private key corresponding to the server certificate. Fine.\r\n\r\nBut what does ECH acceptance mean in Split Mode?\r\n\r\nAt the moment, we do not prohibit backend servers signaling ECH acceptance against connections that originate from arbitrary location.\r\n\r\nIf backend servers are to accept connections from arbitrary client-facing servers and respond with an ECH accept confirmation, it becomes trivial for a network operator controlling DNS responses to setup a client-facing proxy. If such a client-facing proxy acting as a transparent proxy is setup by a local network operator, then the IP address of the client and the SNI would be visible on the Internet. I would be hesitant to say that ECH is providing any value in such scenario.\r\n\r\nTo paraphrase, in contrast to Shared Mode, ECH acceptance means very little when the server is in Split Mode.\r\n\r\nAdmittedly, section 10.9.6 (Enable Multi-party Security Contexts) states that \u201cassuming ECH records retrieved from DNS are authenticated (snip) Resolver, spoofing a client-facing server operating in Split Mode is not possible.\u201d\r\n\r\nBut I wonder if we should better be more direct about the problem. To give an example, it might be a good idea to state in Section 3 (Topologies) that use of a secure channel between the client-facing server and backend server is assumed, and that otherwise spoofing is possible.",
      "createdAt": "2022-11-29T12:06:03Z",
      "updatedAt": "2023-10-13T22:59:44Z",
      "closedAt": "2023-10-13T22:59:44Z",
      "comments": [
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Is there any way for a client to tell the difference between a server operating in \"Shared Mode\" vs one in \"Split Mode\"? I support ECH as a wire protocol, but these deployment considerations don't belong in the document. They can and do inform the design.",
          "createdAt": "2022-12-08T23:50:07Z",
          "updatedAt": "2022-12-08T23:50:07Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@sayrer \r\n> Is there any way for a client to tell the difference between a server operating in \"Shared Mode\" vs one in \"Split Mode\"? I support ECH as a wire protocol, but these deployment considerations don't belong in the document. They can and do inform the design.\r\n\r\nThat's a good point though I'm not sure if that follows the precedent we have.\r\n\r\nIn normal TLS/1.3, when the handshake succeeds, we assume that the owner of the private key corresponding to the certificate is either a) the owner of the ECDH key sent in ServerHello, or that b) there is a trust relationship between the owner of the former and the latter.\r\n\r\n_b_ is the so-called \"Keyless SSL\" case.\r\n\r\nWe do not have a wire signal that distinguishes between the two.\r\n\r\nIMO, ECH in Split Mode is no different from the Keyless SSL case modulo the fact that we explicitly talk about a split deployment without stating that there should be a trust relationship.\r\n\r\nHence my original comment suggests adding a statement that requires such trust relationship.",
          "createdAt": "2022-12-09T02:26:28Z",
          "updatedAt": "2022-12-09T02:55:45Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would expect the exchanges between the client-facing server and the backed server to run on some kind of private network, maybe using something like Masque. If third parties can spoof the client-facing server, then, yes, there will be all kinds of issues. And simply encrypting this front-to-backend traffic may not be enough. If the traffic can be observed, the observers can send ECH requests to the frontend, and see where the next packets from the server go.",
          "createdAt": "2022-12-09T03:09:43Z",
          "updatedAt": "2022-12-09T03:09:43Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Maybe you need to add some guidance in the draft about fronting-backend communications. Could be in the security considerations. If third parties can spoof a fronting server then there are certainly some plausible attacks. If third parties can observe the traffic between fronting and backend, there are other possible attacks.",
          "createdAt": "2022-12-09T03:31:18Z",
          "updatedAt": "2022-12-09T03:31:18Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": "Strong +1 to @huitema 's comments above.  I could do a PR if needed.",
          "createdAt": "2022-12-09T14:00:35Z",
          "updatedAt": "2022-12-09T14:00:35Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The more I think of it, the more I think that the \"split\" works well if fronting and back-end servers are in the same data center. For example, some load balancing scenario in which a specific pool of back-end servers handles a specific SNI. Then, the attack surface is pretty much the same as attacks against the classic LB to back-end communication. If the communication between fronting and back-end goes over the public Internet, we are closer to a proxy scenario and we have to worry about all the attacks against proxy servers.",
          "createdAt": "2022-12-09T17:25:18Z",
          "updatedAt": "2022-12-09T17:25:18Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Maybe you need to add some guidance in the draft about fronting-backend communications. Could be in the security considerations. If third parties can spoof a fronting server then there are certainly some plausible attacks. If third parties can observe the traffic between fronting and backend, there are other possible attacks.\r\n\r\nThis is all true, but these considerations have little to do with ECH. It's not ECH, after all.\r\n\r\nI guess I'd say I think the draft is wrong to lead with \"topologies\", since they do not change the protocol. After that, they only get briefly mentioned.",
          "createdAt": "2022-12-12T01:17:48Z",
          "updatedAt": "2022-12-12T01:17:48Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "IIRC, there were people who showed their interest in deploying ECH in split mode. That's why we have the requirement in [RFC 8744](https://datatracker.ietf.org/doc/html/rfc8744) section 3.6, after all.\r\n\r\nConsidering that fact, I think it'd be favorable to retain the distinction of the topologies as well as the notion of client-facing and backend servers, and also to expand deployment requirements / recommendations for Split Mode, as @huitema and @richsalz have argued. Unless we write them down, the risk becomes higher of people deploying Split Mode in risky ways.",
          "createdAt": "2022-12-12T12:32:26Z",
          "updatedAt": "2022-12-12T12:32:26Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> IIRC, there were people who showed their interest in deploying ECH in split mode.\r\n\r\nSure, no argument. The document is poorly organized, though. Section 3 should start with what is now 3.2, and refer to the \"topologies\" with something like \"See section 10 (Security Considerations)\". In the current draft, \"Split Mode\" doesn't appear again until Section 10.7, and \"Shared Mode\" never appears again.\r\n",
          "createdAt": "2022-12-12T21:27:37Z",
          "updatedAt": "2022-12-12T21:28:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho can you please take a look at #564 and let me know if this clarification resolves your concern? I attempted to describe what assumptions are in place about the attacker and their capabilities, with special emphasis on split mode.",
          "createdAt": "2023-10-09T23:27:21Z",
          "updatedAt": "2023-10-09T23:27:21Z"
        }
      ]
    },
    {
      "number": 545,
      "id": "I_kwDOB-yxNc5bOj8d",
      "title": "Server reuse of key share leaks the target domain for a given connection",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/545",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Related general issue with a suggestion to make client and server reuse SHOULD NOT\r\nhttps://github.com/tlswg/tls13-spec/issues/1285\r\nhttps://github.com/tlswg/tls13-spec/pull/1286\r\n\r\nFor ECH I think MUST NOT for server reuse seems motivated.\r\n\r\n```\r\n  Client                         Attacker                   Server\r\n\r\n      ClientHello\r\n      + ech         ------>\r\n                                                       ServerHello\r\n                                                       + key_share\r\n                                                   <-------\r\n                                 (intercept)\r\n\r\n                                ...\r\n\r\n                                 ClientHello      ------->\r\n                                                       ServerHello\r\n                                                       + key_share\r\n                                                  <-------\r\n                                 (compare key shares)\r\n\r\n  Figure X: Active attacker identifying server resuing key share\r\n\r\n\r\n  Client1      Client2           Attacker                   Server\r\n\r\n      ClientHello\r\n      + ech         ------>\r\n                                                       ServerHello\r\n                                                       + key_share\r\n                                 (intercept)\r\n\r\n                                ...\r\n\r\n                 ClientHello\r\n                    ------>      (intercept SNI)\r\n                                                       ServerHello\r\n                                                       + key_share\r\n                                 (compare key shares)\r\n\r\n  Figure Y: Passive attacker identifying server resuing key share\r\n```\r\n",
      "createdAt": "2023-01-12T11:21:56Z",
      "updatedAt": "2023-10-09T21:37:05Z",
      "closedAt": "2023-10-09T21:37:05Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "HPKE already covers the case of ephemeral key reuse, so we don't need to cite anything new in here for client behavior. Identifying servers based on key reuse is something that TLS -- not ECH -- must deal with. So I think we can comfortably close this.",
          "createdAt": "2023-10-09T21:37:05Z",
          "updatedAt": "2023-10-09T21:37:05Z"
        }
      ]
    },
    {
      "number": 546,
      "id": "I_kwDOB-yxNc5e_IzR",
      "title": "How to get the server_name fileds of OuterClientHello",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/546",
      "state": "CLOSED",
      "author": "LiFulian",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "\u8bf7\u95ee\u5ba2\u6237\u7aef\u662f\u5982\u4f55\u5f97\u5230OuterClientHello\u4e2d\u53ef\u89c1\u7684SNI\u5b57\u6bb5\u7684\u5462\uff1f\u662f\u901a\u8fc7DNS\u5417\uff0c\u8bf7\u95ee\u53ef\u4ee5\u8be6\u7ec6\u63cf\u8ff0\u4e00\u4e0b\u5417\uff0c\u975e\u5e38\u611f\u8c22\uff01\r\n\r\nHow does the client get the SNI fields visible in OuterClientHello? Is it through DNS? Can you describe it in detail? Thank you very much!",
      "createdAt": "2023-02-21T14:46:04Z",
      "updatedAt": "2023-07-25T17:37:44Z",
      "closedAt": "2023-07-25T17:37:43Z",
      "comments": [
        {
          "author": "Lekensteyn",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To get the SNI field in the OuterClientHello, follow the steps in https://datatracker.ietf.org/doc/html/draft-ietf-tls-esni#section-6.1\r\n\r\nIn particular\r\n\r\n> 5. The value of ECHConfig.contents.public_name MUST be placed in the \"server_name\" extension.\r\n\r\n\r\nThis \"ECHConfig\" is shared out-of-band. One of the potential mechanisms is indeed DNS, through the HTTPS RR:\r\n\r\n> [3.2. Encrypted ClientHello (ECH)](https://datatracker.ietf.org/doc/html/draft-ietf-tls-esni#section-3.2)\r\n>\r\n> A client-facing server enables ECH by publishing an ECH configuration, which is an encryption public key and associated metadata. The server must publish this for all the domains it serves via Shared or Split Mode. This document defines the ECH configuration's format, but delegates DNS publication details to [[HTTPS-RR](https://datatracker.ietf.org/doc/html/draft-ietf-dnsop-svcb-https-10)]. Other delivery mechanisms are also possible. For example, the client may have the ECH configuration preconfigured.\r\n\r\n",
          "createdAt": "2023-02-21T17:26:44Z",
          "updatedAt": "2023-02-21T17:26:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as resolved based on @Lekensteyn's comment. Please let us know if this is still unclear!",
          "createdAt": "2023-07-25T17:37:43Z",
          "updatedAt": "2023-07-25T17:37:43Z"
        }
      ]
    },
    {
      "number": 547,
      "id": "I_kwDOB-yxNc5hz3A-",
      "title": "\"Don't fallback to non-ECH\" option",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/547",
      "state": "CLOSED",
      "author": "TheBlueMatt",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Given we've now gone to all the effort to pipe a public key through from DNS to TLS clients and can use that to securely communicate with a server, it seems like an oversight to not have a \"dont fallback to not using this cryptographic key\" option. For clients which support it, this would prevent CA compromise from enabling MITM attacks by requiring *both* a DNS-\"authenticated\" (at least insofar as DNS cache poisoning is not also done, or otherwise prevented using DNSSEC) key, plus a CA-authenticated key.",
      "createdAt": "2023-03-26T16:46:28Z",
      "updatedAt": "2023-10-09T21:28:23Z",
      "closedAt": "2023-10-09T21:28:22Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "See https://datatracker.ietf.org/doc/rfc6698/",
          "createdAt": "2023-03-26T22:01:52Z",
          "updatedAt": "2023-03-26T22:01:52Z"
        },
        {
          "author": "TheBlueMatt",
          "authorAssociation": "NONE",
          "body": "Yes I'm well aware of DANE lol, sadly it's used nowhere outside of email. ECH, on the other hand, is likely to be adopted in ~every web browser, and (a) at the cost of one bit and an extra if statement we can substantially improve security of the web under certain attack models (compare to DANE, which requires substantial additional implementation complexity) and (b) since when has \"there's already some other protocol for that, we can't have any overlapping feature sets\" been an IETF stance :p.",
          "createdAt": "2023-03-27T00:40:32Z",
          "updatedAt": "2023-03-27T00:47:25Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't really understand the semantics of what you're proposing here. Can you lay out your proposal in more detail.",
          "createdAt": "2023-03-27T01:03:24Z",
          "updatedAt": "2023-03-27T01:03:24Z"
        },
        {
          "author": "TheBlueMatt",
          "authorAssociation": "NONE",
          "body": "Sure, of course, and apologies if I've missed anything in how ECH works as currently defined.\r\n\r\nIf an ECH negotiation succeeds, the client knows that the inner client hello was decrypted with the key it fetched from DNS (I believe? At least its trivial to accomplish as long as the client MUST use sufficiently cryptographically distinct info in its inner/outer client hellos that the transcript hash is sufficiently distinct) - ultimately successfully authenticated the server against both the (optionally) CA-signed certificate, and the ECH key fetched from the DNS. This has given the client two \"roots of trust\" for the authentication of their connection!\r\n\r\nHowever, currently, a server can reject ECH in a number of ways (negotiating TLS < 1.3, using ClientHelloOuter, etc). In such a case we fall back to only the CA as the root of trust. The simplest approach to allowing a server to opt in to the dual root of trust required world would be to add a bit in the HTTPS RR which indicates that a client which supports ECH MUST return a failure to the calling application if the server rejects ECH (after all retry_configs have been exhausted, if any).\r\n\r\nThis does end up with a similar result as DANE (where if the server tries to authenticate with a cert other than the specified one, failure occurs). However, it has a number of advantages over DANE - (a) obviously the implementation path I mentioned above, (b) it doesn't require checking the DNSSEC AD flag on the client, which was a major sticking point for DANE integration in browsers (these days with DoH this could be revisited given checking the AD flag is trivial now, but I'm not holding my breath), (c) doesn't require DNSSEC on the domain (which was also a major sticking point for DANE adoption, though things are shifting glacially for email). As described in 10.2 of the current ECH draft-15 while DNSSEC is an additional defense, worry over this bit being \"misused\" to break handshakes via poising or so isn't a big concern.\r\n\r\nAlternatively, the server could be allowed to reject ECH with proof that it has decrypted the inner client hello, but that's likely substantially more complexity especially at this later stage of the design.",
          "createdAt": "2023-03-27T01:40:28Z",
          "updatedAt": "2023-03-27T02:16:02Z"
        },
        {
          "author": "dennisjackson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As far as I understand the proposal, you'd like to add a 1-bit field to ECHConfig which if set will require clients to fail with an error if they can't connect with ECH. If not set, clients follow the current behaviour of falling back to non-ECH if the server securely disables ECH, otherwise they fail with an error.\r\n\r\nI don't agree with your analysis. If you're concerned with a CA MiTM, you can't rely on the DoH channel being secure but you're also explicitly saying clients don't need to check DNSSEC. Without at least checking DNSSEC, you aren't actually getting a second root of trust, but you are risking significant breakage from misconfiguration which ECH is designed to avoid. \r\n\r\nIf you want to mitigate CA MiTM, I think you need DANE (and DNSSEC) and we shouldn't try to glue a DANE-like mode on to ECH. ",
          "createdAt": "2023-03-27T02:39:37Z",
          "updatedAt": "2023-03-27T02:39:37Z"
        },
        {
          "author": "TheBlueMatt",
          "authorAssociation": "NONE",
          "body": "> I don't agree with your analysis. If you're concerned with a CA MiTM, you can't rely on the DoH channel being secure but you're also explicitly saying clients don't need to check DNSSEC. \r\n\r\nI wasn't assuming a DoH channel to some third party DoH provider? If my DNS is local that isn't an issue. Further, if my DNS is my ISP and the server gets BGP hijacked or their ISP is compromised, adding a second root of trust outside CAs also adds value. There are, of course, many many potential attacks which this doesn't help with, but there are absolutely real setups where this provides a meaningful difference.\r\n\r\n> Without at least checking DNSSEC, you aren't actually getting a second root of trust\r\n\r\nSure you are, just not necessarily a particularly secure one! Luckily ~every DNS resolver software written in the past 20 years validates DNSSEC by default, so as long as your connection to your resolver is secure (which for many people it is, within reason, though definitely not all!) you've got a pretty reasonable second root of trust.\r\n\r\n> but you are risking significant breakage from misconfiguration which ECH is designed to avoid.\r\n\r\nWhich issues specifically are you concerned about? Presumably the largest issue here would be setting the bit and forgetting it while rotating the ECH key, so I'll assume you meant that.\r\n\r\nLuckily, the retry_configs already offer good key rotation support, so its very possible to do this safely. In general, having this be opt-in largely addresses it - if you're not someone who can do careful key management (eg because this stuff isn't automated between the web server/dns server boundary), you simply won't use it. Naming it something scary also usually helps :).\r\n\r\nWhile DNSSEC suffers from a generally much worse version of this issue (losing your keys or rotating them leaves your zone inoperable, but generally with a much, much, much higher TTL than most modern A/AAAA records for TLS servers), and yet we see incredibly few issues of this sort. This is in part because the idea of this kind of zone-bricking is scary, preventing lots of adoption, but also it causes deployment to generally be very justifiably cautious. With reasonable communication of the potential outcome, engineers managing this stuff get very careful :)\r\n\r\n> If you want to mitigate CA MiTM, I think you need DANE (and DNSSEC) and we shouldn't try to glue a DANE-like mode on to ECH.\r\n\r\nIf web browsers were chomping at the bit to implement DNSSEC verification (or at least check the AD flag), check DANE records, and website admins were chomping at the bit to opt into DNSSEC, I'd probably agree with you. But for many reasons none of those are true, so for the purposes of this discussion I think we'd be much more realistic by assuming DANE didn't exist.",
          "createdAt": "2023-03-27T03:06:08Z",
          "updatedAt": "2023-03-27T03:06:08Z"
        },
        {
          "author": "dennisjackson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > but you are risking significant breakage from misconfiguration which ECH is designed to avoid.\r\n> \r\n> Which issues specifically are you concerned about? Presumably the largest issue here would be setting the bit and forgetting it while rotating the ECH key, so I'll assume you meant that.\r\n\r\nI'm concerned about clients in an enterprise or educational network which performs TLS MiTM. Right now, ECH will gracefully degrade for them as they'll get a secure fallback signal. This is critical to the adoption of ECH. \r\n\r\nWith your change, these networks will need to prevent clients from receiving an EchConfig with the no-fallback bit set otherwise the website will break. Note that in this case there is no security improvement for your proposal because these devices have already had a root installed by the user or administrator. \r\n\r\n> \r\n> > If you want to mitigate CA MiTM, I think you need DANE (and DNSSEC) and we shouldn't try to glue a DANE-like mode on to ECH.\r\n> \r\n> If web browsers were chomping at the bit to implement DNSSEC verification (or at least check the AD flag), check DANE records, and website admins were chomping at the bit to opt into DNSSEC, I'd probably agree with you. But for many reasons none of those are true, so for the purposes of this discussion I think we'd be much more realistic by assuming DANE didn't exist.\r\n\r\nYour position seems to be simultaneously that DNSSEC is widely used and that no one uses DNSSEC. If we're agreeing that website admins are reluctant to opt in to DNSSEC (let alone DANE), then why do you think opting in to noFallback ECH is going to be likely? ",
          "createdAt": "2023-03-27T04:26:07Z",
          "updatedAt": "2023-03-27T04:26:07Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "For some of the same brittleness reasons as Dennis, I'm skeptical of this idea. More importantly, however, this seems like something that's orthogonal to the purpose of ECH, so I don't think we should make it part of this spec.\r\n\r\nFortunately, ECH supports [extensions](https://datatracker.ietf.org/doc/html/draft-ietf-tls-esni-15#name-encrypted-clienthello-confi) so it would be straightforward to define an extension for this.",
          "createdAt": "2023-03-27T04:39:55Z",
          "updatedAt": "2023-03-27T04:39:55Z"
        },
        {
          "author": "TheBlueMatt",
          "authorAssociation": "NONE",
          "body": "> I'm concerned about clients in an enterprise or educational network which performs TLS MiTM. Right now, ECH will gracefully degrade for them as they'll get a secure fallback signal. This is critical to the adoption of ECH.\r\n\r\nDidn't we have this whole debate with TLS 1.3 to begin with? I understood the conclusion there to be a resounding \"we don't degrade the security of the web for enterprises that want to do MiTM\"? Why is that different here?\r\n\r\n> With your change, these networks will need to prevent clients from receiving an EchConfig with the no-fallback bit set otherwise the website will break. Note that in this case there is no security improvement for your proposal because these devices have already had a root installed by the user or administrator.\r\n\r\nIndeed, that seems totally fine? In an enterprise environment where TLS MiTM is required, whatever existing scheme for MiTM they use which provides plaintext/decryption keys will continue to work fine with or without ECH. If management only wants to see the SNI field for monitoring, it would be rather trivial to simply unset any ECH-required bit at the DNS level or simply drop the HTTPS RR responses entirely, which such systems seem likely to do with or without an ECH-required bit.\r\n\r\n> Your position seems to be simultaneously that DNSSEC is widely used and that no one uses DNSSEC. If we're agreeing that website admins are reluctant to opt in to DNSSEC (let alone DANE), then why do you think opting in to noFallback ECH is going to be likely?\r\n\r\nDNSSEC validation is widely deployed (since it is default in ~every DNS resolver made in the past 20 years). DNSSEC signing of domains is relatively rare, for many reasons (including fear over bricking domains, outdated views of the security of DNSSEC, etc), though seeing some moderate adoption in the email world.\r\n\r\nDANE validation in the browser world has ~0 adoption, for many reasons (the last time we tried DNSSEC did have weaker keys than folks would like, the above DNSSEC-signing fears preventing adoption, system resolvers not exposing the AD flag or TLSA records, trusting ISP DNS resolverss to provide authentication keys, etc, etc). With DoH becoming more popular, the AD flag carries even less meaning than it used to (now you're explicitly trusting a third-party rather than some server presumably operated by even your ISP), so I'm highly doubtful this will change, and not for no reason.\r\n\r\nI'd hope we don't disagree on any of that?\r\n\r\nMany of those issues do not apply to any noFallback ECH - while its conceptually similar DANE (at least when still requiring a CA-signed trusted cert), the avoidance of DNSSEC here provides for a rather huge potential difference in adoption - instead of being forced to opt your entire zone into a potentially-bricking scheme where you have no control over the TTL and you have a whole new set of key material to worry about, this reuses key material you were already going to be adding, allows you to opt in only at the single hostname level, and avoids any of the legacy DNSSEC key insecurity fears, not to mention the debate around DNSSEC operational concerns.\r\n\r\n> More importantly, however, this seems like something that's orthogonal to the purpose of ECH, so I don't think we should make it part of this spec.\r\n\r\nIn the general \"the goal of ECH is to encrypt the client hello\" view, I'd say that's fair. But in the more practical sense that we have now added a DNS-provided key exchange, it seems entirely within the purpose. Not to mention given the simplicity of actually implementing it seems more than worth it? It provides us an opportunity to not just improve privacy on the web with SNI encryption, but also a genuine substantial security improvement with an extra bit and a few conditionals - that seems like it should be more than worth it!\r\n\r\n> Fortunately, ECH supports [extensions](https://datatracker.ietf.org/doc/html/draft-ietf-tls-esni-15#name-encrypted-clienthello-confi) so it would be straightforward to define an extension for this.\r\n\r\nSadly I think its pretty clear the adoption of such an extension would be a substantial uphill battle. Instead of this security improvement being there on day one, now we have to go through a process of convincing browsers to add an extension, define it as a spec, get that through the IETF process (which in practice some/most? TLS vendors would want to see), etc, etc. Sadly I don't have the substantial time commitment available for such a thing, and given this conversation it sounds like no one else is going to do it :)",
          "createdAt": "2023-03-27T16:21:42Z",
          "updatedAt": "2023-03-27T16:21:42Z"
        },
        {
          "author": "dennisjackson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > I'm concerned about clients in an enterprise or educational network which performs TLS MiTM. Right now, ECH will gracefully degrade for them as they'll get a secure fallback signal. This is critical to the adoption of ECH.\r\n> \r\n> Didn't we have this whole debate with TLS 1.3 to begin with? I understood the conclusion there to be a resounding \"we don't degrade the security of the web for enterprises that want to do MiTM\"? Why is that different here?\r\n\r\nTLS1.3 gracefully falls back to TLS1.2 (with correctly implemented devices). Similarly, ECH gracefully falls back to non-ECH. In both cases the fallback mechanism is authenticated the same way (to a valid cert for the domain). \r\n> \r\n> > With your change, these networks will need to prevent clients from receiving an EchConfig with the no-fallback bit set otherwise the website will break. Note that in this case there is no security improvement for your proposal because these devices have already had a root installed by the user or administrator.\r\n> \r\n> Indeed, that seems totally fine? In an enterprise environment where TLS MiTM is required, whatever existing scheme for MiTM they use which provides plaintext/decryption keys will continue to work fine with or without ECH. \r\n\r\nIt won't work though, because their MiTM with a locally installed root on a server that doesn't support ECH looks just like a CA MiTM to the client. Your noFallback bit will cause these connections to fail. \r\n\r\n> Many of those issues do not apply to any noFallback ECH - while its conceptually similar DANE (at least when still requiring a CA-signed trusted cert), the avoidance of DNSSEC here provides for a rather huge potential difference in adoption [...]\r\n\r\nMy main concern here is the breakage I described above, which I don't see any way to address. \r\n",
          "createdAt": "2023-03-29T04:45:02Z",
          "updatedAt": "2023-03-29T04:45:02Z"
        },
        {
          "author": "TheBlueMatt",
          "authorAssociation": "NONE",
          "body": "\n> It won't work though, because their MiTM with a locally installed root on a server that doesn't support ECH looks just like a CA MiTM to the client. Your noFallback bit will cause these connections to fail.\n> My main concern here is the breakage I described above, which I don't see any way to address.\n\n\"Clients MAY ignore the noFallback bit if the certificate authority which is ultimately trusted in the certificate path provided by the server was installed through administrator intervention.\" :) \n\n(Okay I know it's not *that* simple and a pretty awkward carve-out, but on most platforms, or at least in most browser contexts, you can determine if a CA was system-default or not, and it does solve this case. If the goal is narrowly the MITM-CA case, this seems like a reasonable tradeoff.)\n\nAlternatively, clients could simply ignore the bit if *any* modification to the system CA store has been made.\n\n> TLS1.3 gracefully falls back to TLS1.2 (with correctly implemented devices). Similarly, ECH gracefully falls back to non-ECH. In both cases the fallback mechanism is authenticated the same way (to a valid cert for the domain).\n\nApologies for the confusion, my comment was in reference to the more general philosophy here of not allowing middlebox upgrade concerns to dominate security decisions and not the specific fallback argument.\n\nCan you more clearly define the fallback design goal? While clients & servers may fall back from TLS1.3 to TLS1.2, they certainly aren't required to. Increasingly few sites support TLS prior to 1.2, and 1.3-required isn't all that wild to see on the open internet.\n\nAny monitoring systems built which relied on null cipher options are increasingly breaking if they intended to work with general TLS, or in fact any MITM appliances which intended to work with all real-world TLS traffic which don't yet support TLS 1.3.\n\nBackwards compatibility on the web is obviously absolutely critical, including through already deployed middleboxes. However, we also move forward. Real-world applications drop support for old protocols - there are several popular TLS libraries that *only* support TLS 1.3. If middleboxes expect to MITM TLS and work with general internet TLS traffic, over the course of protocol adoption lifetimes they have to adapt. Nothing any IETF WG says or does can change that.\n\nLuckily, in this case, adaptation is trivial. If the client is using DoH the same appliance MITMing all TLS is already MITMing DNS, and if not DNS likely the simplest internet protocol to MITM (if they aren't already). Alternatively, any client with software which installed a CA can also trivially disable the enforcement of such a noFallback option - if browser or other TLS client vendors are concerned about adoption with this feature, allowing it to be disabled should address that.\n\nMore generally, your argument applies to *any* change to browser or other client activity which changes to enforce new rules or otherwise behaves differently at all. If such concerns were absolute DANE would be entirely off the table, as would browsers moving automatically to DoH, or even ECH itself. After all, there are many monitoring middleboxes (including on my network!) which read SNI data and can react to it, not to mention that nation state firewalls blocked ESNI when it originally shipped (they may not this time around thanks to GREASE, but there's no guarantee!). I hope we aren't in a world where we can't have nice things :).\n\nAs browsers did with the automated DoH rollout, checking if enforcement breaks connectivity to a sentinel host would allow for seamless fallback on networks on which it results in connection \nfailure. It wouldn't be unreasonable to tell clients they SHOULD check for such breakage prior to enforcing a new noFallback option.",
          "createdAt": "2023-03-29T07:11:21Z",
          "updatedAt": "2023-03-29T08:15:22Z"
        },
        {
          "author": "dennisjackson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> \"Clients MAY ignore the noFallback bit if the certificate authority which is ultimately trusted in the certificate path provided by the server was installed through administrator intervention.\" :)\r\n> \r\n> (Okay I know it's not _that_ simple and a pretty awkward carve-out, but on most platforms, or at least in most browser contexts, you can determine if a CA was system-default or not, and it does solve this case. If the goal is narrowly the MITM-CA case, this seems like a reasonable tradeoff.)\r\n\r\nUnfortunately some of those installed CAs are also the ones we're most concerned by. E.g. the current situation with the Russian Domestic CA. Definitely something this fallback bit should prevent, but it appears just like a user installed CA and so with your proposal would not be protected against... \r\n \r\n> > TLS1.3 gracefully falls back to TLS1.2 (with correctly implemented devices). Similarly, ECH gracefully falls back to non-ECH. In both cases the fallback mechanism is authenticated the same way (to a valid cert for the domain).\r\n> \r\n> Apologies for the confusion, my comment was in reference to the more general philosophy here of not allowing middlebox upgrade concerns to dominate security decisions and not the specific fallback argument.\r\n> \r\n> Can you more clearly define the fallback design goal? While clients & servers may fall back from TLS1.3 to TLS1.2, they certainly aren't required to. Increasingly few sites support TLS prior to 1.2, and 1.3-required isn't all that wild to see on the open internet.\r\n\r\nWhomever owns a valid TLS certificate for the domain (validity as determined by the client), controls the fallback behaviour. Whether that's to non-ECH or non-TLS1.3 or whatever. This is the property that TLS and its extensions ensure. \r\n \r\n> Luckily, in this case, adaptation is trivial. If the client is using DoH the same appliance MITMing all TLS is already MITMing DNS, and if not DNS likely the simplest internet protocol to MITM (if they aren't already). Alternatively, any client with software which installed a CA can also trivially disable the enforcement of such a noFallback option - if browser or other TLS client vendors are concerned about adoption with this feature, allowing it to be disabled should address that.\r\n\r\nAs I stated, the competence of the IT teams operating this middlebox infrastructure is usually extremely low. I'm doubtful they can reliably filter DNS and based on the error reports users send to us.... getting them to either install CAs into Firefox's specific root store or flip the Firefox pref to use the OS store is already difficult enough.  \r\n\r\n> More generally, your argument applies to _any_ change to browser or other client activity which changes to enforce new rules or otherwise behaves differently at all. If such concerns were absolute DANE would be entirely off the table, as would browsers moving automatically to DoH, or even ECH itself. After all, there are many monitoring middleboxes (including on my network!) which read SNI data and can react to it, not to mention that nation state firewalls blocked ESNI when it originally shipped (they may not this time around thanks to GREASE, but there's no guarantee!). I hope we aren't in a world where we can't have nice things :).\r\n\r\nMoving to DoH and ECH doesn't break the invariant I mentioned above. Moving to DANE and/or this proposal does. It also delivers very marginal gains, considering the rarity of CA MiTM in practice. \r\n\r\n> As browsers did with the automated DoH rollout, checking if enforcement breaks connectivity to a sentinel host would allow for seamless fallback on networks on which it results in connection failure. It wouldn't be unreasonable to tell clients they SHOULD check for such breakage prior to enforcing a new noFallback option.\r\n\r\nAn attacker capable of CA MiTM would break connectivity to the sentinel host as a prelude to starting their attack...\r\n",
          "createdAt": "2023-04-06T16:04:07Z",
          "updatedAt": "2023-04-06T16:04:07Z"
        },
        {
          "author": "TheBlueMatt",
          "authorAssociation": "NONE",
          "body": "> Unfortunately some of those installed CAs are also the ones we're most concerned by. E.g. the current situation with the Russian Domestic CA. Definitely something this fallback bit should prevent, but it appears just like a user installed CA and so with your proposal would not be protected against...\r\n\r\n> An attacker capable of CA MiTM would break connectivity to the sentinel host as a prelude to starting their attack...\r\n\r\nWe can't have it both ways - as I pointed out in my earlier response *any* improvement in the security model of TLS will result in breakage in any case where someone installs a malicious/MiTMing root CA. If you hold the view that we must not break such a thing, then you can avoid breaking them. If you hold the view that we should break such things, then you can break them. I don't think that has anything to do with this proposal, but is rather a fundamental tradeoff in any security improvement to TLS.\r\n\r\nI sincerely hope we're not in a world where we can't have nice things :)\r\n\r\n> > Can you more clearly define the fallback design goal? While clients & servers may fall back from TLS1.3 to TLS1.2, they certainly aren't required to. Increasingly few sites support TLS prior to 1.2, and 1.3-required isn't all that wild to see on the open internet.\r\n\r\n> Whomever owns a valid TLS certificate for the domain (validity as determined by the client), controls the fallback behaviour. Whether that's to non-ECH or non-TLS1.3 or whatever. This is the property that TLS and its extensions ensure.\r\n\r\nHeh, I meant describing the *why* of the goal in specifics, what can/should/mustnot/etc be impacted by any change.\r\n\r\n> As I stated, the competence of the IT teams operating this middlebox infrastructure is usually extremely low. I'm doubtful they can reliably filter DNS and based on the error reports users send to us.... getting them to either install CAs into Firefox's specific root store or flip the Firefox pref to use the OS store is already difficult enough.\r\n\r\nThen they've already been broken by TLS 1.2, and soon 1.3 (there's discussion on deprecating TLS 1.2 now!) because they didn't support those when they installed the machine, and will be equally broken by any change to TLS which is eventually required, or any improvement to the TLS security model. I'd really like to better understand the concrete goal here, because \"don't break deployed things\" isn't sufficiently detailed.",
          "createdAt": "2023-04-07T02:58:48Z",
          "updatedAt": "2023-04-07T02:58:48Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the discussion here, folks! Given that this is being proposed as an option, I think the best course of action is to write up this capability as an ECH extension in a separate draft. We can then discuss the semantics of the option separately. I'm going to close this issue with that as the recommended next step.",
          "createdAt": "2023-10-09T21:28:22Z",
          "updatedAt": "2023-10-09T21:28:22Z"
        }
      ]
    },
    {
      "number": 548,
      "id": "I_kwDOB-yxNc5sUa3O",
      "title": "DTLS 1.3 reference",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/548",
      "state": "CLOSED",
      "author": "sayrer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "`ECH is only supported with (D)TLS 1.3 [[RFC8446](https://www.ietf.org/archive/id/draft-ietf-tls-esni-16.html#RFC8446)] and newer versions of the protocol.`\r\n\r\nThere should probably be a reference to [RFC9147](https://datatracker.ietf.org/doc/rfc9147/) here, and then in the normative references.",
      "createdAt": "2023-07-23T20:51:09Z",
      "updatedAt": "2023-09-20T18:46:21Z",
      "closedAt": "2023-09-20T18:46:21Z",
      "comments": []
    },
    {
      "number": 549,
      "id": "I_kwDOB-yxNc5sUwD0",
      "title": "HPKE reference",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/549",
      "state": "CLOSED",
      "author": "sayrer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The draft still refers to I-D.irtf-cfrg-hpke, but it's [RFC9180](https://datatracker.ietf.org/doc/html/rfc9180) now.",
      "createdAt": "2023-07-24T00:25:47Z",
      "updatedAt": "2023-09-20T18:46:22Z",
      "closedAt": "2023-09-20T18:46:22Z",
      "comments": []
    },
    {
      "number": 551,
      "id": "I_kwDOB-yxNc5u_G4z",
      "title": "Question related to section 10.9.3 (Prevent SNI-Based Denial-of-Service Attacks)",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/551",
      "state": "CLOSED",
      "author": "louisroyer",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": ">  This attack is bound by the number of valid TCP connections an attacker can open.\r\n\r\nIs this really only true for TCP or should \"**TCP** connections\" be replaced by \"**transport** connections\" ?",
      "createdAt": "2023-08-22T19:05:11Z",
      "updatedAt": "2023-10-12T15:15:33Z",
      "closedAt": "2023-10-12T15:15:33Z",
      "comments": []
    },
    {
      "number": 554,
      "id": "I_kwDOB-yxNc5yGngO",
      "title": "Move ECH references over to draft-ietf-tls-svcb-ech",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/554",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In https://github.com/tlswg/draft-ietf-tls-esni/pull/553/files we added registration of the \"ech\" codepoint.  It is also in draft-ietf-tls-svcb-ech which will be confusing if they are both updating the codepoint.  We likely want to remove this registration and update SVCB/HTTPS RR references to point to draft-ietf-tls-svcb-ech.",
      "createdAt": "2023-09-26T21:34:16Z",
      "updatedAt": "2023-10-12T15:17:01Z",
      "closedAt": "2023-10-12T15:17:01Z",
      "comments": []
    },
    {
      "number": 555,
      "id": "I_kwDOB-yxNc5ycNcn",
      "title": "Do ECHConfig extensions use the same ExtensionType enum from TLS?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/555",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I'm not sure how I only noticed this now, but `ECHConfigContents` reuses the TLS `Extension` structure...\r\n\r\n```\r\n    struct {\r\n        ExtensionType extension_type;\r\n        opaque extension_data<0..2^16-1>;\r\n    } Extension;\r\n```\r\n\r\nThat would suggest ECH uses the same `ExtensionType` enum as TLS extensions. I.e. we share a codepoint space and registry. But then we don't do anything with the \"TLS 1.3\" column. We also introduce our own rule here:\r\n\r\n> An extension can be tagged as mandatory by using an extension type codepoint with the high order bit set to 1.\r\n\r\nBut if it's meant to be a separate enum, we haven't defined the name of the enum or a registry or anything, it's unclear how anyone could allocate them. We'd probably also need our own struct definition to inject the new enum in there.",
      "createdAt": "2023-09-29T23:04:37Z",
      "updatedAt": "2023-10-12T15:22:19Z",
      "closedAt": "2023-10-12T15:22:19Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I concur with @davidben here, and I think we just need a new registry.\r\n",
          "createdAt": "2023-10-01T19:00:08Z",
          "updatedAt": "2023-10-01T19:00:25Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 to a new registry, I'd be even happier if we ditched the concept entirely and left extensibility to only be exercised via the TLS extension code-point; if we're not willing to do that then I'd be moderately happy if we removed the mandatory ECHConfig idea - deploying one of those is really going to be like a new TLS extension code-point so there's no benefit I think\r\n\r\nnote: I expect I'm probably in the rough there but no harm trying:-)\r\n",
          "createdAt": "2023-10-01T19:57:09Z",
          "updatedAt": "2023-10-01T19:57:29Z"
        }
      ]
    },
    {
      "number": 565,
      "id": "I_kwDOB-yxNc5zVg_T",
      "title": "Requirements language around retry configs may be too strong",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/565",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See [this comment](https://github.com/tlswg/draft-ietf-tls-esni/pull/562/files#r1351063150) and also [this comment](https://github.com/tlswg/draft-ietf-tls-esni/pull/562#discussion_r1351054280).",
      "createdAt": "2023-10-10T10:35:49Z",
      "updatedAt": "2023-10-18T14:26:54Z",
      "closedAt": "2023-10-18T14:26:54Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I'll address this after #562 lands.",
          "createdAt": "2023-10-10T10:49:08Z",
          "updatedAt": "2023-10-10T10:49:08Z"
        }
      ]
    },
    {
      "number": 567,
      "id": "I_kwDOB-yxNc5zYtVW",
      "title": "Are mandatory ECH extensions deployable?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/567",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We currently have a way to mark ECH extensions as mandatory via the high-bit of their codepoint.\r\n\r\nI can't see a way in which that's deployable without being the equivalent of cutting a new codepoint for the ECH TLS extension.\r\n\r\nDo we have any outline scenarios that indicate this mandatory ECH extension mechanism is deployable? \r\n\r\nIf not, it may be better to remove it. (I'd be for removing it:-)",
      "createdAt": "2023-10-10T17:16:19Z",
      "updatedAt": "2023-11-06T08:55:03Z",
      "closedAt": "2023-11-06T08:55:03Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure what you mean by deployable. The compatibility requirement here is just that clients know to skip over mandatory extensions, just like they need to know to skip over unknown codepoints.\r\n\r\nMandatory extensions are very similar to cutting a new top-level version, yes. That's generally true in any protocols. The main difference is in how to coordinate changes. We could have cut extensions out of TLS entirely and simply bumped the version every time we wanted to extend it. (Extension lists were an IETF innovation. SSL 3.0 did not have them and extended by appending to the ClientHello.) Indeed in a protocol from a single vendor, that is probably a better and simpler extensibility strategy. But in the IETF's multi-vendor protocols, it can be useful for extensions to be defined, implemented, and deployed at different rates. Thus, extension lists, with their various semantics on how to handle unknown ones.\r\n\r\nWhether extending ECH rises to this sort of thing being useful, I don't know. But I don't think the question is deployability, nor is the litmus test _simply_ whether it's equivalent to bumping the top-level version. That litmus test would knock out every extension scheme the IETF has ever produced. :-)",
          "createdAt": "2023-10-10T18:14:34Z",
          "updatedAt": "2023-10-10T18:15:18Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "> The compatibility requirement here is just that clients know to skip over mandatory extensions, just like they need to know to skip over unknown codepoints.\r\n\r\nIs that the case? Doesn't a client need to skip over an entire ECHConfig if it encounters a mandatory extension that it does not support?",
          "createdAt": "2023-10-10T18:27:27Z",
          "updatedAt": "2023-10-10T18:27:27Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, sorry, sloppy phrasing on my part. I meant skip over the whole ECHConfig.",
          "createdAt": "2023-10-10T19:20:16Z",
          "updatedAt": "2023-10-10T19:20:16Z"
        },
        {
          "author": "dennisjackson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I have a **hypothetical** use case for mandatory extensions. Let's call this extension \"Alternative Cover Names\". It contains a list of website names as a payload. If ECH is rejected, the client should authenticate the resulting connection against the cover name or any of the website names in this extension, accepting the retry ECHConfigs if any verification succeeds. This extension needs to be mandatory, because otherwise clients which don't support the extension will only validate against the cover name and won't be able to retrieve retry configs.\r\n\r\nI'd much rather keep the mandatory byte, it allows for a much wider range of experimentation than non-mandatory extensions. ",
          "createdAt": "2023-10-10T19:23:03Z",
          "updatedAt": "2023-10-10T19:23:18Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "Fair enough that it's a hypothetical but won't servers who want to use that need to publish two ECHConfigs one with, and one without, your new ACN extension? So that'd mean they still need to be able to authenticate retry_configs using the public_name from the ECHConfig without ACN, reducing the hypothetical benefit a lot? I guess I'm just skeptical that this'll turn out to be a useful bit (not byte:-) in the ECH extension codepoints,\r\n\r\nWRT experiments, I do think those'd be better done using a different TLS extension codepoint in general, though fair enough that that's not a strong argument.",
          "createdAt": "2023-10-10T19:29:50Z",
          "updatedAt": "2023-10-10T19:29:50Z"
        },
        {
          "author": "dennisjackson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The value of (mandatory) extensions is that you can combine orthogonal ones in way that is tedious with codepoint bumps. I don't want to speculate about how the ecosystem could develop, but I'd rather keep the flexibility to allow folks to find their own use cases. It's a tiny amount of complexity in terms of implementation. ",
          "createdAt": "2023-10-10T19:35:25Z",
          "updatedAt": "2023-10-10T19:35:45Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "It's true that if we have ECH extensions, the additional code complexity of handling the mandatory bit is tiny. (I'd prefer we just get rid of ECH extensions entirely, but seem to have lost that argument:-)\r\n\r\nOTOH, is there any history of mandatory extensions being successful in IETF protocols? I think the experience with e.g. X.509 criticality shows that at least didn't work, but maybe there's some example somewhere that did, I dunno.",
          "createdAt": "2023-10-10T20:08:03Z",
          "updatedAt": "2023-10-10T20:08:03Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the headache with X.509 is only somewhat analogous. The ecosystem around X.509 moves much, much more slowly, and is often deployed in problematic ways. (This thing where servers have a single certificate chain for all clients is such a mess.)\r\n\r\nAnd then protocol-wise, X.509 made criticality a decision you make when you encode the individual field. Sometimes an extension is critical and sometimes it isn't. ECH extensions avoid this and make it part of the codepoint. I.e., it's a decision we make when we _design_ the field.\r\n\r\nWhen we use extension points, we need to reason about what happens when one side is older and the other side is newer. A lot of protocol engineering is trying to get the right thing to happen. Things like critical/mandatory extensions, etc., are tools in our toolbox for getting that right thing to happen. If we're in a context where sometimes we want the older receiver to ignore it, and sometimes we want them to reject it, that's exactly what a mandatory bit is for.\r\n\r\nYou don't see this in TLS only because TLS is a very online protocol, so one side can just say \"I know about this\" and everything flows from there. ECH and X.509 are different because the relevant structures are much more static.",
          "createdAt": "2023-10-10T20:25:54Z",
          "updatedAt": "2023-10-10T20:25:54Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "Reasonable points, but count me unconvinced. I'll leave it there for now, and I guess if others don't chime in arguing to remove the feature, it'll be ok to close this issue.",
          "createdAt": "2023-10-10T20:35:15Z",
          "updatedAt": "2023-10-10T20:35:15Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing per discussion at IETF 118.",
          "createdAt": "2023-11-06T08:55:03Z",
          "updatedAt": "2023-11-06T08:55:03Z"
        }
      ]
    },
    {
      "number": 568,
      "id": "I_kwDOB-yxNc5zqBR-",
      "title": "Make anonymity set references consistent (reference single definition?)",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/568",
      "state": "CLOSED",
      "author": "klinvill",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As mentioned in #560, there's slightly different language when referencing anonymity sets. Specifically, the Introduction mentions that co-located servers with `consistent externally visible TLS configurations` form an anonymity set. The Security and Privacy Goals section states that `The set of hosts which share the same ECHConfig and TLS configuration is referred to as the anonymity set`. To me there's a subtle difference here in that I understand the `externally visible TLS configurations` is meant to apply to all externally observable behavior, but my impression when just seeing `ECHConfig and TLS configuration` is that these are referring to user-provided TLS configurations which don't encompass all externally observable behavior.\r\n\r\nOne way to fix this is simply to make the phrasing consistent, but I think it would be even nicer to have the term `anonymity set` clearly defined in a single, easily accessible location since it's central to the precise guarantees ECH aims to provide. Maybe it could be explicitly defined in the Conventions and Definitions section? Given a canonical definition, further usages of the anonymity set could just refer to that definition.\r\n\r\nMaybe other significant terms like Client-Facing Server could also be defined in a similar location too? ",
      "createdAt": "2023-10-12T16:48:15Z",
      "updatedAt": "2023-10-18T14:26:45Z",
      "closedAt": "2023-10-18T14:26:45Z",
      "comments": []
    },
    {
      "number": 572,
      "id": "I_kwDOB-yxNc50IpRR",
      "title": "Are we quite right now with \"MUST use public_name\"?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/572",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The spec currently says:\r\n\r\n'The value of ECHConfig.contents.public_name MUST be placed in the  \"server_name\" extension.'\r\n\r\nI've never been fond of that, but I think it's also overly restrictive. For example, tests I've done with my and others' servers indicate that servers do not insist on this, if ECH decryption worked, and I think the code is doing the right thing there.\r\n\r\nI've also included the capability for a command-line override of public_name (in the outer SNI) in the cURL code I've proposed to that project. The logic there is that could be useful for some circumvention applications in future - I don't know that is or will be true, but it seems good to preserve the flexibility. (That said only my client library code seems to have an API that allows that override as of now.)\r\n\r\nSo I'd suggest we modify the MUST quoted above and add a SHOULD NOT (or make any equivalent change), to e.g.:\r\n\r\n- Clients SHOULD place the ECHConfig.contents.public_name in the (outer) server_name extension, unless specifically overridden by application layer code\r\n- In the event of successful ECH decryption, servers SHOULD NOT insist that the outer server_name extension carries the public_name from an ECHConfig corresponding to the relevant ECH decryption key.\r\n\r\nI don't think we need to say anything new on this topic related to ECH decryption failures.\r\n",
      "createdAt": "2023-10-17T22:54:31Z",
      "updatedAt": "2023-11-06T08:51:31Z",
      "closedAt": "2023-11-06T08:51:31Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This is a dupe of #396, which we already closed in the past, perhaps maybe prematurely. Relaxing this to a SHOULD NOT would effectively reintroduce domain fronting, which is not something I think we want to encourage. If anything, I would suggest that servers willing to accept the risk of not enforcing this MUST opt in via an ECHConfig extension.",
          "createdAt": "2023-10-18T14:33:31Z",
          "updatedAt": "2023-10-18T14:33:31Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "Looking back at #396 (which I'd forgotten was an issue on here, sorry;-) I don't think it was clear that a MUST (as we have now) was really preferred over a SHOULD. \r\n\r\nThe suggested SHOULD NOT for servers above is based on just testing what the ones I know of, do now. (And of course it matches what I'd like too:-)\r\n\r\nI've no preference as to whether to close this and re-open #396 or not but I do think it's worth revisiting/rechecking this topic before we're done.",
          "createdAt": "2023-10-18T15:27:12Z",
          "updatedAt": "2023-10-18T15:27:12Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Based on your testing, what server implementations do not enforce this requirement?",
          "createdAt": "2023-10-18T17:32:00Z",
          "updatedAt": "2023-10-18T17:32:00Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "All few of them. Meaning those using my OpenSSL fork, those using CF's server code and tls-ech.dev which uses boringssl. I [added](https://github.com/sftcd/curl/commit/026f12e0aa93150ef31a177d50116ef2794d9d6e) some tests for this to my [cURL test script](https://github.com/sftcd/curl/blob/ECH-experimental/tests/ech_tests.sh). I checked with wireshark that the outer SNI was as expected (value == \"override\") when sending to CF.\r\n\r\nIf anyone knows of additional servers to add to test, I'd be happy to add 'em to my list.",
          "createdAt": "2023-10-18T18:45:22Z",
          "updatedAt": "2023-10-18T18:59:18Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If the connection works without one sure.  But there are two reasons that a client might want to include a public name.\r\n\r\n1. The server just doesn't work without one.  I can easily imagine a server implementation that routes to ECH logic based on the public SNI and fails otherwise.\r\n2. Fallback.  \r\n\r\nMaybe you can argue that a server can execute fallback with the public name without the client telling it what that public name is.  So maybe this is just one reason.\r\n\r\nWith a single reason you could imagine allowing the public name to be empty in the config.  The problem there would be if there is some sort of system that depends on having an SNI, which is likely.  In that case, you could use a fixed string instead.",
          "createdAt": "2023-10-19T00:57:42Z",
          "updatedAt": "2023-10-19T00:57:42Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "No, the argument here is not to omit the public_name, but rather to say, for clients, the outer SNI SHOULD be the public_name, and for servers, when ECH decryption worked, they SHOULD NOT care. When ECH decryption fails, then using the public_name will get better interop, hence the SHOULD for clients.",
          "createdAt": "2023-10-19T00:59:23Z",
          "updatedAt": "2023-10-19T00:59:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": ">  and for servers, when ECH decryption worked, they SHOULD NOT care\r\n\r\nThis just isn't true. Servers will care about this because, again, not caring about it just opens up the door to effectively domain front.",
          "createdAt": "2023-10-19T01:01:15Z",
          "updatedAt": "2023-10-19T01:01:15Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "If a server cares, that's fine. Saying all servers MUST care seem wrong. Esp since none currently seem to care.",
          "createdAt": "2023-10-19T01:04:21Z",
          "updatedAt": "2023-10-19T01:04:21Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> If a server cares, that's fine. Saying all servers MUST care seem wrong. Esp since none currently seem to care.\r\n\r\nI agree with this. I would be fine just relaxing this MUST to a SHOULD and describing the consequences of not enforcing this check for clients and servers.",
          "createdAt": "2023-10-19T01:05:22Z",
          "updatedAt": "2023-10-19T01:05:22Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd be ok with that.",
          "createdAt": "2023-10-19T01:06:02Z",
          "updatedAt": "2023-10-19T01:06:02Z"
        },
        {
          "author": "ckcr4lyf",
          "authorAssociation": "NONE",
          "body": "I'd talked about this a bit on the mailing list, but didn't receive much response there. (See: https://mailarchive.ietf.org/arch/msg/tls/HUG1CU0Q4PorZ7fD0yafVfj7VUY/)\r\n\r\nIs github the preferred discussion point for ECH rather than the mailing list? If so I will state my view of it here as well for those not on the mailing list",
          "createdAt": "2023-10-26T10:36:58Z",
          "updatedAt": "2023-10-26T10:36:58Z"
        },
        {
          "author": "ckcr4lyf",
          "authorAssociation": "NONE",
          "body": "FYI: My main point revolves around the public name \"leaking\" which website you're connecting to anyway, which was one of the problems with SNI initially (and how some ISPs such as Jio in India were blocking websites).\r\n\r\nUsing the public_name field only is viable if you're behind a big corporation like Cloudflare, but if you want to do it for your personal website it gets tricky (which \u6d9b\u53d4  mentioned here: https://mailarchive.ietf.org/arch/msg/tls/0yxB-VwM8ayf6QLWpqCBcrSCFT4/)",
          "createdAt": "2023-10-26T10:39:05Z",
          "updatedAt": "2023-10-26T10:39:05Z"
        }
      ]
    },
    {
      "number": 578,
      "id": "I_kwDOB-yxNc51eB8N",
      "title": "Trying to contribute but I cannot",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/578",
      "state": "CLOSED",
      "author": "taddhar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Am trying to be a good citizen here and trying to push my first PR but I cannot. \r\n\r\nCan somebody help me understand 1) if I can contribute? and 2) if yes which mistake am I doing?\r\n\r\n```\r\n> git push --set-upstream origin arnaud-dev-branch\r\nremote: Permission to tlswg/draft-ietf-tls-esni.git denied to taddhar.\r\nfatal: unable to access 'https://github.com/tlswg/draft-ietf-tls-esni.git/': The requested URL returned error: 403\r\n```",
      "createdAt": "2023-10-31T16:06:32Z",
      "updatedAt": "2023-10-31T16:48:14Z",
      "closedAt": "2023-10-31T16:38:10Z",
      "comments": [
        {
          "author": "cpu",
          "authorAssociation": "NONE",
          "body": "Hi @taddhar\r\n\r\nIt looks like you're trying to push your dev branch directly to the TLSWG repository and you don't have permission to do so. Instead, you should fork the repository to make your own copy, push your branch to your fork, and then open a pull request from your fork to this repo.\r\n\r\nTry following GitHub's [quickstart guide for forking a repository](https://docs.github.com/en/get-started/quickstart/fork-a-repo).",
          "createdAt": "2023-10-31T16:27:38Z",
          "updatedAt": "2023-10-31T16:27:38Z"
        },
        {
          "author": "taddhar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok thanks I will do my best to follow this guidance and happy to learn something new. Sorry to be a rookie, doing my best to ramp-up. Glad I did a small test first.",
          "createdAt": "2023-10-31T16:44:30Z",
          "updatedAt": "2023-10-31T16:48:14Z"
        }
      ]
    },
    {
      "number": 580,
      "id": "I_kwDOB-yxNc51ejNG",
      "title": "My first PR - did I do it correctly?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/580",
      "state": "CLOSED",
      "author": "taddhar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Ok thanks to answers on #578 I did my best to follow the instructions to create my first fork and as a result I did a first PR #579. \r\n\r\nPlease anyone keep educating me as these are my first steps. \r\n\r\nFor example should I have done my own branch on my own fork or updating my own main branch in my own fork is good enough?\r\n\r\nApart from that the PR itself is really a minor edit. I hope this helps a tiny bit and more to come. ",
      "createdAt": "2023-10-31T17:23:26Z",
      "updatedAt": "2023-11-03T09:55:40Z",
      "closedAt": "2023-11-03T09:55:39Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The process you followed for #579 is correct! Fork, create a branch, submit a PR. That's all there is to it.",
          "createdAt": "2023-11-03T09:55:40Z",
          "updatedAt": "2023-11-03T09:55:40Z"
        }
      ]
    },
    {
      "number": 583,
      "id": "I_kwDOB-yxNc52QPAC",
      "title": "IANA Considerations: DTLS-Only values",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/583",
      "state": "CLOSED",
      "author": "seanturner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Need to indicate whether the \"DTLS-only\" column is Y or N for the extensions in s11.1.",
      "createdAt": "2023-11-08T16:20:56Z",
      "updatedAt": "2023-11-08T16:33:08Z",
      "closedAt": "2023-11-08T16:33:08Z",
      "comments": []
    },
    {
      "number": 585,
      "id": "I_kwDOB-yxNc52QXZg",
      "title": "s11.1 item 2: include \"TLS 1.3\" column values",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/585",
      "state": "CLOSED",
      "author": "seanturner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Need to indicate where extension can appear.",
      "createdAt": "2023-11-08T16:40:29Z",
      "updatedAt": "2024-02-17T15:25:23Z",
      "closedAt": "2024-02-17T15:25:23Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Done.",
          "createdAt": "2024-02-17T15:25:23Z",
          "updatedAt": "2024-02-17T15:25:23Z"
        }
      ]
    },
    {
      "number": 586,
      "id": "I_kwDOB-yxNc520Yrc",
      "title": "Server retry flow, section 7.1",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/586",
      "state": "CLOSED",
      "author": "sayrer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "propose to close"
      ],
      "body": "I understand why the last part of this section is there.\r\n\r\n`Otherwise, if all candidate ECHConfig values fail to decrypt the extension, the client-facing server MUST ignore the extension and proceed with the connection using ClientHelloOuter, ...`\r\n\r\nIs this part really a MUST, though? Maybe `if the server wishes to allow retries...`? I noticed that you can get the same effect by sending no `retry_configs` and refusing non-ECH connections, just with double the connection attempts. So why not allow `ech_failure` errors? Apologies if this part was already discussed, I might have missed it.",
      "createdAt": "2023-11-14T19:44:00Z",
      "updatedAt": "2024-02-24T23:47:49Z",
      "closedAt": "2024-02-24T23:47:49Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "This is really a MUST. The entire design of both the recovery flow and GREASE is predicated on this.\r\n\r\nThe recovery flow requires the server handshake with ClientHelloOuter in order to authenticate the retry signal. As a client, we would not be willing to deploy ECH if servers were not required to send a retry signal because it's far too much of a footgun and the end result is users cannot visit sites.\r\n\r\nEven, if we were to make the retry signal optional, this is necessary for GREASE to work. Consider a server transitioning from not deploying ECH to deploying ECH. Because DNS fundamentally may get out of sync with the server, there will be a period of time when the serving endpoint implements ECH, but the client does not realize it. (Cached DNS records, etc.) Such a client will then send ECH GREASE. To the server, ECH GREASE looks like a payload that cannot decrypt with any available ECH key. For such connections to work, the server must handshake with ClientHelloOuter.",
          "createdAt": "2023-11-14T21:21:07Z",
          "updatedAt": "2023-11-14T21:21:43Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Note this transition may also last indefinitely. It could well be that the server deploys ECH, has published ECH in the DNS, but for whatever reason, the client does not have those records. The client could be using a non-DoH DNS resolver where the records don't get through. The record may just fail to get through because DNS is flake. Or the client's local policy may have ECH disabled.\r\n\r\nEven if that client cannot take advantage of ECH, it may still send ECH GREASE to help prevent network ossification. But, again, that only works if servers all correctly handshake with ClientHelloOuter.\r\n",
          "createdAt": "2023-11-14T21:23:41Z",
          "updatedAt": "2023-11-14T21:23:41Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe I understand all of your points, and I agree with most of them, I think. My point is that you can still comply with the current draft, and have this flow:\r\n\r\n1) Fail to decrypt ECH, whether it's because of an invalid or stale ECHConfig, or GREASE\r\n2) Respond with no `retry_configs`\r\n3) Refuse any ClientHello messages without ECH (`\"SHOULD retry the handshake with a new transport connection and ECH disabled\"`)\r\n\r\nOne could also send a HelloRetryRequest with the wrong number of bytes in the encrypted_client_hello extension. So, there are a couple of ways to do this already. What I'm asking about here is whether there should be a way to signal \"you need an up-to-date ECHConfig, and the server is not going to supply one.\"",
          "createdAt": "2023-11-14T21:42:38Z",
          "updatedAt": "2023-11-14T22:05:25Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> What I'm asking about here is whether there should be a way to signal \"you need an up-to-date ECHConfig, and the server is not going to supply one.\"\r\n\r\nThere should not. The current protocol is that the server should supply one. This is important for ECH to be deployable.",
          "createdAt": "2023-11-14T23:27:27Z",
          "updatedAt": "2023-11-14T23:27:27Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > What I'm asking about here is whether there should be a way to signal \"you need an up-to-date ECHConfig, and the server is not going to supply one.\"\r\n> \r\n> There should not. The current protocol is that the server should supply one. This is important for ECH to be deployable.\r\n\r\nAh, but that is not the current protocol by my read. See the text `If the server is configured with any ECHConfig` and `If the server provided \"retry_configs\"...`. That means the server can be configured without them, or choose not to supply them, I think.\r\n\r\nI agree that most servers will want to supply these `retry_configs`.",
          "createdAt": "2023-11-14T23:42:09Z",
          "updatedAt": "2023-11-14T23:45:54Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "\"If the server is configured with any ECHConfigs\" refers to whether the server is capable of decrypting any encrypted ClientHellos at all. I.e. if it is not configured with any ECHConfigs, it does not have ECH enabled.\r\n\r\n'If the server provided \"retry_configs\"' is text for the client. The client needs to accommodate servers that do not implement this protocol. In particular, it's possible to offer ECH and find the server doesn't enable ECH if, e.g., the server had to rollback support for ECH in an emergency. In order for ECH to be safe for a server operator to enable, it must be safe to rollback in case something goes wrong with the deployment.\r\n\r\nThe rule is not that *most* servers will want to supply retry configs. The rule is that *all* servers that intend to enable ECH *must* supply retry configs. If they do not, they have not correctly enabled ECH.",
          "createdAt": "2023-11-15T00:25:03Z",
          "updatedAt": "2023-11-15T00:25:03Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> \r\n> The rule is not that _most_ servers will want to supply retry configs. The rule is that _all_ servers that intend to enable ECH _must_ supply retry configs. If they do not, they have not correctly enabled ECH.\r\n\r\nWell, I didn't read it that way at all. But you can still get this same behavior by supplying something in retry configs you know will not work.\r\n\r\n`If none of the values provided in \"retry_configs\" contains a supported version, or an earlier TLS version was negotiated, the client can regard ECH as securely disabled by the server`\r\n\r\nI don't think this part is right. The server could send an ECHConfig with an \"unsupported mandatory extension\", for example.\r\n\r\n",
          "createdAt": "2023-11-15T04:34:58Z",
          "updatedAt": "2023-11-15T04:34:58Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I suppose that depends on what how you read \"can regard as\". If a client sees an ECHConfigList in DNS with only incompatible ECHConfigs, it will not offer ECH. Likewise, if the client sees it in retry configs, it should retry without offering ECH. This is to repair DNS/endpoint mismatches, so it should act as if it saw that in DNS.\r\n\r\nAnyway, I'd suggest that if some of the wording isn't clear to you, put together a PR? Hopefully the intent of the spec is clearer now.",
          "createdAt": "2023-11-15T04:56:43Z",
          "updatedAt": "2023-11-15T04:56:43Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I can understand your point of view here. But even accepting everything you've written, you can still get the effect I described in the first post. It just costs two connections vs an error right away. I guess you could also send `handshake_failure` on the first attempt.",
          "createdAt": "2023-11-15T21:55:27Z",
          "updatedAt": "2023-11-15T21:55:27Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Absent more support, I plan to close this on 2/24.",
          "createdAt": "2024-02-17T15:26:57Z",
          "updatedAt": "2024-02-17T15:27:14Z"
        }
      ]
    },
    {
      "number": 591,
      "id": "I_kwDOB-yxNc526A8r",
      "title": "Can we clarify the Misconfiguration section?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/591",
      "state": "CLOSED",
      "author": "taddhar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "pr available"
      ],
      "body": "I am really struggling with this section and before I try again to make a proposal (I failed 3 times on my side) I will ask questions here and then see if and how I can make a proposal. Again consider WHO is the target audience of this section, not TLS developers or people who have been 30 years in it. Operational people will be either completely lost OR worse they will believe they understood which won't be the case. \r\n\r\nI understand too we can't expand too much the text here but now it is reaaally too compact to read it from non-expert side. \r\n\r\nSo to guide the help I need, here are a few questions.\r\n\r\nIn the clause \r\n\r\n```\r\n\"The retry mechanism repairs inconsistencies, provided the server is\r\nauthoritative for the public name. If server and advertised keys mismatch, the\r\nserver will reject ECH and respond with \"retry_configs\". If the server does\r\nnot understand\r\nthe \"encrypted_client_hello\" extension at all, it will ignore it as required by\r\n{{Section 4.1.2 of RFC8446}}. Provided the server can present a certificate\r\nvalid for the public name, the client can safely retry with updated settings,\r\nas described in {{rejected-ech}}.\"\r\n```\r\nCan somebody provide me with a precise definition of the term `the server is authoritative for the public name`\r\n\r\nCan somebody clarify me `If server and advertised keys mismatch` and give me some example. Good example of where you have to build in your brain, which server, which keys, why can they mismatch, etc. remember not everybody is a TLS developer or 30 years in it. Especially for WHO is the audience of this section.\r\n\r\nCan somebody clarify me `can present a certificate valid for the public name`. \r\n\r\nFinally can someone give an example after \r\n```\r\nUnless ECH is disabled as a result of successfully establishing a connection to\r\nthe public name \r\n\r\n```\r\n",
      "createdAt": "2023-11-15T14:43:02Z",
      "updatedAt": "2024-02-25T00:04:42Z",
      "closedAt": "2024-02-25T00:04:42Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "See #602.",
          "createdAt": "2024-02-17T18:12:45Z",
          "updatedAt": "2024-02-17T18:12:45Z"
        }
      ]
    },
    {
      "number": 595,
      "id": "I_kwDOB-yxNc53X0M-",
      "title": "Will we loosen the ECHConfig.version == ECH-extension-codepoint requirement in the longer term?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/595",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "propose to close"
      ],
      "body": "The text that describes ECHConfig.version includes: \"Beginning with draft-08, the version is the same as the code point for the \"encrypted_client_hello\" extension.\" I guess that'll need wordsmithing a bit before the RFC issues, but I have a question - am I right in assuming that if/when ECHv2 is defined with an extension codepoint of e.g. \"0xfe0e\" then it'd still be ok to use an ECHConfig with a version of 0xfe0d when emitting an ECHv2 extension in a ClientHello? \r\n\r\nThat assumes the specifiers of ECHv2 maintain some kind of backwards compatibility of course but I'd be surprised if that weren't done.\r\n\r\nReason to ask now is I'm looking at the ``#define``'d symbols in my code and wondering what code comment to add:-)",
      "createdAt": "2023-11-20T18:05:14Z",
      "updatedAt": "2024-02-17T17:01:34Z",
      "closedAt": "2024-02-17T17:01:34Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "This text should just go away once the RFC is published, so I think we can close this. @sftcd ",
          "createdAt": "2024-02-17T15:26:31Z",
          "updatedAt": "2024-02-17T15:26:31Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "at this point, close away",
          "createdAt": "2024-02-17T17:01:06Z",
          "updatedAt": "2024-02-17T17:01:06Z"
        }
      ]
    },
    {
      "number": 604,
      "id": "I_kwDOB-yxNc5_lKDj",
      "title": "Memory for ECH rejection",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/604",
      "state": "OPEN",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In https://mailarchive.ietf.org/arch/msg/tls/bvvWbtxJAiMfilfy32EvdaCszQ4/, Elardus Erasmus suggests that the suggestion to limit retries for servers which have rejected ECH is too broad, and we should have different guidance for key/config changes than for just disabling ECH. He also suggests a \"holdoff period\" when connections were disabled.  I do think that this gets at something real, but I'm not sure of the proposed resolution. \r\n\r\nISTM that there are two issues:\r\n\r\n\r\n# Limiting Retries\r\n\r\nIf the server securely disables ECH, then the client should expect a subsequent connection to succeed and there is no way for the server to ask for a retry. So I don't think we need a limit here.\r\n\r\nHowever, if the server supplies a new key, it's possible to get into some kind of loop, for instance, if there are two servers with different keys and the client bounces between them. Rather than suggesting that there be an unspecified limit, I think it would be better just to forbid a connection initiated from a retry_config from itself causing a new connection. That means that if servers are so misconfigured that they offer a retry_config that then doesn't work that they will just fail, but that should be rare, and in any case, you're in deep trouble in that case.\r\n\r\n\r\n# Remembering Retry\r\n\r\nUnless I've misread the text, it implies but doesn't say that the retry_configs and secure disablement are for this connection only and that the client should not use them even for a connection which is initiated immediately after the one where it retries (as in multiple HTTP 1.1 connections). As Erasmus indicates, this increases load on the server as well as latency and has to be balanced with the observation that the retry_configs are a tracking vector (as noted in the text). He suggests a \"holdoff\" where you don't retry ECH if it was securely disabled, but no change in cases where a valid retry_config was provided.\r\n\r\nI wonder if we should be a bit more expansive about this, given that we have other TLS-related tracking vectors that clients already need to mitigate (e.g., resumption) and there are already mechanisms to handle this. With that in mind, how about:\r\n\r\n- Clients should remember updated configuration or disabled ECH for up to the lifetime of the ECHConfig (this also gives some content to \"holdoff\").\r\n- Clients should partition retry_configs in both time and space the same way they would for resumption PSKs (this is something browsers already do).\r\n\r\nAm I missing something important?\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "createdAt": "2024-02-17T18:47:13Z",
      "updatedAt": "2024-02-19T06:35:34Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "There was one third issue, which is how the retry interacts with HTTPS-RR/SVCB's multi-CDN business. That is, if I connected previously and got retry configs, how do I know whether those retry configs apply to the next connection? For all I know, they may have gone through a completely different set of HTTPS-RR/SVCB records.\r\n\r\nAt the time I proposed the retry mechanism, SVCB's design was a little less set yet, and while, as you say, the tracking concerns are actually pretty easy to resolve by saying \"do the same thing you'd do with all other state\", I didn't want to open both of those can of worms at the same time as working through the retry mechanism itself. So my initial proposal just said it was a one-time use, and I figured we could work through all that when/if someone was enthusiastic about remembering them, but the enthusiasm never quite came up.",
          "createdAt": "2024-02-18T02:02:29Z",
          "updatedAt": "2024-02-18T02:02:29Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that the multi-CDN scenario is adequately addressed by having the retry only apply to the immediate case.  So it does get harder if you consider what conditions might allow you to reuse that configuration.  Things that seem likely to invalidate that choice:\r\n\r\n* Changes to DNS records (that are invisible to clients).  This is limited by TTL at that layer; people configuring DNS know that they can't rely on propagation for TTL+X (where X is \u311f( \u2594, \u2594 )\u310f more often than not).\r\n* Picking a different DNS RR.  At any stage of the name resolution process.\r\n* Changes to network conditions at the client end. The client might be able to detect this, but not reliably.\r\n* Changes to routing such that a different path is chosen.\r\n* Changes to server deployments. Including servers going down.\r\n\r\nThe sensible thing to do is not to specify anything concrete here, but to explain what might happen that would cause a cached value to become bad, let clients make up their own mind about how long to keep them.\r\n\r\nHowever, if a client uses a retry configuration and it turns out to be bad, I would expect that the server would want to be able to correct it with another retry configuration.  That conflicts with a simpler rule you might write about not accepting retry configurations if the client is using one already.\r\n\r\nSo I see two options here:\r\n\r\n1. Keep things simple and only allow one retry.  If you receive a retry, use it, then discard it.  If you get a retry when you are using a retry, give up.\r\n2. Make things more complex.  A retry configuration can be used for up to some time.  Clients need to limit the time over which they use that according to both their own rules for partitioning state.  They might also consider dropping the value if name resolution cannot produce the same result[^1] or they detect any change to the network conditions.  However, if a retry configuration is used after the first use - or maybe after a minimal period - a client needs to use a retry configuration they get from the server.\r\n\r\nThat last bit is fiddly.  It's something that a server deployment might like to be able to manage with an explicit, TLS-level TTL for a retry configuration.  Also, the whole bit where the first retry is special is going to be very annoying to implement.\r\n\r\n[^1]: This makes certain forms of RR selection design very likely to produce this outcome.  That's OK, because it is a safe failure.  Though it complicates the choice for those who might prefer that sort of deployment, because it now comes with additional costs in the form of the handshakes that Erasmus is suggesting we try to minimize.",
          "createdAt": "2024-02-19T06:17:32Z",
          "updatedAt": "2024-02-19T06:17:32Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> However, if a client uses a retry configuration and it turns out to be bad, I would expect that the server would want to be able to correct it with another retry configuration.\r\n\r\nOne complication here: if you got a retry config from CDN A and accidentally used it for CDN B, you're likely to not have the same public names, and CDN B will not actually be able to give you a retry config.",
          "createdAt": "2024-02-19T06:26:46Z",
          "updatedAt": "2024-02-19T06:26:46Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that this falls under the \"if DNS gives you different answers, don't use the old retry configuration\" clause.\r\n\r\nPresumably, you would have resolved the name and concluded that the retry configuration was OK to reuse.  But the DNS configuration should not use the same SVCB records at all, because the ECH configuration you have now would include the CDN B public name.  The use of different public names also rules out anycast as a means of getting into this state.",
          "createdAt": "2024-02-19T06:35:33Z",
          "updatedAt": "2024-02-19T06:35:33Z"
        }
      ]
    },
    {
      "number": 605,
      "id": "I_kwDOB-yxNc5_mHsq",
      "title": "Use Session ID and/or PSK in Client Hello to transfer enctypred SNI",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/605",
      "state": "CLOSED",
      "author": "0x391F",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Sorry, I sent this message in mailing list on July 26, 2023, but nobody discover it. \r\n\r\nIs it possible to use Session ID in Client Hello, which is obsoleted in TLS 1.3, to transfer enctypred SNI? If it looks random enough, attacker could't distinguish Session ID is encrypted SNI or not.\r\n \r\nIt may have some restrictions, for example, the SNI maybe couldn't longer than Session ID (32 bytes).\r\n \r\nSo we could also additional use TLS 1.3's PSK. It may break the limit of 32 bytes when using Session ID and able to transfer the whole SNI, but it may more distinguishable compare with using Session ID. In thi situation, Session ID is a \"signal\" that ECH is enabled, the real SNI is in PSK. ",
      "createdAt": "2024-02-18T02:17:18Z",
      "updatedAt": "2024-02-24T23:48:16Z",
      "closedAt": "2024-02-24T23:48:16Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "A few points here:\r\n\r\n1. You can't use session ID to carry ESNI because the minimum size of ESNI far exceeds 32 octets. Just the public key in the HPKE is 32 octets or more. Moreover, there's no point in having encrypted SNI in TLS < 1.3  because the certificate is in the clear.\r\n\r\n2. It's not really possible to conceal the fact that you are sending something that is vaguely ECH shaped, because the CH is going to be really enormous compared to a regular CH, and in particular quite a bit larger than the usual PSK. This is one reason why we do GREASE ECH.\r\n\r\nIn any case, we already have a nontrivial amount of deployment experience, so I think it's too late to consider this  kind of reboot of the specification. If you'd like to propose a different design in a separate draft, that's of course still possible.",
          "createdAt": "2024-02-18T02:59:22Z",
          "updatedAt": "2024-02-18T02:59:22Z"
        },
        {
          "author": "0x391F",
          "authorAssociation": "NONE",
          "body": "> Moreover, there's no point in having encrypted SNI in TLS < 1.3 because the certificate is in the clear.\r\n\r\nYes, this is the reason why use Session ID - it has been obsoleted in TLS 1.3. \r\n\r\n>     2. It's not really possible to conceal the fact that you are sending something that is vaguely ECH shaped, because the CH is going to be really enormous compared to a regular CH, and in particular quite a bit larger than the usual PSK. This is one reason why we do GREASE ECH.\r\n\r\nNo, in fact, in this situation, we only need to transfer encrypted SNI, not the whole client hello. AFAIK domian name couldn't longer than 63 btyes, the whole length should't longer than 253 bytes, it may not too big in most situation. ",
          "createdAt": "2024-02-18T03:15:53Z",
          "updatedAt": "2024-02-18T03:15:53Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "We started out with designs that just encrypted the SNI but it turned out to be too difficult to protect against active attacks, which is why we now encrypt the entire ClientHello. I don't see why the situation would be any different with this way of adding the encrypted SNI to the CH.\r\n\r\n\r\n",
          "createdAt": "2024-02-18T03:28:32Z",
          "updatedAt": "2024-02-18T03:28:32Z"
        },
        {
          "author": "0x391F",
          "authorAssociation": "NONE",
          "body": "How about using \"early data\"? It's it possible to transfer encrypted client hello in \"early data\", and Session ID indicate that in fact it is a ECH. ",
          "createdAt": "2024-02-18T04:32:44Z",
          "updatedAt": "2024-02-18T04:32:44Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": "> How about using \"early data\"? It's it possible to transfer encrypted client hello in \"early data\", and Session ID indicate that in fact it is a ECH.\r\n\r\nAnd what is the benefit of that?\r\n\r\nWhat is it you are trying to do?  Fit ECH into something smaller so the clientHello message doesn't grow much?",
          "createdAt": "2024-02-18T17:38:29Z",
          "updatedAt": "2024-02-18T17:38:29Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "> How about using \"early data\"? It's it possible to transfer encrypted client hello in \"early data\", and Session ID indicate that in fact it is a ECH.\r\n\r\nThis would also be a major change. We're trying to get this document finished, so absent there being something really wrong with this design I think we should be focused on shipping rather than looking at alternatives. TLS is extensible, as is ECHConfig, so if you were to write up a full proposal that people agreed was better, there's nothing precluding us considering it in the future.\r\n\r\n",
          "createdAt": "2024-02-18T17:46:50Z",
          "updatedAt": "2024-02-18T17:46:50Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 to ekr's points here, such designs were considered but superseded by the current design, so I think this issue would be best closed as I know of nobody else who would like to change to something other than the current design. I certainly have no such plans, and would be surprised if other implementers had.\r\n\r\nThat said, I do have a couple of students experimenting with what we're calling \"stealthy ECH\" and who are thinking about such designs afresh. However, that's very much *not* intended to be a replacement for ECH, rather that work is to see if we can figure out some possible fallbacks (for co-operating clients/servers) should ECH \"fail,\" i.e. not see widespread deployment for technical or political reasons. I'll be happy to discuss that work later in the year when the students have had a chance to work on it.",
          "createdAt": "2024-02-18T22:41:08Z",
          "updatedAt": "2024-02-18T22:41:08Z"
        },
        {
          "author": "0x391F",
          "authorAssociation": "NONE",
          "body": "> > How about using \"early data\"? It's it possible to transfer encrypted client hello in \"early data\", and Session ID indicate that in fact it is a ECH.\r\n> \r\n> And what is the benefit of that?\r\n\r\nIt will be helpful to bypass goverment's censorship, for example, some country, such as China may block ECH in the future, like how they treat ESNI (they have been block ESNI), so use somehing like PSK might more undectable. \r\n\r\n> What is it you are trying to do? Fit ECH into something smaller so the clientHello message doesn't grow much?\r\n\r\nSee above. \r\n",
          "createdAt": "2024-02-19T01:58:07Z",
          "updatedAt": "2024-02-19T01:58:07Z"
        },
        {
          "author": "x0wllaar",
          "authorAssociation": "NONE",
          "body": "As it is, ECH will still have a ton of distinguishers, like having crypto.cloudflare.com in the outer SNI anyway. It's also enough to block DoH to completely break ECH.\r\n\r\nThe real way to resist censorship here is to make ECH mandatory for a significant part of the internet, so that it becomes too big to block (although this does not always work sadly).\r\n\r\nAlso, we have an actual case where a big censorship target (Telegram) tried to hide behind CDNs. In the end, the CDNs (well, a couple million of Amazon/Azure IPs) ended up blocked in Russia for some time, and then almost all of them disabled domain fronting. I'm not sure whether anyone wants to go this route again, only this time with a more official implementation of the same domain fronting idea. ",
          "createdAt": "2024-02-21T02:46:11Z",
          "updatedAt": "2024-02-21T02:54:15Z"
        },
        {
          "author": "Andrew-419",
          "authorAssociation": "NONE",
          "body": "> > > How about using \"early data\"? It's it possible to transfer encrypted client hello in \"early data\", and Session ID indicate that in fact it is a ECH.\r\n> > \r\n> > \r\n> > And what is the benefit of that?\r\n> \r\n> It will be helpful to bypass goverment's censorship, for example, some country, such as China may block ECH in the future, like how they treat ESNI (they have been block ESNI), so use somehing like PSK might more undectable.\r\n> \r\n> > What is it you are trying to do? Fit ECH into something smaller so the clientHello message doesn't grow much?\r\n> \r\n> See above.\r\n\r\nIIRC TLS 1.3 is blocked in China too, so this is much more complex than just trying to reduce the footprint of ECH.    ",
          "createdAt": "2024-02-23T15:27:55Z",
          "updatedAt": "2024-02-23T15:27:55Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I've heard this claim before but I'm pretty sure it's an urban legend, stemming from people conflating TLS 1.3 and early iterations of ESNI. Enough of the Internet now is TLS 1.3 that, if this were true, far far too many things would be broken that those of us who work professionally in the space would definitely have run into it by now. Remember that blocking TLS 1.3 does not mean you get TLS 1.2. It means the connection does not work.",
          "createdAt": "2024-02-23T15:44:58Z",
          "updatedAt": "2024-02-23T15:45:28Z"
        },
        {
          "author": "Andrew-419",
          "authorAssociation": "NONE",
          "body": "You prompted me to check the original stories as it is a little while since this came up.  There's a helpful post from ISoc from August 2020 at https://www.internetsociety.org/news/statements/2020/internet-society-blocking-tls-1-3-in-china-makes-the-internet-less-secure/ that in turn references coverage of this in ZD-Net.  It seems that the Great Firewall was blocking traffic using TLS 1.3 in combination with eSNI.  [As an aside, I'm not convinced that overblocking was a major concern for the Great Firewall :-) ]",
          "createdAt": "2024-02-23T16:04:41Z",
          "updatedAt": "2024-02-23T16:04:41Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Not seeing any more support for this, so closing it.",
          "createdAt": "2024-02-24T23:48:16Z",
          "updatedAt": "2024-02-24T23:48:16Z"
        }
      ]
    },
    {
      "number": 606,
      "id": "I_kwDOB-yxNc6AUxSM",
      "title": "Recommend greasing PSK?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/606",
      "state": "CLOSED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In Watson Ladd's review, he asks:\r\n\r\n  Should we use RFC 2119 language for the server as well? Right now we\r\n  only say what the client must do when the server violates the rules.\r\n\r\nWe do recommend greasing ECH. My sense is that this is on the bubble\r\nand we could leave it as-is, but I could be persuaded otherwise.\r\n\r\n@davidben  @dennisjackson @martinthomson \r\n \r\n",
      "createdAt": "2024-02-25T20:30:27Z",
      "updatedAt": "2024-03-04T16:00:00Z",
      "closedAt": "2024-03-04T16:00:00Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I just checked with NSS and we overwrite the outer values for PSK (identities and binders) with random data.  That seems fairly simple to do and it makes the handshake choice harder to distinguish.\r\n\r\nNote that we do not hide the length, which might be an issue for identity, but we're already exposed to the length leakage, so fixed-length identities are best in any case.",
          "createdAt": "2024-02-26T02:24:09Z",
          "updatedAt": "2024-02-26T02:24:09Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "So that's a vote for \"grease\"?",
          "createdAt": "2024-03-01T00:48:39Z",
          "updatedAt": "2024-03-01T00:48:39Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, I'm happy with it.",
          "createdAt": "2024-03-01T01:54:23Z",
          "updatedAt": "2024-03-01T01:54:23Z"
        },
        {
          "author": "dennisjackson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\ud83d\udc4d ",
          "createdAt": "2024-03-01T13:24:35Z",
          "updatedAt": "2024-03-01T13:24:35Z"
        }
      ]
    },
    {
      "number": 608,
      "id": "I_kwDOB-yxNc6AU3mp",
      "title": "Can a retry ECHConfig change the public name?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/608",
      "state": "CLOSED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Suppose that I connect to a server with public name `example.com` and it gives me an ECHConfig with public name `example.org`. Is this OK?",
      "createdAt": "2024-02-25T21:43:56Z",
      "updatedAt": "2024-03-01T02:03:08Z",
      "closedAt": "2024-03-01T02:03:07Z",
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n\r\nOn 25/02/2024 21:44, Eric Rescorla wrote:\r\n> Suppose that I connect to a server with public name `example.com` and\r\n> it gives me an ECHConfig with public name `example.org`. Is this OK?\r\n\r\nIf the same server certificate covers both, then I'd say\r\nthat's ok. But I'd have to add an extra check I think,\r\nif we figure a library ought enforce any related checks,\r\nso I'd likely be fine with other constraints or with no\r\nconstraint (at the library level).\r\n\r\nS.\r\n\r\n",
          "createdAt": "2024-02-25T23:15:57Z",
          "updatedAt": "2024-02-25T23:15:57Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson @davidben?",
          "createdAt": "2024-03-01T00:48:27Z",
          "updatedAt": "2024-03-01T00:48:27Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I can't see an attack that might arise from changing the public name.  It creates some interesting cross-provider interactions.",
          "createdAt": "2024-03-01T01:54:05Z",
          "updatedAt": "2024-03-01T01:54:05Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, so I'm just going to close this with no change.",
          "createdAt": "2024-03-01T02:03:07Z",
          "updatedAt": "2024-03-01T02:03:07Z"
        }
      ]
    },
    {
      "number": 612,
      "id": "I_kwDOB-yxNc6CKMgx",
      "title": "Mention that the server identity may be revealed by ServerHellp",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/612",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "https://mailarchive.ietf.org/arch/msg/tls/5oKWlf---OqjQf37giXVVzIbPHw/\r\n\r\n>    \"ECH is not in itself sufficient to protect the identity of the\r\n>    server.  The target domain may also be visible through other\r\n>    channels, such as plaintext client DNS queries or visible server IP\r\n>    addresses.  However, DoH [RFC8484] and DPRIVE [RFC7858] [RFC8094]\r\n>    provide mechanisms for clients to conceal DNS lookups from network\r\n>    inspection, and many TLS servers host multiple domains on the same IP\r\n>    address.  Private origins may also be deployed behind a common\r\n>    provider, such as a reverse proxy.  In such environments, the SNI\r\n>    remains the primary explicit signal used to determine the server's\r\n>    identity.\"\r\n \r\nThis text only discusses that the identity of the server may be revealed by\r\n\"other channels\". I strongly think the document needs to mention that the\r\nidentity of the server may also be reveled by the unencrypted information\r\nin the ServerHello. In particular a reused KeyShare is problematic.\r\n \r\nSuggested addition:\r\n \r\nThe identity of the server may also be reveled by the unencrypted information\r\nin the ServerHello. Most of the current information in ServerHello is not unique.\r\nThe exception is KeyShare, which if reused provides a unique identifier of the server.\r\n \r\nCheers,\r\nJohn Preu\u00df Mattsson",
      "createdAt": "2024-03-13T11:02:47Z",
      "updatedAt": "2024-05-27T18:30:35Z",
      "closedAt": "2024-05-27T18:30:35Z",
      "comments": []
    },
    {
      "number": 618,
      "id": "I_kwDOB-yxNc6Lt6YC",
      "title": "Client behavior on wrong value in HRR extension",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/issues/618",
      "state": "OPEN",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In section 6.1.4, this note is found:\r\n\r\n> [[OPEN ISSUE: Depending on what we do for issue#450, it may be appropriate to change the client behavior if the HRR extension is present but with the wrong value.]]\r\n\r\n#450 is closed, but the text is still present and I didn't see a corresponding issue. Is there anything that needs to be done here, or should the note be removed?",
      "createdAt": "2024-06-10T14:26:30Z",
      "updatedAt": "2024-06-10T14:26:30Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NTg2MDE3",
      "title": "Text",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/1",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-11T22:49:19Z",
      "updatedAt": "2018-05-11T23:09:25Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "cdd930894881e8f1abab1c2d1e8e5b0107fe46b3",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "ded62dd0faa173577a5f31c3fd80fce854464fd3",
      "closedAt": "2018-05-11T23:09:25Z",
      "mergedAt": "2018-05-11T23:09:25Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "ded62dd0faa173577a5f31c3fd80fce854464fd3"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 2,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NTkwMjY5",
      "title": "Add assessment section",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/2",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-11T23:29:04Z",
      "updatedAt": "2018-05-11T23:41:58Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "5dec6a11f91e314205d86de1d73b9fe0abe0ac26",
      "headRepository": null,
      "headRefName": "caw/assess",
      "headRefOid": "8ef656997e7a3f6c63047939757e9d410eaa2127",
      "closedAt": "2018-05-11T23:41:58Z",
      "mergedAt": "2018-05-11T23:41:58Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "483739199977a81d5b6d379e8556e259bd7fc28b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjA1MDg1",
          "commit": {
            "abbreviatedOid": "74bd303"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This is good. Added a few comments.",
          "createdAt": "2018-05-11T23:31:32Z",
          "updatedAt": "2018-05-11T23:33:50Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "Why is this a problem? You have a label?",
              "createdAt": "2018-05-11T23:31:33Z",
              "updatedAt": "2018-05-11T23:40:24Z"
            },
            {
              "originalPosition": 83,
              "body": "I think you should sharpen this point a bit. The argument I would make is that this is a property of the browser and the server, so it's not suspicious at all. Now, it's true that you need more clients to avoid *blocking* but if you're using a generic browser, there's nothing suspicious about running Safari, Firefox, etc.",
              "createdAt": "2018-05-11T23:33:09Z",
              "updatedAt": "2018-05-11T23:40:24Z"
            },
            {
              "originalPosition": 88,
              "body": "I don't think this is true, because the server's share is static.",
              "createdAt": "2018-05-11T23:33:19Z",
              "updatedAt": "2018-05-11T23:40:24Z"
            },
            {
              "originalPosition": 99,
              "body": "This is true, but I think it's worth pointing to the cleartext DNS for why that's not even needed.",
              "createdAt": "2018-05-11T23:33:37Z",
              "updatedAt": "2018-05-11T23:40:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjA1NTM0",
          "commit": {
            "abbreviatedOid": "74bd303"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-11T23:35:39Z",
          "updatedAt": "2018-05-11T23:35:39Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "Oh, yes, oops. I was forgot we said above just to fail open if there's a label mismatch.",
              "createdAt": "2018-05-11T23:35:39Z",
              "updatedAt": "2018-05-11T23:40:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjA1NjAy",
          "commit": {
            "abbreviatedOid": "74bd303"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-11T23:36:20Z",
          "updatedAt": "2018-05-11T23:36:20Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "I'm assuming a short TTL for these keys -- so maybe I'll just say not FS by usual definition, but window of exposure is bound by DNS RR TTL",
              "createdAt": "2018-05-11T23:36:20Z",
              "updatedAt": "2018-05-11T23:40:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjA1ODAz",
          "commit": {
            "abbreviatedOid": "74bd303"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-11T23:38:24Z",
          "updatedAt": "2018-05-11T23:38:24Z",
          "comments": [
            {
              "originalPosition": 99,
              "body": "Done.",
              "createdAt": "2018-05-11T23:38:24Z",
              "updatedAt": "2018-05-11T23:40:24Z"
            }
          ]
        }
      ]
    },
    {
      "number": 3,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NTkxODI4",
      "title": "Cleartext DNS is A-OK.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/3",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-11T23:46:35Z",
      "updatedAt": "2018-05-11T23:57:25Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "483739199977a81d5b6d379e8556e259bd7fc28b",
      "headRepository": null,
      "headRefName": "caw/dns",
      "headRefOid": "02efa31d518f23d395cd20d41b5510f083097320",
      "closedAt": "2018-05-11T23:57:25Z",
      "mergedAt": "2018-05-11T23:57:25Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "2a927e6f3884c74c155ca199e61b997d4089546b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjA2Nzk5",
          "commit": {
            "abbreviatedOid": "8bd1a4b"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-11T23:49:18Z",
          "updatedAt": "2018-05-11T23:49:22Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I think I would phrase this slightly differently, namely that you can provide a per-domain name IP address. It's not the SNI that's published.\r\n\r\n\r\n\r\n",
              "createdAt": "2018-05-11T23:49:18Z",
              "updatedAt": "2018-05-11T23:54:25Z"
            }
          ]
        }
      ]
    },
    {
      "number": 4,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NTkzNzk3",
      "title": "Small rewrite",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/4",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-12T00:10:45Z",
      "updatedAt": "2021-04-19T15:51:25Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "2a927e6f3884c74c155ca199e61b997d4089546b",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "cleartext_dns",
      "headRefOid": "4f173e07500acdd309f458950fd84b59e6d6c664",
      "closedAt": "2018-05-12T00:16:05Z",
      "mergedAt": "2018-05-12T00:16:05Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "4f173e07500acdd309f458950fd84b59e6d6c664"
      },
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "maybe also point out that once you control DNS, getting a certificate is usually fairly easy",
          "createdAt": "2018-05-12T00:12:07Z",
          "updatedAt": "2018-05-12T00:12:07Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjA4ODI3",
          "commit": {
            "abbreviatedOid": "4f173e0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-12T00:13:20Z",
          "updatedAt": "2018-05-12T00:13:20Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "I'd add that the attacker can also inject its own keys, which causes the client to encrypt the SNI to them.",
              "createdAt": "2018-05-12T00:13:20Z",
              "updatedAt": "2018-05-12T00:13:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjA4ODcx",
          "commit": {
            "abbreviatedOid": "4f173e0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-12T00:14:03Z",
          "updatedAt": "2018-05-12T00:14:04Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Maybe add: In fact, SNI encryption is less useful without encryption of DNS queries in transit via DoH or DPRIVE mechanisms.",
              "createdAt": "2018-05-12T00:14:04Z",
              "updatedAt": "2018-05-12T00:14:04Z"
            }
          ]
        }
      ]
    },
    {
      "number": 9,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NjAzNTg4",
      "title": "Address MT's issues.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/9",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Instead of a Fronting SNI field, we should just re-use the Alt-Svc record, which already carries an SNI value to be used.",
      "createdAt": "2018-05-12T04:15:15Z",
      "updatedAt": "2018-05-12T15:12:12Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9da97156f4553c7f3424be53047099fe72328f47",
      "headRepository": null,
      "headRefName": "caw/issues",
      "headRefOid": "a6ee53b988d804d8fd8e368c39fd5566f53cdb73",
      "closedAt": "2018-05-12T15:12:12Z",
      "mergedAt": "2018-05-12T15:12:12Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "a6ee53b988d804d8fd8e368c39fd5566f53cdb73"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjI1Mjk3",
          "commit": {
            "abbreviatedOid": "3002a0e"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-12T12:26:27Z",
          "updatedAt": "2018-05-12T12:27:12Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I'm having trouble following this. Is this each record?",
              "createdAt": "2018-05-12T12:26:28Z",
              "updatedAt": "2018-05-12T13:06:58Z"
            },
            {
              "originalPosition": 15,
              "body": "This sentence seems ot just end.",
              "createdAt": "2018-05-12T12:26:57Z",
              "updatedAt": "2018-05-12T13:06:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjI2MDI2",
          "commit": {
            "abbreviatedOid": "3002a0e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-12T13:04:33Z",
          "updatedAt": "2018-05-12T13:04:33Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Missed period -- fixed now.",
              "createdAt": "2018-05-12T13:04:33Z",
              "updatedAt": "2018-05-12T13:06:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjI2MDU0",
          "commit": {
            "abbreviatedOid": "3002a0e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-12T13:06:24Z",
          "updatedAt": "2018-05-12T13:06:24Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Indeed, the sentence is confusing. I just removed it. The point I was trying to make is that if there are multiple IP addresses to choose from with multiple keys, and the server does not configure each of those addresses with the set of keys, the client might pick the wrong address/key combo.",
              "createdAt": "2018-05-12T13:06:24Z",
              "updatedAt": "2018-05-12T13:06:58Z"
            }
          ]
        }
      ]
    },
    {
      "number": 11,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NjE5Njkx",
      "title": "Simplify key schedule. Remove Nonce. Fixes #6",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/11",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-12T12:43:35Z",
      "updatedAt": "2021-04-19T15:51:26Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9da97156f4553c7f3424be53047099fe72328f47",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "simplify_keys",
      "headRefOid": "314f8e741554c4defb828f536bae8506d20bc3e2",
      "closedAt": "2018-05-12T13:13:32Z",
      "mergedAt": "2018-05-12T13:13:32Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "c30baff03a7471998a775e9f18e25f3f4e8e7eb5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjI2MTcz",
          "commit": {
            "abbreviatedOid": "314f8e7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-12T13:13:13Z",
          "updatedAt": "2018-05-12T13:13:14Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "This is an implementation detail, I think. If a client chooses to expand twice when it's not needed then that's their fault. We could simply state (in the other draft, or here) that \"if clients have computed Z for other purposes, an additional extraction is not needed.\"",
              "createdAt": "2018-05-12T13:13:14Z",
              "updatedAt": "2018-05-12T13:13:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjI2MTg1",
          "commit": {
            "abbreviatedOid": "314f8e7"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-12T13:14:04Z",
          "updatedAt": "2018-05-12T13:14:04Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Sorry, I'm not worried about the implementation, but about whether we're guaranteeing key separation",
              "createdAt": "2018-05-12T13:14:04Z",
              "updatedAt": "2018-05-12T13:14:04Z"
            }
          ]
        }
      ]
    },
    {
      "number": 12,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NjI1NjQz",
      "title": "Don't allow bad labels",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/12",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-12T15:15:00Z",
      "updatedAt": "2021-04-19T15:51:27Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "0a0d116d7ddcf73554597e4716573529ba8f31ce",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "fail_on_bad_label",
      "headRefOid": "1772724e8da753d3deacb4280a87f8ba91ba12de",
      "closedAt": "2018-05-12T15:30:08Z",
      "mergedAt": "2018-05-12T15:30:08Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "eb9af6279dd98f92cfc627f52714b884581b7f89"
      },
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood ",
          "createdAt": "2018-05-12T15:15:19Z",
          "updatedAt": "2018-05-12T15:15:19Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjI5MDg0",
          "commit": {
            "abbreviatedOid": "1772724"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM!",
          "createdAt": "2018-05-12T15:25:25Z",
          "updatedAt": "2018-05-12T15:25:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 13,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NjI2MzAw",
      "title": "Add padding to the encrypted SNI to avoid attacks based on length.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/13",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@chris-wood PTAL",
      "createdAt": "2018-05-12T15:29:57Z",
      "updatedAt": "2021-04-19T15:51:27Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "0a0d116d7ddcf73554597e4716573529ba8f31ce",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "obscure_length",
      "headRefOid": "29c165f147e794c4d266b7b635704ee97b5892a4",
      "closedAt": "2018-05-12T15:38:40Z",
      "mergedAt": "2018-05-12T15:38:40Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "a37f5e34927438ee13fe7fa2622eaf9f5e84bad0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjI5MzIy",
          "commit": {
            "abbreviatedOid": "29c165f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-12T15:34:38Z",
          "updatedAt": "2018-05-12T15:35:50Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "Should we send decrypt_error instead? (Thinking of POs here.)",
              "createdAt": "2018-05-12T15:34:38Z",
              "updatedAt": "2018-05-12T15:35:50Z"
            }
          ]
        }
      ]
    },
    {
      "number": 16,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NjMyODYz",
      "title": "Misc. fixes",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/16",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "A few fixes made while reading through.",
      "createdAt": "2018-05-12T18:00:04Z",
      "updatedAt": "2018-05-12T18:33:25Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "a37f5e34927438ee13fe7fa2622eaf9f5e84bad0",
      "headRepository": null,
      "headRefName": "fixes",
      "headRefOid": "a430e93215f6553185cae4e4e5c5241ce1ba32b4",
      "closedAt": "2018-05-12T18:33:25Z",
      "mergedAt": "2018-05-12T18:33:25Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "ea9fc6d00233bad98d90fbb0b6246179359fe796"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 18,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NjM1MDYy",
      "title": "Add clarity to the DNS encoding section, require base64 encoding, and\u2026",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/18",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "\u2026 deal with TXT string limits.\r\n",
      "createdAt": "2018-05-12T18:53:41Z",
      "updatedAt": "2018-05-13T00:07:31Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "ea9fc6d00233bad98d90fbb0b6246179359fe796",
      "headRepository": null,
      "headRefName": "caw/encoding",
      "headRefOid": "674f746cf41dd33551002f080cc79919865eea94",
      "closedAt": "2018-05-13T00:07:31Z",
      "mergedAt": "2018-05-13T00:07:31Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "a44aea22621347cef696c8fd1a210f92a43e1460"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@huitema @ghedo please take a look.",
          "createdAt": "2018-05-12T18:56:01Z",
          "updatedAt": "2018-05-12T18:56:01Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson @huitema updated based on your feedback -- please take a look!",
          "createdAt": "2018-05-12T23:49:40Z",
          "updatedAt": "2018-05-12T23:49:40Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjM3NjU1",
          "commit": {
            "abbreviatedOid": "12e87e0"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "The general idea looks good, but I am a bit concerned with the concatenation + reordering process, as in theory servers may return records in random order. On the other hand, RFC 4408 has been out for a long time, so maybe that's not really a problem in practice.",
          "createdAt": "2018-05-12T21:53:20Z",
          "updatedAt": "2018-05-12T21:55:42Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I read the text in RFC 4408 and I am a bit concerned that this is one of those things that does not work in theory but does work in practice. In theory, when there are multiple records of the same type for the same name, DNS servers or recursive resolvers can return the records in whichever order they see fit. If they actually do that, the concatenation becomes unpredictable.",
              "createdAt": "2018-05-12T21:53:21Z",
              "updatedAt": "2018-05-12T23:54:12Z"
            },
            {
              "originalPosition": 30,
              "body": "At most one [each] ... TXT ESNI... Is that compatible with the idea that the string may be split over multiple concatenated records?",
              "createdAt": "2018-05-12T21:53:24Z",
              "updatedAt": "2018-05-12T23:54:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjM4OTg0",
          "commit": {
            "abbreviatedOid": "12e87e0"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-12T23:21:01Z",
          "updatedAt": "2018-05-12T23:23:02Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Nit extra period after 3.1.3",
              "createdAt": "2018-05-12T23:21:01Z",
              "updatedAt": "2018-05-12T23:54:12Z"
            },
            {
              "originalPosition": 32,
              "body": "I think that you need to more directly address the notion that the anonymity set is the set of domains that share the same IP address.  That deserves a paragraph that includes this last sentence.",
              "createdAt": "2018-05-12T23:22:59Z",
              "updatedAt": "2018-05-12T23:54:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjM5MjYz",
          "commit": {
            "abbreviatedOid": "12e87e0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-12T23:39:05Z",
          "updatedAt": "2018-05-12T23:39:06Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Fixed.",
              "createdAt": "2018-05-12T23:39:06Z",
              "updatedAt": "2018-05-12T23:54:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjM5Mjc4",
          "commit": {
            "abbreviatedOid": "12e87e0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-12T23:40:12Z",
          "updatedAt": "2018-05-12T23:40:12Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Hmm, interesting. I didn't see records being concatenated. Do we think servers will offer up key sets that need to split up across records?",
              "createdAt": "2018-05-12T23:40:12Z",
              "updatedAt": "2018-05-12T23:54:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjM5Mjk0",
          "commit": {
            "abbreviatedOid": "12e87e0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-12T23:41:47Z",
          "updatedAt": "2018-05-12T23:41:47Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "The text here suggests that we'd split up text within a single record, not across multiple records. Indeed, if the latter were the case, I don't think this would work.",
              "createdAt": "2018-05-12T23:41:47Z",
              "updatedAt": "2018-05-12T23:54:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5NjM5NTA5",
          "commit": {
            "abbreviatedOid": "674f746"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "That's more words than I expected, but they all seem useful.  LGTM.",
          "createdAt": "2018-05-13T00:01:03Z",
          "updatedAt": "2018-05-13T00:01:03Z",
          "comments": []
        }
      ]
    },
    {
      "number": 21,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NjgzODY0",
      "title": "Add Kazuho",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/21",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@kazuho: please double check",
      "createdAt": "2018-05-13T18:33:16Z",
      "updatedAt": "2021-04-19T15:51:28Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "a44aea22621347cef696c8fd1a210f92a43e1460",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "add_kazuho",
      "headRefOid": "e78c4f36dc7d5f117727de1c0c8b52e79a669019",
      "closedAt": "2018-05-13T22:01:01Z",
      "mergedAt": "2018-05-13T22:01:01Z",
      "mergedBy": "kazuho",
      "mergeCommit": {
        "oid": "77a9cef4ba9de590a1cf327a655e10ce0df6d11d"
      },
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you very much!",
          "createdAt": "2018-05-13T22:01:12Z",
          "updatedAt": "2018-05-13T22:01:12Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 22,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NzA3NzE5",
      "title": "add ESNIKeys.extensions",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/22",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "At the moment, there is no extensibility in ESNIKeys. That means that if we want to add additional attributes, we would be forced to define a new DNS record that gets queried simultaneously. I think we do not want to do that.\r\n\r\nHence the extensions field.\r\n\r\nThe text is tentative; please feel free to change in any ways.\r\n\r\nCloses #10.",
      "createdAt": "2018-05-14T02:36:58Z",
      "updatedAt": "2018-05-14T13:16:57Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "77a9cef4ba9de590a1cf327a655e10ce0df6d11d",
      "headRepository": "kazuho/draft-rescorla-tls-esni",
      "headRefName": "kazuho/extensions",
      "headRefOid": "e2362439b34c7e280bb2a9fee2152cbae55016f4",
      "closedAt": "2018-05-14T13:16:57Z",
      "mergedAt": "2018-05-14T13:16:57Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "87f70eeeff775e26b57a92cb0d01586f0cf8f58c"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM.",
          "createdAt": "2018-05-14T13:15:38Z",
          "updatedAt": "2018-05-14T13:15:38Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 23,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NzE1MDgy",
      "title": "client-side validation of ESNIKeys",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/23",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I expect that the resistance against ESNIKeys will come from web-site owners worrying about ESNIKeys being additional source of service disruption.\r\n\r\nOne might argue that the probability of disruption becomes 2x because now two resource records (A and _esni) are involved instead of just one. One might argue that the probability is higher than that because there could be more issues with carrying large TXT records than carrying A records. One might argue that the probability is below 2x because the two records are transmitted through the same path.\r\n\r\nAnyways, these arguments are about the quantitative difference about the probability.\r\n\r\nI prefer having a qualitative guarantee, that assures that there would be no increase in the probability of service disruption assuming that the owner of the `_esni` record does not misconfigure the service.\r\n\r\nHaving a checksum and validity period fields that can be validated by the client provides such guarantee.\r\n\r\nChecksum provides protection against accidental corruption.\r\n\r\nValidity period provides protection against misconfiguration or bugs in the DNS servers. It acts as a protection against an outdated ESNIKeys sent by an out-of-sync authoritative server or a buggy resolver causing disruption.\r\n\r\nThe downside of having checksum and validity is that the additional payload (currently 20 bytes, I think we can minimize this to 10 bytes by removing `not_before` (it's not that needed) and changing the type of `not_after` from `uint64` to `uint48`), and that the client would be required to do the validation.\r\n\r\nBut I assume that having qualitative guarantee that the probability of service disruption remains the same is worth the effort.\r\n\r\nCloses #20.",
      "createdAt": "2018-05-14T04:02:16Z",
      "updatedAt": "2018-05-14T16:04:43Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "16b8a6ff244862647683be24fcded2ab8b5657e9",
      "headRepository": "kazuho/draft-rescorla-tls-esni",
      "headRefName": "kazuho/client-side-validation",
      "headRefOid": "ca6c490833165bf920e6c05af2ebb57c259549a0",
      "closedAt": "2018-05-14T16:04:43Z",
      "mergedAt": "2018-05-14T16:04:43Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "3ad81cc1e3a141ca9ad90c5d184773a25cca4af8"
      },
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood The PR is now aligned with master. I think we should merge this and rebase #24 upon this regardless of what we end up with on the PR.",
          "createdAt": "2018-05-14T16:03:15Z",
          "updatedAt": "2018-05-14T16:03:15Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5ODMwOTA2",
          "commit": {
            "abbreviatedOid": "dfd9bc5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-05-14T13:24:37Z",
          "updatedAt": "2018-05-14T13:24:45Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "While I think this is useful, it requires DNSSEC for this to be safe. Otherwise, a malicious recursive resolver could alter not_before or not_after to prevent a client from using the key as one normally would. It also seems redundant with the TTL field in the RR itself. @ekr thoughts?",
              "createdAt": "2018-05-14T13:24:38Z",
              "updatedAt": "2018-05-14T16:01:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5ODc2MjY3",
          "commit": {
            "abbreviatedOid": "dfd9bc5"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-14T15:05:55Z",
          "updatedAt": "2018-05-14T15:05:56Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "> a malicious recursive resolver could alter not_before or not_after to prevent a client from using the key as one normally would\r\n\r\nI do not think that as an issue, considering the fact that a malicious resolver can do anything including changing the A record or dropping the ESNIKeys entirely.\r\n\r\n> It also seems redundant with the TTL field in the RR itself.\r\n\r\nI do not think so.\r\n\r\nThe issue with TTL is that TTL is always relative to the time when the DNS authoritative server emits the record.\r\n\r\nConsider the case where the authoritative server and the TLS server getting out-of-sync.\r\n\r\nIf we have `not_after`, the servers can be deployed in the a way that it does not cause service disruption. What you need to do setup your system to always generate the ESNIKeys on the TLS server and push it to the authoritative server for distributing it. Then, when the two servers become brain-split, the _esni resource records would become considered as invalid by the clients.\r\n\r\nBut if we do not have `not_after`, the _esni record that the authoritative server will continue to be considered valid, because TTL is set every time the authoritative server emits the record.",
              "createdAt": "2018-05-14T15:05:56Z",
              "updatedAt": "2018-05-14T16:01:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5ODc5NTYw",
          "commit": {
            "abbreviatedOid": "dfd9bc5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-14T15:12:29Z",
          "updatedAt": "2018-05-14T15:12:30Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Fair points! You've convinced me this is needed.",
              "createdAt": "2018-05-14T15:12:30Z",
              "updatedAt": "2018-05-14T16:01:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5OTAxNzY5",
          "commit": {
            "abbreviatedOid": "ca6c490"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-14T16:02:06Z",
          "updatedAt": "2018-05-14T16:02:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 24,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3ODA0MzEx",
      "title": "prevent downgrade attack",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/24",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In ESNI, the server offers a list of ECDH keys and the client selects one of them. However, there seems to be nothing that prevents a downgrade attack.\r\n\r\nThis PR adds the protection, by sending the list of the Named Groups being offered by ESNIKeys in the EncryptedSNI extension.\r\n\r\nThe bonus is that the size of ESNIKeys becomes smaller when more than one keys are offered (because we now only send one label per the entire key set).",
      "createdAt": "2018-05-14T12:01:06Z",
      "updatedAt": "2018-05-17T13:08:17Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3ad81cc1e3a141ca9ad90c5d184773a25cca4af8",
      "headRepository": "kazuho/draft-rescorla-tls-esni",
      "headRefName": "kazuho/one-key-per-group",
      "headRefOid": "f55f9c31735eba8fcf04b8e2110966e0dcafa7a4",
      "closedAt": "2018-05-17T13:08:17Z",
      "mergedAt": "2018-05-17T13:08:17Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "6276955dbfee725e5db060d38d66cd479d8acf58"
      },
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> I don't think the NamedGroupList is necessary to prevent downgrade attacks.\r\n\r\nConsider the case where the authoritative server sends an _esni record containing X448 and X25519 keys. Malicious middlebox rewrites the _esni record to only contain the X25519 key. The client will accept the X25519 key and use that for the TLS handshake.\r\n\r\nI think that is not prevented now, and that we need to prevent it.",
          "createdAt": "2018-05-14T15:08:44Z",
          "updatedAt": "2018-05-14T15:08:44Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho: thanks for identifying this. I agree it's a real issue and wish I'd caught it before :(\r\n\r\nThinking about defenses, do you think it might make more sense to ditch the label and instead just carry a hash of the record? Then we could guarantee that it wasn't changed more easily? OTOH, that would preclude self-encryption of the ESNI Key....",
          "createdAt": "2018-05-14T15:11:47Z",
          "updatedAt": "2018-05-14T15:11:47Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@ekr Servers might want more than one label per record to allow for migration. Why don't we have clients send the hash of the ESNKey structure for the label it chooses? The server could also include that in full in place of the truncated hash.",
          "createdAt": "2018-05-14T15:14:24Z",
          "updatedAt": "2018-05-14T15:14:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho I meant that we don't need to send the NamedGroupsList for mitigation -- we could send something else, e.g., the ESNIKey hash.",
          "createdAt": "2018-05-14T15:15:48Z",
          "updatedAt": "2018-05-14T15:15:48Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> Thinking about defenses, do you think it might make more sense to ditch the label and instead just carry a hash of the record? Then we could guarantee that it wasn't changed more easily? OTOH, that would preclude self-encryption of the ESNI Key....\r\n\r\n@ekr The other issue is that you then need to consider negotiating the hash algorithm to be used. I did not want to deal with that and therefore went for the Named Group list.\r\n\r\n@chris-wood Thank you for the clarification. I think the paragraph right above is my answer.",
          "createdAt": "2018-05-14T15:18:19Z",
          "updatedAt": "2018-05-14T15:19:09Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho The checksum you propose is already computed with SHA256 -- why do you think this is something we ought to negotiate? ",
          "createdAt": "2018-05-14T15:27:43Z",
          "updatedAt": "2018-05-14T15:27:43Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood The checksum is only 32-bits and it's for detecting errors, not preventing attacks.\r\n\r\nNamed Group selection is a cryptographic property of the TLS handshake and it needs to be protected by the digest algorithm of the negotiated cipher-suite. It is either a full-length SHA-256 or SHA-384 at the moment, but could change in the future.",
          "createdAt": "2018-05-14T15:34:11Z",
          "updatedAt": "2018-05-14T15:34:11Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho The intent of this is to convey to the server that the client saw the right set of options before it chose its key. We don't need to consider any properties of NamedGroup selection with TLS to do so. And picking a suitable cryptographic hash function here is good enough. I really don't think we need agility here. \r\n\r\nAlso, I wasn't suggesting the client echo the 32bit hash found in the record. It should send the full SHA256 hash. ",
          "createdAt": "2018-05-14T15:36:01Z",
          "updatedAt": "2018-05-14T15:37:32Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh, also, what if we decide to add an extension that could influence how clients choose keys? Wouldn't we want downgrade protection for that, too? (A hash would work for that, whereas echoing the NamedGroup list would not.)",
          "createdAt": "2018-05-14T15:39:56Z",
          "updatedAt": "2018-05-14T15:39:56Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "My understanding is as follows:\r\n* In TLS 1.3, client offers the Named Groups and server selects one. It is protected by the digest algorithm of the negotiated cipher-suite.\r\n* In TLS 1.3 + ESNI, server offers the Named Groups and client selects one.\r\n\r\nTherefore, I assume that which Named Groups we offered needs to be protected by the digest algorithm of the negotiated cipher-suite, or else we are changing the security properties of TLS 1.3.\r\n\r\n> Oh, also, what if we decide to add an extension that could influence how clients choose keys? Wouldn't we want downgrade protection for that, too? (A hash would work for that, whereas echoing the NamedGroup list would not.)\r\n\r\nI agree. So to me the choice seems to be between a) choose a specific solution (i.e. send Named Group list) or b) add digest algorithm negotiation and send the hash value.\r\n\r\nI went for a, but I won't argue hardly against b.",
          "createdAt": "2018-05-14T15:43:47Z",
          "updatedAt": "2018-05-14T15:44:02Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Well, we could just use the hash associated with the cipher suite, no?\n\nOn Mon, May 14, 2018 at 8:39 AM, Christopher Wood <notifications@github.com>\nwrote:\n\n> Oh, also, what if we decide to add an extension that could influence how\n> clients choose keys? Wouldn't we want downgrade protection for that, too?\n> (A hash would work for that, whereas echoing the NamedGroup list would not.)\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ekr/draft-rescorla-tls-esni/pull/24#issuecomment-388862886>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ABD1offG-C6SQ7_u_hTtaxaKcdOw36wYks5tyaVNgaJpZM4T9qTj>\n> .\n>\n",
          "createdAt": "2018-05-14T15:44:37Z",
          "updatedAt": "2018-05-14T15:44:37Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> Well, we could just use the hash associated with the cipher suite, no?\r\n\r\n@ekr That's possible, but then the server needs to offer a list of hash algorithms that it understands in ESNIKeys, or the client needs to send hash digests for all the cipher-suites it offers.",
          "createdAt": "2018-05-14T15:48:15Z",
          "updatedAt": "2018-05-14T15:48:15Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho I don't think that's necessary. We can assume SHA256 or some other MTI hash function for this to work. \r\n\r\nIn the interest of future proofing, let's use a hash. I care much less about agility for the algorithm in question.",
          "createdAt": "2018-05-14T15:49:30Z",
          "updatedAt": "2018-05-14T15:49:30Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> I don't think that's necessary. We can assume SHA256 or some other MTI hash function for this to work.\r\n\r\nAssuming that is true, I am happy to go for using hash. The primary reason is that we can remove `label` and use the hash value as the key to identify the ESNIKeys record that the client used.\r\n\r\nOTOH, I am still not convinced why we do not need to negotiate the hash algorithm, especially when we are talking about the possibility of transferring additional extensions in the future that will be under the same protection. But I am not a crypto person and I could well be wrong, especially when it is midnight here.\r\n\r\nAnyways thank you very much for your quick response and for quickly merging the other PR. This PR is now in sync with master. Please feel free to use this as a basis of creating a PR that implements hash-based protection, if the current text looks worth enough.",
          "createdAt": "2018-05-14T16:14:33Z",
          "updatedAt": "2018-05-14T16:14:33Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Interesting point about using the hash as the label, though it might help to keep the label in the event that we come up with another way to publish ESNI keys. \r\n\r\nRegarding negotiation, I think SHA256 is sufficient for now and the future. Negotiating yet another algorithm seems like unnecessary complexity here. I can take a stab at writing that text, though I think what you have here is nearly there.",
          "createdAt": "2018-05-14T16:18:47Z",
          "updatedAt": "2018-05-14T16:18:47Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry, I'm confused: the DNS record contains a list oc cipher suites, each of which is associated with a hash. The client chooses one to use to encrypt the SNI. Why can't that be the one you use to hash the ESNIKeys record",
          "createdAt": "2018-05-14T19:50:36Z",
          "updatedAt": "2018-05-14T19:50:36Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@ekr That'd work fine, I just think it's unnecessary here.",
          "createdAt": "2018-05-14T19:57:09Z",
          "updatedAt": "2018-05-14T19:57:09Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "So there's the argument that always using SHA-256 should be fine, and there's the argument that that the cipher-suites list can sent in ESNIKeys to solve the issue.\r\n\r\nI disagree to both. I have already explained why I think using SHA256 always is not fine. Let me explain why I think sending cipher-suites list in ESNIKeys is not fine.\r\n\r\n@ekr Traditionally, we have allowed different cipher-suites to be selected depending on the value of SNI. This becomes an even more important property in the ESNI proposal, because we split the server into fronting server and hidden server. Cipher-suite selection is a negotiation between the client and the hidden server, whereas the ESNIKeys is a key-exchange between the client and the fronting server.\r\n\r\nTherefore, we cannot / should not use ESNIKeys as a conveyer of cipher-suite negotiation.\r\n\r\nConsidering that we have disagreement on the how we can uses hashes, maybe it is a good idea to merge this as-is to fix the security hole, and get back to do the improvements later on if necessary. I thought that we wanted to submit this soon.",
          "createdAt": "2018-05-14T22:42:29Z",
          "updatedAt": "2018-05-14T22:42:29Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho The ciphersuite that's sent by the client in the EncryptedSNI extension only applies to that extension, not to the rest of the handshake or data, right? ",
          "createdAt": "2018-05-14T22:51:33Z",
          "updatedAt": "2018-05-14T22:51:33Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood Ah! That's correct. We now have two cipher-suites. I am fine with using the cipher-suite then.",
          "createdAt": "2018-05-14T22:58:23Z",
          "updatedAt": "2018-05-14T22:58:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Cool -- I'll propose some text. :-)\r\n",
          "createdAt": "2018-05-14T22:59:36Z",
          "updatedAt": "2018-05-14T22:59:36Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "Applied @chris-wood's patch that changes the protection from using a list of Named Groups to using a digest specified by the cipher-suite.",
          "createdAt": "2018-05-15T20:44:35Z",
          "updatedAt": "2018-05-15T20:44:35Z"
        },
        {
          "author": "kontaxis",
          "authorAssociation": "NONE",
          "body": "record_digest is sent together with encrypted_sni in EncryptedSNI which is supposed to be the sensitive information you want to protect from a downgrade attack.\r\n\r\nSo assuming there is a downgrade attack (I'm guessing you get bad key information from the DNS record) the client falls for it, sends the ESNI in a way that allows it to be compromised, and also sends the hash for the server to check whether an attack is going on.\r\n\r\nFronting Server Behavior text says \"If the EncryptedSNI.record_digest value does not match the cryptographic hash of the associated ENSIKeys structure, it MUST abort the connection\"\r\n\r\nBy the time the server realizes the hash is incorrect and drops the connection the ESNI has already been sent over the wire by the client. (And the adversary has intercepted it) So what's the benefit of dropping the connection at that point?\r\n\r\n\r\nAs a side-note, can you explain the specific downgrade attacks you have in mind? My understanding is that the threat here is learning the value of SNI. If you are able to tamper with the DNS record then by definition you know (or can learn) the client's query for the domain name. Why would you need to attack the key material and try to decrypt the ESNI? And on the other hand, if you don't have r/w access to the DNS records, how can you carry out a downgrade attack?",
          "createdAt": "2018-05-16T01:39:51Z",
          "updatedAt": "2018-05-16T01:39:51Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> By the time the server realizes the hash is incorrect and drops the connection the ESNI has already been sent over the wire by the client. (And the adversary has intercepted it) So what's the benefit of dropping the connection at that point?\r\n\r\nThat's a good question.\r\n\r\nThe issue here is the Named Group that is being selected for ESNI protection key will also be used for negotiating the handshake. So the TLS handshake gets compromised (and that is what we are calling downgrade attack here).\r\n\r\nPlease refer to the first paragraph for https://github.com/ekr/draft-rescorla-tls-esni/pull/24#issuecomment-388864250.",
          "createdAt": "2018-05-16T03:24:29Z",
          "updatedAt": "2018-05-16T03:27:03Z"
        },
        {
          "author": "kontaxis",
          "authorAssociation": "NONE",
          "body": "> The issue here is the Named Group that is being selected for ESNI protection key will also be used for negotiating the handshake. So the TLS handshake gets compromised (and that is what we are calling downgrade attack here).\r\n\r\nCan we treat the ESNI key derivation and TLS key derivation as separate processes?\r\n\r\nSeems like the reason we need to protect against downgrade attacks is because we are reusing the (potentially poisoned) ESNIKeys KeyShareEntry structure in the TLS key schedule.\r\n\r\nIf we were to limit its use to just ESNI key derivation would we still need to protect against downgrade attacks?",
          "createdAt": "2018-05-16T04:03:13Z",
          "updatedAt": "2018-05-16T04:03:13Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> Can we treat the ESNI key derivation and TLS key derivation as separate processes?\r\n\r\nMy understanding is that that is possible, and then we do not need to send the digest value of the ESNIKeys structure assuming that we do not add extensions that need downgrade protection.\r\n\r\nHowever, that would require the client to send and generate one more ECDH key, as well as increasing the probability of HRR due to group mismatch.\r\n\r\nTo put it another way, the approach used in this PR is on par with the amount of the data transmitted (the size of the digest and the ECDH key are roughly equal), has the possibility of cutting a round-trip, requires less CPU cost.",
          "createdAt": "2018-05-17T02:20:52Z",
          "updatedAt": "2018-05-17T02:20:52Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5ODI1ODI1",
          "commit": {
            "abbreviatedOid": "5013603"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I'm not sure this change is needed to prevent the attack in question. ",
          "createdAt": "2018-05-14T13:11:54Z",
          "updatedAt": "2018-05-14T13:13:29Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "This makes it so that each label maps to a set of keys, which was not the original intent. We want there to be a 1-1 mapping between label and key, as that allows a server to abort a connection with illegal_parameter if there's a label mismatch, i.e., if a client offers a label that the server does not recognize. ",
              "createdAt": "2018-05-14T13:11:54Z",
              "updatedAt": "2018-05-15T22:44:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5ODQxNTU0",
          "commit": {
            "abbreviatedOid": "5013603"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-14T13:50:27Z",
          "updatedAt": "2018-05-14T13:50:28Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Please disregard! I did not read your comments in #19. The (label, group) => key mapping seems plausible. Though I don't think the NamedGroupList is necessary to prevent downgrade attacks.",
              "createdAt": "2018-05-14T13:50:27Z",
              "updatedAt": "2018-05-15T22:44:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIwNDMzNzg3",
          "commit": {
            "abbreviatedOid": "f95eb78"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This LGTM. @ekr, PTAL when you have time.",
          "createdAt": "2018-05-15T22:11:00Z",
          "updatedAt": "2018-05-15T22:11:00Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIwNDM5ODUw",
          "commit": {
            "abbreviatedOid": "f95eb78"
          },
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-15T22:36:44Z",
          "updatedAt": "2018-05-15T22:36:45Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "What is this struct used for?",
              "createdAt": "2018-05-15T22:36:45Z",
              "updatedAt": "2018-05-15T22:44:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIwNDQxNjY0",
          "commit": {
            "abbreviatedOid": "f55f9c3"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-15T22:45:25Z",
          "updatedAt": "2018-05-15T22:45:25Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Nice catch! We no longer need it. Addressed in f55f9c3.",
              "createdAt": "2018-05-15T22:45:25Z",
              "updatedAt": "2018-05-15T22:45:25Z"
            }
          ]
        }
      ]
    },
    {
      "number": 26,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3ODExNTYw",
      "title": "clarify that limitation of hash-based protection",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/26",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The approach does not work if the mapping between the fronting server and the hidden server contains a wildcard.",
      "createdAt": "2018-05-14T12:31:08Z",
      "updatedAt": "2018-05-14T13:17:38Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "77a9cef4ba9de590a1cf327a655e10ce0df6d11d",
      "headRepository": "kazuho/draft-rescorla-tls-esni",
      "headRefName": "kazuho/hash-based-vs-wildcard-delegation",
      "headRefOid": "ffc797263c950cb44cfd5c199f8f55c57209598f",
      "closedAt": "2018-05-14T13:17:38Z",
      "mergedAt": "2018-05-14T13:17:38Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "16b8a6ff244862647683be24fcded2ab8b5657e9"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM!",
          "createdAt": "2018-05-14T13:05:17Z",
          "updatedAt": "2018-05-14T13:05:25Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5ODIzNDI3",
          "commit": {
            "abbreviatedOid": "ffc7972"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-14T13:05:07Z",
          "updatedAt": "2018-05-14T13:05:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 31,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3OTY2MTM4",
      "title": "Clarify requirements for domains with multiple A, AAAA, ... reconrds",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/31",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "See #29 ",
      "createdAt": "2018-05-14T22:17:28Z",
      "updatedAt": "2018-05-14T22:50:00Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3ad81cc1e3a141ca9ad90c5d184773a25cca4af8",
      "headRepository": null,
      "headRefName": "mulitple_records",
      "headRefOid": "103b04c10bfa6c946c7b290b13a5365661f0d71a",
      "closedAt": "2018-05-14T22:50:00Z",
      "mergedAt": "2018-05-14T22:50:00Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "e19b8088bb5e81983c9b279614766cc8fa7839bf"
      },
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "This looks good to me.\r\n\r\nClarifying the requirements rather than specifying how to act makes more sense here.\r\n\r\nFWIW, I thought the intent of the original text was to encourage _not_ having ESNIKeys shared between multiple hosts whenever possible. This change loses that property. But anyways, that is mentioned in the appendix. Hence my :+1: to the PR.",
          "createdAt": "2018-05-14T22:48:37Z",
          "updatedAt": "2018-05-14T22:48:37Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIwMDMyMzMy",
          "commit": {
            "abbreviatedOid": "103b04c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-14T22:27:31Z",
          "updatedAt": "2018-05-14T22:49:55Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "The ALTSVC records don't matter as much here, and probably shouldn't be bound to the MUST. The rest LGTM.",
              "createdAt": "2018-05-14T22:27:31Z",
              "updatedAt": "2018-05-14T22:49:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 36,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg4MjU3MTU1",
      "title": "normative reference to RFC 4408",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/36",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Lack of the specifier (`!`, `?`) was causing a build error when trying to build the HTML.",
      "createdAt": "2018-05-15T21:11:54Z",
      "updatedAt": "2018-05-15T22:09:55Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "e19b8088bb5e81983c9b279614766cc8fa7839bf",
      "headRepository": "kazuho/draft-rescorla-tls-esni",
      "headRefName": "kazuho/normative-reference-to-rfc4408",
      "headRefOid": "279d79a0697d792288df0054161568c76fe5a87e",
      "closedAt": "2018-05-15T22:09:55Z",
      "mergedAt": "2018-05-15T22:09:55Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "6ba58db63026fed2bcbabe3290e2af451ee6f5bf"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 43,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg4ODMxMDY2",
      "title": "Remove `label`",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/43",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Now that #24 has been merged, label seems to be an unnecessary complication.\r\n\r\n* label has no actual use on the client\r\n* because labels cannot collide, the key generator needs to either keep some state across all invocations (you need a trustable store), or generate a UUID (it's just a random junk) to be used as a label\r\n* a TLS server is required to at first compare the label and then check the digest.\r\n\r\nThese three issues go away if we eliminate label. Key generators do not need to care about uniqueness. TLS servers can just look for the matching digest and that's it.\r\n\r\nNote that a server operator can still associate an identifier to the ESNIKeys structure for internal use. The private key will be kept in relation to the structure anyways. So having a private identifier does not complicate things at all.",
      "createdAt": "2018-05-17T18:59:43Z",
      "updatedAt": "2018-05-21T02:17:03Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "6276955dbfee725e5db060d38d66cd479d8acf58",
      "headRepository": "kazuho/draft-rescorla-tls-esni",
      "headRefName": "kazuho/no-label",
      "headRefOid": "b5ce41040b3f28706ae2f4aa99980e1f705d2e32",
      "closedAt": "2018-05-21T02:17:03Z",
      "mergedAt": "2018-05-21T02:17:02Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "1e1a8ffcc57a616ab418e3097f583da96ce40f42"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIxMTg4MDY2",
          "commit": {
            "abbreviatedOid": "b5ce410"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGMT -- I much prefer content-based identifiers to labels. ",
          "createdAt": "2018-05-17T19:42:22Z",
          "updatedAt": "2018-05-17T19:42:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 44,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg4ODQ1MzM3",
      "title": "Remove reference to ALTSVC",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/44",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #34\r\n\r\nAlso see https://github.com/ekr/draft-rescorla-tls-esni/pull/31#discussion_r188117285",
      "createdAt": "2018-05-17T19:59:40Z",
      "updatedAt": "2018-05-17T20:29:24Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "6276955dbfee725e5db060d38d66cd479d8acf58",
      "headRepository": null,
      "headRefName": "no-altsvc",
      "headRefOid": "46b519f3105f06796ef8c5dee7d2987179556a52",
      "closedAt": "2018-05-17T20:29:24Z",
      "mergedAt": "2018-05-17T20:29:24Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "67ca02fdc6be26906aa401ad8e6a68f839c33a5d"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM -- thanks!",
          "createdAt": "2018-05-17T20:29:20Z",
          "updatedAt": "2018-05-17T20:29:20Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIxMjAzNzA4",
          "commit": {
            "abbreviatedOid": "46b519f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-17T20:29:07Z",
          "updatedAt": "2018-05-17T20:29:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 45,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg5MjU5OTIw",
      "title": "Tone down Fronting Mode",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/45",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@ghedo, PTAL! I tried Transparent mode, though this seemed subjectively better at the time. I'm happy to be convinced otherwise.",
      "createdAt": "2018-05-20T23:59:08Z",
      "updatedAt": "2018-05-21T00:08:27Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "67ca02fdc6be26906aa401ad8e6a68f839c33a5d",
      "headRepository": null,
      "headRefName": "caw/nix-fronting",
      "headRefOid": "5b49eeb30048f04acff1fbcc4cfe74bce5111261",
      "closedAt": "2018-05-21T00:08:27Z",
      "mergedAt": "2018-05-21T00:08:27Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "14cc61eec9b80485d1356857b20c356a1eda0b23"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 46,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg5NDk3Mzg4",
      "title": "add a missing \"and\"",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/46",
      "state": "MERGED",
      "author": "reaperhulk",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Just a trivial fix \ud83d\ude04 ",
      "createdAt": "2018-05-21T21:50:35Z",
      "updatedAt": "2018-05-21T21:51:29Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1e1a8ffcc57a616ab418e3097f583da96ce40f42",
      "headRepository": "reaperhulk/draft-rescorla-tls-esni",
      "headRefName": "patch-1",
      "headRefOid": "1a8b50a4e7240902024dcbdf753db69e34b07605",
      "closedAt": "2018-05-21T21:51:29Z",
      "mergedAt": "2018-05-21T21:51:29Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "dd379d3031f72b6137d2bbee6d067d0787187b39"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIxOTU5NjM3",
          "commit": {
            "abbreviatedOid": "1a8b50a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-21T21:51:24Z",
          "updatedAt": "2018-05-21T21:51:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 48,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkwNDYwNjkw",
      "title": "Add text regarding padding of wildcard delegations, and pad Certificate messages using padding(21)",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/48",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-25T01:32:18Z",
      "updatedAt": "2018-06-16T01:49:21Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "dd379d3031f72b6137d2bbee6d067d0787187b39",
      "headRepository": null,
      "headRefName": "caw/padded",
      "headRefOid": "095eae5ab689aaec89bdabbefb7f9b8caace394b",
      "closedAt": "2018-06-12T17:28:51Z",
      "mergedAt": "2018-06-12T17:28:51Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "44589659396b2f58fccb980860f270cdcbe42684"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzMjQ4MDY4",
          "commit": {
            "abbreviatedOid": "74fc57e"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you for working on this! LGTM aside from the two comments shown below.",
          "createdAt": "2018-05-25T05:30:19Z",
          "updatedAt": "2018-05-25T05:35:11Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "Shouldn't we pad the Certificate message so that it would become as large as the largest Certificate message that ~~would be offered from the server's IP address~~ is covered by the same ESNI key?\r\n\r\nThe same goes for the provision in the Split Mode.",
              "createdAt": "2018-05-25T05:30:19Z",
              "updatedAt": "2018-06-12T17:27:03Z"
            },
            {
              "originalPosition": 27,
              "body": "Considering the fact that the distribution of the ESNI keys is not limited to DNS, it might be worth specifying that the 256 chars limitation is specific to when DNS is being used; e.g. \"If the server supports wildcard names *resolved by DNS*\".",
              "createdAt": "2018-05-25T05:34:24Z",
              "updatedAt": "2018-06-12T17:27:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzMzU1MDcy",
          "commit": {
            "abbreviatedOid": "74fc57e"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-25T12:38:57Z",
          "updatedAt": "2018-05-25T12:39:03Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "I agree with what @kazuho says here. It's not straightforward.\r\n\r\nit's worth noting that this is one case in which random padding might be of some value, because the attacker doesn't know which connections correspond to the same SNI, and therefore can't do simple averageing.",
              "createdAt": "2018-05-25T12:38:57Z",
              "updatedAt": "2018-06-12T17:27:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNDMxMTM4",
          "commit": {
            "abbreviatedOid": "74fc57e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-25T16:10:12Z",
          "updatedAt": "2018-05-25T16:10:13Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "@kazuho I like it -- that's more precise. I'll update accordingly.",
              "createdAt": "2018-05-25T16:10:12Z",
              "updatedAt": "2018-06-12T17:27:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNDMxMzAx",
          "commit": {
            "abbreviatedOid": "74fc57e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-25T16:10:45Z",
          "updatedAt": "2018-05-25T16:10:45Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "\ud83d\udc4d ",
              "createdAt": "2018-05-25T16:10:45Z",
              "updatedAt": "2018-06-12T17:27:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNTQ4ODM5",
          "commit": {
            "abbreviatedOid": "74fc57e"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-26T06:10:35Z",
          "updatedAt": "2018-05-26T06:10:35Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "\ud83d\udc4d ",
              "createdAt": "2018-05-26T06:10:35Z",
              "updatedAt": "2018-06-12T17:27:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNTkwMDg2",
          "commit": {
            "abbreviatedOid": "e10707d"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-27T17:10:22Z",
          "updatedAt": "2018-05-27T17:10:25Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "Why do you think we should use this rather than pad at the record layer?",
              "createdAt": "2018-05-27T17:10:22Z",
              "updatedAt": "2018-06-12T17:27:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNTkwOTkw",
          "commit": {
            "abbreviatedOid": "e10707d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-27T17:51:20Z",
          "updatedAt": "2018-05-27T17:51:20Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "IIUC one could pad Certificate messages offline, if you wanted. One could also pad at the record later. I\u2019ll just note one or the other. ",
              "createdAt": "2018-05-27T17:51:20Z",
              "updatedAt": "2018-06-12T17:27:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MDY3MDEw",
          "commit": {
            "abbreviatedOid": "3d1c6d4"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Sorry, I missed the padding thing, so you'll need to adjust",
          "createdAt": "2018-06-12T17:21:14Z",
          "updatedAt": "2018-06-12T17:22:02Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "Actually, you can't use padding here. It's only allowed in CH.",
              "createdAt": "2018-06-12T17:21:15Z",
              "updatedAt": "2018-06-12T17:27:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MDcxNzYw",
          "commit": {
            "abbreviatedOid": "095eae5"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-12T17:33:54Z",
          "updatedAt": "2018-06-15T23:28:17Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "This change is unrelated. ",
              "createdAt": "2018-06-12T17:33:55Z",
              "updatedAt": "2018-06-15T23:28:17Z"
            },
            {
              "originalPosition": 83,
              "body": "Again, this recommendation describes a single anonymity set.  Because the size of esni and certificate both contribute to information that distinguishes connections, you should include text on padding that addresses the combination of the two fields.",
              "createdAt": "2018-06-15T23:25:47Z",
              "updatedAt": "2018-06-15T23:28:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5MzUwMzgz",
          "commit": {
            "abbreviatedOid": "095eae5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-16T01:49:04Z",
          "updatedAt": "2018-06-16T01:49:04Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "Yeah. The document failed to build with this, so I removed it. ",
              "createdAt": "2018-06-16T01:49:04Z",
              "updatedAt": "2018-06-16T01:49:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5MzUwMzkw",
          "commit": {
            "abbreviatedOid": "095eae5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-16T01:49:21Z",
          "updatedAt": "2018-06-16T01:49:21Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "Yep, good point. I\u2019ll update in a separate PR. ",
              "createdAt": "2018-06-16T01:49:21Z",
              "updatedAt": "2018-06-16T01:49:21Z"
            }
          ]
        }
      ]
    },
    {
      "number": 49,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk0MTQ2ODg5",
      "title": "Briefly discuss pros and cons of alternative designs",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/49",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-06-12T01:56:08Z",
      "updatedAt": "2018-06-20T22:53:19Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "44589659396b2f58fccb980860f270cdcbe42684",
      "headRepository": null,
      "headRefName": "caw/alternates",
      "headRefOid": "35eb736a1fd180e0364d3a0ba036cbcd483c1ca2",
      "closedAt": "2018-06-20T22:50:19Z",
      "mergedAt": "2018-06-20T22:50:19Z",
      "mergedBy": "kazuho",
      "mergeCommit": {
        "oid": "368ed7d1ba6bd0124fe1afe7f0a7c33c2dd03650"
      },
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood Thank you for the changes. It's super clear to me now.",
          "createdAt": "2018-06-20T22:53:18Z",
          "updatedAt": "2018-06-20T22:53:18Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3ODA1NTQ5",
          "commit": {
            "abbreviatedOid": "e0403f5"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you for working on the improvement.\r\n\r\nIt was easy to read, and I like the way you categorize the approaches. I have left my comments in-line.",
          "createdAt": "2018-06-12T02:57:21Z",
          "updatedAt": "2018-06-12T03:02:50Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "I am not sure if \"TLS tunnel\" requires a previous session or the use of 0-RTT data.\r\n\r\nWould you mind considering either adjusting the name or adjusting the text? Because what I expect for a scheme called \"TLS tunnel\" is as follows:\r\n\r\n\"TLS tunnel\" is an approach that first establishes a TLS connection to a fronting host, and then, on top of that connection, establishes another TLS connection that uses the hostname of the hidden host.\r\n\r\nIf that is the case, I'd assume that all prior knowledge that is necessary is the binding between two names: name of the fronting host and that of the hidden host.\r\n\r\nIn other words, I'd expect that the \"TLS Tunnel\" scheme will be distributing using DNS the name of the fronting host instead of the ESNI key.\r\n\r\nThe downside of the tunneling is approach will be that there will be additional roundtrip when 0-RTT is not used, as well as the cost of double handshake and double encryption.",
              "createdAt": "2018-06-12T02:57:22Z",
              "updatedAt": "2018-06-20T00:28:06Z"
            },
            {
              "originalPosition": 47,
              "body": "Doesn't the scheme also has the bootstrap problem: i.e. distributing the name of the client-facing server that corresponds to the name of the server that the client actually wants to connect to?\r\n\r\nI can see that such binding can sometimes advertised eagerly using the CERTIFICATE frames, but I do not think that can be done for every host that the client might want to connect to.",
              "createdAt": "2018-06-12T03:01:38Z",
              "updatedAt": "2018-06-20T00:28:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5MzE1NjI2",
          "commit": {
            "abbreviatedOid": "e0403f5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-15T20:59:16Z",
          "updatedAt": "2018-06-15T20:59:16Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Depending on how it's done, yeah, bootstrapping is also an issue here. I'll mention that.",
              "createdAt": "2018-06-15T20:59:16Z",
              "updatedAt": "2018-06-20T00:28:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5MzE3MjY5",
          "commit": {
            "abbreviatedOid": "2c95fcd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-15T21:05:49Z",
          "updatedAt": "2018-06-15T21:05:49Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "@kazuho The tunnel approach you describe is a simple proxy. We can describe it here, though it's different from what was the \"hide TLS in early data\" proposal. I updated the title to try to make it more clear.",
              "createdAt": "2018-06-15T21:05:49Z",
              "updatedAt": "2018-06-20T00:28:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5NDI4NTgy",
          "commit": {
            "abbreviatedOid": "2c95fcd"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-18T05:09:11Z",
          "updatedAt": "2018-06-18T05:09:11Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Thank you for the changes.\r\n\r\nNow I think I understand the approach suggested here; it's about encapsulating CH using 0-RTT data of an outer TLS connection, but sending the rest of the TLS transmissions directly (i.e. without double encryption).\r\n\r\nAssuming that that is true, it might be worth clarifying that (e.g., state something like \"Rest of the TLS messages / records are exchanged directly between the peers without double encryption\").\r\n\r\nOther than that, the PR looks to be ready for merge.",
              "createdAt": "2018-06-18T05:09:11Z",
              "updatedAt": "2018-06-20T00:28:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwMTYyMjE3",
          "commit": {
            "abbreviatedOid": "7a96223"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-19T21:13:53Z",
          "updatedAt": "2018-06-19T21:13:53Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "@kazuho I added some clarifying text. Please have a look!",
              "createdAt": "2018-06-19T21:13:53Z",
              "updatedAt": "2018-06-20T00:28:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwMTgyMjIw",
          "commit": {
            "abbreviatedOid": "7a96223"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-19T22:22:58Z",
          "updatedAt": "2018-06-19T22:22:58Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Thank you for explicitly stating that only Client Hello is sent as 0-RTT data.\r\n\r\nMaybe we might want to change the sentence starting from \"All Server Hello ...\" to something like \"Rest of the exchanges between the client and the hidden server, starting from Server Hello, are forwarded by the client-facing server -- unmodified.\", to clarify that exchanges following Server Hello are also forwarded directly.\r\n\r\nOther than that, the PR looks ready for merge to me.",
              "createdAt": "2018-06-19T22:22:58Z",
              "updatedAt": "2018-06-20T00:28:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwMTgyODM3",
          "commit": {
            "abbreviatedOid": "7a96223"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-19T22:25:33Z",
          "updatedAt": "2018-06-19T22:25:33Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "@kazuho  I don't think that's necessary, since the remaining messages must necessarily also be forwarded.",
              "createdAt": "2018-06-19T22:25:33Z",
              "updatedAt": "2018-06-20T00:28:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwMTg1NzM4",
          "commit": {
            "abbreviatedOid": "7a96223"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-19T22:38:48Z",
          "updatedAt": "2018-06-19T22:38:49Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "The reason I suggested the change is because the paragraph seemed to be unclear to me on whether or not the handshake messages and application data that follows Server Hello is double-encrypted, because it only discusses about Client Hello and Server Hello explicitly.",
              "createdAt": "2018-06-19T22:38:48Z",
              "updatedAt": "2018-06-20T00:28:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwMjA1NzIx",
          "commit": {
            "abbreviatedOid": "35eb736"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-20T00:28:08Z",
          "updatedAt": "2018-06-20T00:28:08Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "@kazuho Should be more clear now!",
              "createdAt": "2018-06-20T00:28:08Z",
              "updatedAt": "2018-06-20T00:28:08Z"
            }
          ]
        }
      ]
    },
    {
      "number": 50,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk1MjkxMjE2",
      "title": "Add Nick",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/50",
      "state": "MERGED",
      "author": "grittygrease",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-06-15T21:54:29Z",
      "updatedAt": "2018-06-15T21:54:49Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "44589659396b2f58fccb980860f270cdcbe42684",
      "headRepository": "grittygrease/draft-rescorla-tls-esni",
      "headRefName": "nick/author",
      "headRefOid": "d4af1ee50283017f52d56ee587f567876514bc90",
      "closedAt": "2018-06-15T21:54:49Z",
      "mergedAt": "2018-06-15T21:54:49Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "99de7bde18aed8a52e362ae0b33a89540efbbbba"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5MzI4MTM0",
          "commit": {
            "abbreviatedOid": "d4af1ee"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-15T21:54:45Z",
          "updatedAt": "2018-06-15T21:54:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 51,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk2NjI4NTkw",
      "title": "Self-add author.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/51",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Please do not merge yet!",
      "createdAt": "2018-06-22T03:22:55Z",
      "updatedAt": "2021-04-19T15:51:28Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "368ed7d1ba6bd0124fe1afe7f0a7c33c2dd03650",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/author",
      "headRefOid": "1a8b0959b887f86ca8bf9f93c4e6652c9a341020",
      "closedAt": "2018-06-25T19:42:07Z",
      "mergedAt": "2018-06-25T19:42:07Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f0e80361e890e99d86477c8c03b86a4b51699f76"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 52,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4NTIzMjg2",
      "title": "Fix use of padded_length",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/52",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "\"padding_length\" appears out of nowhere and is not defined.",
      "createdAt": "2018-07-01T12:59:36Z",
      "updatedAt": "2018-07-02T14:11:47Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f0e80361e890e99d86477c8c03b86a4b51699f76",
      "headRepository": null,
      "headRefName": "padding_len",
      "headRefOid": "0348f408b95c833744de9571f9ce9a09de4f1f34",
      "closedAt": "2018-07-02T14:11:47Z",
      "mergedAt": "2018-07-02T14:11:47Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "df2fcf152d436683090eb0ae395dddd699ed33f4"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 53,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4NTIzNjc3",
      "title": "Prevent clients from caching keys based on not_after",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/53",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-01T13:09:03Z",
      "updatedAt": "2018-07-02T14:15:50Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f0e80361e890e99d86477c8c03b86a4b51699f76",
      "headRepository": null,
      "headRefName": "client_cache",
      "headRefOid": "9f452faf97a5cc082dea2c548a2d9e487a480617",
      "closedAt": "2018-07-02T14:15:50Z",
      "mergedAt": "2018-07-02T14:15:50Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "237cb9dd389c23224379eb0cfd1f72211403d0db"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzNDU1NzA2",
          "commit": {
            "abbreviatedOid": "9f452fa"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-01T14:19:43Z",
          "updatedAt": "2018-07-01T14:19:43Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I am sympathetic to the proposed change, but might prefer using \"SHOULD NOT\" rather than a \"MUST NOT\" here.\r\n\r\nConsider a client that uses `getaddrinfo`. The client cannot access the TTL value. OTOH, it makes sense for such a client to cache the query result for a short amount of time to reduce the load on the resolver running on the client machine. My understanding is that some clients are implemented that way.",
              "createdAt": "2018-07-01T14:19:43Z",
              "updatedAt": "2018-07-01T14:19:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzNTk1MTk2",
          "commit": {
            "abbreviatedOid": "9f452fa"
          },
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-02T11:54:59Z",
          "updatedAt": "2018-07-02T11:54:59Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "This PR only prevents the client from using \"not_after\" for caching, it doesn't really forbid using another random value (not sure if we want to be more specific on this).\r\n\r\nAnyway, I'm fine changing this to SHOULD NOT.",
              "createdAt": "2018-07-02T11:54:59Z",
              "updatedAt": "2018-07-02T11:54:59Z"
            }
          ]
        }
      ]
    },
    {
      "number": 54,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4NTI2MjE1",
      "title": "ServerNameList should be 260 octets long for fronting servers with wildcard support",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/54",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Because the longest name is 255 octets (see RFC 1035), and there is 5-octet overhead in the ServerNameList structure (defined in RFC 6066 as shown below).\r\n\r\n```\r\n      struct {\r\n          NameType name_type;\r\n          select (name_type) {\r\n              case host_name: HostName;\r\n          } name;\r\n      } ServerName;\r\n\r\n      enum {\r\n          host_name(0), (255)\r\n      } NameType;\r\n\r\n      opaque HostName<1..2^16-1>;\r\n\r\n      struct {\r\n          ServerName server_name_list<1..2^16-1>\r\n      } ServerNameList;\r\n```\r\n\r\namends #48 ",
      "createdAt": "2018-07-01T14:12:23Z",
      "updatedAt": "2018-07-02T14:15:27Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f0e80361e890e99d86477c8c03b86a4b51699f76",
      "headRepository": "kazuho/draft-rescorla-tls-esni",
      "headRefName": "kazuho/fix-max-length",
      "headRefOid": "c153340a60062c6698015e805ca9690d5782a721",
      "closedAt": "2018-07-02T14:15:27Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Why not just pad the name ? Then the field can be 1 octet. ",
          "createdAt": "2018-07-01T23:50:55Z",
          "updatedAt": "2018-07-01T23:50:55Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson \r\n> Why not just pad the name ? Then the field can be 1 octet.\r\n\r\nThat's definitely possible, but I am not sure if we want to do that.\r\n\r\nUntil now, we have tried to consider ServerNameList  (the server_name extension) as an abstract structure. Current draft allows us to use the ESNIKeys to encrypt a server_name extension of any name_type.\r\n\r\nDefining padded_length to designate the length of the HostName field that exists only when server_name.name_type == host_name destroys that abstraction.\r\n\r\nNote also that specifying the amount of padding appended to ServerNameList based on the value of `ServerNameList[0].name.HostName` makes implementations complex. This is because you would be required to parse the struct before validating the length of the padding.\r\n\r\nGenerally speaking, I am not opposed to dealing directly with \"hostname\"s stored in the server_name extension. However, if that is the case, I think we should consider adding a `encrypted_host_name` type to the NameType so that we do not need to deal with the complex structure of ServerNameList.",
          "createdAt": "2018-07-02T01:47:30Z",
          "updatedAt": "2018-07-02T01:47:58Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I tend to think we should leave it as-is rather than breaking the\nencapsulation barrier.\n\nOn Sun, Jul 1, 2018 at 6:47 PM, Kazuho Oku <notifications@github.com> wrote:\n\n> @martinthomson <https://github.com/martinthomson>\n>\n> Why not just pad the name ? Then the field can be 1 octet.\n>\n> That's definitely possible, but I am not sure if we want to do that.\n>\n> Until now, we have tried to consider ServerNameList (the server_name\n> extension) as an abstract structure. Current draft allows us to use the\n> ESNIKeys to encrypt a server_name extension of any name_type.\n>\n> Defining padded_length to designate the length of the HostName field that\n> exists only when server_name.name_type == host_name destroys that\n> abstraction.\n>\n> Note also that specifying the amount of padding appended to ServerNameList\n> based on the value of ServerNameList[0].name.HostName makes\n> implementations complex. This is because you would be required to parse the\n> struct before validating the length of the padding.\n>\n> Generally speaking, I am not opposed removing the restriction to directly\n> deal with \"hostname\"s stored in the server_name extension. However, if that\n> is the case, I think we should consider adding a encrypted_host_name type\n> to the NameType so that we do not need to deal with the complex structure\n> of ServerNameList.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ekr/draft-rescorla-tls-esni/pull/54#issuecomment-401650517>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ABD1oYVLU7B1rR_BJVCq4dYXulz-mKLJks5uCXuygaJpZM4U-VrF>\n> .\n>\n",
          "createdAt": "2018-07-02T02:33:45Z",
          "updatedAt": "2018-07-02T02:33:45Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 55,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4NjU0NDEx",
      "title": "Make server send empty encrypted_server_name in EE",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/55",
      "state": "CLOSED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Since encrypted_server_name mirrors server_name, I think it makes sense\r\nfor the server to send this back.\r\n\r\n---\r\n\r\nI don't quite understand the objection regarding \"stock servers\", @ekr ?",
      "createdAt": "2018-07-02T11:46:59Z",
      "updatedAt": "2018-07-09T14:01:34Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f0e80361e890e99d86477c8c03b86a4b51699f76",
      "headRepository": null,
      "headRefName": "server_echo",
      "headRefOid": "106d313f0a7c37833b0ebb2e77a22fe12592cb8f",
      "closedAt": "2018-07-03T08:53:07Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "This will make it impossible to run in split mode without modifying your server, which I think is bad.",
          "createdAt": "2018-07-02T12:47:55Z",
          "updatedAt": "2018-07-02T12:47:55Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Not putting this in -00",
          "createdAt": "2018-07-02T14:10:04Z",
          "updatedAt": "2018-07-02T14:10:04Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oh, I see what you mean now. FWIW, we could just make the Shared Mode server echo the extension. RFC6066 says:\r\n```\r\n   A server that receives a client hello containing the \"server_name\"\r\n   extension MAY use the information contained in the extension to guide\r\n   its selection of an appropriate certificate to return to the client,\r\n   and/or other aspects of security policy.  In this event, the server\r\n   SHALL include an extension of type \"server_name\" in the (extended)\r\n   server hello.\r\n```\r\n\r\nSo if we adopt a similar text, the split mode hidden server technically doesn't use ESNI to select the certificate, so it wouldn't need to echo the extension.",
          "createdAt": "2018-07-02T19:57:46Z",
          "updatedAt": "2018-07-02T19:57:46Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Though now I'm questioning how useful this is at all... even with plain \"server_name\", do clients care if they get back the empty extension?",
          "createdAt": "2018-07-02T20:02:52Z",
          "updatedAt": "2018-07-02T20:02:52Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Clients just ignore SNI from a server: there is no point in a server ever sending it.  It's just another bit of cruftiness in RFC 6066.  (Oh, how I wish that I could enumerate the ways in which that RFC is bad...)",
          "createdAt": "2018-07-03T01:07:43Z",
          "updatedAt": "2018-07-03T01:07:43Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok, so, I guess we don't really want this at all then. I'll make a PR to remove the OPEN ISSUE.",
          "createdAt": "2018-07-03T08:53:07Z",
          "updatedAt": "2018-07-03T08:53:07Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Concur.",
          "createdAt": "2018-07-09T14:01:33Z",
          "updatedAt": "2018-07-09T14:01:33Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 56,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4NjU1Mzky",
      "title": "Add IANA considerations and pick a codepoint from the reserved range",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/56",
      "state": "CLOSED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "**NOTE**, this depends on https://github.com/ekr/draft-rescorla-tls-esni/pull/55 and if we decide that we don't want to send the empty extension in EE, then it needs to be removed from this PR too.",
      "createdAt": "2018-07-02T11:51:37Z",
      "updatedAt": "2018-07-02T14:14:14Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f0e80361e890e99d86477c8c03b86a4b51699f76",
      "headRepository": null,
      "headRefName": "iana",
      "headRefOid": "bb30359063a7189be2e7440b3f9f676ae1544ac8",
      "closedAt": "2018-07-02T14:14:14Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 57,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4Nzc3ODIy",
      "title": "clock skew is about not_after, record TTL will not be affected by that",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/57",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-02T20:12:11Z",
      "updatedAt": "2018-07-02T20:46:08Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "0cd1d37cfd9d8cd7eadb3f0f7204853969f5f14c",
      "headRepository": "kazuho/draft-rescorla-tls-esni",
      "headRefName": "kazuho/reorg-not-after-vs-ttl-discussion",
      "headRefOid": "d75151312c15814691390e2c53833a99598cd037",
      "closedAt": "2018-07-02T20:14:19Z",
      "mergedAt": "2018-07-02T20:14:19Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "3f4ec98e02e5a0478e08041ac93cfdc8300938ee"
      },
      "comments": [
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure this is much better. I would changes the \"Note that servers...\" sentence to something like:\r\n\r\n> Note that servers MAY need to retain the decryption key for some time after \"not_after\", and will need to consider clock skew, internal caches and the like, when selecting the \"not_before\" and \"not_after\" values.",
          "createdAt": "2018-07-02T20:43:35Z",
          "updatedAt": "2018-07-02T20:43:35Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See https://github.com/ekr/draft-rescorla-tls-esni/pull/59",
          "createdAt": "2018-07-02T20:46:08Z",
          "updatedAt": "2018-07-02T20:46:08Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 58,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4Nzc4MDI0",
      "title": "Remove the use of 'hidden'",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/58",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I decided \"hidden\" was bad.\r\n\r\n@mcmanus",
      "createdAt": "2018-07-02T20:13:07Z",
      "updatedAt": "2021-04-19T15:51:29Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "0cd1d37cfd9d8cd7eadb3f0f7204853969f5f14c",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "terminology",
      "headRefOid": "b6c54c7c0a657c91f6e506b8852e7fa16d9e7eac",
      "closedAt": "2018-07-02T20:31:05Z",
      "mergedAt": "2018-07-02T20:31:05Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "6611fb65fa444721fa22ebc3e2303e1d12dab219"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzNzYyODYw",
          "commit": {
            "abbreviatedOid": "9d83bc9"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "+1 to the change. I think that this is the right direction.",
          "createdAt": "2018-07-02T20:18:19Z",
          "updatedAt": "2018-07-02T20:27:32Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "\"private private\" => \"private domains\"",
              "createdAt": "2018-07-02T20:18:19Z",
              "updatedAt": "2018-07-02T20:30:48Z"
            }
          ]
        }
      ]
    },
    {
      "number": 59,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4Nzg1MDg3",
      "title": "Try to clarify clock skew sentence some more",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/59",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-02T20:45:42Z",
      "updatedAt": "2018-07-02T21:12:08Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "6611fb65fa444721fa22ebc3e2303e1d12dab219",
      "headRepository": null,
      "headRefName": "more_nitpick_language",
      "headRefOid": "ce7622476cd7b0ecc172c5cb405cd200a11e7f82",
      "closedAt": "2018-07-02T21:12:07Z",
      "mergedAt": "2018-07-02T21:12:07Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "91ea306749c85e77f7e749469cc2e3aa40362211"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 60,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4ODkzNjY4",
      "title": "Remove OPEN ISSUE about sending empty ESNI in EE",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/60",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As per discussion in https://github.com/ekr/draft-rescorla-tls-esni/pull/55\r\nthis would require changes to Split Mode backend servers, and it turns out\r\nthat even for plain \"server_name\" this behaviour is pretty much useless.",
      "createdAt": "2018-07-03T08:56:39Z",
      "updatedAt": "2018-07-09T14:19:17Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "91ea306749c85e77f7e749469cc2e3aa40362211",
      "headRepository": null,
      "headRefName": "remove_open_issue",
      "headRefOid": "54d7151f1a706036e6d3320d1eede151ec4ed39c",
      "closedAt": "2018-07-09T14:19:16Z",
      "mergedAt": "2018-07-09T14:19:16Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "e72b0512cc779f2273f72a794af18a36598d19a2"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 70,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk5NjA5NzYz",
      "title": "allow use of different Key Share for ESNI and handshake",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/70",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As pointed out in #69, current draft allows a client-facing server to downgrade the TLS handshake under Split mode.\r\n\r\nFor example, if the hidden server supports X25519 and X448 but the ESNIKeys published by the client-facing server only includes X25519, client only sends X25519.\r\n\r\nThis PR fixes the issue in the least intrusive way, by allowing the parties to use different key shares for ESNI and TLS key schedule.\r\n\r\nIn short, KE for ESNI is selected by the server offering the list of supported groups in ESNIKeys and client choosing one; KE for key schedule is selected exactly the same way as is defined in TLS 1.3.\r\n\r\nfixes #67",
      "createdAt": "2018-07-05T23:17:42Z",
      "updatedAt": "2018-07-11T01:36:55Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "91ea306749c85e77f7e749469cc2e3aa40362211",
      "headRepository": "kazuho/draft-rescorla-tls-esni",
      "headRefName": "kazuho/different-ke-for-esni-and-handshake",
      "headRefOid": "6bd78b7a76b1ec9f66c652e28928a4a4d01ccc95",
      "closedAt": "2018-07-11T01:36:55Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho: I haven't gone through this in detail, but doesn't this create the possibility of a cut-and-paste attack if the client uses a less-preferred group.\r\n\r\nConsider the case where the server's preferences are [X448, X25519] and the client's preferences are [X25519, X448]. The client sends one key share: X25519. The attacker then adds his own X448 share. The server decrypts SNI but sends an X448 share, thus allowing the attacker to decrypt the certificate. Is there a reason why this won't work?",
          "createdAt": "2018-07-05T23:33:49Z",
          "updatedAt": "2018-07-05T23:33:49Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@ekr I think you are correct. Thank you for pointing that out. I now understand that the approach used in this PR does not work.\r\n\r\nI also notice that under Split mode, KEs and cipher-suites that can be offered in ESNIKeys will be the intersection of those supported by the various hidden servers. That would mean that the operator of the client-facing server will need to instruct the operators of hidden servers which KE and cipher-suites that they must support; otherwise only secp256r1 / aes128gcm-sha256 will be usable in practice.",
          "createdAt": "2018-07-06T00:18:57Z",
          "updatedAt": "2018-07-06T00:18:57Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 71,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAwMTQ0MTE0",
      "title": "Clarifications",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/71",
      "state": "CLOSED",
      "author": "tmshort",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Use active tense in some places to clarify meaning.\r\nConsolidate shared and split mode common description.\r\nAdd anonymity set size Security Consideration",
      "createdAt": "2018-07-09T15:51:41Z",
      "updatedAt": "2019-10-25T17:57:49Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "e72b0512cc779f2273f72a794af18a36598d19a2",
      "headRepository": "tmshort/draft-rescorla-tls-esni",
      "headRefName": "master-tmshort",
      "headRefOid": "aa1bd7ae6eff44e7e2112e6673f09ac3ad9e1af5",
      "closedAt": "2019-10-25T17:57:49Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing due to staleness. @tmshort, please re-open and update if you still think we need this.",
          "createdAt": "2019-10-25T17:57:49Z",
          "updatedAt": "2019-10-25T17:57:49Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1NDk1OTAx",
          "commit": {
            "abbreviatedOid": "1c26075"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-07-09T16:29:34Z",
          "updatedAt": "2018-07-09T16:31:08Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "I think this creates confusion. From the TLS perspective, the Client-Facing server is the origin server.",
              "createdAt": "2018-07-09T16:29:34Z",
              "updatedAt": "2018-07-10T13:07:52Z"
            },
            {
              "originalPosition": 76,
              "body": "I think you need to soften this point. It's true in principle, but plenty of monitoring entities will not have access to this information.",
              "createdAt": "2018-07-09T16:30:51Z",
              "updatedAt": "2018-07-10T13:07:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1NTE3MTky",
          "commit": {
            "abbreviatedOid": "1c26075"
          },
          "author": "tmshort",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-09T17:27:49Z",
          "updatedAt": "2018-07-09T17:27:49Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Understood. Proxy-mode (as I described) is a hybrid of Shared and Split mode. Any CDN that caches content will operate in this proxy mode. Few operate in split mode; which seems to be more like a firewall in PNAT mode.\r\nSo, proxy-mode be considered a special case of shared mode? \r\n\r\n",
              "createdAt": "2018-07-09T17:27:49Z",
              "updatedAt": "2018-07-10T13:07:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1NTIyNTg5",
          "commit": {
            "abbreviatedOid": "1c26075"
          },
          "author": "tmshort",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-09T17:42:38Z",
          "updatedAt": "2018-07-09T17:42:38Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Thinking about it some more, the difference between these two modes is termination of the TLS connection, rather than where the origin server (and data) actually are. I will try to come up with something.",
              "createdAt": "2018-07-09T17:42:38Z",
              "updatedAt": "2018-07-10T13:07:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1ODczODk2",
          "commit": {
            "abbreviatedOid": "aa1bd7a"
          },
          "author": "tmshort",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-10T15:13:38Z",
          "updatedAt": "2018-07-10T15:13:38Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "softened.",
              "createdAt": "2018-07-10T15:13:38Z",
              "updatedAt": "2018-07-10T15:13:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM2MDY2Njc5",
          "commit": {
            "abbreviatedOid": "aa1bd7a"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-11T01:43:37Z",
          "updatedAt": "2018-07-11T01:43:37Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Use of words like \"origin\" and \"retrieves content\" (below) might sound like that the use of HTTP is implied. It might make sense avoid using such words, and rather talk about things like \"server that terminates TLS\" or \"application data\".",
              "createdAt": "2018-07-11T01:43:37Z",
              "updatedAt": "2018-07-11T01:44:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM2Mjg5MDYw",
          "commit": {
            "abbreviatedOid": "aa1bd7a"
          },
          "author": "tmshort",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-11T15:15:03Z",
          "updatedAt": "2018-07-11T15:15:04Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "This is the text for the common case between shared and split mode. The origin server has different behavior in each case. \r\n\r\nIn shared mode the client-facing-server terminates TLS; the origin may be elsewhere. In split mode, the origin behind the client-facing-server is the server that terminates TLS. That distinction is made below, not here.\r\n\r\nThis text was moved, with minor modifications, from it's original location. The term \"origin\" is frequently used within the CDN community, and has a well-understood meaning. I purposely used \"retrieves content\", because the origin server may very well only use HTTP, if it's a private server protected by this client-facing server.  But I can change it to \"application data\"; I'm not sure it really maters.\r\n\r\n",
              "createdAt": "2018-07-11T15:15:03Z",
              "updatedAt": "2018-07-11T15:15:50Z"
            }
          ]
        }
      ]
    },
    {
      "number": 72,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAwNzU0OTcy",
      "title": "Support both specific RR type and TXT",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/72",
      "state": "CLOSED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The idea here is to have a new RR type which makes DNS people happier, but also be able to fallback to the plain TXT lookup to address @kazuho's concerns.\r\n\r\nThis should also fix #35 since the ESNI lookup will follow the CNAME, I _think_.\r\n\r\nThe ESNI RRData format is kind of dumb, so we probably need to make it better.",
      "createdAt": "2018-07-11T16:16:58Z",
      "updatedAt": "2018-07-11T17:35:15Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "e72b0512cc779f2273f72a794af18a36598d19a2",
      "headRepository": null,
      "headRefName": "rrtype",
      "headRefOid": "7d69391b239f21f8cf6c3fae18f1fb51558ec9ca",
      "closedAt": "2018-07-11T17:35:15Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There is general opposition to doing both ESNI and TXT records, so I made https://github.com/ekr/draft-rescorla-tls-esni/pull/73 to just add a new ESNI RR type.",
          "createdAt": "2018-07-11T17:35:15Z",
          "updatedAt": "2018-07-11T17:35:15Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 73,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAwNzc0MTIw",
      "title": "Replace TXT record with dedicated RRType",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/73",
      "state": "CLOSED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #35.\r\n\r\n---\r\n\r\nThe problem this introduces is that the domain owner won't be able to delegate just the ESNI record of the apex name, to a different DNS provider (like they would be able to do if we used a separate \"_esni.\" prefix), which might prevent adoption from CDNs that do not handle DNS (or that allow customers to use an external DNS provider), since they would need to update the ESNI record frequently for key rotation.\r\n\r\nOn the other hand it solves the CNAME problem outlined in #35.",
      "createdAt": "2018-07-11T17:31:54Z",
      "updatedAt": "2019-03-06T00:55:10Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "7b2c2f8b8ff9656a713b1449a50efb9ee8ca60bc",
      "headRepository": null,
      "headRefName": "rrtype-bis",
      "headRefOid": "e9f39739d5c24e739c777842b01c880b698dc31c",
      "closedAt": "2019-03-06T00:55:10Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> The problem this introduces is that the domain owner won't be able to delegate just the ESNI record of the apex name, to a different DNS provider (like they would be able to do if we used a separate \"_esni.\" prefix), which might prevent adoption from CDNs that do not handle DNS (or that allow customers to use an external DNS provider), since they would need to update the ESNI record frequently for key rotation.\r\n\r\nThis is true, and I would like to avoid the problem. May I ask why you need to remove the prefix? I do not see a reason why we cannot use a prefix _and_ a dedicated type at the same time.\r\n\r\nI prefer discussing whether the `_esni.example.com` record should use TXT or a dedicated type, and if we decide to go with a dedicated type, then we might consider if having a prefix is OK.\r\n\r\n> On the other hand it solves the CNAME problem outlined in #35.\r\n\r\nI do not see how it solves the problem.\r\n\r\nConsider the case where the load of `foo.example.com` uses `cdnA.example` and `cdnB.example`. In such case, `foo.example.com` will sometimes be a CNAME to `cdnA.example` and sometimes to `cdnB.example`.\r\n\r\nWe want both the query for A and ESNI to use the same CNAME.\r\n\r\nBut there is no guarantee that the two queries will reach the recursive resolver at the same time. If they arrive at different time, the recursive resolver might return an A using CNAME `cdnA.example`, then query for `foo.example.com` for ESNI that might return `cdnB.example`.\r\n\r\nAm I missing something?",
          "createdAt": "2018-07-11T18:01:32Z",
          "updatedAt": "2018-07-11T18:16:01Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> May I ask why you need to remove the prefix? I do not see a reason why we cannot use a prefix and a dedicated type at the same time.\r\n\r\nBecause then a single CNAME can cover both the A/AAAA records and ESNI. I don't think keeping the prefix with a dedicated RR type makes a whole lot of sense, since they are both meant to signal that this is an ESNI query (that is, they are redundant).\r\n\r\nFWIW, #35 is not the main motivator for this. Simplifying DNS automatic processing server-side is (e.g. automatically handling ESNI for multiple domains at a time, rather than configuring single ones on their own). The need to handle a prefix in a query makes processing kind of awkward.\r\n\r\n> But there is no guarantee that the two queries will reach the recursive resolver at the same time\r\n\r\nThat is true of the status quo as well (which would require you to e.g. CNAME the _esni record as well, and keep it in sync with the CNAME of the main domain).\r\n\r\nThe only possible way an atomic query could work that I can think of is if the DNS server returned the ESNI answer as \"additional data\" of the A/AAAA response (which would also need some way to negotiate e.g. an EDNS(0)/OPT flag or something), though I don't know if this would work with resolvers.",
          "createdAt": "2018-07-11T20:38:19Z",
          "updatedAt": "2018-07-11T20:38:19Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "> Because then a single CNAME can cover both the A/AAAA records and ESNI. I don't think keeping the prefix with a dedicated RR type makes a whole lot of sense, since they are both meant to signal that this is an ESNI query (that is, they are redundant).\r\n> \r\n> FWIW, #35 is not the main motivator for this. Simplifying DNS automatic processing server-side is (e.g. automatically handling ESNI for multiple domains at a time, rather than configuring single ones on their own). The need to handle a prefix in a query makes processing kind of awkward.\r\n\r\nAs we agree, having no prefix is a no-go for certain deployments.\r\n\r\nI would also argue that providing customers of CDN the ability to opt-in to ESNI is important, especially during the early stages. Otherwise, CDNs cannot starting ESNI for _any_ domains until _all_ their customers permit the use ESNI.\r\n\r\nI can understand your argument about simplicity, but seeing wider adoption seems more important to me. And all this discussion is _not_ about the record type about having prefix; hence the suggestion to limit the scope of the PR to changing the type only.",
          "createdAt": "2018-07-11T21:59:46Z",
          "updatedAt": "2018-07-11T21:59:46Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@kazuho ok I restored the prefix for now and removed the reference to #35, though the page is not updating with the new commits for some reason.",
          "createdAt": "2018-07-12T12:11:45Z",
          "updatedAt": "2018-07-12T12:11:45Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Rebased and updated after https://github.com/ekr/draft-rescorla-tls-esni/pull/76 got merged.",
          "createdAt": "2018-07-19T19:36:55Z",
          "updatedAt": "2018-07-19T19:36:55Z"
        },
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Rebased on master.",
          "createdAt": "2018-09-24T12:39:47Z",
          "updatedAt": "2018-09-24T12:39:47Z"
        },
        {
          "author": "mhofman",
          "authorAssociation": "NONE",
          "body": ">> Because then a single CNAME can cover both the A/AAAA records and ESNI. I don't think keeping the prefix with a dedicated RR type makes a whole lot of sense, since they are both meant to signal that this is an ESNI query (that is, they are redundant).\r\n>\r\n> As we agree, having no prefix is a no-go for certain deployments.\r\n\r\nI'm wondering, couldn't both non-prefixed and prefixed records be allowed to cover all cases?\r\n\r\nThe client would start simultaneous queries on the non-prefixed name for A/AAAA records, non-prefixed ESNI records, and for the _esni prefixed TXT (or ESNI?) record.\r\nIf an ESNI record is present on the non-prefixed name, the client uses it immediately, discarding whatever answer may be provided for the _esni prefix.\r\n\r\nIt would solve the wildcard use case (#79), while keeping the option of the _esni prefix for cases where delegation is needed (e.g. APEX or when the DNS and CDN providers are separate).\r\n\r\nWhile in itself it doesn't solve the case of a domain balanced over multiple CDNs like mentioned in #35, it does open the door to improvements when/if [multiple QTYPEs in queries](https://tools.ietf.org/html/draft-bellis-dnsext-multi-qtypes-06) ever get supported.\r\nI have a hunch it also makes it more likely for the A/AAAA and ESNI records to be in sync for DNS providers that offer ALIAS \"virtual\" records.\r\n\r\n> I would also argue that providing customers of CDN the ability to opt-in to ESNI is important, especially during the early stages. Otherwise, CDNs cannot starting ESNI for any domains until all their customers permit the use ESNI.\r\n\r\nI think this should be possible with either approach.\r\nIn the non-prefixed case, the CDN can offer a dedicated CNAME target that has both the A/AAAA records of the ESNI enabled TLS servers and the ESNI records to use with them. If the customer doesn't want ESNI enabled, they can use the non-ESNI CNAME target. Or for CDN providers that offer a CNAME target personalized to the customer, this could be handled by a configuration at the CDN provider level.\r\nIn the prefixed case, it's of course a matter of the customer adding an _esni CNAME record pointing to the CDN's ESNI record.",
          "createdAt": "2018-09-25T18:21:44Z",
          "updatedAt": "2018-09-25T18:21:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #144.",
          "createdAt": "2019-03-06T00:55:10Z",
          "updatedAt": "2019-03-06T00:55:10Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 76,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAxNTAwODMy",
      "title": "add a iana instruction for _esni",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/76",
      "state": "MERGED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "closes #75 ",
      "createdAt": "2018-07-15T14:28:55Z",
      "updatedAt": "2018-07-15T14:36:02Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "e72b0512cc779f2273f72a794af18a36598d19a2",
      "headRepository": "mcmanus/draft-rescorla-tls-esni",
      "headRefName": "attrleaf",
      "headRefOid": "d13c5c843b00248df342308beb897b3e8f494a3c",
      "closedAt": "2018-07-15T14:36:02Z",
      "mergedAt": "2018-07-15T14:36:02Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "9b8f4362a7f7bed7507a5c6932fbb1be7b4989cf"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 77,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAxNTA3NTMy",
      "title": "Clarify that ServerNameList does not include extension wrapper.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/77",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-15T17:38:43Z",
      "updatedAt": "2018-07-16T20:32:47Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9b8f4362a7f7bed7507a5c6932fbb1be7b4989cf",
      "headRepository": null,
      "headRefName": "caw/clarify-encoding",
      "headRefOid": "53126950df6185be5c37a63da80172188ae2f446",
      "closedAt": "2018-07-16T20:32:47Z",
      "mergedAt": "2018-07-16T20:32:47Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "49af7eb82f46c3fcc58f485d5abd7bcdbb65b5b2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM3NTg1MDc3",
          "commit": {
            "abbreviatedOid": "5312695"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM.",
          "createdAt": "2018-07-16T20:31:59Z",
          "updatedAt": "2018-07-16T20:31:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 78,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAxNzEyMDk5",
      "title": "Add versioning",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/78",
      "state": "CLOSED",
      "author": "tmshort",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Add versioning to the ESNI domain entry and the extension.\r\nAs this ID evolves, it will permit interoperability.\r\n\r\nAlso fix a minor type",
      "createdAt": "2018-07-16T18:01:16Z",
      "updatedAt": "2018-09-17T18:23:12Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9b8f4362a7f7bed7507a5c6932fbb1be7b4989cf",
      "headRepository": "tmshort/draft-rescorla-tls-esni",
      "headRefName": "master-tmshort-rev",
      "headRefOid": "96c94d5ef23e68c7a7c89a2089429a3da1349a59",
      "closedAt": "2018-09-17T18:23:12Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "FWIW #63 discusses this.",
          "createdAt": "2018-07-17T05:27:42Z",
          "updatedAt": "2018-07-17T05:27:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This was addressed in #90. Please re-open if that's not the case.",
          "createdAt": "2018-09-17T18:23:12Z",
          "updatedAt": "2018-09-17T18:23:12Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM3ODUwOTE4",
          "commit": {
            "abbreviatedOid": "96c94d5"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-17T14:18:24Z",
          "updatedAt": "2018-07-17T14:18:24Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "~~I am not sure if we need to explicitly include the version of ESNIKeys in the TLS extension.\r\n\r\nCurrent approach assumes that the server looks for the corresponding ESNIKeys by checking the value of `record_digests`. That will lead you to the ESNIKeys that contains a version. Having another version seems unnecessary complication to me.~~\r\n\r\nSorry for the noise, I now notice that the proposal is to offer a list of versions using ESNIKeys and let the client select one in the TLS extension. Please let me retract my comment.",
              "createdAt": "2018-07-17T14:18:24Z",
              "updatedAt": "2018-07-17T14:21:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM3ODUzMjI1",
          "commit": {
            "abbreviatedOid": "96c94d5"
          },
          "author": "tmshort",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-17T14:23:05Z",
          "updatedAt": "2018-07-17T14:23:06Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "A server can support multiple versions of the draft; it is a list in the DNS record, and the record digest would be the same for all versions in that list.\r\n\r\nYou are correct that the record_digest would be updated when a server adds support for a new version of ESNI, but that doesn't indicate *which* version of ESNI the client is trying to use.",
              "createdAt": "2018-07-17T14:23:05Z",
              "updatedAt": "2018-07-17T14:23:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM3ODU1NjY4",
          "commit": {
            "abbreviatedOid": "96c94d5"
          },
          "author": "tmshort",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-17T14:27:55Z",
          "updatedAt": "2018-07-17T14:27:55Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Example:\r\n```\r\nRecord digest for version list [0xFF01] = 0x01234567\r\nRecord digest for version list [0xFF01, 0xFF02] = 0x89ABCDEF\r\n```\r\nUsing record digest 0x89ABCDEF won't indicate which version is in use; 0xFF02 can't be assumed since 0xFF01 is still listed as being supported",
              "createdAt": "2018-07-17T14:27:55Z",
              "updatedAt": "2018-07-17T14:27:56Z"
            }
          ]
        }
      ]
    },
    {
      "number": 85,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA2MjYxNzg0",
      "title": "Mix the server record (digest), client key share, and client random into the ESNI key derivation.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/85",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #81.",
      "createdAt": "2018-08-05T22:40:32Z",
      "updatedAt": "2018-08-20T15:04:24Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "49af7eb82f46c3fcc58f485d5abd7bcdbb65b5b2",
      "headRepository": null,
      "headRefName": "caw/contributive",
      "headRefOid": "134b15c87b5c4cde7f52500138662f64757e2e9c",
      "closedAt": "2018-08-20T15:04:24Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "This is an improvement, but I thought we had agreed to move towards the separate keys/AAD approach?",
          "createdAt": "2018-08-07T13:14:03Z",
          "updatedAt": "2018-08-07T13:14:03Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "We did, but that\u2019s slightly orthogonal. I\u2019ll do that in a separate PR. ",
          "createdAt": "2018-08-07T13:44:44Z",
          "updatedAt": "2018-08-07T13:44:44Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQzOTc3OTI4",
          "commit": {
            "abbreviatedOid": "134b15c"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM :+1:",
          "createdAt": "2018-08-07T12:50:59Z",
          "updatedAt": "2018-08-07T12:50:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 86,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA2Mjg2NzA2",
      "title": "Add advice about query strategy.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/86",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-08-06T04:33:00Z",
      "updatedAt": "2018-08-14T15:38:27Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "49af7eb82f46c3fcc58f485d5abd7bcdbb65b5b2",
      "headRepository": null,
      "headRefName": "caw/query",
      "headRefOid": "3152be598fbfcef510b89589963389c1cedbe0a3",
      "closedAt": "2018-08-14T15:38:27Z",
      "mergedAt": "2018-08-14T15:38:27Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "3d52a23db2ddda6279c1915b5224789ccf5d951a"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@mcmanus please have a look!",
          "createdAt": "2018-08-07T16:02:29Z",
          "updatedAt": "2018-08-07T16:02:29Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 87,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA2NzU4OTYw",
      "title": "Separate the key shares used by the TLS handshake and ESNI to avoid downgrade",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/87",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-08-07T16:37:46Z",
      "updatedAt": "2018-08-20T15:13:09Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "49af7eb82f46c3fcc58f485d5abd7bcdbb65b5b2",
      "headRepository": null,
      "headRefName": "caw/separate-keyshares",
      "headRefOid": "0a47e5b16eecb49678ec83fcbf3e3dd3e321f32f",
      "closedAt": "2018-08-20T15:13:09Z",
      "mergedAt": "2018-08-20T15:13:09Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "6995fd93a9a69363581b531318115543c9afb6bf"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ2MTI2MDk4",
          "commit": {
            "abbreviatedOid": "3a96c00"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-08-14T15:39:55Z",
          "updatedAt": "2018-08-14T15:43:40Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I would call this |key_share|",
              "createdAt": "2018-08-14T15:39:55Z",
              "updatedAt": "2018-08-20T15:12:23Z"
            },
            {
              "originalPosition": 65,
              "body": "I think this is not quite what we want.\r\n\r\nI think rather the hash should be:\r\n\r\n```Hash(record_digest || EncryptedSNI.entry || ClientHello.Random)```\r\n\r\nAnd then you want to have the AAD include ClientHello.key_shares.\r\n",
              "createdAt": "2018-08-14T15:43:17Z",
              "updatedAt": "2018-08-20T15:12:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ2MTMyMDYy",
          "commit": {
            "abbreviatedOid": "3a96c00"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-14T15:52:20Z",
          "updatedAt": "2018-08-14T15:52:20Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "That works for me.",
              "createdAt": "2018-08-14T15:52:20Z",
              "updatedAt": "2018-08-20T15:12:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ2MTM0Mzg1",
          "commit": {
            "abbreviatedOid": "3a96c00"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-14T15:57:33Z",
          "updatedAt": "2018-08-14T15:57:33Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "EncryptedSNI.entry is already mixed in by virtue of being used to derive the KDF input secret. Putting ClientHello.KeyShareClientHello here or in the AAD has the same affect on malleability.",
              "createdAt": "2018-08-14T15:57:33Z",
              "updatedAt": "2018-08-20T15:12:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 89,
      "id": "MDExOlB1bGxSZXF1ZXN0MjEzMDMxNDY3",
      "title": "Caw/echo nonce",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/89",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a proposal to address the misrouting and key share replacement attacks identified by Ekr, Karthik, and Benjamin. Please help me improve it!",
      "createdAt": "2018-09-04T16:15:15Z",
      "updatedAt": "2018-09-10T17:03:44Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "6995fd93a9a69363581b531318115543c9afb6bf",
      "headRepository": null,
      "headRefName": "caw/echo-nonce",
      "headRefOid": "6eb942287b53da31eece48bab25d1a3ac945e284",
      "closedAt": "2018-09-10T17:03:44Z",
      "mergedAt": "2018-09-10T17:03:44Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "e3cd3f544b0018a4b42621a9a12b62ff92d81cdf"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyMjUwMDAx",
          "commit": {
            "abbreviatedOid": "b5e60f8"
          },
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Some minor nits.",
          "createdAt": "2018-09-04T20:55:53Z",
          "updatedAt": "2018-09-04T21:04:08Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "This should be `encrypted_server_name(0xffce)` to match IANA considerations.",
              "createdAt": "2018-09-04T20:55:53Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            },
            {
              "originalPosition": 23,
              "body": "Should update the \"TLS 1.3\" column in IANA considerations for the extension to be \"CH, EE\".",
              "createdAt": "2018-09-04T20:58:01Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            },
            {
              "originalPosition": 86,
              "body": "s/if/it/",
              "createdAt": "2018-09-04T21:01:55Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyMjc2Mjcx",
          "commit": {
            "abbreviatedOid": "b5e60f8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-04T22:23:11Z",
          "updatedAt": "2018-09-04T22:23:12Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "Fixed!",
              "createdAt": "2018-09-04T22:23:12Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyMjc2MzEz",
          "commit": {
            "abbreviatedOid": "84053dd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-04T22:23:22Z",
          "updatedAt": "2018-09-04T22:23:22Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Fixed!\r\n",
              "createdAt": "2018-09-04T22:23:22Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyMjc2MzMx",
          "commit": {
            "abbreviatedOid": "84053dd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-04T22:23:25Z",
          "updatedAt": "2018-09-04T22:23:26Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Fixed!\r\n",
              "createdAt": "2018-09-04T22:23:26Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzNzI5MTU4",
          "commit": {
            "abbreviatedOid": "84053dd"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-09-10T11:24:03Z",
          "updatedAt": "2018-09-10T11:26:05Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Because the nonce is constant-length, I wouldn't include it in the padding calculation",
              "createdAt": "2018-09-10T11:24:03Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            },
            {
              "originalPosition": 68,
              "body": "I think either of these is correct.",
              "createdAt": "2018-09-10T11:24:14Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            },
            {
              "originalPosition": 90,
              "body": "This could be read as saying that the client must abort if it doesn't check. Maybe \"provided by the server, and otherwise abort the connection ....\"",
              "createdAt": "2018-09-10T11:24:41Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            },
            {
              "originalPosition": 118,
              "body": "This text seems OBE. This mechanism won't work unless the backend has nonce, so you might as well give it SNI too.",
              "createdAt": "2018-09-10T11:25:48Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            },
            {
              "originalPosition": 180,
              "body": "This text also seems OBE.",
              "createdAt": "2018-09-10T11:25:59Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzNzQ2MTM1",
          "commit": {
            "abbreviatedOid": "84053dd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-10T12:20:32Z",
          "updatedAt": "2018-09-10T12:20:32Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Works for me. ",
              "createdAt": "2018-09-10T12:20:32Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzNzQ2NjY0",
          "commit": {
            "abbreviatedOid": "84053dd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-10T12:21:59Z",
          "updatedAt": "2018-09-10T12:40:40Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "Yep, good suggestion. Fixed.",
              "createdAt": "2018-09-10T12:21:59Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            },
            {
              "originalPosition": 118,
              "body": "Good catch. I'll make this point to the preceding section.",
              "createdAt": "2018-09-10T12:29:58Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzNzUzMzU1",
          "commit": {
            "abbreviatedOid": "84053dd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-10T12:41:46Z",
          "updatedAt": "2018-09-10T12:41:46Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "The article seems necessary. Or at least it reads odd without it.",
              "createdAt": "2018-09-10T12:41:46Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzNzUzNDQy",
          "commit": {
            "abbreviatedOid": "84053dd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-10T12:42:00Z",
          "updatedAt": "2018-09-10T12:42:00Z",
          "comments": [
            {
              "originalPosition": 180,
              "body": "Yep, addressed, and also removed the hand-wavy bit.",
              "createdAt": "2018-09-10T12:42:00Z",
              "updatedAt": "2018-09-10T12:43:33Z"
            }
          ]
        }
      ]
    },
    {
      "number": 90,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE1NzcwMTU5",
      "title": "Version number",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/90",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-15T13:50:23Z",
      "updatedAt": "2021-04-19T15:51:29Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1e7bf63593a342fd15ee065450686ed9b99a8d7f",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "version_number",
      "headRefOid": "792ec78c70cb3f8d8c26d6c07b3f507f14ead029",
      "closedAt": "2018-09-16T20:03:23Z",
      "mergedAt": "2018-09-16T20:03:23Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "a5c6ac1843f5cc251c32723f2686b3d8066aa0fa"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU1NzE1ODEw",
          "commit": {
            "abbreviatedOid": "f83f937"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Looks good \u2014 two minor comments.",
          "createdAt": "2018-09-15T14:54:47Z",
          "updatedAt": "2018-09-15T14:56:32Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "I\u2019d replace \u201cmultiple TXT records\u201d with \u201cmultiple ESNIKeys structures.\u201d",
              "createdAt": "2018-09-15T14:54:47Z",
              "updatedAt": "2018-09-16T19:39:43Z"
            },
            {
              "originalPosition": 29,
              "body": "This should be fine, as clients tell servers which one via the digest. If a client-facing server can\u2019t handle any ESNI for a version it has published then that seems to be a configuration error, no? ",
              "createdAt": "2018-09-15T14:56:11Z",
              "updatedAt": "2018-09-16T19:39:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU1NzU2MDQ3",
          "commit": {
            "abbreviatedOid": "792ec78"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-16T19:46:38Z",
          "updatedAt": "2018-09-16T19:46:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 91,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE1ODQxMTc1",
      "title": "Reorder the extension in a more logical way to make padding easier.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/91",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-16T19:37:54Z",
      "updatedAt": "2021-04-19T15:51:31Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "a5c6ac1843f5cc251c32723f2686b3d8066aa0fa",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "reorder_psnl",
      "headRefOid": "a35fbb358e8a13fe9097a3b6f284c0c11625b14e",
      "closedAt": "2018-09-16T22:10:06Z",
      "mergedAt": "2018-09-16T22:10:06Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "71105a168d81a7bb11e37d18fe147f27ab395f72"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU1NzU2NTIx",
          "commit": {
            "abbreviatedOid": "e844c86"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-09-16T20:05:23Z",
          "updatedAt": "2018-09-16T20:07:55Z",
          "comments": [
            {
              "originalPosition": 118,
              "body": "This should be ClientESNIInner.",
              "createdAt": "2018-09-16T20:05:23Z",
              "updatedAt": "2018-09-16T22:03:17Z"
            },
            {
              "originalPosition": 23,
              "body": "If you're renaming this, I'd rename the client one, too. (ClientEncryptedSNI)",
              "createdAt": "2018-09-16T20:07:19Z",
              "updatedAt": "2018-09-16T22:03:17Z"
            },
            {
              "originalPosition": 28,
              "body": "Missing ClientESNIInner prefix to .nonce.",
              "createdAt": "2018-09-16T20:07:48Z",
              "updatedAt": "2018-09-16T22:03:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU1NzU2ODA1",
          "commit": {
            "abbreviatedOid": "1ee113b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-09-16T20:15:26Z",
          "updatedAt": "2018-09-16T20:17:01Z",
          "comments": [
            {
              "originalPosition": 111,
              "body": "Capital Client",
              "createdAt": "2018-09-16T20:15:26Z",
              "updatedAt": "2018-09-16T22:03:17Z"
            }
          ]
        }
      ]
    },
    {
      "number": 92,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE2MDM4NTQ1",
      "title": "Clarify",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/92",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-17T16:17:48Z",
      "updatedAt": "2021-04-19T15:51:31Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "d1caee56da2f49ea38f9c064d26049aaf8d2418e",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "clarify_key_share",
      "headRefOid": "4f9b8f06329aba4952ddab94a58146f24cafab30",
      "closedAt": "2018-09-17T16:37:24Z",
      "mergedAt": "2018-09-17T16:37:24Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "1dd0d218b8a12dcbf695338b4880bd677e440b76"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU2MDE0NTcz",
          "commit": {
            "abbreviatedOid": "4f9b8f0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-17T16:37:13Z",
          "updatedAt": "2018-09-17T16:37:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 93,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE2MzMwMjY3",
      "title": "Clarify what encrypted_sni is",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/93",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-18T14:32:14Z",
      "updatedAt": "2018-09-18T14:33:17Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1dd0d218b8a12dcbf695338b4880bd677e440b76",
      "headRepository": null,
      "headRefName": "encrypted_sni",
      "headRefOid": "34522b7c617dd80873818f49cf506bd93aa69447",
      "closedAt": "2018-09-18T14:33:17Z",
      "mergedAt": "2018-09-18T14:33:17Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "682928e63c897ff5fba83693625a70073b0978c1"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 94,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE2MzMzNTMz",
      "title": "Calculate checksum over the whole structure",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/94",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-18T14:41:02Z",
      "updatedAt": "2018-09-18T15:38:01Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "682928e63c897ff5fba83693625a70073b0978c1",
      "headRepository": null,
      "headRefName": "checksum",
      "headRefOid": "dfe09481d3eead6825da3e7a79e8640a1693ef1f",
      "closedAt": "2018-09-18T15:38:00Z",
      "mergedAt": "2018-09-18T15:38:00Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "67fb40a4bee107293a3f835673a76015f9acd79f"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@ekr @kazuho what do you think?",
          "createdAt": "2018-09-18T14:42:35Z",
          "updatedAt": "2018-09-18T14:42:35Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU2NDA0Njgz",
          "commit": {
            "abbreviatedOid": "dfe0948"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-18T14:42:17Z",
          "updatedAt": "2018-09-18T14:42:17Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU2NDExMTc1",
          "commit": {
            "abbreviatedOid": "dfe0948"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": ":+1:",
          "createdAt": "2018-09-18T14:54:21Z",
          "updatedAt": "2018-09-18T14:54:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 95,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE2MzM0OTM2",
      "title": "Clarify clarification",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/95",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-18T14:44:55Z",
      "updatedAt": "2018-09-18T15:38:44Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "682928e63c897ff5fba83693625a70073b0978c1",
      "headRepository": null,
      "headRefName": "clarify_clarify",
      "headRefOid": "6e2e80c32f0e2bdec5db3649ac0e7a7474f1583a",
      "closedAt": "2018-09-18T15:38:44Z",
      "mergedAt": "2018-09-18T15:38:44Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "bff4cee30cec7e8a4ba0397dbc58dc93201fa8cd"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU2NDA4MzE5",
          "commit": {
            "abbreviatedOid": "6e2e80c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-18T14:49:04Z",
          "updatedAt": "2018-09-18T14:49:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 96,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE2Mzg0MjMx",
      "title": "Update version to 0xff01 for draft",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/96",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-18T17:23:14Z",
      "updatedAt": "2018-09-18T17:24:22Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "bff4cee30cec7e8a4ba0397dbc58dc93201fa8cd",
      "headRepository": null,
      "headRefName": "version",
      "headRefOid": "5442864faab95a1bc79922f25748886d3b4adfff",
      "closedAt": "2018-09-18T17:24:22Z",
      "mergedAt": "2018-09-18T17:24:21Z",
      "mergedBy": "kazuho",
      "mergeCommit": {
        "oid": "7b2c2f8b8ff9656a713b1449a50efb9ee8ca60bc"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 98,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE3NjY4MDAx",
      "title": "Clarify what the server must do with server_name",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/98",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-24T14:04:24Z",
      "updatedAt": "2018-09-24T14:32:05Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "7b2c2f8b8ff9656a713b1449a50efb9ee8ca60bc",
      "headRepository": null,
      "headRefName": "sni_ack",
      "headRefOid": "3655e4c9d64c470790fb7dc432fe304a126e9a1c",
      "closedAt": "2018-09-24T14:32:05Z",
      "mergedAt": "2018-09-24T14:32:05Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "b74e843a0e6db2553e216df6508296e5a3cc5292"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed offline.",
          "createdAt": "2018-09-24T14:31:57Z",
          "updatedAt": "2018-09-24T14:31:57Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU4MTE5OTUw",
          "commit": {
            "abbreviatedOid": "a5cfc3a"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-24T14:07:06Z",
          "updatedAt": "2018-09-24T14:07:09Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Maybe instead MUST NOT send the \"server_name\" extension to the client.",
              "createdAt": "2018-09-24T14:07:06Z",
              "updatedAt": "2018-09-24T14:16:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU4MTIwNDUx",
          "commit": {
            "abbreviatedOid": "a5cfc3a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-09-24T14:08:06Z",
          "updatedAt": "2018-09-24T14:08:13Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I'm not sure this is consistent with the text above, which reads: \"The client MAY either omit the \"server_name\" extension or provide  an innocuous dummy one (this is required for technical conformance with {{!RFC7540}}; Section 9.2.).\" It seems we can only prohibit servers from echoing server_name iff the client is also prohibited from sending it in conjunction with ESNI.",
              "createdAt": "2018-09-24T14:08:07Z",
              "updatedAt": "2018-09-24T14:16:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU4MTI0MDA1",
          "commit": {
            "abbreviatedOid": "a5cfc3a"
          },
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-24T14:15:33Z",
          "updatedAt": "2018-09-24T14:15:33Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "The server doesn't have to send server_name even if the client does. That is, irrespective of ESNI, the server can decide to ignore the server_name from the client and not send server_name at all. So, the client can send a dummy server_name, but the server is not going to use it (if nothing else, because it's \"dummy\"), so it shouldn't send server_name.",
              "createdAt": "2018-09-24T14:15:33Z",
              "updatedAt": "2018-09-24T14:16:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU4MTI0NzYy",
          "commit": {
            "abbreviatedOid": "3655e4c"
          },
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-24T14:17:02Z",
          "updatedAt": "2018-09-24T14:17:02Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Ok, fixed.",
              "createdAt": "2018-09-24T14:17:02Z",
              "updatedAt": "2018-09-24T14:17:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU4MTI3NTMz",
          "commit": {
            "abbreviatedOid": "3655e4c"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-24T14:22:41Z",
          "updatedAt": "2018-09-24T14:22:41Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I don't think that's true. There's no hard requirement that the server echo SNI. It only must echo it if it used \"the information contained in the extension to guide  its selection of an appropriate certificate to return to the client, and/or other aspects of security policy\".  But a server that ignores SNI doesn't have to do anything. Concretely, NSS only echoes SNI if there is an SNI callback installed.\r\n\r\n",
              "createdAt": "2018-09-24T14:22:41Z",
              "updatedAt": "2018-09-24T14:22:41Z"
            }
          ]
        }
      ]
    },
    {
      "number": 100,
      "id": "MDExOlB1bGxSZXF1ZXN0MjIzNzc3Njcz",
      "title": "clarify for alt-svc that we lookup txt/esni from origin name. closes #61",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/100",
      "state": "MERGED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-10-17T22:54:58Z",
      "updatedAt": "2018-10-21T20:52:40Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "b74e843a0e6db2553e216df6508296e5a3cc5292",
      "headRepository": "mcmanus/draft-rescorla-tls-esni",
      "headRefName": "mcmanus-61",
      "headRefOid": "88cc4bb5ef44c88d878d76bc33e87d169ac01563",
      "closedAt": "2018-10-21T20:52:40Z",
      "mergedAt": "2018-10-21T20:52:40Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "35ab3043ffb8e4a266407e1750c9aa8c932cb440"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY1OTE1MDk2",
          "commit": {
            "abbreviatedOid": "88cc4bb"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-18T03:41:53Z",
          "updatedAt": "2018-10-18T03:41:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 101,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI0NTY1NzU2",
      "title": "Abort the handshake if the server does not negotiate TLS 1.3.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/101",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-10-21T20:10:13Z",
      "updatedAt": "2021-04-19T15:51:33Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "b74e843a0e6db2553e216df6508296e5a3cc5292",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "reject_tls12",
      "headRefOid": "342e1ebc6e9675741d96d6c532047c24645e6188",
      "closedAt": "2018-10-21T20:17:50Z",
      "mergedAt": "2018-10-21T20:17:50Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "3fcacbeb8f4feb5f80ea89460a4252c3bea12b72"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2Nzk5MTAz",
          "commit": {
            "abbreviatedOid": "342e1eb"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-21T20:17:46Z",
          "updatedAt": "2018-10-21T20:17:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 102,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI0NTY2NDY2",
      "title": "Clarify that if you can't negotiate ESNI, you should act as if none o\u2026",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/102",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "\u2026f the ESNI Keys values were present",
      "createdAt": "2018-10-21T20:22:16Z",
      "updatedAt": "2021-04-19T15:51:33Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3fcacbeb8f4feb5f80ea89460a4252c3bea12b72",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "clarify_soft_fail",
      "headRefOid": "c114216ff895005b361cce73c6b37d89b805216c",
      "closedAt": "2018-10-21T22:29:24Z",
      "mergedAt": "2018-10-21T22:29:24Z",
      "mergedBy": "kazuho",
      "mergeCommit": {
        "oid": "bf4f394215d04aafefaf8870285d27866abad217"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2Nzk5Mjgy",
          "commit": {
            "abbreviatedOid": "4b7f49a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-10-21T20:23:03Z",
          "updatedAt": "2018-10-21T20:24:41Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "s/non/no",
              "createdAt": "2018-10-21T20:23:03Z",
              "updatedAt": "2018-10-21T22:15:48Z"
            },
            {
              "originalPosition": 33,
              "body": "By \"another value\" I assume you mean a ESNIKeys structure obtained through some other means?",
              "createdAt": "2018-10-21T20:23:50Z",
              "updatedAt": "2018-10-21T22:15:48Z"
            },
            {
              "originalPosition": 5,
              "body": "Should we make this a MUST? This is different from the group/ciphersuite mismatch issue. ",
              "createdAt": "2018-10-21T20:24:39Z",
              "updatedAt": "2018-10-21T22:15:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2Nzk5Mzg3",
          "commit": {
            "abbreviatedOid": "4b7f49a"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-21T20:26:15Z",
          "updatedAt": "2018-10-21T20:26:15Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "No I mean say you give me two ESNIKeys structures, one of which advertises only 25519 and one of which advertises only P-256, and for some reason I only like P-256, but I try the 25519 one first\r\n",
              "createdAt": "2018-10-21T20:26:15Z",
              "updatedAt": "2018-10-21T22:15:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2Nzk5NDI5",
          "commit": {
            "abbreviatedOid": "5a90f15"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-21T20:27:06Z",
          "updatedAt": "2018-10-21T20:27:06Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Gotcha -- we should clarify that, I think. How about: \"If the client is unable to select an appropriate group or suite it SHOULD ignore that ESNIKeys value and MAY attempt to use another value provided by the server. (Recall that servers may provide multiple ESNIKeys in response to a ESNI TXT query.)\"?",
              "createdAt": "2018-10-21T20:27:06Z",
              "updatedAt": "2018-10-21T22:15:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2Nzk5NTI2",
          "commit": {
            "abbreviatedOid": "376b34f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-21T20:29:56Z",
          "updatedAt": "2018-10-21T20:29:56Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2ODAzMDA0",
          "commit": {
            "abbreviatedOid": "376b34f"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-21T22:08:40Z",
          "updatedAt": "2018-10-21T22:09:42Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "\"should\" should be in upper case?",
              "createdAt": "2018-10-21T22:08:40Z",
              "updatedAt": "2018-10-21T22:15:48Z"
            },
            {
              "originalPosition": 31,
              "body": "\"servers may provide\": lower-case \"may\". Change it to \"might\"?",
              "createdAt": "2018-10-21T22:09:24Z",
              "updatedAt": "2018-10-21T22:15:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2ODAzMDk2",
          "commit": {
            "abbreviatedOid": "376b34f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-21T22:11:36Z",
          "updatedAt": "2018-10-21T22:11:36Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "\ud83d\udc4d ",
              "createdAt": "2018-10-21T22:11:36Z",
              "updatedAt": "2018-10-21T22:15:48Z"
            }
          ]
        }
      ]
    },
    {
      "number": 104,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI1NTQ4OTI0",
      "title": "Restrict keys to address records in the same canonical name.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/104",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "fixes #35 \r\n\r\nthis would be a bit cleaner if we got rid of the prefix.. which I think we ought to do as well but is separable.",
      "createdAt": "2018-10-24T20:59:49Z",
      "updatedAt": "2019-06-27T20:23:36Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "bf4f394215d04aafefaf8870285d27866abad217",
      "headRepository": "mcmanus/draft-rescorla-tls-esni",
      "headRefName": "mcmanus-35",
      "headRefOid": "ec9f09c84750d1c03bb3ed4cbae44e3f63553f6d",
      "closedAt": "2019-06-27T20:23:36Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "mostly obe #136 and #137",
          "createdAt": "2019-06-27T20:23:36Z",
          "updatedAt": "2019-06-27T20:23:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY4MTI0ODky",
          "commit": {
            "abbreviatedOid": "ca03799"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This has the effect of creating a different resolution method for _esni, which I'm a little concerned about.",
          "createdAt": "2018-10-24T21:19:36Z",
          "updatedAt": "2018-10-24T21:28:03Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "```suggestion\r\ninformation to implement ESNI. The server is identified through DNS\r\n```",
              "createdAt": "2018-10-24T21:19:36Z",
              "updatedAt": "2018-10-25T19:47:41Z"
            },
            {
              "originalPosition": 19,
              "body": "does \"address records\" mean A or AAAA?",
              "createdAt": "2018-10-24T21:20:05Z",
              "updatedAt": "2018-10-25T19:47:41Z"
            },
            {
              "originalPosition": 60,
              "body": "How does it know that the TXT record is the one that needs updating?  It is presented with a mismatch, with TTLs.  Should we instead recommend requesting both, or does that invite problems?\r\n\r\nDoes it start over from _esni.example.com, or does this allow for an end-run on the CNAME resolution process from the prefixed domain.  That is, if www.example.com is CNAMEd through various intermediaries to providerA.example, does the client just construct _esni.providerA.example, or does it have to go back to _esni.example.com?  I get the problem - if this is load balanced, how do we ensure that this ends up routing the same way?  So why would you not just start with _esni.providerA.example then?",
              "createdAt": "2018-10-24T21:26:46Z",
              "updatedAt": "2018-10-25T19:47:41Z"
            },
            {
              "originalPosition": 35,
              "body": "```suggestion\r\nthe client MUST confirm that the unprefixed (i.e., lacking the\r\n```",
              "createdAt": "2018-10-24T21:26:53Z",
              "updatedAt": "2018-10-25T19:47:41Z"
            },
            {
              "originalPosition": 55,
              "body": "```suggestion\r\n     -> \"... KEY FOR B ...\"\r\n```",
              "createdAt": "2018-10-24T21:27:16Z",
              "updatedAt": "2018-10-25T19:47:41Z"
            },
            {
              "originalPosition": 64,
              "body": "```suggestion\r\n        -> \"... KEY FOR A ...\"\r\n```",
              "createdAt": "2018-10-24T21:27:24Z",
              "updatedAt": "2018-10-25T19:47:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY4MTMzNzE5",
          "commit": {
            "abbreviatedOid": "5804df7"
          },
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-24T21:44:39Z",
          "updatedAt": "2018-10-24T21:44:39Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "yes.. I don't mind saying a/aaaa I was trying to leave room for other ways of specifying the address. srv? new A* type?",
              "createdAt": "2018-10-24T21:44:39Z",
              "updatedAt": "2018-10-25T19:47:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY4MTM1MDQ4",
          "commit": {
            "abbreviatedOid": "5804df7"
          },
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-24T21:48:32Z",
          "updatedAt": "2018-10-24T21:48:32Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "My thought here is that the TXT record is the new kid on the block, so deference ought to be given to the A for backwards compatibility.\r\n\r\nif you're trying to loadbalance, you may well be doing so to add/delete traffic from certain regions (and people have been known to choose providers due to their strengths in particular regions) so capturing the traffic in service of using a valid key seems sub-optimal.. \r\n\r\nI wouldn't be surprised to see keys with bigger TTLs than the A's - creating an easy scenario for the mismatch to occur.. and we wouldn't want the routing of traffic impacted by that imo.",
              "createdAt": "2018-10-24T21:48:32Z",
              "updatedAt": "2018-10-25T19:47:41Z"
            }
          ]
        }
      ]
    },
    {
      "number": 106,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI2MDExNDcx",
      "title": "Fix two typos in text",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/106",
      "state": "MERGED",
      "author": "thomwiggers",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "There were two minor typos. This PR fixes them.\n\nWhile I was at it, I ran `aspell` over it, most seemed fine.",
      "createdAt": "2018-10-26T08:12:35Z",
      "updatedAt": "2018-10-27T04:53:30Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "bf4f394215d04aafefaf8870285d27866abad217",
      "headRepository": null,
      "headRefName": "typos",
      "headRefOid": "c37cfa3ffbfe908d7b7b9f70ab601e77e66ebf6c",
      "closedAt": "2018-10-27T04:53:30Z",
      "mergedAt": "2018-10-27T04:53:30Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "7bd60fcc09c1569b0f87cdebd6534fbaad922161"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY5MDQzNzI0",
          "commit": {
            "abbreviatedOid": "c37cfa3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-27T04:53:24Z",
          "updatedAt": "2018-10-27T04:53:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 108,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI2MTQyMjE3",
      "title": "remove the _esni prefix ",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/108",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "allow synchronization of both Key-Info and A/AAAA via the traditional single CNAME.\r\n\r\nfixes #105 amd #79\r\nessentially requires #73 otherwise there is namespace conflict\r\n\r\ntext conflicts a bit with #104 so if both were landed the slower one would need an update",
      "createdAt": "2018-10-26T15:40:14Z",
      "updatedAt": "2019-03-06T00:55:12Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "bf4f394215d04aafefaf8870285d27866abad217",
      "headRepository": "mcmanus/draft-rescorla-tls-esni",
      "headRefName": "mcmanus-105",
      "headRefOid": "283701cf86728c5c6550f9f459a2b1af9dd62ec4",
      "closedAt": "2019-03-06T00:55:12Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "this is premised on #109",
          "createdAt": "2018-10-27T19:39:38Z",
          "updatedAt": "2018-10-27T19:39:38Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #144.",
          "createdAt": "2019-03-06T00:55:12Z",
          "updatedAt": "2019-03-06T00:55:12Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY5MDYzMDQ3",
          "commit": {
            "abbreviatedOid": "283701c"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-27T17:12:53Z",
          "updatedAt": "2018-10-27T17:12:53Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "It seems like you would need to have some prefix or something here to distinguish from other TXT records (this is of course what the _esni prefix was supposed to do). Do we need a published convention",
              "createdAt": "2018-10-27T17:12:53Z",
              "updatedAt": "2018-10-27T17:12:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk1Nzg4NzMx",
          "commit": {
            "abbreviatedOid": "283701c"
          },
          "author": "paulehoffman",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-23T23:07:09Z",
          "updatedAt": "2019-01-23T23:07:09Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "1) It is a terrible idea to have non-prefixed TXT records\r\n2) This has been overtaken by events with the likely proposal of a new RRtype",
              "createdAt": "2019-01-23T23:07:09Z",
              "updatedAt": "2019-01-23T23:07:09Z"
            }
          ]
        }
      ]
    },
    {
      "number": 111,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI2MTU1MDkw",
      "title": "break RRData into ESNIKeys and ESNIInclude",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/111",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "fixes #110",
      "createdAt": "2018-10-26T16:24:46Z",
      "updatedAt": "2020-02-23T13:49:21Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "bf4f394215d04aafefaf8870285d27866abad217",
      "headRepository": "mcmanus/draft-rescorla-tls-esni",
      "headRefName": "mcmanus-esniptr",
      "headRefOid": "22614a4eb459b6634081ee82f54dad7acf07d17e",
      "closedAt": "2020-02-23T13:49:21Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as this is OBE.",
          "createdAt": "2020-02-23T13:49:21Z",
          "updatedAt": "2020-02-23T13:49:21Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 112,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI2MzE4NDE4",
      "title": "Convenient integration branch for DNS issues",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/112",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "includes multicdn #35 \r\nesni rrtype #109 #74\r\nremove _esni prefix #105 #79 \r\nesniinclude #110 ",
      "createdAt": "2018-10-27T19:38:08Z",
      "updatedAt": "2019-06-27T20:21:29Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "7bd60fcc09c1569b0f87cdebd6534fbaad922161",
      "headRepository": "mcmanus/draft-rescorla-tls-esni",
      "headRefName": "mcmanus-cnamefriendly",
      "headRefOid": "a189ef2cd5ee26595154a08b4db389e440385e3d",
      "closedAt": "2019-06-27T20:21:28Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "obe. but #110 should live on.",
          "createdAt": "2019-06-27T20:21:28Z",
          "updatedAt": "2019-06-27T20:21:28Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY5MDkwMzIy",
          "commit": {
            "abbreviatedOid": "a189ef2"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-10-28T12:31:41Z",
          "updatedAt": "2018-10-28T12:40:32Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "This is kind of unclear, but I think the point is that the server operator provides the domain operator with the A record which the domain operator then installs in the DNS, but this works badly for ESNI Keys because then the server operator cannot frequently rotate the ENSI Keys.",
              "createdAt": "2018-10-28T12:31:42Z",
              "updatedAt": "2018-10-28T12:40:32Z"
            },
            {
              "originalPosition": 114,
              "body": "I would say A/AAAA.",
              "createdAt": "2018-10-28T12:34:31Z",
              "updatedAt": "2018-10-28T12:40:32Z"
            },
            {
              "originalPosition": 149,
              "body": "You should indicate that this is a failure example.",
              "createdAt": "2018-10-28T12:35:37Z",
              "updatedAt": "2018-10-28T12:40:32Z"
            },
            {
              "originalPosition": 137,
              "body": "This text is unclear at least to me.",
              "createdAt": "2018-10-28T12:37:11Z",
              "updatedAt": "2018-10-28T12:40:32Z"
            },
            {
              "originalPosition": 159,
              "body": "This algorithm seems over-complicated. I.e., there's no reason to query for the ESNI at a different CNAME than A/AAAA. Also, it seems like there is an open case here.\r\n\r\n````\r\nQuery for ESNI and A/AAAA records.\r\nIf A/AAAA is CNAME=X {\r\n   Query for ESNI at X\r\n} else {\r\n   if ESNI is not CNAME {\r\n     success\r\n} else {\r\n     ???\r\n}\r\n```\r\n\r\n",
              "createdAt": "2018-10-28T12:40:25Z",
              "updatedAt": "2018-10-28T12:40:32Z"
            }
          ]
        }
      ]
    },
    {
      "number": 114,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI4MTAwMTk1",
      "title": "Uniform capitalization of \"Split Mode\" and \"Shared Mode\"",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/114",
      "state": "MERGED",
      "author": "Eudi4H",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-11-03T05:10:27Z",
      "updatedAt": "2018-11-03T06:47:39Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "7bd60fcc09c1569b0f87cdebd6534fbaad922161",
      "headRepository": "Eudi4H/draft-ietf-tls-esni",
      "headRefName": "caps",
      "headRefOid": "935470acc000c03b6fb8f66e534cf3b45db5fe15",
      "closedAt": "2018-11-03T06:47:39Z",
      "mergedAt": "2018-11-03T06:47:39Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "752c4ff43cc1aaf163a5955539e74029c46b3522"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 115,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI4MTE3Nzc0",
      "title": "Update README.md",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/115",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-11-03T13:13:34Z",
      "updatedAt": "2018-11-03T21:57:32Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "752c4ff43cc1aaf163a5955539e74029c46b3522",
      "headRepository": "martinthomson/draft-ietf-tls-esni",
      "headRefName": "README",
      "headRefOid": "ce6c4c93e15eb632d274df06590c2a508b3a65db",
      "closedAt": "2018-11-03T21:57:31Z",
      "mergedAt": "2018-11-03T21:57:31Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "65e0cc3b795cfd87aedbc347901fd97083177bca"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 120,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM2MDE5MzEz",
      "title": "Fix typo.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/120",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-12-05T01:42:45Z",
      "updatedAt": "2018-12-05T15:30:23Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1ed8d7d02c3b0884ac20c93f891d2745ab0f9d49",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "fix-typo",
      "headRefOid": "39f17a269fef9807a01ee48aef3ce1748218453f",
      "closedAt": "2018-12-05T15:30:16Z",
      "mergedAt": "2018-12-05T15:30:16Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "3013b3c0c7bd93202cd4ca847380de64352ec79f"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks!",
          "createdAt": "2018-12-05T15:30:22Z",
          "updatedAt": "2018-12-05T15:30:22Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 122,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM4NDk2NzYw",
      "title": "Add CertificateVerify to padding recommendation",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/122",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Also takes out the \"longest length\" part of the SHOULD since (as Viktor pointed out) a server might not always know that and it can change due to CA or other PKI changes that might lead to errors in some scenarios. (E.g. CA adds new extension thereby causing a cert to be longer than what the TLS server thinks is longest.)",
      "createdAt": "2018-12-13T19:00:33Z",
      "updatedAt": "2020-04-27T21:59:32Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3013b3c0c7bd93202cd4ca847380de64352ec79f",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "c57591570967befd4bcaebc05833694048618179",
      "closedAt": "2020-04-27T21:59:31Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't agree with the longest length removal.\r\n\r\nPlease two separate PRs, one of which contains the non-controversial piece (CertificateVerify) and one with the longest length change.",
          "createdAt": "2018-12-13T19:05:26Z",
          "updatedAt": "2018-12-13T19:05:26Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "Not sure I know how to split a PR into two:-) Can take a look at it tomorrow but given one of 'em adds two words it'll likely be as easy to just treat this like an issue and make that change before a new rev and treat this one as arguing that longest-length is perhaps better not being a SHOULD.",
          "createdAt": "2018-12-13T19:15:21Z",
          "updatedAt": "2018-12-13T19:16:12Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sftcd what\u2019s the plan here?",
          "createdAt": "2019-06-19T16:52:59Z",
          "updatedAt": "2019-06-19T16:52:59Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "I guess the non-controversial change ought be made. That's just s/SHOULD pad the Certificate message/SHOULD pad the Certificate and CertificateVerify messages/. I can make a PR for that or you can just do it and kill this one. \r\nFor the non non-controversial change, I can send mail the WG list I guess:-)",
          "createdAt": "2019-06-19T20:47:22Z",
          "updatedAt": "2019-06-19T20:47:22Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sftcd this is likely overcome by events in #207. Would you mind updating based on that text, or closing this PR?",
          "createdAt": "2020-03-08T00:34:44Z",
          "updatedAt": "2020-03-08T00:34:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as overcome by #209!",
          "createdAt": "2020-04-27T21:59:31Z",
          "updatedAt": "2020-04-27T21:59:31Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg4NTE3NDEy",
          "commit": {
            "abbreviatedOid": "db1ee1b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-12-31T17:02:46Z",
          "updatedAt": "2018-12-31T17:05:43Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "typo \"ahnshake\"",
              "createdAt": "2018-12-31T17:02:46Z",
              "updatedAt": "2019-01-01T14:30:00Z"
            },
            {
              "originalPosition": 12,
              "body": "s/on the network/on the wire?",
              "createdAt": "2018-12-31T17:02:56Z",
              "updatedAt": "2019-01-01T14:30:00Z"
            },
            {
              "originalPosition": 12,
              "body": "Perhaps add a sentence that says the padded length equals the size of the largest possible Certificate and CertificateVerify messages covered by the same ESNI key?",
              "createdAt": "2018-12-31T17:05:37Z",
              "updatedAt": "2019-01-01T14:30:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg4NTU4NzIz",
          "commit": {
            "abbreviatedOid": "db1ee1b"
          },
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-01T14:27:21Z",
          "updatedAt": "2019-01-01T14:27:22Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I'm not sure that's a good plan TBH. It seems there are openssl deployments where there's a bunch of certs in a database somewhere so a) it could be slow to find that information afresh and b) that max size is liable to change as CAs renew certs, e.g. if the PKI renewal results in more/bigger extensions being put in certs. So while the max size could work in many places perhaps a simpler approach is better as the example to give.\r\n\r\nFWIW, my current code just pads the Certificate to a multiple of 2000 bytes and the CertificateVerify to a multiple of 500 bytes, those could maybe be smaller, but it seems to work ok.",
              "createdAt": "2019-01-01T14:27:22Z",
              "updatedAt": "2019-01-01T14:30:00Z"
            }
          ]
        }
      ]
    },
    {
      "number": 124,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM5MzE1MjU3",
      "title": "Improve ESNI robustness",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/124",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "(WG email coming shortly.)\r\n\r\nCloses #82.\r\n\r\nESNI has different compatibility characteristics than most TLS\r\nextensions. It involves client state, and encrypting the SNI makes the\r\nClientHello unusable for servers that do not have the key or do not\r\nimplement ESNI. This breaks common rollout and rollback strategies and\r\nplaces strong requirements on DNS/server consistency. This makes\r\ndeploying ESNI risky for servers.\r\n\r\nThis change aims to reduce these deployment risks. ESNI is much more\r\nuseful if widely deployed. Moreover, if ESNI is unreliable due to\r\ncomplex requirements on the server, clients will be disincentivized to\r\nimplement it. The DNS/server consistency requirements also\r\ndisincentivize rotating keys (section 7.2.5).\r\n\r\nThis change introduces the notion of a \"public name\" which allows the\r\nclient to receive authenticated signals from the server that the\r\nESNIKeys are out of sync, so clients can safely repair key mismatches.\r\nIt also aligns with existing server behavior before ESNI, so partial\r\nrollouts and rollbacks can also be handled.\r\n\r\nThe fix for the latter also handles MITM scenarios, replacing the\r\nexisting client recommendation:\r\n\r\n>   A Web client client can securely detect case (2) because it will\r\n>   result in a connection which has an invalid identity (most likely)\r\n>   but which is signed by a certificate which does not chain to a\r\n>   publicly known trust anchor.  The client can detect this case and\r\n>   disable ESNI while in that network configuration.\r\n>\r\n>   https://tools.ietf.org/html/draft-ietf-tls-esni-02#section-6.2\r\n\r\nThe public name notion fixes a bug in that text: an attacker could\r\ndisable ESNI on all servers, given the existence of *any* such server.",
      "createdAt": "2018-12-17T23:16:08Z",
      "updatedAt": "2019-02-26T21:14:13Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "5e08e1439e3bbfd8ed022252679e76d0c90b4c88",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "robustness",
      "headRefOid": "7e67cd82ec8b0c9f2ef2455222031e23c3f2060f",
      "closedAt": "2019-02-26T21:14:13Z",
      "mergedAt": "2019-02-26T21:14:12Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f07d3806d52add7920a0f4087f93c85bede08581"
      },
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> Hopefully I didn't miss anything.\r\n\r\nAnd, as I write this, I realize I forgot to deal with Stephen's comment on the thread about the middlebox stuff! It's quite late here, so I will reword that tomorrow morning.",
          "createdAt": "2019-02-15T01:25:39Z",
          "updatedAt": "2019-02-15T01:25:39Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg2NzIzOTEy",
          "commit": {
            "abbreviatedOid": "641ded1"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-19T19:59:52Z",
          "updatedAt": "2018-12-19T19:59:53Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "I had real trouble with this text because it doesn't say which direction the resumption applies to.  In general, when talking about resumption, you need to be very clear about whether you are talking about accepting a PSK for *this* session, or whether you are talking about maybe later establishing a resumed connection.  In this case, it's possible that both apply, so I had trouble with this.",
              "createdAt": "2018-12-19T19:59:52Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg4NTE4MTA3",
          "commit": {
            "abbreviatedOid": "641ded1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Overall, this looks good to me. Thanks for the PR! @ekr, @kazuho, can you please give it a review?",
          "createdAt": "2018-12-31T17:10:25Z",
          "updatedAt": "2018-12-31T17:33:21Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "s/public key/public key and metadata?",
              "createdAt": "2018-12-31T17:10:25Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 165,
              "body": "s/encrypted SNI/ENSI",
              "createdAt": "2018-12-31T17:17:21Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 240,
              "body": "My take is that the text refers to the former, not the latter, though it is a little unclear. ",
              "createdAt": "2018-12-31T17:27:45Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 263,
              "body": "s/by servers/by (other) servers?",
              "createdAt": "2018-12-31T17:28:54Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3MzE5ODMw",
          "commit": {
            "abbreviatedOid": "641ded1"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-28T23:56:28Z",
          "updatedAt": "2019-01-29T23:35:20Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Done.",
              "createdAt": "2019-01-28T23:56:28Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 165,
              "body": "Done.",
              "createdAt": "2019-01-28T23:56:56Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 240,
              "body": "It's just the former, yeah.\r\n\r\nThe intent of the text is to prevent resumption/SNI mismatches. With ESNI and, in particular, this ESNI to SNI fallback, a client offering {(non-GREASE) ESNI, SNI, PSK} now needs to consider all four possible responses:\r\n\r\n1. Server ACK'd ESNI and did full handshake\r\n2. Server ACK'd ESNI and resumed PSK\r\n3. Server ignored ESNI (thus used SNI) and did full handshake\r\n4. Server ignored ESNI (thus used SNI) and resumed PSK\r\n\r\nIn particular, whether the server ACKs or ignores ESNI determines which name the server believes it is acting on behalf of. So we want that to be consistent with the identity the client has associated with the PSK, if any. (1) and (3) are vacuously self-consistent, so that's easy.\r\n\r\nAs for (2) and (4), presumably the client would not be offering a session good for the public name because it's actually trying to connect to the ESNI name. Thus we want to reject (4) and allow (2). (If we allow (4), then the verify-public-name section needs to decide whether this weird scenario counts as authenticating the replacement ESNI keys and that's weird.) That means the server needs to know not the produce (4).\r\n\r\nNow, we could that, if a server ignores the ESNI extension due to key mismatch, it should also ignore the PSK extension. That works, except:\r\n* We want to be robust to server rollbacks and partial deployments. Such a server won't know to ignore the PSK extension.\r\n* Being able to send GREASE extensions is nice and a GREASE client wants to accept (4) since all the names are actually identical all around.\r\n\r\nOur thinking was to instead take leaf out of EMS's (and new TLS versions in general) book and partitions the connection/resumption space by whether ESNI was used. We remember a bit in the session state for whether ESNI was used when establishing it. We then say that a client offering ESNI [for real, not GREASE] can only offer ESNI-ful sessions, and a server can only accept ESNI-ful sessions in ESNI-ful handshakes.\r\n\r\nThis gives all the properties we want:\r\n* Clients offering ESNI will only offer an ESNI-ful session, which is invalid for the server to accept if it declined ESNI. Thus it can reject (4) above.\r\n* This can work with ESNI-oblivious servers on rollback. The server makes the ESNI bit in the session state unparseable by older versions of itself. This is the same sort of thing the server would already have had to do for EMS, or TLS 1.3.\r\n* Clients offering GREASE ESNI will almost always offer ESNI-less sessions (last time I talked to the server, it presumably didn't have ESNI either). The server will decline ESNI (since it's random noise), which means it's allowed to resume ESNI-less sessions.\r\n\r\nThere isn't an immediate need to constrain ESNI-less sessions, so I didn't in this version of the text. Though maybe a full partition is cleaner? It also occurs to me I have no idea what to do about external PSKs. We could say that if you really want ESNI + external PSK (strange considering that ESNI is usually about picking a certificate anyway...), you have to associate an ESNI bit with the EPSK?? EPSKs are a really underspecified use case that I don't know how to evaluate it.\r\n\r\nAnyway, I've tweaked the text slightly and left the above questions as-is for now. Is the new text clearer? / Thoughts on the above?",
              "createdAt": "2019-01-29T23:14:36Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 263,
              "body": "Rephrased. (See longer comment on resumption above.)",
              "createdAt": "2019-01-29T23:34:28Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAzNDU4NjUy",
          "commit": {
            "abbreviatedOid": "18ee79c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-13T21:33:35Z",
          "updatedAt": "2019-02-13T21:33:35Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAzNDU4NzIy",
          "commit": {
            "abbreviatedOid": "18ee79c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-13T21:33:45Z",
          "updatedAt": "2019-02-13T21:33:46Z",
          "comments": [
            {
              "originalPosition": 263,
              "body": "\ud83d\udc4d ",
              "createdAt": "2019-02-13T21:33:45Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAzNDU4OTYy",
          "commit": {
            "abbreviatedOid": "18ee79c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-13T21:34:17Z",
          "updatedAt": "2019-02-13T21:34:18Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "I think the proposed text clears things up. @martinthomson @ekr I'll take this PR to the list to see if there are any objections. ",
              "createdAt": "2019-02-13T21:34:18Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAzNDYyNjIz",
          "commit": {
            "abbreviatedOid": "18ee79c"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-13T21:42:49Z",
          "updatedAt": "2019-02-13T21:42:49Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAzNDk1MjE5",
          "commit": {
            "abbreviatedOid": "18ee79c"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I think that this still needs a little work.\r\n\r\nI've not been following closely, so consider this a review from fresh eyes.",
          "createdAt": "2019-02-13T23:03:42Z",
          "updatedAt": "2019-02-13T23:35:02Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Maybe avoid making untestable claims:\r\n```suggestion\r\n```\r\n\r\nMore so this set of changes makes the design the very opposite of straightforward.",
              "createdAt": "2019-02-13T23:03:42Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 78,
              "body": "We will evolve the format over time.  That means that this field is going to contain a specific version.  If that version is not supported, this design offers no means of recovery.  The client knows for certain that ESNI is supported, but there is no remedy.\r\n\r\nCan this include a list of key structures?  That would be consistent with the DNS, which can have multiple alternative records with different versions.",
              "createdAt": "2019-02-13T23:07:37Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 104,
              "body": "I'm confused.  This is the first mention of a PSK.  This needs more context.\r\n\r\nThe point here is that if you get a PSK from a previous connection (presumably an external PSK can have its own rules), then you need to ensure that you mark that PSK as being ESNI or not.  If it is ESNI, then you never resume from an ESNI PSK without ESNI and you never resume from a non-ESNI PSK if you are adding ESNI.\r\n\r\nWithout context, this is impossible to decipher.  I'm not even sure if I agree with the latter part of the requirement, so explaining why is probably necessary.\r\n\r\nAlso, this sentence is a run-on, so I can't really parse it.",
              "createdAt": "2019-02-13T23:10:13Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 146,
              "body": "Can public_name be empty?  If it is, can I omit SNI?",
              "createdAt": "2019-02-13T23:14:16Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 186,
              "body": "The SHOULD here is either out of scope, or under-specified.\r\n\r\nI think that the intent here is to say that if ESNI is not negotiated for any reason, but the connection is completed successfully with \"public_name\", then you aren't being attacked, but ESNI has simply been disabled.  A necessary condition for the \"SHOULD retry\" here is that the connection is successfully established with \"public_name\", but that connection is not explicit here.\r\n\r\nYou also want to add a condition here that if the server provides retry keys that the client cannot use, then it can regard ESNI as securely disabled.\r\n\r\nIf that is not the intent, then this stipulates policy: it's OK to fall back when you have a clear signal that ESNI is enabled, but the server doesn't do ESNI.  That's not a policy I would support.",
              "createdAt": "2019-02-13T23:20:40Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 209,
              "body": "This is right, but in the degenerate case it leads to three connections: one to fail resumption, one to get ESNI keys (because presumably you don't want the server that resumes to be able to supply retry keys - something that needs to be said more clearly in previous sections), and finally one to connect with the updated keys to the real host.  That isn't ideal, but I don't see how that could be shortened at all.",
              "createdAt": "2019-02-13T23:23:34Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 258,
              "body": "Why not prohibit resumption and PSK entirely for the case where the keys need replacing?  This only works for certificate-based server authentication anyway.  Are you really trying to salvage this for servers that authenticate with a PSK?",
              "createdAt": "2019-02-13T23:27:28Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 273,
              "body": "```suggestion\r\nfield set to the decrypted PaddedServerNameList.nonce value from the client\r\n\"encrypted_server_name\" extension.\r\n```",
              "createdAt": "2019-02-13T23:29:12Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 304,
              "body": "Remove \"in DNS\"",
              "createdAt": "2019-02-13T23:30:21Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 309,
              "body": "s/DNS/systems that advertise ESNI keys/",
              "createdAt": "2019-02-13T23:30:51Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 315,
              "body": "s/DNS/advertisements/",
              "createdAt": "2019-02-13T23:31:07Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 317,
              "body": "```suggestion\r\ndeployment. This may also occur if a server loses its ESNI keys, or if a deployment\r\n```",
              "createdAt": "2019-02-13T23:31:37Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 330,
              "body": "s/DNS/advertised",
              "createdAt": "2019-02-13T23:31:59Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 336,
              "body": "Again, you need to separate retries that provide usable keys and ones that don't.",
              "createdAt": "2019-02-13T23:32:36Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 374,
              "body": "As much as I like and agree with this sentiment, the last sentence can go.",
              "createdAt": "2019-02-13T23:33:22Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 383,
              "body": "Editorial: avoid possessive for inanimate objects or abstract concepts.",
              "createdAt": "2019-02-13T23:34:29Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MDAzMDUz",
          "commit": {
            "abbreviatedOid": "18ee79c"
          },
          "author": "kaduk",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-14T22:25:20Z",
          "updatedAt": "2019-02-14T22:25:20Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "Should probably be clear about who can do this tracking (a network observer), since the server has other ways to track specific clients.",
              "createdAt": "2019-02-14T22:25:20Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MDIyNTM2",
          "commit": {
            "abbreviatedOid": "18ee79c"
          },
          "author": "kaduk",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-14T23:25:35Z",
          "updatedAt": "2019-02-14T23:34:23Z",
          "comments": [
            {
              "originalPosition": 208,
              "body": "\"parameters not based on certificates\" should probably be worded differently.  I assume the intent is that you can't negotiate a PSK-only mode and need to pick something where the server authenticates with a certificate?",
              "createdAt": "2019-02-14T23:25:35Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 220,
              "body": "I'm not sure that this usage of \"origin\" is consistent with the other usages in this document; do we want to be talking about the \"private domain\" instead?",
              "createdAt": "2019-02-14T23:26:15Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAzODg1MzEx",
          "commit": {
            "abbreviatedOid": "18ee79c"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks for the thorough review! I've uploaded a new revision. Hopefully I didn't miss anything.",
          "createdAt": "2019-02-14T17:55:27Z",
          "updatedAt": "2019-02-15T01:24:35Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "It is a list of key structures. See retry\\_key*s* and the `<1..2^16-1>`.  Also below where it says:\r\n\r\n> *If one of the values used a version known*\r\n>  *to the client*, the client SHOULD retry the handshake with a new transport\r\n>  connection, using that value to encrypt the SNI.",
              "createdAt": "2019-02-14T17:55:27Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 209,
              "body": "Only two. It is not intended for the `illegal_parameter` to be a retry signal. The rules around resumption mean this scenario will never occur for a well-behaved client and server. (Client only offers ESNI sessions, which the server will not accept.)\r\n\r\nThis is precisely why there's the business about resumption that you commented on here:\r\nhttps://github.com/tlswg/draft-ietf-tls-esni/pull/124#discussion_r243055936",
              "createdAt": "2019-02-14T18:03:24Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 258,
              "body": "See here:\r\nhttps://github.com/tlswg/draft-ietf-tls-esni/pull/124#discussion_r243055936\r\n\r\nIf we simply prohibit resumption, non-ESNI clients can't send GREASE. It also doesn't fully solve the problem because an ESNI-ignorant server won't know to do this, hence the text below about issuing tickets. Since we're doing that anyway, this is free and buys us GREASE.",
              "createdAt": "2019-02-14T18:05:10Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 146,
              "body": "In the current text, no it cannot be empty. See `<1..2^16-1>` above.",
              "createdAt": "2019-02-14T21:50:43Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 13,
              "body": "The untestable claim is existing text. I merely downgraded it a notch from \"quite straightforward\" to \"straightforward\". Happy to downgrade it further and remove that line altogether. Done.",
              "createdAt": "2019-02-14T22:00:12Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 104,
              "body": "By \"the latter part of the requirement\", do you mean \"you never resume from a non-ESNI PSK if you are adding ESNI\"? The document does not prescribe that. See my response to your thread here:\r\nhttps://github.com/tlswg/draft-ietf-tls-esni/pull/124#discussion_r243055936\r\n\r\nI've reworded this a bit.",
              "createdAt": "2019-02-14T22:07:51Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 186,
              "body": "> I think that the intent here is to say that if ESNI is not negotiated for any reason, but the connection is completed successfully with \"public_name\", then you aren't being attacked, but ESNI has simply been disabled. A necessary condition for the \"SHOULD retry\" here is that the connection is successfully established with \"public_name\", but that connection is not explicit here.\r\n\r\nIt says to follow the steps in {{verify-public-name}}, which includes abort rules, but I guess it's not obvious which aborts are caught and which aren't. Rephrased a bit.\r\n\r\n> You also want to add a condition here that if the server provides retry keys that the client cannot use, then it can regard ESNI as securely disabled.\r\n\r\nAlready there:\r\n\r\n>  The client then processes the \"retry_keys\" field from the server's\r\n>  \"encrypted_server_name\" extension. If one of the values used a version known\r\n>  to the client, the client SHOULD retry the handshake with a new transport\r\n>  connection, using that value to encrypt the SNI. If no value is applicable,\r\n>  the client SHOULD retry with ESNI disabled.\r\n\r\nBut I like the framing of \"securely disabled\". It's not normative but explains what's going on. What do you think of the new text.\r\n\r\n> If that is not the intent, then this stipulates policy: it's OK to fall back when you have a clear signal that ESNI is enabled, but the server doesn't do ESNI. That's not a policy I would support.\r\n\r\nTo clarify, when you say \"clear\", do you mean \"cleartext and not secured\" or do you mean \"unambiguous, including verifying the public name\"? I agree with you if the former, but the latter is kind of the point. :-)",
              "createdAt": "2019-02-15T00:24:40Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 304,
              "body": "Done.",
              "createdAt": "2019-02-15T00:58:47Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 309,
              "body": "Done.",
              "createdAt": "2019-02-15T00:59:16Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 315,
              "body": "Done",
              "createdAt": "2019-02-15T01:01:08Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 330,
              "body": "Done.",
              "createdAt": "2019-02-15T01:01:21Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 336,
              "body": "I don't quite follow. What's the concern here? This one says \"If the public name does not verify\". Note this is also existing text, but slightly adapted. From before this PR:\r\n\r\n> If the servers does not\r\n> require SNI, it will complete the handshake with its default\r\n> certificate. Most likely, this will cause a certificate name\t\r\n> mismatch and thus handshake failure. Clients SHOULD NOT fall\t\r\n> back to cleartext SNI, because that allows a network attacker\t\r\n> to disclose the SNI. They MAY attempt to use another server\t\r\n> from the DNS results, if one is provided.",
              "createdAt": "2019-02-15T01:02:54Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 374,
              "body": "This too is an existing sentence from before this PR. :-P Happy to remove it though. Removed.",
              "createdAt": "2019-02-15T01:03:43Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 383,
              "body": "Done.",
              "createdAt": "2019-02-15T01:04:17Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 173,
              "body": "Well, it's a little fussy. If we were worried about a malicious server colluding with a network observer, that malicious server could already just broadcast whatever tracking information it has to the clear somewhere else. :-P\r\n\r\nBut if the client is already not bothering with session resumption or scoping it for tracking reasons, a single-use retry means they don't *also* need to scope this. Honestly, saying that you must scope this at least as tightly as session resumption probably is sufficient? Though there's also thinking through accidental pinning if retry keys manage to change the public name.\r\n\r\nI added \"pinning concerns\" to the text but I dunno what other text is needed given the above. Thoughts?\r\n\r\n(Neither of these are obviously fatal. There is a corner of the design space around in-band provisioning of ESNI keys, if we're okay caching these and can stomach the complexity of an in-band retry. I know some folks on the list were interested in that. But I think it makes sense to focus on the simplest version of the idea first.)",
              "createdAt": "2019-02-15T01:11:40Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 208,
              "body": "Yeah. Otherwise we don't have a public name to check. :-) How about \"did not negotiate certificate-based authentication\"?",
              "createdAt": "2019-02-15T01:12:37Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 220,
              "body": "The word \"origin\" shows up elsewhere in the doc a bunch, but I only see \"private domain\" once. Though \"origin\" usually says \"origin server\" or \"private origin\" and not plain \"origin\". I think \"private origin\" fits better here than \"origin server\". What do you think?",
              "createdAt": "2019-02-15T01:15:12Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MDUyMzg4",
          "commit": {
            "abbreviatedOid": "7ce9b5c"
          },
          "author": "kaduk",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-15T01:45:42Z",
          "updatedAt": "2019-02-15T01:45:42Z",
          "comments": [
            {
              "originalPosition": 220,
              "body": "I agree that \"private origin\" is better than \"origin server\"",
              "createdAt": "2019-02-15T01:45:42Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MDUyNjYx",
          "commit": {
            "abbreviatedOid": "7ce9b5c"
          },
          "author": "kaduk",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-15T01:47:04Z",
          "updatedAt": "2019-02-15T01:47:05Z",
          "comments": [
            {
              "originalPosition": 208,
              "body": "I think we need to stay positive, \"negotiated a session that did not use a certificate for authentication\" -- otherwise we get confused if we have any sort of PSK+cert or other joint authentication scheme.",
              "createdAt": "2019-02-15T01:47:05Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MDU5MjQz",
          "commit": {
            "abbreviatedOid": "7ce9b5c"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I see that I missed something about disabling.  I think that this could be a lot more explicit about the three primary cases that I talk about in the comments below.",
          "createdAt": "2019-02-15T02:24:06Z",
          "updatedAt": "2019-02-15T02:37:02Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "Prose in support of this would be useful.",
              "createdAt": "2019-02-15T02:24:07Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 336,
              "body": "This is a matter of not leaning on other text properly.  There are three cases and this says two:\r\n\r\nThe public name can not verify, which is clearly a terminal error condition.  \r\nThe server can indicate that ESNI is disabled, which triggers a retry without ESNI.\r\nThe server can provide (usable) alternative keys, which triggers a retry with those keys.  If those keys are no good, that's a terminal condition.\r\n\r\nI think that you can simplify this to say that unless ESNI is disabled as a result of successfully establishing a connection to the public name, then a client MUST NOT attempt to connect without ESNI.  (not SHOULD NOT)\r\n\r\nYes, this is probably not your fault.  I'll let others sort that bit out.",
              "createdAt": "2019-02-15T02:25:13Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 78,
              "body": "I see.  It's not very clear.  I'll make some suggestions.",
              "createdAt": "2019-02-15T02:27:22Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 91,
              "body": "```suggestion\r\n: One or more ESNIKeys structures containing the keys that the client should use on\r\n```",
              "createdAt": "2019-02-15T02:27:38Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 147,
              "body": "\"If none of the values provided in \"retry_keys\" contains a version supported by the client, the client MUST consider the server to have disabled ESNI.\"\r\n\r\nWhat the client does in response to an authenticated signal that disables ESNI is a matter for client policy, so the SHOULD is inappropriate.\r\n\r\nBTW, this would argue for having a third option: esni_disabled.\r\n\r\n",
              "createdAt": "2019-02-15T02:30:01Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MzE2Mzg4",
          "commit": {
            "abbreviatedOid": "7ce9b5c"
          },
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Looks mostly good, but added some nits and clarification questions.",
          "createdAt": "2019-02-15T16:09:35Z",
          "updatedAt": "2019-02-15T16:44:30Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "This is used by the _client_?",
              "createdAt": "2019-02-15T16:09:35Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 105,
              "body": "I think this sentence is missing something...",
              "createdAt": "2019-02-15T16:12:20Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 167,
              "body": "Nit: ...to _the_ calling application.",
              "createdAt": "2019-02-15T16:14:28Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 180,
              "body": "Does \"previously cached keys\" refer to the keys fetched from DNS?",
              "createdAt": "2019-02-15T16:28:18Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 203,
              "body": "I'm not sure I understand this. Where would the toggle go, in DNS? And having the toggle turned on would signal to the client that it must not retry the connection with ESNI disabled?",
              "createdAt": "2019-02-15T16:39:40Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0NDA1NjE3",
          "commit": {
            "abbreviatedOid": "21f8eab"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-15T19:35:27Z",
          "updatedAt": "2019-02-15T19:51:52Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "Er, I was thinking it's used by the server in that it's the identity the server assumes, but yeah conversely the client verifies it. I've reworded this to not reference either side.",
              "createdAt": "2019-02-15T19:35:27Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 105,
              "body": "Oops! The mistake was s/which/negotiated/.",
              "createdAt": "2019-02-15T19:36:25Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 146,
              "body": "Added the word non-empty to the public_name description.",
              "createdAt": "2019-02-15T19:36:51Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 167,
              "body": "Done. Also removed \"as described below\". That could be read as \"as described below, here's how you avoid using the retry keys\", which is weird.",
              "createdAt": "2019-02-15T19:37:10Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 180,
              "body": "@martinthomson left a bunch of comments that suggested he didn't want the specification text to talk about DNS keys. Thus, to answer your question, yes but not necessarily so we can't say that. :-P\r\n\r\nOn the list, someone thought a version of this text implied that you're supposed to keep track of all the retry keys and make sure they never repeat. (Honestly, I think that reading was tenuous to say the least.) So I've tried to avoid it saying MUST NOT use the old keys.\r\n\r\nI've now switched it to \"previously-advertised\" which matches the verb used elsewhere. If you all still don't like it, please give me an alternative! :-)",
              "createdAt": "2019-02-15T19:45:15Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 203,
              "body": "Some extension on the ESNIKeys yeah. This is a TODO, not spec text.",
              "createdAt": "2019-02-15T19:46:15Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            },
            {
              "originalPosition": 336,
              "body": "Adopted your text with the MUST NOT.",
              "createdAt": "2019-02-15T19:48:17Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0NDkxNzQx",
          "commit": {
            "abbreviatedOid": "0ec053c"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-16T00:42:46Z",
          "updatedAt": "2019-02-16T00:42:46Z",
          "comments": [
            {
              "originalPosition": 147,
              "body": "Oops. Missed this one somehow. (GitHub's UI is... not the best).\r\n\r\n> \"If none of the values provided in \"retry_keys\" contains a version supported by the client, the client MUST consider the server to have disabled ESNI.\"\r\n\r\nI tweaked the wording a bit based on the first part. It seemed better to adjust the surrounding text too. Re the second part, I'm not sure what \"[MUST consider](https://tools.ietf.org/html/rfc6919#section-2)\" would mean as a normative requirement...\r\n\r\n> What the client does in response to an authenticated signal that disables ESNI is a matter for client policy, so the SHOULD is inappropriate.\r\n\r\nThe text around unechoed extensions also uses SHOULD. It's true that there isn't a single \"hook point\" for client policy around the disabling bit. It sounds like you might prefer a more \"abstracted\" text where something first outputs \"secure disable\", or \"secure replace\" and then there's policy on that.\r\n\r\nI haven't done that yet, in part because it's late on a Friday, but also I think we're well into wordsmithing weeds now. :-) I don't know what the right document organization would be for that. Also it's getting pretty long. Thoughts?\r\n\r\n> BTW, this would argue for having a third option: esni_disabled.\r\n\r\nIt's already there by way of not echoing the extension. I think a separate explicit version would only make sense if there are clients who:\r\n* are happy with `esni_retry_requested`\r\n* would be happy with `esni_disabled`\r\n* are *not* happy with the unechoed signal.\r\n\r\nThat preference is not entirely implausible because not echoing the extension is an implicit signal repurposing existing server behavior. However, that's also kind of the point, since it allows safe rollback. If server deployments cannot rely on that, the cost of deploying ESNI goes up dramatically.\r\n\r\nESNI, even more so than most TLS improvements, really wants a wide deployment, so I think it's good for the document to have a strong opinion here.\r\n\r\n(Specialized clients and specialized servers, of course, would probably ignore disable signals, but they would ignore `esni_disabled` too, so that's more about the SHOULD. But it seems to me that's covered by \"there may exist valid reasons in particular circumstances to ignore a particular item, but the full implications must be understood and carefully weighed before choosing a different course\".)",
              "createdAt": "2019-02-16T00:42:46Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0NDkxNzg0",
          "commit": {
            "abbreviatedOid": "0ec053c"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-16T00:43:01Z",
          "updatedAt": "2019-02-16T00:43:01Z",
          "comments": [
            {
              "originalPosition": 147,
              "body": "Er, hit comment too soon. Will upload the corresponding git commit shortly.",
              "createdAt": "2019-02-16T00:43:01Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0NDkyMDcw",
          "commit": {
            "abbreviatedOid": "aaccb84"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-16T00:45:12Z",
          "updatedAt": "2019-02-16T00:45:13Z",
          "comments": [
            {
              "originalPosition": 147,
              "body": "(Uploaded.)",
              "createdAt": "2019-02-16T00:45:13Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0NDk1NjM2",
          "commit": {
            "abbreviatedOid": "aaccb84"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-16T01:16:27Z",
          "updatedAt": "2019-02-16T01:16:28Z",
          "comments": [
            {
              "originalPosition": 220,
              "body": "\ud83d\udc4d ",
              "createdAt": "2019-02-16T01:16:28Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0NDk2MjQ3",
          "commit": {
            "abbreviatedOid": "aaccb84"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-16T01:22:51Z",
          "updatedAt": "2019-02-16T01:22:51Z",
          "comments": [
            {
              "originalPosition": 208,
              "body": "(Also missed this. I clearly don't know how to use GitHub...)\r\n\r\nDone.",
              "createdAt": "2019-02-16T01:22:51Z",
              "updatedAt": "2019-02-26T21:13:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 125,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM5MzE1NDA4",
      "title": "Allow clients to send GREASE ESNI extensions.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/125",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "(WG email coming shortly.)\r\n\r\n~~NB: When reviewing, ignore the first commit. This PR and https://github.com/tlswg/draft-ietf-tls-esni/pull/124 were originally formulated together. I split them into two based on some feedback, but since they touch the same text, it was simplest to include https://github.com/tlswg/draft-ietf-tls-esni/pull/124 in this PR. If the WG wishes to go with one but not the other, the text and details can be adjusted accordingly.~~\r\n\r\n*Update: This has been rebased to master, now that #124 is merged.*\r\n\r\nThe new server behavior (\"Improve ESNI robustness\") means clients can send\r\nGREASE ESNI extensions without interop issues. Write some text recommending\r\nthis, better meeting the \"Do not stick out\" criteria.",
      "createdAt": "2018-12-17T23:16:54Z",
      "updatedAt": "2019-04-22T21:00:26Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "8679dc49caa2131d9b660d9d30e4343aa7e994f9",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "grease",
      "headRefOid": "361feec6e4ad6dff2b40c27ba3cd09b491d667a6",
      "closedAt": "2019-04-22T21:00:26Z",
      "mergedAt": "2019-04-22T21:00:26Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "4f3ce56fdb4caea12c6480ca3a9a5ec6bfd074c1"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The GREASE section seems fine to me. (@davidben is there other new material in this PR?) @ekr, @kazuho, please have a look when possible.",
          "createdAt": "2018-12-31T17:36:25Z",
          "updatedAt": "2018-12-31T17:36:25Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> @davidben is there other new material in this PR?\r\n\r\nIt's whatever's in the second commit, so mostly that section but also a bit elsewhere:\r\nhttps://github.com/tlswg/draft-ietf-tls-esni/pull/125/commits/7401f55013f68ec47dad36b99977ad6aa881d9f1",
          "createdAt": "2019-01-28T23:55:34Z",
          "updatedAt": "2019-01-28T23:55:34Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "I share the view that the GREASE section looks fine.",
          "createdAt": "2019-02-13T21:48:53Z",
          "updatedAt": "2019-02-13T21:48:53Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "@ekr Did you mean to leave the comments on https://github.com/tlswg/draft-ietf-tls-esni/pull/124? (Notably the text already has seen a number of revisions here. I haven't gone back to update this PR yet. This PR was meant to just be the second commit.)",
          "createdAt": "2019-02-25T23:00:32Z",
          "updatedAt": "2019-02-25T23:00:32Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Ugh. Having something which claims to be a merged PR is kind of an\nattractive nusiance, then, no? Perhaps you can apply the changes here?\n\nOn Mon, Feb 25, 2019 at 3:00 PM David Benjamin <notifications@github.com>\nwrote:\n\n> @ekr <https://github.com/ekr> Did you mean to leave the comments on #124\n> <https://github.com/tlswg/draft-ietf-tls-esni/pull/124>? (Notably the\n> text already has seen a number of revisions here. I haven't gone back to\n> update this PR yet. This PR was meant to just be the second commit.)\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/pull/125#issuecomment-467219457>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ABD1oTg3ZYafmOt5ubYAqvmNV9qDX1GUks5vRGsRgaJpZM4ZXTha>\n> .\n>\n",
          "createdAt": "2019-02-25T23:04:10Z",
          "updatedAt": "2019-02-25T23:04:10Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "In my defense, I split them at your request and did include the following. ;-)\r\n\r\n> NB: When reviewing, ignore the first commit. This PR and #124 were originally formulated together. I split them into two based on some feedback, but since they touch the same text, it was simplest to include #124 in this PR. If the WG wishes to go with one but not the other, the text and details can be adjusted accordingly.\r\n\r\nBut, sure, I can rebase this one. I figured #124 was the bulk of the interesting bits (7401f55013f68ec47dad36b99977ad6aa881d9f1 is much smaller) so I figured we'd resolve #124 first and then I'd update this one at the end.",
          "createdAt": "2019-02-25T23:06:34Z",
          "updatedAt": "2019-02-25T23:06:34Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "On Mon, Feb 25, 2019 at 3:06 PM David Benjamin <notifications@github.com>\nwrote:\n\n> In my defense, I split them at your request and did include the following.\n> ;-)\n>\n> NB: When reviewing, ignore the first commit. This PR and #124\n> <https://github.com/tlswg/draft-ietf-tls-esni/pull/124> were originally\n> formulated together. I split them into two based on some feedback, but\n> since they touch the same text, it was simplest to include #124\n> <https://github.com/tlswg/draft-ietf-tls-esni/pull/124> in this PR. If\n> the WG wishes to go with one but not the other, the text and details can be\n> adjusted accordingly.\n>\n>\nSure, and I read that as \"this is an accurate reflection of my put for both\nof these\".\n\nBut, sure, I can rebase this one. I figured #124\n> <https://github.com/tlswg/draft-ietf-tls-esni/pull/124> was the bulk of\n> the interesting bits (7401f55\n> <https://github.com/tlswg/draft-ietf-tls-esni/commit/7401f55013f68ec47dad36b99977ad6aa881d9f1>\n> is much smaller) so I figured we'd resolve #124\n> <https://github.com/tlswg/draft-ietf-tls-esni/pull/124> first and then\n> I'd update this one at the end.\n>\n\nThanks.\n\n-Ekr\n\n\u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/pull/125#issuecomment-467221253>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ABD1oYi28jBhWjeNTZw4DxJZNo2VxMC_ks5vRGx6gaJpZM4ZXTha>\n> .\n>\n",
          "createdAt": "2019-02-25T23:10:08Z",
          "updatedAt": "2019-02-25T23:10:08Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> Sure, and I read that as \"this is an accurate reflection of my put for both of these\".\r\n\r\nWell, it was when I wrote that sentence. :-) Anyway, it's now been rebased and I've incorporated your comments as well.",
          "createdAt": "2019-03-02T05:17:02Z",
          "updatedAt": "2019-03-02T05:17:02Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAzNDc1NzQ0",
          "commit": {
            "abbreviatedOid": "7401f55"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-13T22:13:06Z",
          "updatedAt": "2019-02-13T22:13:06Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAzNDc2OTY1",
          "commit": {
            "abbreviatedOid": "7401f55"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-13T22:16:05Z",
          "updatedAt": "2019-02-13T22:16:05Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA3Njc1OTQ5",
          "commit": {
            "abbreviatedOid": "7401f55"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-25T22:46:52Z",
          "updatedAt": "2019-02-25T22:57:21Z",
          "comments": [
            {
              "originalPosition": 106,
              "body": "What's the function of this alert as opposed to just closing the connection?",
              "createdAt": "2019-02-25T22:46:52Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 167,
              "body": "It's worth noting that this is only relevant for the earlier version case.",
              "createdAt": "2019-02-25T22:49:42Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 195,
              "body": "This seems like it ought to be in the client section.",
              "createdAt": "2019-02-25T22:51:59Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 201,
              "body": "IMPORTANT: It seems like with TLS 1.3 you could just abort the connection as soon as you get SFIN.",
              "createdAt": "2019-02-25T22:52:23Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 225,
              "body": "Should we instead use consistent hashing so that you had the same record_digest for each server.",
              "createdAt": "2019-02-25T22:53:16Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 240,
              "body": "\"offer to resume\"?",
              "createdAt": "2019-02-25T22:54:53Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 306,
              "body": "I'm not sure how iluminating this hint about how to implement is. I would remove it.",
              "createdAt": "2019-02-25T22:56:10Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 354,
              "body": "I'm not sure if it's \"most\". We expect CDN conflictst o be common.",
              "createdAt": "2019-02-25T22:56:50Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA3NjgzNjM4",
          "commit": {
            "abbreviatedOid": "7401f55"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-25T23:08:42Z",
          "updatedAt": "2019-03-02T05:15:05Z",
          "comments": [
            {
              "originalPosition": 106,
              "body": "Using a `close_notify` felt slightly off because the client is not cleanly closing the connection. It's rejecting it altogether. A more generic alert would work too, but this way a deployment can monitor that alert for whether it's getting out of sync a lot. (Merely being unable to decrypt ESNI isn't sufficient given GREASE.)\r\n\r\nI've adjusted the \"Note that an unrecognized ClientEncryptedSNI.record_digest [...]\" paragraph in the server behavior section to talk about this.",
              "createdAt": "2019-02-25T23:08:42Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 225,
              "body": "That's a tracking vector, no?",
              "createdAt": "2019-02-26T00:08:27Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 240,
              "body": "Done.",
              "createdAt": "2019-03-02T04:48:00Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 306,
              "body": "Removed.",
              "createdAt": "2019-03-02T04:48:16Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 354,
              "body": "Well, hopefully the CDN issue will be resolved by the current discussion. But fair enough. I've replaced the sentence with \"The retry mechanism repairs inconsistencies, provided the server is authoritative for the public name.\" which is more descriptive and avoids the subjective \"most\".",
              "createdAt": "2019-03-02T04:50:55Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 167,
              "body": "Done.",
              "createdAt": "2019-03-02T04:52:04Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            },
            {
              "originalPosition": 195,
              "body": "Well, this is a subsection of the client section. :-) Do you mean that it belongs in {{handle-server-response}}?\r\n\r\nThe nuisance is it's common to both the key mismatch and rollback cases. The purpose of this section was so the text didn't have to write it twice. (A subroutine if you will.) Though, now that you mention it, it is weird that the subroutine call is labelled \"verifying the certificate against ESNIKeys.public_name as described in {{verify-public-name}}\" which kinda presupposes a certificate story.\r\n\r\nWDYT about this: I've changed the description from \"verifying [the certificate] against the public name\" to \"authenticating for the public name\", which puts it at a bit larger scope than certificate verification.",
              "createdAt": "2019-03-02T05:07:50Z",
              "updatedAt": "2019-04-22T20:59:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI5MTg3MTY4",
          "commit": {
            "abbreviatedOid": "a06d119"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-04-22T18:38:43Z",
          "updatedAt": "2019-04-22T18:38:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 127,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ2MDExNDky",
      "title": "Clarify that ESNI clients MUST NOT send cached_info cert extensions",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/127",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-01-19T00:47:26Z",
      "updatedAt": "2021-04-19T15:51:34Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3013b3c0c7bd93202cd4ca847380de64352ec79f",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/cached_info",
      "headRefOid": "105aa9a14d351afbcca44961facc9dd302cad73a",
      "closedAt": "2019-02-13T21:32:03Z",
      "mergedAt": "2019-02-13T21:32:03Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "5e08e1439e3bbfd8ed022252679e76d0c90b4c88"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Addresses #126.",
          "createdAt": "2019-01-19T00:47:48Z",
          "updatedAt": "2019-01-19T00:47:48Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 128,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ2MDEzMzYw",
      "title": "Specify HRR behavior.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/128",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-01-19T01:06:50Z",
      "updatedAt": "2019-03-08T01:07:59Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "d9437fd5a4ed04dff1b5e48f97c586f242e80fb4",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/hrr",
      "headRefOid": "39295c9b7b3a50ab39416021154f520f0374ed90",
      "closedAt": "2019-03-08T00:53:16Z",
      "mergedAt": "2019-03-08T00:53:16Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "1b339186ec98274e93132de121e76ca55cce849d"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho @ekr please have a look.",
          "createdAt": "2019-01-27T21:46:58Z",
          "updatedAt": "2019-01-27T21:46:58Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "We also need to specify server-side HRR behavior, right? Specifically, the server MUST recheck the second ClientHello's ESNI extension before sending the server certificate, otherwise putting the key share into the AD field doesn't really mean anything. The attacker would be able to do a cut-and-paste thing.\r\n\r\n(We could also incorporate the nonce into key schedule, but that upsets the document's split mode use case.)",
          "createdAt": "2019-03-08T01:03:23Z",
          "updatedAt": "2019-03-08T01:03:36Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yep! Thanks for bringing that up. I'll prepare text.",
          "createdAt": "2019-03-08T01:07:58Z",
          "updatedAt": "2019-03-08T01:07:58Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEwNDc1MTEx",
          "commit": {
            "abbreviatedOid": "a656687"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you for the text. LGTM.",
          "createdAt": "2019-03-05T03:11:49Z",
          "updatedAt": "2019-03-05T03:11:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 129,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ2MDEzODA1",
      "title": "Swap version[4] and checksum, so the latter covers the entire struct.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/129",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #119, and we want the checksum to cover the entire struct by definition. ",
      "createdAt": "2019-01-19T01:12:21Z",
      "updatedAt": "2021-04-19T15:51:35Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3013b3c0c7bd93202cd4ca847380de64352ec79f",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/version-swap",
      "headRefOid": "8842702305794a3c100a47e598605fb66691796c",
      "closedAt": "2019-07-02T23:53:35Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This looks fine, though the downside of this seems to be that the checksum becomes part of the \"invariants\" and can't be changed/removed in future versions.",
          "createdAt": "2019-01-19T13:18:48Z",
          "updatedAt": "2019-01-19T13:18:48Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, I assumed that was @kazuho\u2019s intent with the checksum. That is, if we see value in it for v1, it likely has value for all versions. ",
          "createdAt": "2019-01-19T15:01:29Z",
          "updatedAt": "2019-01-19T15:01:29Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho can you please comment?",
          "createdAt": "2019-01-27T21:46:41Z",
          "updatedAt": "2019-01-27T21:46:41Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "I am fine with making it an invariant, considering the fact that it exists for detecting transmission errors (or human errors during copy-and-paste).\r\n\r\nWe do not need to worry about this becoming \"insecure,\" unlike cryptographic hash functions.",
          "createdAt": "2019-02-15T02:03:12Z",
          "updatedAt": "2019-02-15T02:03:12Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MDU1NzEx",
          "commit": {
            "abbreviatedOid": "8842702"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-15T02:03:40Z",
          "updatedAt": "2019-02-15T02:03:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 136,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU2NzQwNjQ0",
      "title": "Add support for \"combined records\" via an ESNIKeys extension",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/136",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This change does the following:\r\n\r\n1. Add support for mandatory extensions, which are those that clients must process else reject the ESNIKeys record.\r\n2. Add a mandatory extension carrying a set of v4/v6 addresses, which is effectively the combined record mode. \r\n3. Add text describing how clients ought to resolve ESNI and A/AAAA records, and use the results to initiate TLS connections.",
      "createdAt": "2019-02-27T16:05:14Z",
      "updatedAt": "2019-03-10T02:04:22Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "a73367b8c58ba0a7f726743ad72ca4fd2b22574d",
      "headRepository": "chris-wood/draft-ietf-tls-esni",
      "headRefName": "caw/multi-cdn-simple",
      "headRefOid": "e9140ecba6c2fa17231c0d040e96e78f4cb44219",
      "closedAt": "2019-03-10T02:04:22Z",
      "mergedAt": "2019-03-10T02:04:22Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ba52fe66fb3a9a8d98dfd3d59b7322c454405f03"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> This is a substantial step in the right direction, but the fact that A/AAAA records are basically ignored makes me uneasy. \r\n\r\nThat's fair. However, it seems to be the price to get this sort of simplicity. Moreover, as an extension, it's not pressed upon all clients for all providers.\r\n\r\n> The fact that A/AAAA results are essentially fully embedded would imply that all logic involved in selectively returning those responses has to be duplicated for ESNIKeys, which is also sub-optimal.\r\n\r\nAlso true! I'm hoping that folks who are in the position and capable of vending these records can comment on this design's cost. ",
          "createdAt": "2019-02-28T00:39:09Z",
          "updatedAt": "2019-02-28T00:39:09Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Given that there was no serious objection to this change and that it works for at least one operator, I'm merging this PR. We can continue to iterate on #137 as needed in parallel.",
          "createdAt": "2019-03-10T02:04:19Z",
          "updatedAt": "2019-03-10T02:04:19Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4ODMwODE1",
          "commit": {
            "abbreviatedOid": "293f61c"
          },
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This is a substantial step in the right direction, but the fact that A/AAAA records are basically ignored makes me uneasy.  The fact that A/AAAA results are essentially fully embedded would imply that all logic involved in selectively returning those responses has to be duplicated for ESNIKeys, which is also sub-optimal.",
          "createdAt": "2019-02-27T23:57:27Z",
          "updatedAt": "2019-02-28T00:27:52Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Other than being lower-case (\"must\" vs. \"MUST\"), this seems duplicative with the following paragraph.",
              "createdAt": "2019-02-27T23:57:27Z",
              "updatedAt": "2019-03-10T02:02:03Z"
            },
            {
              "originalPosition": 153,
              "body": "So in this design, ESNIKeys containing address(es) causes the A/AAAA results to be entirely ignored?",
              "createdAt": "2019-02-28T00:02:46Z",
              "updatedAt": "2019-03-10T02:02:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4ODQwNTk5",
          "commit": {
            "abbreviatedOid": "293f61c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-28T00:36:37Z",
          "updatedAt": "2019-02-28T00:36:37Z",
          "comments": [
            {
              "originalPosition": 153,
              "body": "Yep!",
              "createdAt": "2019-02-28T00:36:37Z",
              "updatedAt": "2019-03-10T02:02:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4ODQwNzU5",
          "commit": {
            "abbreviatedOid": "293f61c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-28T00:37:18Z",
          "updatedAt": "2019-02-28T00:37:19Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "I opted for redundancy here. Happy to remove the subsequent text if people feel that's best.",
              "createdAt": "2019-02-28T00:37:18Z",
              "updatedAt": "2019-03-10T02:02:03Z"
            }
          ]
        }
      ]
    },
    {
      "number": 137,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU2NzQyNTUx",
      "title": "Add support for \"host pointers\" via an ESNIKeys extension",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/137",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This change does the following:\r\n\r\n1. Add support for mandatory extensions, which are those that clients must process else reject the ESNIKeys record.\r\n2. Add a mandatory extension carrying a \"host pointer,\" which is a (probably poorly named) struct containing a \"terminal CNAME\" for the domain, along with address masks, which may be partial or complete. Clients may use complete addresses if present, else they may use masks to resolve ESNI+A/AAAA mismatches. When these fail, the terminal CNAME may be used to get an address of some host that has the corresponding ESNI key.\r\n3. Add text describing how clients ought to resolve ESNI and A/AAAA records, and use the results to initiate TLS connections.\r\n\r\nThis is certainly more complex than #136.",
      "createdAt": "2019-02-27T16:10:00Z",
      "updatedAt": "2019-07-02T23:53:59Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f07d3806d52add7920a0f4087f93c85bede08581",
      "headRepository": "chris-wood/draft-ietf-tls-esni",
      "headRefName": "caw/multi-cdn",
      "headRefOid": "7adfa01707ef34bca44891084f386d2c587e1e04",
      "closedAt": "2019-07-02T23:53:59Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@MikeBishop Thanks for the feedback! I'll comment that, as an extension, this is compatible with #136, assuming of course that both extensions are not present. We could move forward with both.",
          "createdAt": "2019-02-28T00:44:01Z",
          "updatedAt": "2019-02-28T00:44:01Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing with #136.",
          "createdAt": "2019-07-02T23:53:59Z",
          "updatedAt": "2019-07-02T23:53:59Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4ODM1MDAw",
          "commit": {
            "abbreviatedOid": "7adfa01"
          },
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Despite the additional complexity, I think this takes us to a better place than #136.  In particular, it enables the generation of ESNIKeys to be simpler (outlining a block of addresses and a recovery path) and leaves the complexity in the A/AAAA where it already exists.\r\n\r\nThere's some wording issues, but technically I like this direction.",
          "createdAt": "2019-02-28T00:13:16Z",
          "updatedAt": "2019-02-28T00:30:02Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "So the idea here is that, even if there's no overlap between the A/AAAA results and the ESNI record addresses, if the host_pointer chain includes (terminal might be too strong a statement) the indicated name, then you try it?  This is a bit of a leap of faith on two fronts:  First, that they have the appropriate keys without being in the list of addresses, but second that the caller will get the CNAME chain back rather than just the addresses.\r\n\r\nPerhaps a reasonable optimization for those clients that can do it, though.",
              "createdAt": "2019-02-28T00:13:16Z",
              "updatedAt": "2019-02-28T00:30:02Z"
            },
            {
              "originalPosition": 168,
              "body": "\"the address netmask\" isn't defined, here or elsewhere.  I presume that this should read something like \"...and if the intersection of the A or AAAA responses and the set of address ranges in address_set is not empty, then clients SHOULD initiate TLS with ESNI to addresses in that intersection.\"",
              "createdAt": "2019-02-28T00:17:47Z",
              "updatedAt": "2019-02-28T00:30:02Z"
            },
            {
              "originalPosition": 175,
              "body": "Likewise, \"If the intersection (...) is empty but the A/AAAA resolution included a CNAME which matches....\"",
              "createdAt": "2019-02-28T00:19:02Z",
              "updatedAt": "2019-02-28T00:30:02Z"
            },
            {
              "originalPosition": 186,
              "body": "Isn't this just a subcase of the previous points?  If the address_set is empty, then by definition there's no overlap with the A/AAAA results.  So either the name occurs in the CNAME chain (4) or you resolve the name (5).",
              "createdAt": "2019-02-28T00:21:21Z",
              "updatedAt": "2019-02-28T00:30:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4ODQxNTc5",
          "commit": {
            "abbreviatedOid": "7adfa01"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-28T00:40:41Z",
          "updatedAt": "2019-02-28T00:40:41Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "Oh, hah, yes! Will fix.",
              "createdAt": "2019-02-28T00:40:41Z",
              "updatedAt": "2019-02-28T00:40:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4ODQxNjI1",
          "commit": {
            "abbreviatedOid": "7adfa01"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-28T00:40:52Z",
          "updatedAt": "2019-02-28T00:40:52Z",
          "comments": [
            {
              "originalPosition": 175,
              "body": "\ud83d\udc4d \r\n",
              "createdAt": "2019-02-28T00:40:52Z",
              "updatedAt": "2019-02-28T00:40:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4ODQxODc0",
          "commit": {
            "abbreviatedOid": "7adfa01"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-28T00:41:56Z",
          "updatedAt": "2019-02-28T00:41:56Z",
          "comments": [
            {
              "originalPosition": 186,
              "body": "Yes, technically. I left it as is to be explicit. I can remove it if we think it's excessive.",
              "createdAt": "2019-02-28T00:41:56Z",
              "updatedAt": "2019-02-28T00:41:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA5ODA4MDM3",
          "commit": {
            "abbreviatedOid": "7adfa01"
          },
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-01T22:15:55Z",
          "updatedAt": "2019-03-01T22:15:56Z",
          "comments": [
            {
              "originalPosition": 186,
              "body": "Maybe instead of listing it as a separate step, just turn it into an unnumbered comment that an empty address set will always land in (4) or (5).",
              "createdAt": "2019-03-01T22:15:56Z",
              "updatedAt": "2019-03-01T22:15:56Z"
            }
          ]
        }
      ]
    },
    {
      "number": 144,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU4MTYwNDU5",
      "title": "Use new RRType instead of TXT with a custom prefix",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/144",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Subsumes #73 and #108.",
      "createdAt": "2019-03-05T02:31:59Z",
      "updatedAt": "2019-09-24T10:55:09Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f07d3806d52add7920a0f4087f93c85bede08581",
      "headRepository": "chris-wood/draft-ietf-tls-esni",
      "headRefName": "caw/remove-prefix-with-new-rrtype",
      "headRefOid": "5f191fdb2c5826a7be33de59a2128ac6d7ee6060",
      "closedAt": "2019-03-06T00:54:53Z",
      "mergedAt": "2019-03-06T00:54:52Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "5fda4a09bcde55a2256053c79d5fc432d58b2f8d"
      },
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "lgtm",
          "createdAt": "2019-03-05T02:48:38Z",
          "updatedAt": "2019-03-05T02:48:38Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">   Internet-Drafts are draft documents valid for a maximum of six months\r\n >  and may be updated, replaced, or obsoleted by other documents at any\r\n  > time.  It is inappropriate to use Internet-Drafts as reference\r\n  > material or to cite them other than as \"work in progress.\"\r\n",
          "createdAt": "2019-04-19T20:20:48Z",
          "updatedAt": "2019-04-19T20:20:48Z"
        },
        {
          "author": "Viktor45",
          "authorAssociation": "NONE",
          "body": "this is good for wiretapping for easy to drop all ESNI with DPI for SNI downgrade",
          "createdAt": "2019-09-24T10:55:09Z",
          "updatedAt": "2019-09-24T10:55:09Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEwNDcyMjQ1",
          "commit": {
            "abbreviatedOid": "5f191fd"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": ":+1:",
          "createdAt": "2019-03-05T02:57:05Z",
          "updatedAt": "2019-03-05T02:57:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 147,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU5MzA1ODEy",
      "title": "Encrypt nonce for secure sharing of the true SNI with a third party",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/147",
      "state": "CLOSED",
      "author": "roelfdutoit",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Third party secret sharing solutions might be developed in future.  This PR enables sharing of the true SNI  while at the same time preventing the third party from impersonating the server.  The client encrypts the nonce with a key derived from Z, and only a server with access to Z will be able to acknowledge the decrypted nonce.",
      "createdAt": "2019-03-07T23:15:49Z",
      "updatedAt": "2019-07-04T15:52:58Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "d9437fd5a4ed04dff1b5e48f97c586f242e80fb4",
      "headRepository": "roelfdutoit/draft-ietf-tls-esni",
      "headRefName": "encrypted_nonce",
      "headRefOid": "9346ce43c15b9ccbb2d3369c362bed1acbc64e11",
      "closedAt": "2019-07-04T15:52:58Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@roelfdutoit what's the plan for this PR?",
          "createdAt": "2019-07-04T14:24:24Z",
          "updatedAt": "2019-07-04T14:24:24Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 148,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU5NjEwNTQ2",
      "title": "specify 7838 reference applies to section 2.3",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/148",
      "state": "MERGED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "closes #132",
      "createdAt": "2019-03-08T21:19:31Z",
      "updatedAt": "2019-03-08T21:24:29Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1b339186ec98274e93132de121e76ca55cce849d",
      "headRepository": "mcmanus/draft-rescorla-tls-esni",
      "headRefName": "mcmanus-altsvc-clarification",
      "headRefOid": "89e83e54809f169c36679cba6b92bccf89fa2978",
      "closedAt": "2019-03-08T21:24:29Z",
      "mergedAt": "2019-03-08T21:24:28Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "a73367b8c58ba0a7f726743ad72ca4fd2b22574d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNDg1OTI0",
          "commit": {
            "abbreviatedOid": "89e83e5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-08T21:24:25Z",
          "updatedAt": "2019-03-08T21:24:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 151,
      "id": "MDExOlB1bGxSZXF1ZXN0MjY4OTQyMjEw",
      "title": "Exclude extensions from record digest",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/151",
      "state": "CLOSED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #150.",
      "createdAt": "2019-04-09T22:08:37Z",
      "updatedAt": "2019-04-14T23:22:12Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "ba52fe66fb3a9a8d98dfd3d59b7322c454405f03",
      "headRepository": null,
      "headRefName": "record-digest-no-extensions",
      "headRefOid": "0d5c6905c8fc5ec2d9d9574bc958c8179af643ba",
      "closedAt": "2019-04-14T23:22:11Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Superseded by #153.",
          "createdAt": "2019-04-14T23:22:11Z",
          "updatedAt": "2019-04-14T23:22:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI0NjgxNTAz",
          "commit": {
            "abbreviatedOid": "0d5c690"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-09T22:14:36Z",
          "updatedAt": "2019-04-09T22:14:37Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "It seems weird to exclude other extensions. Also I assume you mean the first byte of \"version\"?",
              "createdAt": "2019-04-09T22:14:36Z",
              "updatedAt": "2019-04-09T22:14:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI0NzAyODgw",
          "commit": {
            "abbreviatedOid": "0d5c690"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-09T23:36:08Z",
          "updatedAt": "2019-04-09T23:36:08Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I agree. I'm not sure this is the right approach. It seems we should either (a) have individual extensions included in the digest or not via some mandatory-like bit, or (b) have a separate extensions field that's omitted from the digest, in which the address information can go. Both are... not great.",
              "createdAt": "2019-04-09T23:36:08Z",
              "updatedAt": "2019-04-09T23:36:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI0NzAzMTI3",
          "commit": {
            "abbreviatedOid": "0d5c690"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for taking this issue! As the comment suggest, I'm not sure this is the best approach. I'm curious to hear counterarguments. ",
          "createdAt": "2019-04-09T23:37:11Z",
          "updatedAt": "2019-04-09T23:37:11Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI0ODI2OTU2",
          "commit": {
            "abbreviatedOid": "0d5c690"
          },
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-10T08:30:30Z",
          "updatedAt": "2019-04-10T08:30:30Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "To me the point of `record_digest` is to identify a specific key so that the TLS server doesn't have to do trial decryption, that is, its point is not the digest itself, but the fact that it identifies a key, is this correct?\r\n\r\nIf so, it seems fine (but not great) that it would only really cover the specific key and the metadata directly associated with the key, while extensions can potentially be associated with multiple keys.\r\n\r\nBut a potentially better alternative is to just get rid of `record_digest` (if my assumption that it only provides an \"identity\" for the key), and replace with an explicit `key_identity` field that is generated by the server and would get added to `ESNIKeys` as well as replace `record_digest` in the ClientHello extension.\r\n\r\nThoughts?",
              "createdAt": "2019-04-10T08:30:30Z",
              "updatedAt": "2019-04-10T08:30:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI1Mjk4MjY2",
          "commit": {
            "abbreviatedOid": "0d5c690"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-11T02:00:24Z",
          "updatedAt": "2019-04-11T02:00:25Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "@ghedo \r\n> But a potentially better alternative is to just get rid of `record_digest` (if my assumption that it only provides an \"identity\" for the key), and replace with an explicit `key_identity` field that is generated by the server and would get added to `ESNIKeys` as well as replace `record_digest` in the ClientHello extension.\r\n\r\nI am not sure if that is the correct thing to do. I'd be concerned that omission of a digest might lead to availability concerns.\r\n\r\nThe reason we have had `record_digest` is because the TLS handshake used to always hard-fail when client uses a corrupt ESNI record. With #124 being merged, we have a fallback mechanism that would work in _some_ failure modes without the need for the digest. However, I believe that there are still certain cases of hard failure (like the server sending an `illegal_parameter` alert) when the ESNI record is corrupt.\r\n\r\nPS. Therefore I think I might favor the approach proposed by @davidben in #150: place the IP address list outside of the ESNIKeys.",
              "createdAt": "2019-04-11T02:00:25Z",
              "updatedAt": "2019-04-11T02:02:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI1NTEwMDQy",
          "commit": {
            "abbreviatedOid": "0d5c690"
          },
          "author": "ghedo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-11T12:45:31Z",
          "updatedAt": "2019-04-11T12:45:32Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I'm not sure I follow @kazuho, isn't the `checksum` value intended to detect record corruption? If so, why do we have two?",
              "createdAt": "2019-04-11T12:45:32Z",
              "updatedAt": "2019-04-11T12:45:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI1NzE4ODI2",
          "commit": {
            "abbreviatedOid": "0d5c690"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-11T18:41:38Z",
          "updatedAt": "2019-04-11T18:41:38Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "@ghedo `record_digest` was originally added to prevent downgrades, so we want it to cover as much of the necessary bits in the record as possible. It just so happens to also serve as a key identifier for the server.",
              "createdAt": "2019-04-11T18:41:38Z",
              "updatedAt": "2019-04-11T18:41:38Z"
            }
          ]
        }
      ]
    },
    {
      "number": 152,
      "id": "MDExOlB1bGxSZXF1ZXN0MjcwMTMzMjY5",
      "title": "There's no ESNI TXT record anymore",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/152",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-04-12T19:52:40Z",
      "updatedAt": "2019-04-12T23:18:38Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "ba52fe66fb3a9a8d98dfd3d59b7322c454405f03",
      "headRepository": null,
      "headRefName": "not-txt",
      "headRefOid": "70b9b6b66a02866626699d0ad11981cf55309e32",
      "closedAt": "2019-04-12T23:18:38Z",
      "mergedAt": "2019-04-12T23:18:38Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "51bc4ed89ae61585bd800d55785b5abd7c457a30"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI2MzIwMTE0",
          "commit": {
            "abbreviatedOid": "70b9b6b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-04-12T23:18:32Z",
          "updatedAt": "2019-04-12T23:18:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 153,
      "id": "MDExOlB1bGxSZXF1ZXN0MjcwMzM1NjU5",
      "title": "Introduce ESNIRecord wrapper and move AddressSet into it",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/153",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #150.\r\n\r\n---\r\n\r\nTry 2. This turned out to be somewhat tricky due to existing text using \"ESNI record\" and \"ESNIKeys record\" (and similar) interchangeably, so I might have missed some instances.\r\n\r\nAn alternative design would have been to have a single ESNIRecord value per ESNI record, and then have multiple ESNIKeys values for each ESNIRecord (instead of multiple ESNIRecord values per ESNI and single ESNIKeys per ESNIRecord), though that will require more changes.",
      "createdAt": "2019-04-14T23:20:56Z",
      "updatedAt": "2019-04-18T16:40:57Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "51bc4ed89ae61585bd800d55785b5abd7c457a30",
      "headRepository": null,
      "headRefName": "extensions-all-the-way-down",
      "headRefOid": "2432376197825756c171842e06fbcfc981f13a74",
      "closedAt": "2019-04-18T16:40:57Z",
      "mergedAt": "2019-04-18T16:40:57Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "8679dc49caa2131d9b660d9d30e4343aa7e994f9"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @ghedo!",
          "createdAt": "2019-04-18T16:40:44Z",
          "updatedAt": "2019-04-18T16:40:44Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI4MDAwMDM2",
          "commit": {
            "abbreviatedOid": "2432376"
          },
          "author": "dvorak42",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-04-17T21:09:23Z",
          "updatedAt": "2019-04-17T21:11:29Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Might be useful to call out that these extensions aren't verified as part of the record_digest?",
              "createdAt": "2019-04-17T21:09:23Z",
              "updatedAt": "2019-04-17T21:11:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI4MzkwNTYy",
          "commit": {
            "abbreviatedOid": "2432376"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-18T16:40:33Z",
          "updatedAt": "2019-04-18T16:40:33Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Agreed. I'll merge this and then make that change directly. ",
              "createdAt": "2019-04-18T16:40:33Z",
              "updatedAt": "2019-04-18T16:40:33Z"
            }
          ]
        }
      ]
    },
    {
      "number": 154,
      "id": "MDExOlB1bGxSZXF1ZXN0MjcyODcxMDIy",
      "title": "Switch to record_digest_mac to prevent GREASE detection.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/154",
      "state": "CLOSED",
      "author": "dvorak42",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Currently an attacker can distinguish a real ESNI extension and\r\nGREASE extension based on the error returned by replaying the\r\nclient's ClientHello with swapped out keyshares.",
      "createdAt": "2019-04-23T19:57:59Z",
      "updatedAt": "2020-05-20T15:59:48Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "4f3ce56fdb4caea12c6480ca3a9a5ec6bfd074c1",
      "headRepository": "dvorak42/draft-ietf-tls-esni",
      "headRefName": "grease_mac",
      "headRefOid": "bf4dee02a17f8afbb2828b50c320527be1e2d455",
      "closedAt": "2020-05-20T15:59:48Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favor of #235!",
          "createdAt": "2020-05-20T15:59:47Z",
          "updatedAt": "2020-05-20T15:59:47Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwMjYwNzc3",
          "commit": {
            "abbreviatedOid": "eadc232"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-24T17:43:32Z",
          "updatedAt": "2019-04-24T17:43:33Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "s/, however/. However,",
              "createdAt": "2019-04-24T17:43:32Z",
              "updatedAt": "2019-04-24T19:21:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwMjYxMTQx",
          "commit": {
            "abbreviatedOid": "eadc232"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-24T17:44:19Z",
          "updatedAt": "2019-04-24T17:44:20Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "nit: s/the IP it is connecting to./the destination IP address./",
              "createdAt": "2019-04-24T17:44:19Z",
              "updatedAt": "2019-04-24T19:21:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwMjYzMDQz",
          "commit": {
            "abbreviatedOid": "eadc232"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-24T17:47:56Z",
          "updatedAt": "2019-04-24T17:47:56Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "nit: I'd replace \"the attacker Adv\" with \"an attacker\", and \"they'd\" with \"Adv\"",
              "createdAt": "2019-04-24T17:47:56Z",
              "updatedAt": "2019-04-24T19:21:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwMjYzMzI3",
          "commit": {
            "abbreviatedOid": "eadc232"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-24T17:48:27Z",
          "updatedAt": "2019-04-24T17:48:27Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "nit: Perhaps say that this *may* disincentive deployment?",
              "createdAt": "2019-04-24T17:48:27Z",
              "updatedAt": "2019-04-24T19:21:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwMjYzODE1",
          "commit": {
            "abbreviatedOid": "1bcb80f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I'm OK with this change given the perceived risk. @ekr, @kazuho @grittygrease: please have a look and comment. ",
          "createdAt": "2019-04-24T17:49:24Z",
          "updatedAt": "2019-04-24T17:52:45Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Perhaps drop a forward pointer to the security considerations blurb here?",
              "createdAt": "2019-04-24T17:49:24Z",
              "updatedAt": "2019-04-24T19:21:19Z"
            },
            {
              "originalPosition": 20,
              "body": "Perhaps point to the section where it's defined?",
              "createdAt": "2019-04-24T17:52:02Z",
              "updatedAt": "2019-04-24T19:21:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwMzI4Mzk4",
          "commit": {
            "abbreviatedOid": "bf4dee0"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-24T20:06:40Z",
          "updatedAt": "2019-04-24T20:06:40Z",
          "comments": [
            {
              "originalPosition": 140,
              "body": "I'm not sure how persuasive I find this. It seems like it's quite likely that the attacker can determine which IP addresses support ESNI, simply by doing reverse resolution and then forward resolution. Why does this help?",
              "createdAt": "2019-04-24T20:06:40Z",
              "updatedAt": "2019-04-24T20:06:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxODczNTM1",
          "commit": {
            "abbreviatedOid": "bf4dee0"
          },
          "author": "dvorak42",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-29T20:02:21Z",
          "updatedAt": "2019-04-29T20:02:22Z",
          "comments": [
            {
              "originalPosition": 140,
              "body": "A way of avoiding that, though which might be problematic to deploy, is that the reverse resolution name and the public name don't have ESNI records, since you don't necessarily need ESNI when hitting those names, since they're already visible to an attacker.",
              "createdAt": "2019-04-29T20:02:22Z",
              "updatedAt": "2019-04-29T20:02:22Z"
            }
          ]
        }
      ]
    },
    {
      "number": 157,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg0MzI5MzI4",
      "title": "Allow different records while keeping the same anonymity set",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/157",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The current text about anonymity sets for records is too restrictive. If I have 100000 names and 100 IPs and for all queries I randomly return four out of my 100 IPs chosen randomly, I still provide the same anonymity set but I violate the SHOULD. The proposed text fixes #133 ",
      "createdAt": "2019-06-02T09:35:45Z",
      "updatedAt": "2019-06-03T08:26:37Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "4f3ce56fdb4caea12c6480ca3a9a5ec6bfd074c1",
      "headRepository": "DavidSchinazi/draft-ietf-tls-esni",
      "headRefName": "allow_different_records",
      "headRefOid": "0248ca74b80bcf2c9174753c2599232d555964c4",
      "closedAt": "2019-06-02T15:13:39Z",
      "mergedAt": "2019-06-02T15:13:38Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "8c9626ea59a087ab006da8b37bb251b28df68403"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjMwNzcz",
          "commit": {
            "abbreviatedOid": "0248ca7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM -- thanks!",
          "createdAt": "2019-06-02T15:12:46Z",
          "updatedAt": "2019-06-02T15:12:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 158,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg0MzYwNDk3",
      "title": "Clarify AAD for encrypted_sni and HKDF-Extract salt",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/158",
      "state": "MERGED",
      "author": "Lekensteyn",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "While at it, remove the redundant \"ClientHello.\" prefix, the name\r\nKeyShareClientHello implies this. Fixes #155\r\n___\r\n@sftcd I did not explicitly mention that \"extension_data\" is a list of key shares, but hope that the suggested phrase is strong enough to imply that. Do you think that is sufficient or should it become something like:\r\n\r\n> Where ClientHello.KeyShareClientHello is the \"extension_data\" field of the\r\n> \"key_share\" extension in a Client Hello (Section 4.2.8 of {{!RFC8446}})),\r\n> namely a list of key shares.\r\n\r\n(By the way, the list of client key shares could contain one or more entries, but it could also be empty if the client would like to trigger a HRR. That should still be OK since the key/nonce is derived from the client hello random.)",
      "createdAt": "2019-06-02T18:16:04Z",
      "updatedAt": "2019-06-02T23:03:59Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "8c9626ea59a087ab006da8b37bb251b28df68403",
      "headRepository": "Lekensteyn/draft-ietf-tls-esni",
      "headRefName": "clarify-aad",
      "headRefOid": "6c43eb7a76fb16cc18746bae665dd54a767f9b6f",
      "closedAt": "2019-06-02T19:57:43Z",
      "mergedAt": "2019-06-02T19:57:43Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "6c78c495e19f4977d3b030a36433dd982f544b18"
      },
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "Those changes seem okish though could maybe be better. My issue was that OpenSSL (afaics) previously ignored all the key shares except the one used, so handling two of 'em as the AAD meant adding some new state. No idea if other implementations are like that though. I guess it might help someone else if it explicitly said that there can be >1 key share to include in the AAD.\r\n\r\n(BTW, on your BTW, I need to think more about ESNI and HRR handling, haven't tested that yet so not sure if there's a case where the encoding of 0 key shares would be used as ESNI AAD.)\r\n",
          "createdAt": "2019-06-02T18:30:34Z",
          "updatedAt": "2019-06-02T18:30:34Z"
        },
        {
          "author": "Lekensteyn",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If this adds so much complication, why not drop the KeyShareClientHello completely? If the purpose is to bind this to the original Client Hello, then the Client Random should be sufficient.\r\n\r\nAn implementation that creates the encrypted_sni field is also responsible for generating a random client hello and a new ESNI key share. Assuming that these are always unique between Client Hellos, then removing the KeyShareClientHello extension should still preserve the binding property.\r\n\r\nAnd even if for some reason the ESNI key share is reused (e.g. shared between different client hello, or reusing one from KeyShareClientHello), the derived key/nonce would still be different if Client Hello Random is unique.\r\n\r\n@chris-wood what was the reason for mixing the client key shares list in addition to the existing client random (commit 134b15c87b5c4cde7f52500138662f64757e2e9c)?",
          "createdAt": "2019-06-02T19:14:13Z",
          "updatedAt": "2019-06-02T19:14:13Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "If you don't bind in the client key share, there is a trivial attack in which the attacker replaces the key share with their own, causing the server's certificate to be encrypted to them.",
          "createdAt": "2019-06-02T19:22:17Z",
          "updatedAt": "2019-06-02T19:22:17Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> @chris-wood what was the reason for mixing the client key shares list in addition to the existing client random (commit 134b15c)?\r\n\r\nWhat @ekr said above. :-)",
          "createdAt": "2019-06-02T19:56:05Z",
          "updatedAt": "2019-06-02T19:56:05Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the clarifying text!",
          "createdAt": "2019-06-02T19:57:39Z",
          "updatedAt": "2019-06-02T19:57:39Z"
        },
        {
          "author": "Lekensteyn",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> If you don't bind in the client key share, there is a trivial attack in which the attacker replaces the key share with their own, causing the server's certificate to be encrypted to them.\r\n\r\nOh I see, the sender of the ESNI extension does not have to prove its knowledge about the ESNI private key, so an attacker could trivially copy the victim's ESNI extension and client random into the attacker's handshake, and recover the certificate if the client key shares were not included. Even if the attacker cannot decrypt SNI, they can still observe the side-effects. Thanks!\r\n\r\nI think the text could be clarified to highlight this, I'll prepare a proposal for this.",
          "createdAt": "2019-06-02T23:03:59Z",
          "updatedAt": "2019-06-02T23:03:59Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ0NjQwMTU1",
          "commit": {
            "abbreviatedOid": "6c43eb7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-02T19:57:31Z",
          "updatedAt": "2019-06-02T19:57:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 159,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg0Mzg2MjY0",
      "title": "Clarify how anti-replay protection is achieved",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/159",
      "state": "CLOSED",
      "author": "Lekensteyn",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The SNI encryption key is not bound to the Client Hello, one could for\r\nexample \"cut and paste\" the ESNI value in a different Client Hello with\r\nthe same Random field, key_share extension and ESNI extension, but with\r\na different, say, supported_groups extension.\r\n\r\nRemove the (EC)DH argument since it only ensures that an attacker cannot\r\ncompute the SNI encryption key, but actual anti-replay protection is\r\nprovided by binding to the key_share extension.",
      "createdAt": "2019-06-03T01:00:58Z",
      "updatedAt": "2020-03-09T21:58:20Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "6c78c495e19f4977d3b030a36433dd982f544b18",
      "headRepository": "Lekensteyn/draft-ietf-tls-esni",
      "headRefName": "clarify-anti-replay",
      "headRefOid": "429e5a8da0bd3e09effbc7075eb62a94597aedd5",
      "closedAt": "2020-03-09T21:58:20Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This is likely overcome by events in #207. @Lekensteyn, can you please update this PR based on that text, or close it?",
          "createdAt": "2020-03-08T00:36:50Z",
          "updatedAt": "2020-03-08T00:36:50Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Overcome by #207.",
          "createdAt": "2020-03-09T21:58:20Z",
          "updatedAt": "2020-03-09T21:58:20Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 161,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg4NzQyMDY1",
      "title": "Remove not_before and not_after",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/161",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "We now have a proper retry mechanism, so we don't need to prevent\r\nclients to connect using expired keys anymore.",
      "createdAt": "2019-06-17T08:24:11Z",
      "updatedAt": "2019-06-17T18:17:17Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "6c78c495e19f4977d3b030a36433dd982f544b18",
      "headRepository": null,
      "headRefName": "remove-not-before-after",
      "headRefOid": "9b267c20662db55ba54afa715a06be5990fe6930",
      "closedAt": "2019-06-17T18:17:17Z",
      "mergedAt": "2019-06-17T18:17:17Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "46490d1ad41cf67b2ae4ad4aac9785a351acd8fd"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUwMzc1OTEw",
          "commit": {
            "abbreviatedOid": "9b267c2"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you for the PR. LGTM",
          "createdAt": "2019-06-17T09:10:38Z",
          "updatedAt": "2019-06-17T09:10:38Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUwNjY2NDM3",
          "commit": {
            "abbreviatedOid": "9b267c2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-06-17T18:17:10Z",
          "updatedAt": "2019-06-17T18:17:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 162,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg5ODM2NTQ1",
      "title": "Restrict padded_length values",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/162",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "See discussion at https://github.com/tlswg/draft-ietf-tls-esni/issues/134",
      "createdAt": "2019-06-19T18:53:21Z",
      "updatedAt": "2019-06-27T18:09:36Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "46490d1ad41cf67b2ae4ad4aac9785a351acd8fd",
      "headRepository": "bemasc/draft-ietf-tls-esni",
      "headRefName": "bemasc-padded-length",
      "headRefOid": "7d453b23db56f59e9a72895f953ca789a8b00060",
      "closedAt": "2019-06-27T18:09:36Z",
      "mergedAt": "2019-06-27T18:09:36Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "dfad9d1f770133375535808f12ccc6376faabeb7"
      },
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I am not a fan of this change. I don't like encoding this kind of restrictive choice in the protocol.",
          "createdAt": "2019-06-19T19:01:16Z",
          "updatedAt": "2019-06-19T19:01:16Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK, I've removed the protocol change and made the restriction purely advisory.",
          "createdAt": "2019-06-19T19:15:01Z",
          "updatedAt": "2019-06-19T19:15:01Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0MjUxNTcx",
          "commit": {
            "abbreviatedOid": "7d453b2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "The recommended text LGTM. @kazuho @ekr @grittygrease please have a look.",
          "createdAt": "2019-06-25T20:29:55Z",
          "updatedAt": "2019-06-25T20:29:55Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU0MzIwNjgw",
          "commit": {
            "abbreviatedOid": "7d453b2"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM. Thank you for the text!",
          "createdAt": "2019-06-25T23:33:29Z",
          "updatedAt": "2019-06-25T23:33:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 163,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkzOTY0NzAy",
      "title": "Remove checksum in favor of record_digest and retry mechanism.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/163",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The checksum seems to add little value with the retry mechanism and record_digest. I think we should remove it. See #64 for some context.",
      "createdAt": "2019-07-03T00:56:28Z",
      "updatedAt": "2021-04-19T15:51:37Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "dfad9d1f770133375535808f12ccc6376faabeb7",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/remove-checksum",
      "headRefOid": "f087cd10d2586ebf61341f32aa80c474ad1ea89b",
      "closedAt": "2019-07-03T01:20:19Z",
      "mergedAt": "2019-07-03T01:20:19Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "a25f407349622080025d737536b09ba421cd6bbb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3MjIwNjYz",
          "commit": {
            "abbreviatedOid": "f087cd1"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I agree that we can now and should make this simplification. The PR looks good to me.",
          "createdAt": "2019-07-03T01:19:48Z",
          "updatedAt": "2019-07-03T01:19:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 164,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkzOTY1NjE2",
      "title": "Add reference to RFC8446 for TLS notation.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/164",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #160.",
      "createdAt": "2019-07-03T01:02:37Z",
      "updatedAt": "2021-04-19T15:51:38Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "dfad9d1f770133375535808f12ccc6376faabeb7",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/presentation-language",
      "headRefOid": "fad362f9809d24b96ed029e36a60f616792135da",
      "closedAt": "2019-07-03T01:09:00Z",
      "mergedAt": "2019-07-03T01:08:59Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "5f41edfaa689fe899148bb640a3886ce7c7e3fef"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 165,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkzOTY3NDA5",
      "title": "SNI extensibility failed. See [1].",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/165",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "[1] https://mailarchive.ietf.org/arch/msg/tls/1t79gzNItZd71DwwoaqcQQ_4Yxc\r\n\r\nFixes #68.",
      "createdAt": "2019-07-03T01:15:09Z",
      "updatedAt": "2021-04-19T15:51:38Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "5f41edfaa689fe899148bb640a3886ce7c7e3fef",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/hostnames-only",
      "headRefOid": "6a37e61f86521654a9afe015347e9a8d9bd4a8b9",
      "closedAt": "2019-07-03T20:30:29Z",
      "mergedAt": "2019-07-03T20:30:29Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "4ec4cb4ee196a4cec35fdce9640bf86cc559bc2a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3MjIxNjYy",
          "commit": {
            "abbreviatedOid": "6a37e61"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-03T01:25:16Z",
          "updatedAt": "2019-07-03T01:25:20Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I don't know if this is the best place to signal this, but I approve anyway.",
              "createdAt": "2019-07-03T01:25:17Z",
              "updatedAt": "2019-07-03T01:25:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3MjIyMjcy",
          "commit": {
            "abbreviatedOid": "6a37e61"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T01:28:17Z",
          "updatedAt": "2019-07-03T01:28:17Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I figured it's best to be honest and up front. :-)",
              "createdAt": "2019-07-03T01:28:17Z",
              "updatedAt": "2019-07-03T01:28:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3MjI5MDUx",
          "commit": {
            "abbreviatedOid": "6a37e61"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-03T02:02:50Z",
          "updatedAt": "2019-07-03T02:02:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 166,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkzOTkxMjE1",
      "title": "Add note about optional record_digest and trial decryption alternative.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/166",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #138.",
      "createdAt": "2019-07-03T03:50:04Z",
      "updatedAt": "2021-04-19T15:51:41Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "342840b5430948ffe709f5d665d63859edee2f67",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/optional-digest",
      "headRefOid": "4163aff4ffdcf9f5cc7b61588128be0102d25714",
      "closedAt": "2019-07-08T17:25:21Z",
      "mergedAt": "2019-07-08T17:25:21Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "b33c43a8b751643962e3d12c441f4baa0d7c1776"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@huitema can you please take a look?",
          "createdAt": "2019-07-03T03:50:17Z",
          "updatedAt": "2019-07-03T03:50:17Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, adding a trial decryption is a good thing. Two suggestions:\r\n\r\n1) in security section describe privacy attack by tracking the crypto ID.\r\n\r\n2) also describe the attack by forcing trial decryption.\r\n\r\nMaybe add an option to publish ESNI record with NULL checksum as a way to signal acceptance of trial decryption ?\r\n\r\n",
          "createdAt": "2019-07-03T06:18:53Z",
          "updatedAt": "2019-07-03T06:18:53Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> 1. in security section describe privacy attack by tracking the crypto ID.\r\n\r\nI plan to address this in a PR for #146.\r\n\r\n> 2. also describe the attack by forcing trial decryption.\r\n\r\nGood suggestion! I'll add that here.\r\n",
          "createdAt": "2019-07-03T13:51:10Z",
          "updatedAt": "2019-07-03T13:51:10Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@huitema please let me know if the latest text works for you!",
          "createdAt": "2019-07-03T13:57:00Z",
          "updatedAt": "2019-07-03T13:57:00Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho @ekr can you please take a look?",
          "createdAt": "2019-07-04T14:18:42Z",
          "updatedAt": "2019-07-04T14:18:42Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I think you should say that it has to be somehow externally configured.\n\nOn Mon, Jul 8, 2019 at 9:27 AM Christopher Wood <notifications@github.com>\nwrote:\n\n> *@chris-wood* commented on this pull request.\n> ------------------------------\n>\n> In draft-ietf-tls-esni.md\n> <https://github.com/tlswg/draft-ietf-tls-esni/pull/166#discussion_r301187179>\n> :\n>\n> > @@ -743,10 +750,14 @@ for servers to proceed with the connection and rely on the client to abort if\n>  ESNI was required. In particular, the unrecognized value alone does not\n>  indicate a misconfigured ESNI advertisement ({{misconfiguration}}). Instead,\n>  servers can measure occurrences of the \"esni_required\" alert to detect this\n> -case.\n> +case. An empty ClientEncryptedSNI.record_digest value MAY be used in environments\n> +wherein trial decryption is a viable approach for matching ClientEncryptedSNI\n> +contents to a known ESNIKeys. (Some uses of ESNI, such as local discovery mode,\n>\n> It'd be application or deployment-specific. In DNS-SD, for example, they'd\n> likely configure the stack to omit the record digest.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/pull/166?email_source=notifications&email_token=AAIPLINEK7B5LDKCKVQFIXLP6NTHJA5CNFSM4H5BUB4KYY3PNVWWK3TUL52HS4DFWFIHK3DMKJSXC5LFON2FEZLWNFSXPKTDN5WW2ZLOORPWSZGOB5YFAVQ#discussion_r301187179>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAIPLIMP7MKI63IRGSLCW3LP6NTHJANCNFSM4H5BUB4A>\n> .\n>\n",
          "createdAt": "2019-07-08T16:28:43Z",
          "updatedAt": "2019-07-08T16:28:43Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think you should say that it has to be somehow externally configured.\r\n\r\nGood suggestion! Will fix.",
          "createdAt": "2019-07-08T16:37:29Z",
          "updatedAt": "2019-07-08T16:37:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NTQ5NjEw",
          "commit": {
            "abbreviatedOid": "87a98f0"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T14:59:36Z",
          "updatedAt": "2019-07-03T14:59:37Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "To clarify, is the intent here is that servers outside those environments are not required to implement trial decryption?\r\n\r\nThe text reads a little unclear to me. The paragraph above just says an empty one \"MAY be used in [some environments]\", but that could mean by either the client or the server. This paragraph also could read as if the server needs to check the trial decryption, otherwise it doesn't know whether to follow these steps.\r\n\r\n(Trial decryption would more fully solve the issue #154 is trying to address, but I worry about the performance cost of asymmetric trial decryption if you rotate keys decently often. Then again, the robustness fixes do mean it's okay to drop older keys sooner if only used by a tiny fraction of clients...)",
              "createdAt": "2019-07-03T14:59:36Z",
              "updatedAt": "2019-07-08T17:24:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NTU4NDEw",
          "commit": {
            "abbreviatedOid": "87a98f0"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T15:12:29Z",
          "updatedAt": "2019-07-03T15:12:29Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "The trial decryption should be opt-in. The typical use case is in local discovery, with DTLS or QUIC. Broadcast or multicast the first packet, and then all servers who are ready to be discovered do trial detection. Yes, this is trading off CPU for server privacy, which is only OK in some scenario. In a typical implementation, the server would have a \"discovery\" flag, which will enable trial decryption when \"waiting to be discovered\". ",
              "createdAt": "2019-07-03T15:12:29Z",
              "updatedAt": "2019-07-08T17:24:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NTgwMzQ4",
          "commit": {
            "abbreviatedOid": "87a98f0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T15:45:47Z",
          "updatedAt": "2019-07-03T15:45:47Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "> To clarify, is the intent here is that servers outside those environments are not required to implement trial decryption?\r\n\r\nPrecisely. I see what you mean about it implying trial decryption is necessary. Perhaps: \r\n\r\n```\r\nIf the ClientEncryptedSNI.record_digest value does match a known ESNIKeys, the server...\r\n```\r\n\r\nAnd then later on...\r\n\r\n```\r\nIf ClientEncryptedSNI.record_digest is non-empty, servers SHOULD compare it against cryptographic hashes of known ESNIKeys to find a match. If ClientEncryptedSNI.record_digest is empty, servers MAY use trial decryption to match to a known ESNIKeys.\r\n```\r\n",
              "createdAt": "2019-07-03T15:45:47Z",
              "updatedAt": "2019-07-08T17:24:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NTg0NDAz",
          "commit": {
            "abbreviatedOid": "249505b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T15:52:12Z",
          "updatedAt": "2019-07-03T15:52:13Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "@davidben @huitema: I made an attempt at clarifying the text. Suggestions for improvements are welcome!",
              "createdAt": "2019-07-03T15:52:13Z",
              "updatedAt": "2019-07-08T17:24:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NjAwODcz",
          "commit": {
            "abbreviatedOid": "249505b"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T16:19:34Z",
          "updatedAt": "2019-07-03T16:20:22Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "Looking at this, I wonder whether there are other mitigations than \"rate limiting\". Take for example the case of a server that has published only one key: trial decryption then is no more expensive that decryption directed by a specific checksum, which the adversary can learn from the DNS record. So an obvious mitigation in case of stress is to only trial one of the published keys, possibly the latest, or a randomly chosen one.\r\n\r\nMaybe we should point out the directed DOS attack -- for example, an adversary could bomb a forwarding server with repeated connection request. But then, that's not much more potent than repeated non-ESNI connection requests.",
              "createdAt": "2019-07-03T16:19:34Z",
              "updatedAt": "2019-07-08T17:24:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NjExNDU0",
          "commit": {
            "abbreviatedOid": "249505b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T16:39:13Z",
          "updatedAt": "2019-07-03T16:39:13Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "> I wonder whether there are other mitigations than \"rate limiting\".\r\n\r\nThere probably are, which is why I list this as only one example :-) Would you prefer we just drop this sentence entirely?",
              "createdAt": "2019-07-03T16:39:13Z",
              "updatedAt": "2019-07-08T17:24:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDExNzE2",
          "commit": {
            "abbreviatedOid": "cc89246"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T16:14:07Z",
          "updatedAt": "2019-07-08T16:16:51Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "This \"otherwise\" seems to forbid random record_digests (as opposed to empty) or to fall back to trial decryption.. Is that intended?",
              "createdAt": "2019-07-08T16:14:07Z",
              "updatedAt": "2019-07-08T17:24:59Z"
            },
            {
              "originalPosition": 29,
              "body": "How would you know that this is possible.",
              "createdAt": "2019-07-08T16:14:57Z",
              "updatedAt": "2019-07-08T17:24:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDE4NTAz",
          "commit": {
            "abbreviatedOid": "cc89246"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T16:26:51Z",
          "updatedAt": "2019-07-08T16:26:51Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Hmm, good point. It's not intended. I'll remove \"Otherwise.\"",
              "createdAt": "2019-07-08T16:26:51Z",
              "updatedAt": "2019-07-08T17:24:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDE4ODM4",
          "commit": {
            "abbreviatedOid": "cc89246"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T16:27:30Z",
          "updatedAt": "2019-07-08T16:27:31Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "It'd be application or deployment-specific. In DNS-SD, for example, they'd likely configure the stack to omit the record digest. ",
              "createdAt": "2019-07-08T16:27:31Z",
              "updatedAt": "2019-07-08T17:24:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDQ2MzQw",
          "commit": {
            "abbreviatedOid": "bca2bb3"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-08T17:20:35Z",
          "updatedAt": "2019-07-08T17:20:43Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "I would write this as:\r\n\"Unless specified by the application using DTLS or externally configured on both sides, implementations MUST use the first method.\"",
              "createdAt": "2019-07-08T17:20:35Z",
              "updatedAt": "2019-07-08T17:24:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDQ4Nzky",
          "commit": {
            "abbreviatedOid": "4163aff"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T17:25:14Z",
          "updatedAt": "2019-07-08T17:25:14Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "That's much better -- thanks!",
              "createdAt": "2019-07-08T17:25:14Z",
              "updatedAt": "2019-07-08T17:25:14Z"
            }
          ]
        }
      ]
    },
    {
      "number": 167,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkzOTkzNDAx",
      "title": "Add note about cleartext OCSP.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/167",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #156.",
      "createdAt": "2019-07-03T04:05:10Z",
      "updatedAt": "2021-04-19T15:51:40Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "22e62139a983958708e4fb6f3cf0d5043b54375c",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/ocsp",
      "headRefOid": "f09381dd10831296a8f7a155eb0dc11d912664b0",
      "closedAt": "2019-07-04T01:12:54Z",
      "mergedAt": "2019-07-04T01:12:54Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "cb1c91658944a23938b51d4cd420ddb5a33f186b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3MjUyNzkz",
          "commit": {
            "abbreviatedOid": "33af345"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-03T04:15:27Z",
          "updatedAt": "2019-07-03T04:18:52Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "The PR looks good to me.\r\n\r\nThat said, it might be to a good idea to say something like \"prohibit generating OCSP traffic, especially in cleartext\", as using an encrypted channel to the OCSP responder could still be an issue in sense that it leaks the IP address of the responder (or because use of OCSP is an act of leaking information to the OCSP responder).",
              "createdAt": "2019-07-03T04:15:28Z",
              "updatedAt": "2019-07-03T20:46:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3MjU0Mzcy",
          "commit": {
            "abbreviatedOid": "33af345"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T04:24:37Z",
          "updatedAt": "2019-07-03T04:24:40Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "OCSP or CRL.\r\n\r\nI think that this needs to be framed differently.  The point here is that OCSP (or CRL checks) can leak the name.  But the reaction I would encourage is OCSP stapling, not \"don't do OCSP\" as this would appear to advocate for.",
              "createdAt": "2019-07-03T04:24:37Z",
              "updatedAt": "2019-07-03T20:46:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3MjU1NjYw",
          "commit": {
            "abbreviatedOid": "33af345"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T04:32:07Z",
          "updatedAt": "2019-07-03T04:32:07Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "Perhaps requiring stapling with a SHOULD is fine? (It seems fine to me, at least.)",
              "createdAt": "2019-07-03T04:32:07Z",
              "updatedAt": "2019-07-03T20:46:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3MjczNDg5",
          "commit": {
            "abbreviatedOid": "544ba89"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you for the changes. LGTM.",
          "createdAt": "2019-07-03T06:00:10Z",
          "updatedAt": "2019-07-03T06:00:10Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NTkzMTIw",
          "commit": {
            "abbreviatedOid": "544ba89"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T16:05:43Z",
          "updatedAt": "2019-07-03T16:05:44Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "For a security considerations, it's probably better to spell this out more generically, because there are other ways in the verification stack to leak information. The most obvious omission here is AIA fetching, but it also relates to other proposals, such as Gossip or SCT verification proposals related to Certificate Transparency, or bespoke vendor solutions such as custom revocation information sources or on-the-fly downloading of CA information.\r\n\r\n```\r\nESNI requires encrypted DNS to be an effective privacy protection mechanism.\r\nHowever, verifying the server's identity from the Certificate message, particularly\r\nwhen using the X509 CertificateType, may result in additional network traffic\r\nthat may reveal the server identity. Examples of this traffic may include requests\r\nfor revocation information, such as OCSP or CRL traffic, or requests for repository\r\ninformation, such as authorityInformationAccess. It may also include\r\nimplementation-specific traffic for additional information sources as part of\r\nverification.\r\n\r\nImplementations SHOULD avoid leaking information that may identify the\r\nserver. Even when sent over an encrypted transport, such requests may result\r\nin indirect exposure of the server's identity, such as indicating a specific CA\r\nor service being used. To mitigate this risk, servers SHOULD deliver such\r\ninformation in-band when possible, such as through the use of OCSP stapling,\r\nand clients SHOULD take steps to minimize or protect such requests during\r\ncertificate validation.\r\n```",
              "createdAt": "2019-07-03T16:05:44Z",
              "updatedAt": "2019-07-03T20:46:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzIxMjIw",
          "commit": {
            "abbreviatedOid": "544ba89"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T20:32:29Z",
          "updatedAt": "2019-07-03T20:32:30Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "Generalizing this is a great idea, and your suggested text looks good. I'll use it. ",
              "createdAt": "2019-07-03T20:32:30Z",
              "updatedAt": "2019-07-03T20:46:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzI3MDI3",
          "commit": {
            "abbreviatedOid": "f09381d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T20:46:18Z",
          "updatedAt": "2019-07-03T20:46:19Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "@sleevi -- updated. Thanks!",
              "createdAt": "2019-07-03T20:46:19Z",
              "updatedAt": "2019-07-03T20:46:19Z"
            }
          ]
        }
      ]
    },
    {
      "number": 168,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk0MzI0MzMy",
      "title": "Clarify server HRR behavior, and add label-based workaround for nonce-reuse",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/168",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Since the client's ESNI key share doesn't change across CHs in response to a HRR, the same AEAD IV would be used to encrypt/decrypt two different messages. This is an attempt to fix that, while also specifying the server-side HRR behavior. (Basically, check that the ESNI contents have not changed.)",
      "createdAt": "2019-07-03T20:47:58Z",
      "updatedAt": "2021-04-19T15:52:01Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "4ec4cb4ee196a4cec35fdce9640bf86cc559bc2a",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/hrr",
      "headRefOid": "ccb5b563caea6f84aa4c27c71bacb13836d7a8b0",
      "closedAt": "2019-07-08T21:55:51Z",
      "mergedAt": "2019-07-08T21:55:51Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "393aa3301cda28b0d27e486ad595434d4b39a946"
      },
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Nice catch, Would it make more sense to instead use the KeyShare as a salt in the HKDF?",
          "createdAt": "2019-07-04T16:12:39Z",
          "updatedAt": "2019-07-04T16:12:39Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Or you could include the handshake transcript up to, but not including, the ClientHello.  That is the empty string before HRR< but something else after.",
          "createdAt": "2019-07-08T00:24:10Z",
          "updatedAt": "2019-07-08T00:24:10Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> Nice catch, Would it make more sense to instead use the KeyShare as a salt in the HKDF?\r\n\r\nThat is a little iffy with cookie-only HelloRetryRequests. Those don't change the ClientHello key shares list, so the client would derive the same key + nonce pair. The client would also use the same plaintext so it's fine, but it seems an unnecessarily fragility.",
          "createdAt": "2019-07-08T16:08:01Z",
          "updatedAt": "2019-07-08T16:08:01Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed. I think I prefer the \"new DH\" version.",
          "createdAt": "2019-07-08T16:09:58Z",
          "updatedAt": "2019-07-08T16:09:58Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3ODI4NzEx",
          "commit": {
            "abbreviatedOid": "21c2dbe"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-04T05:03:18Z",
          "updatedAt": "2019-07-04T05:03:18Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": "I agree that servers MUST verify the value of the ESNI extension, but the fields being required to be validated seems to differ from the the fields that are required to be consistent. Is there a reason for the two to be different?\r\n\r\nFWIW, \"Handling the server response\" section states as follows:\r\n> If the server sends a HelloRetryRequest in response to the ClientHello and the client can send a second updated ClientHello per the rules in {{RFC8446}}, the \"encrypted_server_name\" extension values which do not depend on the (possibly updated) KeyShareClientHello, i.e,, ClientEncryptedSNI.suite, ClientEncryptedSNI.key_share, and ClientEncryptedSNI.record_digest, MUST NOT change across ClientHello messages. Moreover, ClientESNIInner.nonce and ClientESNIInner.realSNI MUST not change across ClientHello messages. Informally, the values of all unencrypted extension information, as well as the inner extension plaintext, must be consistent between the first and second ClientHello messages.",
              "createdAt": "2019-07-04T05:03:18Z",
              "updatedAt": "2019-07-08T20:58:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4MDY5MTcy",
          "commit": {
            "abbreviatedOid": "7ae2f15"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-04T14:17:36Z",
          "updatedAt": "2019-07-04T14:17:36Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": "No reason -- just an oversight on my part. It should be fixed now!",
              "createdAt": "2019-07-04T14:17:36Z",
              "updatedAt": "2019-07-08T20:58:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4MDcxMzQx",
          "commit": {
            "abbreviatedOid": "7ae2f15"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you for the changes! LGTM.",
          "createdAt": "2019-07-04T14:22:07Z",
          "updatedAt": "2019-07-04T14:22:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 169,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk0NzI5NTA3",
      "title": "Add note about SNI-only encryption key design.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/169",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #41.",
      "createdAt": "2019-07-05T04:24:05Z",
      "updatedAt": "2021-04-19T15:51:40Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "cb1c91658944a23938b51d4cd420ddb5a33f186b",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/alpn-note",
      "headRefOid": "0e51ecd9e9634fafd6d16127f0a889addc8e6af5",
      "closedAt": "2019-07-08T13:45:25Z",
      "mergedAt": "2019-07-08T13:45:25Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "342840b5430948ffe709f5d665d63859edee2f67"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 170,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk0NzMxMDE2",
      "title": "Drop fixed key_share requirement to avoid nonce reuse and better align with HPKE",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/170",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is an alternative to #168, wherein we use fresh DH keys each time and avoid changing the key/iv derivation labels across CH messages.",
      "createdAt": "2019-07-05T04:33:31Z",
      "updatedAt": "2021-04-19T15:52:01Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "cb1c91658944a23938b51d4cd420ddb5a33f186b",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/hrr-fresh-esni-key",
      "headRefOid": "8cf067d5ab8bd7d5621e50aa6991c6c6e4a94552",
      "closedAt": "2019-10-11T17:43:30Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Ping @ekr @kazuho ",
          "createdAt": "2019-07-06T22:02:48Z",
          "updatedAt": "2019-07-06T22:02:48Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "IIUC, this is a trade-off issue. Therefore I do not have a strong preference, though my weak prerefence goes to keeping the design as-is. The reasons are as follows.\r\n\r\nThe benefit of the proposed change is that it frees client from buffering the content of the ESNI extension (after encryption), when using a building block that does not support reusing the same public key pair. Though, we might argue that even with this change, clients might still want to buffer the extension for possible retransmission rather than doing another public key operation in case of receiving a HRR.\r\n\r\nThe downside of the proposed change is that it might require the server to do another public key operation when verifying the ESNI extension found in ClientHello being sent in response to HelloRetryRequest. Current design, by requiring the keys to be identical, allows a server to validate the indifference of the ESNI extension without actually deciphering the payload.\r\n\r\nOne of the role of HRR is to mitigate attacks. When under attack, I believe that servers would be reluctant to do an additional public key operation. Therefore, to me it seems that the proposed change would incentivize the server to skip the verification of the ESNI extension sent in response to HRR.\r\n\r\nComparing the benefit and the downside, my weak preference goes to retaining the design as-is, because as I stated, I think that clients would be (mostly) fine with the design, and under the assumption that it is beneficial to encourage servers to validate the ESNI extension sent in response to HRR.",
          "createdAt": "2019-07-07T06:04:36Z",
          "updatedAt": "2019-07-07T06:18:50Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I share @kazuho's concerns.  The use of a different label after HRR is annoying, but not that difficult to manage.  You could also include the session transcript up to (but not including) the ClientHello, but you need something.\r\n\r\nFlipping the shares is a costly exercise.  You might have to do it anyway, but if you don't, then you can save some computation.  I can definitely see the value in stuffing the decrypted SNI into the cookie so that you don't have to redo the ESNI piece.",
          "createdAt": "2019-07-07T23:35:23Z",
          "updatedAt": "2019-07-07T23:35:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The benefit of this approach is primarily simplicity for clients and HPKE alignment. (HPKE generates a fresh key each time, so we couldn\u2019t adopt it as is unless that draft changed.) I agree that the cost of yet another DH operation is not great, though I\u2019m not yet convinced it\u2019s enough to disqualify this change.",
          "createdAt": "2019-07-07T23:46:03Z",
          "updatedAt": "2019-07-07T23:46:03Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Hmm... I'm not sure I follow all of this.\r\n\r\nYou can't store the decrypted SNI in the cookie because you need to re-verify the AEAD which is tied to the new key share. You can of course stuff Z in the cookie, though, so I'm not sure how much difference this makes. With that said, in the common case (one server) you are going to have a uniform config so you don't need to decrypt ESNI at all in order to send HRR, no?\r\n\r\nAs @chris-wood says  this is tied to using HPKE -- if we decide to do that, we are going to either have to adopt a \"fresh DH\" version or extend the HPKE API to have some sort of key reuse + salt.\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2019-07-07T23:46:48Z",
          "updatedAt": "2019-07-07T23:47:10Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood \r\n> The benefit of this approach is primarily simplicity for clients and HPKE alignment. (HPKE generates a fresh key each time, so we couldn\u2019t adopt it as is unless that draft changed.)\r\n\r\nI think our disagreement is if current provision deters the adoption of HPKE.\r\n\r\nI'm not familiar with HPKE and I could be wrong, but it is my understanding that the current design can use a public key crypto engine that uses a fresh key for every operation.\r\n\r\nThat is because the ESNI extension sent in the 2nd ClientHello is a \"retransmission.\" Server's public key pair does not change, and ClientHello.random does not change. Therefore, when sending the first ClientHello, a client can just keep the encrypted payload of ESNI extension. Then, when it receives a HelloRetryRequest, it would retransmit the buffered payload of the ESNI extension.",
          "createdAt": "2019-07-07T23:57:56Z",
          "updatedAt": "2019-07-07T23:57:56Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho: I don't believe that this will work because the client's KeyShare will likely change in HRR, and it is AAD to the ESNI Extension, thus the ciphertext will change. Or am I confused?",
          "createdAt": "2019-07-08T00:02:59Z",
          "updatedAt": "2019-07-08T00:02:59Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@ekr Ah I missed that (and picotls has a bug!). Thank you for pointing that out.\r\n\r\nThat said, I think that the @martinthomson's argument (which was also the rest of my argument) still holds. If we want servers to verify the ESNI extension sent in the 2nd ClientHello, it is benefical to require the clients to use the same public key.\r\n\r\nBecause, then, a server can retain the key and iv (either in it's state or in Cookie), and just do the AEAD operation to validate the ESNI extension found in the 2nd ClientHello. If we think that such check can be avoided (even though we would not encourage that), I think I'd be fine with allowing the client to change the public key.",
          "createdAt": "2019-07-08T00:09:26Z",
          "updatedAt": "2019-07-08T00:09:26Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho nitpicking: you will need to retain Z, I think.\r\n\r\nWith that said, how do you think we would handle the transition to HPKE?",
          "createdAt": "2019-07-08T00:17:10Z",
          "updatedAt": "2019-07-08T00:17:10Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho @grittygrease how do you want to proceed here?",
          "createdAt": "2019-07-08T17:29:57Z",
          "updatedAt": "2019-07-08T17:29:57Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "(This comment ended up long, so I'm splitting it into sections.)\r\n\r\n**Why check the second ClientHello**\r\n\r\n> If we think that such check can be avoided (even though we would not encourage that), I think I'd be fine with allowing the client to change the public key.\r\n\r\nIf the server does not check the second ClientHello, then cut-and-paste attacks are possible against client/server pairs which hit HelloRetryRequest because we lose the binding between ESNI and the key shares that were actually used. (It really would be cleaner if we just stuffed something into the key schedule, but then the client needs to trial-decrypt or we need a cleartext \"yes, I used ESNI\" signal.)\r\n\r\nFor completeness, deployments which allow different services to have different version, cipher, or group preferences need to process ESNI on the first ClientHello because resolving HRR requires those preferences. Of course, services with different preferences will partition the anonymity sets a little bit, but enough deployments expect to be able to vary TLS parameters this way that I think we need to allow for this. (BoringSSL, for instance, resolves SNI on the first ClientHello.)\r\n\r\n**Split mode**\r\n\r\nOn that note, split mode and HRR are a little messy. Possibilities I can see:\r\n\r\n1. Dispatch happens at second ClientHello. Frontend and backend must agree on HRR-sensitive parameters, and backend gets a handshake transcript from the frontend.\r\n2. Dispatch happens at first ClientHello, but frontend and backend agree on enough of TLS parameters that frontend can sniff HelloRetryRequest + second ClientHello (technically a [protocol invariant](https://tools.ietf.org/html/rfc8446#section-9.3) violation) to check the ESNI.\r\n3. Backend and frontend both have ESNI keys. This contradicts #169.\r\n\r\n**Near-attack**\r\n\r\nFinally, I think there's one more issue here with changing the key share which, while not fatal, is rather a headache. Suppose we went with this PR. Here is a near-attack:\r\n\r\n1. Attacker observes an ESNI-ful HRR-ful connection. Let CH1 and CH2 be the first and second ClientHellos.\r\n2. Attacker wants to determine if CH1/CH2's ESNI contained hostname H. (It can repeat this process with different guesses.)\r\n3. Attacker makes a connection to the server. It replays CH1 and gets an HRR.\r\n4. Attacker sends its own second ClientHello with its own key shares and an ESNI record containing H.\r\n5. If H matched CH1's ESNI, the server will accept the connection and continue. If it mismatched, the server will fail with an alert.\r\n\r\nThis is only a near-attack because ClientESNIInner contains a nonce the attacker cannot guess, so even if it matched the hostname, it cannot match the nonce. But this means the server must perform the comparison in constant-time (attacker can repeat steps 3-5 all it wants) and the nonce is even more load-bearing in a subtle way.\r\n\r\nExample of subtlety: In both \"server must check CH2\" PRs, it is easy for the server to ignore it and no one notices. One could imagine saying the ESNI nonce must change in CH2, so the server *at least* doesn't ignore it. But that would turn this near-attack into an actual attack. Whereas I believe the same-key version avoids all of this.\r\n\r\n**Changing the key schedule**\r\n\r\nIt seems we're in this mess because we've bound ESNI to the handshake in a roundabout way rather than injecting the key into the key schedule. I believe this originally was to aid split mode, but we've since added this nonce anyway, so having frontend pass the key schedule addition into the backend is plausible. Perhaps this is worth reconsidering? Some thoughts:\r\n\r\nFirst, there isn't a slot in the key schedule for this. I think that's fine though, as long as we change the label. Here's one possibility:\r\n\r\n```\r\n             0\r\n             |\r\n             v\r\n   PSK ->  HKDF-Extract = Early Secret\r\n             |\r\n             +-----> Derive-Secret(...)\r\n             |                     = binder_key\r\n             |                     = client_early_traffic_secret\r\n             |                     = early_exporter_master_secret\r\n             v\r\n       Derive-Secret(., \"derived\", \"\")\r\n             |\r\n             v\r\n   (EC)DHE -> HKDF-Extract\r\n             |\r\n             v\r\n       Derive-Secret(., \"esni nonce\", \"\")\r\n             |\r\n             v\r\nESNI nonce -> HKDF-Extract = Handshake Secret\r\n             |\r\n             +-----> Derive-Secret(...)\r\n             |                     = client_handshake_traffic_secret\r\n             |                     = server_handshake_traffic_secret\r\n             v\r\n            ...\r\n ```\r\n(Arguably all the \"derived\" labels should have had names.)\r\n\r\nThe second issue is how to signal it on the client. I see two options:\r\n\r\n1. Cleartext signal in ServerHello. This violates \"do not stick out\" and makes the GREASE extensions totally useless.\r\n2. The client computes both server_handshake_traffic_secret values and trial-decrypts to figure out which one to use. This is trial decryption and non-destructive trial-decryption at that, so it's rather a headache. (On the plus side, it only needs to be done on the first handshake record.)\r\n\r\nNeither of these is very satisfactory but, then again, nor are our other two options. :-/\r\n\r\n**Conclusion**\r\n\r\nEverything is a mess.",
          "createdAt": "2019-07-08T20:38:58Z",
          "updatedAt": "2019-07-08T20:38:58Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood \r\n> how do you want to proceed here?\r\n\r\nAs we do not have time, I think we should merge #168 (it does not change the client behavior, and I think we agree that requiring the server to validate the ESNI extension found in 2nd CH is a good idea), while keeping this PR open for further discussion.",
          "createdAt": "2019-07-08T21:53:20Z",
          "updatedAt": "2019-07-08T21:53:20Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 172,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk5NTc4MDQ0",
      "title": "Fix typo in text for ClientEncryptedSNI.key_share",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/172",
      "state": "MERGED",
      "author": "dmcardle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-07-20T17:11:49Z",
      "updatedAt": "2019-07-23T19:43:24Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "393aa3301cda28b0d27e486ad595434d4b39a946",
      "headRepository": "dmcardle/draft-ietf-tls-esni",
      "headRefName": "master",
      "headRefOid": "112f9db180f50c7f95ef6af40f1f95aecdf692cb",
      "closedAt": "2019-07-23T19:43:24Z",
      "mergedAt": "2019-07-23T19:43:24Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ddf3111a618bcda8791ced99aa7c87a90f165165"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you!",
          "createdAt": "2019-07-23T19:43:18Z",
          "updatedAt": "2019-07-23T19:43:18Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY1NjM0Mzcw",
          "commit": {
            "abbreviatedOid": "112f9db"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-23T19:43:11Z",
          "updatedAt": "2019-07-23T19:43:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 174,
      "id": "MDExOlB1bGxSZXF1ZXN0MzAwMDg0NTI2",
      "title": "Remove `sni` reference from padded server name list",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/174",
      "state": "MERGED",
      "author": "mrsylerpowers",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "#173 ",
      "createdAt": "2019-07-23T00:18:57Z",
      "updatedAt": "2019-07-23T19:42:54Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "393aa3301cda28b0d27e486ad595434d4b39a946",
      "headRepository": "mrsylerpowers/draft-ietf-tls-esni",
      "headRefName": "sni-reference-remove",
      "headRefOid": "971f2318b74f06164fb3bd11ec84815d474896c2",
      "closedAt": "2019-07-23T19:42:54Z",
      "mergedAt": "2019-07-23T19:42:54Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "aed9ec47295529ab9188a1deb6230175fcba912d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY1NjMzNjAy",
          "commit": {
            "abbreviatedOid": "971f231"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-23T19:41:46Z",
          "updatedAt": "2019-07-23T19:41:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 175,
      "id": "MDExOlB1bGxSZXF1ZXN0MzAwMTA3MTU3",
      "title": "refer GREASE extension in resolution algorithm & formatting fix",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/175",
      "state": "CLOSED",
      "author": "gsamat",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I referred GREASE extensions in 4.2.2 Resolution algorithm to make it in line with 5.1.4. GREASE extensions\r\n\r\nalso fixed 4.2.2. Resolution algorithm formatting issue: line width > 72 resulted in ugly PDF",
      "createdAt": "2019-07-23T02:45:29Z",
      "updatedAt": "2019-11-04T20:36:07Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "393aa3301cda28b0d27e486ad595434d4b39a946",
      "headRepository": "gsamat/draft-ietf-tls-esni",
      "headRefName": "patch-4",
      "headRefOid": "6c2c02346626ea88ee36f84018ac4e603b9f6202",
      "closedAt": "2019-11-04T20:36:06Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This PR no longer applies since this section of the document was removed.",
          "createdAt": "2019-11-04T20:36:06Z",
          "updatedAt": "2019-11-04T20:36:06Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 176,
      "id": "MDExOlB1bGxSZXF1ZXN0MzAwNzQzNTc0",
      "title": "Clarify that ESNIContents is not transmitted",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/176",
      "state": "MERGED",
      "author": "dmcardle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I got a little tripped up on this point! Maybe you have a better way to explain it.",
      "createdAt": "2019-07-24T14:11:10Z",
      "updatedAt": "2019-10-25T17:57:20Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "ddf3111a618bcda8791ced99aa7c87a90f165165",
      "headRepository": "dmcardle/draft-ietf-tls-esni",
      "headRefName": "dmcardlebranch",
      "headRefOid": "483ca96533d05ce9c05f1a7ada5c91adde8946ed",
      "closedAt": "2019-10-25T17:57:20Z",
      "mergedAt": "2019-10-25T17:57:20Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "6ade68ed92984b283ddf1b0834e452431688c903"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @dmcardle!",
          "createdAt": "2019-10-25T17:57:15Z",
          "updatedAt": "2019-10-25T17:57:15Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3MzYyNzQ5",
          "commit": {
            "abbreviatedOid": "483ca96"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-25T17:57:07Z",
          "updatedAt": "2019-10-25T17:57:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 181,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA1ODA0MTEy",
      "title": "editorial nits",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/181",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Credits to @huitema.",
      "createdAt": "2019-08-09T01:34:27Z",
      "updatedAt": "2019-08-09T17:40:40Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "ddf3111a618bcda8791ced99aa7c87a90f165165",
      "headRepository": "kazuho/draft-rescorla-tls-esni",
      "headRefName": "kazuho/editorial",
      "headRefOid": "e2eb0d8b0e1d8febafe4b84d9f7f9ffd4cca5406",
      "closedAt": "2019-08-09T17:40:40Z",
      "mergedAt": "2019-08-09T17:40:39Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "9e54d3572c171a65e522a3a045907282a046843e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjcyOTE1Njk5",
          "commit": {
            "abbreviatedOid": "a1da8a7"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-09T02:02:13Z",
          "updatedAt": "2019-08-09T02:02:17Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\nindication would divulge the true server name.\r\n```",
              "createdAt": "2019-08-09T02:02:14Z",
              "updatedAt": "2019-08-09T03:33:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjczMjczNjUz",
          "commit": {
            "abbreviatedOid": "e2eb0d8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-09T17:40:32Z",
          "updatedAt": "2019-08-09T17:40:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 184,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI2NzI5MDAx",
      "title": "Add description about \"cipher suites\" via an ESNIKeys extension",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/184",
      "state": "MERGED",
      "author": "pengin7384",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Add missing description for cipher_suites and add colon symbol to padded_length",
      "createdAt": "2019-10-10T13:12:22Z",
      "updatedAt": "2020-02-23T13:51:59Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9e54d3572c171a65e522a3a045907282a046843e",
      "headRepository": "pengin7384/draft-ietf-tls-esni",
      "headRefName": "encrypted-sni-record-patch",
      "headRefOid": "8a9cacebaf6910688743d794ef8469e3679c08b6",
      "closedAt": "2020-02-23T13:51:59Z",
      "mergedAt": "2020-02-23T13:51:59Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "80df23129af22ea6846b7f2dfe1efe2e371892d0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMDk2Mzcx",
          "commit": {
            "abbreviatedOid": "8a9cace"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-23T13:51:54Z",
          "updatedAt": "2020-02-23T13:51:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 185,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI4ODk3MzAw",
      "title": "Remove partial split mode",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/185",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Based on comments in Montreal, I believe that the authors\r\nno longer intend to document the partial-split configuration.",
      "createdAt": "2019-10-16T18:30:25Z",
      "updatedAt": "2019-10-25T19:01:36Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9e54d3572c171a65e522a3a045907282a046843e",
      "headRepository": "bemasc/draft-ietf-tls-esni",
      "headRefName": "bemasc-partial-split",
      "headRefOid": "8e7113d0204805c3e29cc1ef84e9fa041457ecd5",
      "closedAt": "2019-10-25T19:01:36Z",
      "mergedAt": "2019-10-25T19:01:36Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "5abba83633afe4dc15e57a976dcd93be5119447b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3MzY0MjAz",
          "commit": {
            "abbreviatedOid": "8e7113d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-10-25T17:59:47Z",
          "updatedAt": "2019-10-25T17:59:57Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Is this always true? Might the provider have access in shared mode?",
              "createdAt": "2019-10-25T17:59:47Z",
              "updatedAt": "2019-10-25T17:59:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3Mzk0ODkz",
          "commit": {
            "abbreviatedOid": "8e7113d"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-25T19:00:03Z",
          "updatedAt": "2019-10-25T19:00:04Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "This paragraph is only about split mode (and this sentence is unchanged).",
              "createdAt": "2019-10-25T19:00:03Z",
              "updatedAt": "2019-10-25T19:00:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3Mzk1NTc4",
          "commit": {
            "abbreviatedOid": "8e7113d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-25T19:01:25Z",
          "updatedAt": "2019-10-25T19:01:26Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Oh, hah, yes. That\u2019s what I get for skimming. ",
              "createdAt": "2019-10-25T19:01:25Z",
              "updatedAt": "2019-10-25T19:01:26Z"
            }
          ]
        }
      ]
    },
    {
      "number": 186,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMxNjI3MjA3",
      "title": "Proposal: Use a hash instead of padding",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/186",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is (almost) entirely compatible with wildcard names\r\nand avoids the need for padding.",
      "createdAt": "2019-10-23T16:05:42Z",
      "updatedAt": "2019-10-23T20:22:36Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9e54d3572c171a65e522a3a045907282a046843e",
      "headRepository": "bemasc/draft-ietf-tls-esni",
      "headRefName": "bemasc-hash",
      "headRefOid": "33f2537c2c47ed2c2110ff840fc6f82fa2d3c048",
      "closedAt": "2019-10-23T20:22:35Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I do not think this change is worth the complexity. First, it does not avoid the need for padding. The server certificate needs to be padded regardless, so the server already needs to make decisions based on the length distributions of known hostnames.\r\n\r\nSecond, it dramatically increases the complexity of deploying ESNI. In the existing design, the actual certificate lookup on the server is relatively unchanged. The TLS library could even abstract much of the name lookup, public name fallback, etc., from the application by simply passing the name along the same interface as before and leave that portion unchanged. This design forces the server to have a new digest-based path, which extends throughout the entire configuration pipeline.\r\n\r\nThe `label_limit` notion for dealing with wildcards is also another source of stateful deployment problems with configuration mismatches. Perhaps I used to use a wildcard cert, but now I'd like to switch to individual subdomains. This transition is difficult under this PR. For more fun, the folks managing the names may be different from the folks who implemented ESNI, so the deployment concern will go unnoticed.\r\n\r\nThe wildcard cert scheme is also messy with protocols that do not have their own in-band vhosting mechanism and just use TLS. HTTP doesn't care about HTTP has a Host header, so it doesn't actually care about the SNI. (I will observe, however, that the Host header should probably trigger padding too, so we're still back to square one. :-) )",
          "createdAt": "2019-10-23T16:42:59Z",
          "updatedAt": "2019-10-23T16:42:59Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yep, deployment is more complex in this mode.  I'm going to close this to avoid creating ongoing confusion; I just wanted to remind people that there are other options beyond debates about padding length, and we shouldn't be too quick to adopt a leaky padding scheme for the sake of handshake size.",
          "createdAt": "2019-10-23T20:22:35Z",
          "updatedAt": "2019-10-23T20:22:35Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 187,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMyMjkyNDY4",
      "title": "Replace ESNIKeys with ESNIConfig, and delegate the publishing container to HTTPSVC.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/187",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "DNSOP adopted HTTPSSVC recently [1]. This is a generalized Resource Record that supports the same functionality as the custom ESNI RRType, including direct IP address specification and ENSI key delivery. This change drops the custom DNS bits from the ESNI document and delegates this to HTTPSSVC, where it probably belongs. This change also renames ESNIKeys to ESNIConfig to more accurately capture its intended purpose, i.e., as a struct for conveying ESNI keys and metadata.\r\n\r\nThis should address #180, #179, #139, and #110.\r\n\r\n[1] https://mailarchive.ietf.org/arch/msg/dnsop/9zCxhCfIhDzA3Cv3D2k4NF_nj4s",
      "createdAt": "2019-10-25T00:24:16Z",
      "updatedAt": "2019-11-02T01:01:45Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "5abba83633afe4dc15e57a976dcd93be5119447b",
      "headRepository": "chris-wood/draft-ietf-tls-esni",
      "headRefName": "caw/httpsvc",
      "headRefOid": "160dd9085c9ec730c7845fa6d74836b1739a645f",
      "closedAt": "2019-11-02T01:01:45Z",
      "mergedAt": "2019-11-02T01:01:45Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "6457893d8614fe47f3e8365957985ec848d754b0"
      },
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure that this is going to work with HTTPSSVC as currently defined. The current ESNIKeys record specifies the IP address explicitly and you are supposed to favor that. However, assuming I am reading HTTPSSVC S 6.4 correctly, ipv[46]hint are not in fact favored but are actually disfavored.\r\n\r\n  \"The \"ipv4hint\" and \"ipv6hint\" keys represent IP address hints for the\r\n   service.  If A and AAAA records for SvcDomainName are locally\r\n   available, the client SHOULD ignore these hints.  Otherwise, clients\r\n   MUST perform A and/or AAAA queries for SvcDomainName as in Section 3,\r\n   and clients SHOULD switch to an IP address in those records as soon\r\n   as possible.\"\r\n\r\nThis is counter to what we agreed upon for ESNI and resurrects the A/AAAA vs. ESNIKeys mismatch problem. \r\n\r\nUnless I am misunderstanding this, we should first fix HTTPSSVC before making this change.\r\n\r\n\r\n",
          "createdAt": "2019-10-25T16:34:42Z",
          "updatedAt": "2019-10-25T16:34:42Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the intent with HTTPSSVC is that, if you're using the HTTPSSVC record, you'd look up A/AAAA from the SvcDomainName not the origin name you queried. That way there's still a binding between A/AAAA and ESNIKeys.\r\n\r\nThis does, however, cost an extra DNS round-trip, so this plan does require the recursive resolvers follow HTTPSSVC for you like they do CNAME, otherwise it would not meet the performance requirements. DoT/DoH are an ecosystem reset, so maybe that's plausible? I think this goes back to how sacred you believe A and AAAA are and whether you believe it's rude to get IP addresses elsewhere. The HTTPSSVC record evidently has different views on this point than the ESNI record.",
          "createdAt": "2019-10-25T17:16:52Z",
          "updatedAt": "2019-10-25T17:16:52Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> This is counter to what we agreed upon for ESNI and resurrects the A/AAAA vs. ESNIKeys mismatch problem.\r\n\r\nI would choose to interpret their \"SHOULD ignore\" advice as optional to ensure the ESNIRecord functionality is maintained. @bemasc, perhaps we can clarify this in the HTTPSVC draft?",
          "createdAt": "2019-10-25T17:20:52Z",
          "updatedAt": "2019-10-25T17:20:52Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I think the intent with HTTPSSVC is that, if you're using the HTTPSSVC record, you'd look up A/AAAA from the SvcDomainName not the origin name you queried. That way there's still a binding between A/AAAA and ESNIKeys.\r\n\r\nYep, that's exactly right.\r\n\r\n> I would choose to interpret their \"SHOULD ignore\" advice as optional to ensure the ESNIRecord functionality is maintained.\r\n\r\nI'm not sure I understand you.  The purpose of \"SHOULD ignore\" is to ensure that DNS-based load balancing of A/AAAA on SvcDomainName continues to work correctly.  Whether the client uses an ipv6hint or a AAAA record for SvcDomainName, it will be contacting a server that has the corresponding ESNI private key; there's no possibility of mismatch either way.\r\n\r\n> perhaps we can clarify this in the HTTPSVC draft?\r\n\r\nI think the confusion here is that in HTTPSSVC, clients use the IP of SvcDomainName, not the IP of the origin hostname.  There's no way for a client to accidentally combine the ESNIConfig for the SvcDomainName with the IP of the origin hostname (or of a different SvcDomainName).\r\n\r\nI think the draft is pretty clear on this point (e.g. the [intro example](https://tools.ietf.org/html/draft-nygren-dnsop-svcb-httpssvc-00#section-1.1)), but the authors always think that :).  Suggestions are welcome.",
          "createdAt": "2019-10-25T17:49:56Z",
          "updatedAt": "2019-10-25T17:49:56Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Well, so as @davidben points out, this requires a second resolution, which is a performance problem.",
          "createdAt": "2019-10-25T17:53:04Z",
          "updatedAt": "2019-10-25T17:53:04Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, waiting for a second resolution is the performance problem that ipv6hint solves, by giving the client an IP address along with the ESNIConfig in the same response.",
          "createdAt": "2019-10-25T18:13:19Z",
          "updatedAt": "2019-10-25T18:13:19Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@bemasc: then I just don't see the point of doing the second resolution. It seems disruptive and doesn't add anything. Once I have connected to the server, it can Alt-Svc me itself.",
          "createdAt": "2019-10-25T18:25:43Z",
          "updatedAt": "2019-10-25T18:25:43Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I should add, I'm not quite sure how I would implement this in Firefox. Say I resolve example.com and get 1.2.3.4 for ipv4 hints. Now I am supposed to in parallel connect to the server *and* try to resolve SvcDomainName? But what then? I've already started the connection so I'm not going to abort it if I get a 5.6.7.8....",
          "createdAt": "2019-10-25T18:35:51Z",
          "updatedAt": "2019-10-25T18:35:51Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I just don't see the point of doing the second resolution. It seems disruptive and doesn't add anything.\r\n\r\nConsider a CDN customer with their own (old-fashioned, static) DNS.  The customer publishes an HTTPSSVC record whose SvcDomainName, ESNIConfig, and IP hint are the CDN's domain, ESNIConfig, and IP.  Clients connect to the IP from the hint, use this ESNIConfig, and everything works ... but the customer has broken the CDN's load balancing.  All of their traffic is going to a single  CDN IP.\r\n\r\nThe point of the second resolution is to move customer traffic onto the CDN's preferred IP.\r\n\r\n> Once I have connected to the server, it can Alt-Svc me itself.\r\n\r\nTrue, but HTTPSSVC doesn't require clients to support Alt-Svc.  (Chrome, for example, does not support this feature of Alt-Svc.)\r\n\r\n> Say I resolve example.com and get 1.2.3.4 for ipv4 hints. Now I am supposed to in parallel connect to the server and try to resolve SvcDomainName? But what then? I've already started the connection so I'm not going to abort it if I get a 5.6.7.8....\r\n\r\nThe draft says clients \"SHOULD switch to an IP address in those records as soon as possible\".  An aggressive implementation might start connecting to 5.6.7.8, and close the connection to 1.2.3.4 once it is connected.  (This is roughly what Chrome does for QUIC upgrade.)  A less aggressive implementation might just let the A record sit in the local DNS cache, so that any subsequent connections to this origin can go to the CDN's preferred IP.",
          "createdAt": "2019-10-25T18:49:33Z",
          "updatedAt": "2019-10-25T18:49:33Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, so I think that this text needs a bunch of work before I would be comfortable with it, as I do not think your \"less aggressive implementation\" would be conformant with this SHOULD",
          "createdAt": "2019-10-25T18:51:03Z",
          "updatedAt": "2019-10-25T18:51:03Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@ekr if that\u2019s the case, can you please suggest concrete changes to the text?",
          "createdAt": "2019-10-25T18:56:15Z",
          "updatedAt": "2019-10-25T18:56:15Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@bemasc is there some place I can send a PR?\n\nOn Fri, Oct 25, 2019 at 11:56 AM Christopher Wood <notifications@github.com>\nwrote:\n\n> @ekr <https://github.com/ekr> if that\u2019s the case, can you please suggest\n> concrete changes to the text?\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/pull/187?email_source=notifications&email_token=AAIPLIPSWDOAN7SHH24S3V3QQM6NBA5CNFSM4JE5AOYKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOECJIAHA#issuecomment-546471964>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAIPLINOF65ZGCXUMO47AOTQQM6NBANCNFSM4JE5AOYA>\n> .\n>\n",
          "createdAt": "2019-10-25T19:57:35Z",
          "updatedAt": "2019-10-25T19:57:35Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ekr yes, https://github.com/MikeBishop/dns-alt-svc/pulls",
          "createdAt": "2019-10-25T20:17:25Z",
          "updatedAt": "2019-10-25T20:17:25Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "https://github.com/MikeBishop/dns-alt-svc/pull/69\n\nOn Fri, Oct 25, 2019 at 1:17 PM Benjamin M. Schwartz <\nnotifications@github.com> wrote:\n\n> @ekr <https://github.com/ekr> yes,\n> https://github.com/MikeBishop/dns-alt-svc/pulls\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/pull/187?email_source=notifications&email_token=AAIPLIIH2PM4BPFJCBSGKBTQQNH5PA5CNFSM4JE5AOYKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOECJOJFY#issuecomment-546497687>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAIPLIO5B7V7QND6ZZZB5MDQQNH5PANCNFSM4JE5AOYA>\n> .\n>\n",
          "createdAt": "2019-10-25T20:44:09Z",
          "updatedAt": "2019-10-25T20:44:09Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, the new text has been merged, so I am now OK with this PR.\n\nOn Fri, Oct 25, 2019 at 1:43 PM Eric Rescorla <ekr@rtfm.com> wrote:\n\n> https://github.com/MikeBishop/dns-alt-svc/pull/69\n>\n> On Fri, Oct 25, 2019 at 1:17 PM Benjamin M. Schwartz <\n> notifications@github.com> wrote:\n>\n>> @ekr <https://github.com/ekr> yes,\n>> https://github.com/MikeBishop/dns-alt-svc/pulls\n>>\n>> \u2014\n>> You are receiving this because you were mentioned.\n>> Reply to this email directly, view it on GitHub\n>> <https://github.com/tlswg/draft-ietf-tls-esni/pull/187?email_source=notifications&email_token=AAIPLIIH2PM4BPFJCBSGKBTQQNH5PA5CNFSM4JE5AOYKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOECJOJFY#issuecomment-546497687>,\n>> or unsubscribe\n>> <https://github.com/notifications/unsubscribe-auth/AAIPLIO5B7V7QND6ZZZB5MDQQNH5PANCNFSM4JE5AOYA>\n>> .\n>>\n>\n",
          "createdAt": "2019-10-25T21:07:46Z",
          "updatedAt": "2019-10-25T21:07:46Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2OTYzODUy",
          "commit": {
            "abbreviatedOid": "2daa3df"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-25T03:14:11Z",
          "updatedAt": "2019-10-25T03:14:40Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "```suggestion\r\npublication details to {{!HTTPSSVC=I-D.nygren-dnsop-svcb-httpssvc}}, though other delivery\r\n```",
              "createdAt": "2019-10-25T03:14:11Z",
              "updatedAt": "2019-10-25T21:08:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3MzQyMjA0",
          "commit": {
            "abbreviatedOid": "d0eaef9"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-25T17:18:04Z",
          "updatedAt": "2019-10-25T17:18:19Z",
          "comments": [
            {
              "originalPosition": 239,
              "body": "Nit: s/retry_keys/retry_configs/",
              "createdAt": "2019-10-25T17:18:05Z",
              "updatedAt": "2019-10-25T21:08:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3MzQyNjg0",
          "commit": {
            "abbreviatedOid": "d0eaef9"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-25T17:19:02Z",
          "updatedAt": "2019-10-25T17:19:02Z",
          "comments": [
            {
              "originalPosition": 239,
              "body": "Benefit of the ESNIConfig rename: really `retry_keys` should have been `retry_keyses`, but now we don't have to pretend to be Gollum. :-)",
              "createdAt": "2019-10-25T17:19:02Z",
              "updatedAt": "2019-10-25T21:08:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NDI3MTk5",
          "commit": {
            "abbreviatedOid": "d0eaef9"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-25T20:09:00Z",
          "updatedAt": "2019-10-25T20:09:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 194,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2NDY4NzMz",
      "title": "Add note about inconsistent cryptographic configurations.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/194",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #178.",
      "createdAt": "2019-11-04T20:45:17Z",
      "updatedAt": "2021-04-19T15:52:02Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "6457893d8614fe47f3e8365957985ec848d754b0",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/crypto-consistency",
      "headRefOid": "fdf6d5a3e259e555922dad7064d116965fee626f",
      "closedAt": "2019-11-04T21:40:59Z",
      "mergedAt": "2019-11-04T21:40:59Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "8395959ed6e17e3b6b91aa132fbce93652ad2ef1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExMzU3OTg0",
          "commit": {
            "abbreviatedOid": "371cf44"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-04T21:06:12Z",
          "updatedAt": "2019-11-04T21:06:22Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "```suggestion\r\nthe contents of the ServerHello as this message is not encrypted.\r\n```  ",
              "createdAt": "2019-11-04T21:06:13Z",
              "updatedAt": "2019-11-04T21:07:29Z"
            }
          ]
        }
      ]
    },
    {
      "number": 195,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2NTEzNjg3",
      "title": "Clarify rules on order and repetition for ESNIConfig extensions",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/195",
      "state": "MERGED",
      "author": "dmcardle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Followup on #183.\r\n\r\nLooks like ESNIConfig is the only ESNI structure that has extensions, now that we've delegated the key delivery to HTTPSSVC.\r\n\r\nShould I avoid reflowing the text?",
      "createdAt": "2019-11-04T22:38:32Z",
      "updatedAt": "2020-02-23T13:51:20Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "8395959ed6e17e3b6b91aa132fbce93652ad2ef1",
      "headRepository": "dmcardle/draft-ietf-tls-esni",
      "headRefName": "esniconfig-httpssvc-changes",
      "headRefOid": "fdc917ff8d9fb4d6a6c25062339adc444948bb48",
      "closedAt": "2020-02-23T13:51:19Z",
      "mergedAt": "2020-02-23T13:51:19Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "9024e205e2b7f151c49882e49803f4486fa6d042"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMDk2MzAy",
          "commit": {
            "abbreviatedOid": "fdc917f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-23T13:51:01Z",
          "updatedAt": "2020-02-23T13:51:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 196,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2OTIzOTM2",
      "title": "Tunnel version",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/196",
      "state": "CLOSED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-05T18:29:17Z",
      "updatedAt": "2020-03-08T00:32:23Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "8395959ed6e17e3b6b91aa132fbce93652ad2ef1",
      "headRepository": "ekr/draft-ietf-tls-esni",
      "headRefName": "tunnel_version",
      "headRefOid": "44a7d7dc0706c30932f645abd19fecfba3ef5883",
      "closedAt": "2020-03-08T00:32:22Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I haven't looked at this in full detail yet, but one initial comment is that encrypting an entire ClientHello means doubling the size, and [post-quantum key shares](https://www.imperialviolet.org/2019/10/30/pqsivssl.html) are looking to be quite large. I believe [one of our experiments](https://www.imperialviolet.org/2018/04/11/pqconftls.html) suggested the additional cost is roughly linear to the number of bytes.\r\n\r\nWe could encrypt some sort of \"delta ClientHello\", either saying \"copy these extensions from the outside\" or something hilarious scheme where you specify a sequence of new bytes and references into your outer ClientHello... (I think the former is easier to send while the latter is easier to receive.)\r\n\r\nAnother thought, though it requires a side channel from frontend to backend, is the `ClientHelloInner` omits `key_shares` in favor of a new `key_shares_hashed` extension where you insert `SHA256(ClientHelloOuter.key_shares)` for transcript purposes. The receiver then asserts the hash matches and pretends you included `ClientHelloOuter.key_shares` in `ClientHelloInner` for handshake purposes.",
          "createdAt": "2019-11-05T23:43:29Z",
          "updatedAt": "2019-11-05T23:43:29Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, one big drawback here is clearly the size, and yeah, PQ makes that worse.\r\n\r\nWith that said, it seems like you could potentially ameliorate this by only including classical KeyShares in ClientHelloOuter. The rationale here would be that the only purpose of ClientHelloOuter is to enable the fallback handshake, and so those keys are just protecting the SNI (and ESNIConfig, but that's just there to protect SNI), and we could potentially live with that being non-quantum-safe, especially if we're not going to use PQ algorithms for ESNI encryption. And of course if we *do* use PQ algorithms for ESNI encryption, then the overhead of the second CH is only about 1/2 as opposed to double.\r\n\r\n\r\n\r\n",
          "createdAt": "2019-11-05T23:48:47Z",
          "updatedAt": "2019-11-05T23:48:47Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Wouldn't that would negate the point of GREASE? ClientHellos advertising ESNI would have large ciphertext and classical-only outer key shares, while ClientHellos not advertising ESNI would include the PQ outer key shares (and probably send a small GREASE extension ton compensate).",
          "createdAt": "2019-11-06T00:00:05Z",
          "updatedAt": "2019-11-06T00:00:05Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, that's true. I think I'd be willing to live with that tradeoff but\nperhaps others would not.\n\nOn Tue, Nov 5, 2019 at 4:00 PM David Benjamin <notifications@github.com>\nwrote:\n\n> Wouldn't that would negate the point of GREASE? ClientHellos advertising\n> ESNI would have large ciphertext and classical-only outer key shares, while\n> ClientHellos not advertising ESNI would include the PQ outer key shares\n> (and probably send a small GREASE extension ton compensate).\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tlswg/draft-ietf-tls-esni/pull/196?email_source=notifications&email_token=AAIPLIIXQ7PURA5TEIE2ETLQSICINA5CNFSM4JJGLDW2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEDEYQ7Y#issuecomment-550078591>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAIPLIOIH23TNN2NC7ODZLLQSICINANCNFSM4JJGLDWQ>\n> .\n>\n",
          "createdAt": "2019-11-06T00:01:47Z",
          "updatedAt": "2019-11-06T00:01:47Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The size-doubling issue could be addressed through the use of compression.  If the inner and outer values are the same, then the inner could just reference the outer (and the removal of encryption could also include expansion).",
          "createdAt": "2019-11-06T00:52:48Z",
          "updatedAt": "2019-11-06T00:52:48Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "By compression (or reusing stuff), doesn't the proposal become closer to the ESNI transformation design that we have been talking in https://github.com/kazuho/draft-rescorla-tls-esni/pull/1?",
          "createdAt": "2019-11-06T01:50:01Z",
          "updatedAt": "2019-11-06T01:50:01Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson Yeah, compression was what I was referring with \"delta ClientHello\". You could imagine a ClientHello-specific compression that knows how to toss extensions around (in which case, yeah, it starts getting closer to ESNI transformation), or some more generic delta encoding. Here's an ad hoc goofy thing:\r\n\r\n```\r\nenum { bytes(0), reference(1) } FragmentType;\r\n \r\nstruct {\r\n  uint24 offset;\r\n  uint24 length;\r\n} ReferenceFragment;\r\n \r\nopaque BytesFragment<1..2^24-1>;\r\n \r\nstruct {\r\n  FragmentType type;\r\n  select (Fragment.type) {\r\n    // Append these bytes.\r\n    case bytes: BytesFragment;\r\n    // Append the referenced fragment of the outer ClientHello.\r\n    case reference: ReferenceFragment;\r\n  }\r\n} Fragment;\r\n \r\nstruct {\r\n  // Included so preallocating the buffer and enforcing size limits is easy.\r\n  uint24 clienthello_length;\r\n  // Walk over all the fragments to reconstruct the ClientHello.\r\n  Fragment clienthello_fragments<0..2^24-1>;\r\n} ESNIPlaintext;\r\n```\r\n\r\nA ClientHello-specific encoding is easier to produce since senders know how their ClientHellos look like and we can tailor things what fields should and shouldn't be copied. But it's harder to decode since you need to add checks for silly questions like \"what order do I insert extensions?\" or \"what happens if the placeholder is missing\" or \"what happens if there are two placeholders?\" or \"what happens if the outer ClientHello is missing the extension to copy?\".\r\n\r\nConversely, though it may take more spec text to describe, a bytes-based encoding is easier to decode since you just blindly evaluate the two opcodes and only need to include a couple of checks. But it's harder to encode since you need to account for length prefixes when chopping things up.",
          "createdAt": "2019-11-06T15:55:10Z",
          "updatedAt": "2019-11-06T15:55:10Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "@ekr pointed out that delta-encoding tricks should include the hash of the reconstructed ClientHello, otherwise the ciphertext tag does not cover the key shares, etc., so the above needs one more field.",
          "createdAt": "2019-11-06T20:43:34Z",
          "updatedAt": "2019-11-06T20:43:34Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "While waiting for this or some similar PR to be merged, I played about a bit with implementing guesses as to how it might be done in a [branch](https://github.com/sftcd/openssl/tree/encch) of my ESNI-enabled OpenSSL fork. If interested here's the [diff](https://github.com/sftcd/openssl/compare/master...sftcd:encch) and [some notes](https://github.com/sftcd/openssl/blob/encch/esnistuff/echo.md) on what I did.\r\n\r\nDoing that was fairly messy but not that hard, the main thoughts/questions I was left with were:\r\n- <strike>it'd maybe be easier to have the ESNI-specific padding in the esni-nonce extension directly as that'd mean less change to OpenSSL API behaviour (applications can set callbacks to do padding themselves too)</strike> In the end, I added a CH padding extension to the inner CH, (sort of) as envisaged in the PR, but could as easily do the padding within the esni_nonce. Still not sure if there're any API issues. The ``padded_length`` field in the ESNIConfig is now (IMO) even more of a bad plan than before as the relevant thing to pad is the entire plaintext inner CH and not just the server_name - so whomever is writing values to the DNS has even less likelihood of knowing a good exact max/value. (And it can be >260 now too.)\r\n - I took a stab at using my OpenSSL code for [HPKE](https://github.com/sftcd/happykey) instead of the ESNI-specific stuff that's been in earlier drafts and that wasn't a problem (though I didn't spend time thinking about how exactly to use HPKE - I just set the TLS session key share as the AAD)\r\n- I'm still very unclear as to what rules should/must apply to the relationship between values in the inner and outer CH's - but the simpler we can make that the better (I don't mean compression here, just what rules are to apply when we have two versions of a thing, like the TLS session key share or ALPN for example)\r\n- For ALPN, I implemented support for different values in inner and outer CH, which was easy enough and could even be possibly useful:-) One upshot of that is that it more or less means that the server really ought also do record layer padding of the EncryptedExtensions as otherwise the length of that might give the game away where values like ALPN differ between inner and outer CH.\r\n\r\nAnd just in case: I didn't try any compression and this code is likely flakey as hell in error cases, so don't anyone go using it for anything:-) I plan to ditch it anyway once draft-06 is out.",
          "createdAt": "2020-01-29T14:33:01Z",
          "updatedAt": "2020-02-07T16:20:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favor of #207.",
          "createdAt": "2020-03-08T00:32:22Z",
          "updatedAt": "2020-03-08T00:32:22Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE4MDg5MTU0",
          "commit": {
            "abbreviatedOid": "44a7d7d"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "The design looks promising, I have just some minor comments.",
          "createdAt": "2019-11-18T03:56:13Z",
          "updatedAt": "2019-11-18T05:38:35Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "Maybe: then \"it\" does not send",
              "createdAt": "2019-11-18T03:56:13Z",
              "updatedAt": "2019-11-18T05:38:35Z"
            },
            {
              "originalPosition": 193,
              "body": "s/wil/will/",
              "createdAt": "2019-11-18T03:59:21Z",
              "updatedAt": "2019-11-18T05:38:35Z"
            },
            {
              "originalPosition": 202,
              "body": "Is this a typo \"outer_extension\"?",
              "createdAt": "2019-11-18T04:40:36Z",
              "updatedAt": "2019-11-18T05:38:35Z"
            },
            {
              "originalPosition": 126,
              "body": "This paragraph talks about sending a ESNIKeys that the client should use for retrying.\r\n\r\nTherefore, maybe s/If it rejects ESNI/If the client sent an ESNI \"encrypted_client_hello\" extension using a key not available to the server/.",
              "createdAt": "2019-11-18T05:32:16Z",
              "updatedAt": "2019-11-18T05:38:35Z"
            },
            {
              "originalPosition": 667,
              "body": "Have you dropped the period by an accident?",
              "createdAt": "2019-11-18T05:37:53Z",
              "updatedAt": "2019-11-18T05:38:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyMDQ4MTE1",
          "commit": {
            "abbreviatedOid": "44a7d7d"
          },
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-25T05:35:00Z",
          "updatedAt": "2019-11-25T05:35:01Z",
          "comments": [
            {
              "originalPosition": 354,
              "body": "The draft -02 protocol seems to work without an unencrypted SNI. Is this adding a required unencrypted SNI?",
              "createdAt": "2019-11-25T05:35:01Z",
              "updatedAt": "2019-11-25T05:35:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyMDQ4ODQ5",
          "commit": {
            "abbreviatedOid": "44a7d7d"
          },
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-25T05:38:15Z",
          "updatedAt": "2019-11-25T05:38:15Z",
          "comments": [
            {
              "originalPosition": 336,
              "body": "Double capital I in \"ClientHelloIInner\"",
              "createdAt": "2019-11-25T05:38:15Z",
              "updatedAt": "2019-11-25T05:38:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyMDQ5NjY0",
          "commit": {
            "abbreviatedOid": "44a7d7d"
          },
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-25T05:41:45Z",
          "updatedAt": "2019-11-25T05:41:46Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "nit: Both the AP style guide and https://tools.ietf.org/html/rfc7322 no longer capitalize \"web\"",
              "createdAt": "2019-11-25T05:41:45Z",
              "updatedAt": "2019-11-25T05:41:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyMDUwNDA2",
          "commit": {
            "abbreviatedOid": "44a7d7d"
          },
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-25T05:45:05Z",
          "updatedAt": "2019-11-25T05:45:05Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "\"reject an ESNIConfig\"?\r\n\r\nI'm still not clear on the reason for server-controlled padding here. I can see using this figure as a hint, though.",
              "createdAt": "2019-11-25T05:45:05Z",
              "updatedAt": "2019-11-25T05:54:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyMDUwODg1",
          "commit": {
            "abbreviatedOid": "44a7d7d"
          },
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-25T05:47:08Z",
          "updatedAt": "2019-11-25T05:47:09Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "May want to cite draft-hoffman-c2pq or a successor draft here.",
              "createdAt": "2019-11-25T05:47:09Z",
              "updatedAt": "2019-11-25T05:47:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyMDUxMzM5",
          "commit": {
            "abbreviatedOid": "44a7d7d"
          },
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-25T05:49:10Z",
          "updatedAt": "2019-11-25T05:49:10Z",
          "comments": [
            {
              "originalPosition": 245,
              "body": "I've noticed that this draft uses \"encrypted SNI\" and \"ESNI\" interchangeably, but unpredictably. Would recommend taking a pass over all of these acronyms once the naming is settled (\"ECHO\" etc...)",
              "createdAt": "2019-11-25T05:49:10Z",
              "updatedAt": "2019-11-25T05:49:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyMDUxNjQ0",
          "commit": {
            "abbreviatedOid": "44a7d7d"
          },
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-25T05:50:34Z",
          "updatedAt": "2019-11-25T05:50:34Z",
          "comments": [
            {
              "originalPosition": 316,
              "body": "I think the commas are off here. I think the best fix might be to leave out \"large\" and write \"duplicated extensions\".",
              "createdAt": "2019-11-25T05:50:34Z",
              "updatedAt": "2019-11-25T05:50:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyMDUyMDU0",
          "commit": {
            "abbreviatedOid": "44a7d7d"
          },
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-25T05:52:24Z",
          "updatedAt": "2019-11-25T05:52:24Z",
          "comments": [
            {
              "originalPosition": 510,
              "body": "Incomplete sentence.",
              "createdAt": "2019-11-25T05:52:24Z",
              "updatedAt": "2019-11-25T05:52:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1NTQ1NjAz",
          "commit": {
            "abbreviatedOid": "44a7d7d"
          },
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-20T22:08:44Z",
          "updatedAt": "2019-12-20T22:08:44Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "Just to add to the seemingly endless traffic identification via packet size: https://isc.sans.edu/diary/25616",
              "createdAt": "2019-12-20T22:08:44Z",
              "updatedAt": "2019-12-20T22:08:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 197,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2OTYyNzY5",
      "title": "Key schedule injection proposal.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/197",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-05T20:06:28Z",
      "updatedAt": "2019-11-22T00:52:13Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "8395959ed6e17e3b6b91aa132fbce93652ad2ef1",
      "headRepository": "chris-wood/draft-ietf-tls-esni",
      "headRefName": "caw/key-schedule-injection",
      "headRefOid": "a22ffbe5e5aa1f00f9f6d6b541f00379bde8e937",
      "closedAt": "2019-11-22T00:52:13Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favor of #196.",
          "createdAt": "2019-11-22T00:52:12Z",
          "updatedAt": "2019-11-22T00:52:12Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 198,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM3MDI5Nzgw",
      "title": "Add a length prefix to ESNIConfig contents.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/198",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "ESNIConfig has a version number in front for extensibility, but it is\r\nunclear what the version invariants are. Presumably we would like\r\nversions to change the contents of an ESNIConfig (indeed different\r\ndrafts have done so), but it is not obvious this is possible and it is\r\nimpossible to skip over an ESNIConfig with a version you do not\r\nunderstand.\r\n\r\nFix this by moving the body of an ESNIConfig into an ESNIConfigContents\r\nand adding a length prefix in front.\r\n\r\nFixes #192.",
      "createdAt": "2019-11-05T22:03:51Z",
      "updatedAt": "2019-11-21T10:17:48Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "8395959ed6e17e3b6b91aa132fbce93652ad2ef1",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "esni-config-contents",
      "headRefOid": "4a589f9559fd8d65d923d595dc0be4a7e9851432",
      "closedAt": "2019-11-21T10:17:47Z",
      "mergedAt": "2019-11-21T10:17:47Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "4a589f9559fd8d65d923d595dc0be4a7e9851432"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 199,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM3MDY0ODcw",
      "title": "Unify version/extension and key share negotiation mechanisms",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/199",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "[This PR sits on top of #198. Ignore the first commit to look at it in isolation.]\r\n\r\nWe currently have two levels of mechanisms for servers to advertise multiple sets of parameters. First, each ESNIConfig has multiple keys in it, so a server can suport multiple groups at once. These keys are stapled together so a single HTTPSSVC record, etc., delivers the entire configuration.\r\n\r\nAt a layer above that, we have a version/extension-based mechanism. The server may advertise multiple ESNIConfigs to cover multiple versions of ESNI (hopefully we won't need this mechanism after standardization, but it's quite useful for draft versions) or multiple sets of mandatory extensions. Unlike the group advertisement, these are each in separate configuration units, so, e.g., they may be in multiple HTTPSSVC records.\r\n\r\nThis PR flattens the two mechanisms into one. Each ESNIConfig now has a single KeyShareEntry. Multiple groups and multiple versions are expressed in the same way: multiple ESNIConfig structures. It then introduces a wrapper ESNIConfigs structure which is the new unit of ESNI configuration delivered in HTTPSSVC, etc.\r\n\r\nThis should be paired with a change to draft-nygren-dnsop-svcb-httpssvc to carry an ESNIConfigs, not an ESNIConfig (formerly ESNIKeys). (@bemasc FYI)\r\n\r\nThis fixes a number of oddities:\r\n\r\n- Client and server need to maintain two levels of configuration. On the server, the structure has two layers of lists, something like list(tuple(ESNIConfig, list(PrivateKey))). Now the server maintains list(tuple(ESNIConfig, PrivateKey)). Conversely, the client needed two negotiation loops whereas now it only requires one.\r\n\r\n- Logic across different layers of the client stack now more reliably have the full ESNI configuration available in one unit.\r\n\r\n  In the old design, a single ESNIConfig, rather than a set of them, would be correlated with an IP address or CNAME, by way of the HTTPSSVC record. A server which supportsed multiple ESNI versions or mandatory extension sets would advertise several HTTPSSVC records, potentially with different IPs. That means the DNS and transport connection logic must know about TLS capabitilies to pick the right HTTPSSVC record.\r\n\r\n  In the new design, the server includes all its variations at once, so the DNS and transport logic can reasonably pick an HTTPSSVC purely based on whether the TLS stack supports ESNI, rather than the full set of capabilities. That is, the text in [0] does not work right now, and this PR fixes it.\r\n\r\nThe downside is that, in the likely case that the server only supports one version and one set of extensions, the non-key ESNI config bits (notably the public name; the rest is small) are repeated for every named group. However, the public name should not be that large and servers should only need one or two groups[1].\r\n\r\nThis also does make ESNIConfigs and ESNIConfig separate structures, which is slightly goofy. Alternate names if folks prefer:\r\n\r\n- ESNIConfig/ESNIConfigs => ESNIConfig/ESNIBundle\r\n- ESNIConfig/ESNIConfigs => ESNIKey/ESNIConfig\r\n\r\n[0] https://tools.ietf.org/html/draft-nygren-dnsop-svcb-httpssvc-00#section-8.1.1\r\n[1] https://www.imperialviolet.org/2016/05/16/agility.html",
      "createdAt": "2019-11-05T23:14:18Z",
      "updatedAt": "2019-11-06T15:44:28Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "8395959ed6e17e3b6b91aa132fbce93652ad2ef1",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "esni-configs",
      "headRefOid": "d4f38d88ab9e11718a638f669e7b254813d68ba8",
      "closedAt": "2019-11-06T15:44:28Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "It seems to me that there are two changes here:\r\n\r\n1. Bundling all the ESNIConfigs into a single HTTPSVC record. This seems like a good idea for the reasons you lay out.\r\n\r\n2. Flattening the structure. I'm less enthusiastic about this: it requires duplicating data and is a new opportunity to have inconsistencies as well as bloat.",
          "createdAt": "2019-11-05T23:19:39Z",
          "updatedAt": "2019-11-05T23:19:39Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "That's a good point. It's late here, so I will see about splitting this into two PRs tomorrow.",
          "createdAt": "2019-11-05T23:24:26Z",
          "updatedAt": "2019-11-05T23:24:26Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Split this into #200 and #201.",
          "createdAt": "2019-11-06T15:44:27Z",
          "updatedAt": "2019-11-06T15:44:27Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 200,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM3NDI4OTE5",
      "title": "Advertise multiple ESNIConfigs as a unit",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/200",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "[This was split out of #199 as the hopefully less controversial idea. Also it sits on top of #198. Ignore the first commit to look at it in isolation.]\r\n\r\nWe have two levels of mechanisms for servers to advertise parameters. Each ESNIConfig has multiple keys, so a server can suport multiple groups at once. These keys are stapled together so a single HTTPSSVC record delivers the entire configuration.\r\n\r\nThen we have a versions/extensions mechanism. A server supporting multiple versions of ESNI or multiple sets of mandatory extensions must advertise multiple ESNIConfigs. Unlike the group advertisement, these require separate HTTPSSVC records. This means the full ESNI config is not reliably available to logic across different layers of the client stack. In particular, the HTTPSSVC spec text in [0] does not work. (@bemasc FYI)\r\n\r\nCurrently, a single ESNIConfig, rather than a set of them, is correlated with an IP address or CNAME, by way of the HTTPSSVC record. A server which supports multiple ESNI versions or mandatory extension sets must advertise several HTTPSSVC records, potentially with different IPs. DNS and transport logic must know TLS capabilities to pick the right HTTPSSVC record.\r\n\r\nThis PR introduces an ESNIConfigs structure which advertises a list of ESNIConfig structures. The ESNIConfigs is the new unit of ESNI configuration. This should be paired with a change to draft-nygren-dnsop-svcb-httpssvc to carry an ESNIConfigs, not an ESNIConfig (formerly ESNIKeys).\r\n\r\nNow the server can include the full config at once, so the DNS and transport logic can reasonably pick an HTTPSSVC purely based on whether the TLS stack supports ESNI, rather than the full set of capabilities. This fixes the text in [0].\r\n\r\nThat ESNIConfigs and ESNIConfig are separate structures is slightly goofy naming. Alternate names if folks prefer:\r\n\r\n- ESNIConfig/ESNIConfigs => ESNIConfig/ESNIBundle\r\n\r\n- ESNIConfig/ESNIConfigs => ESNIKeys/ESNIConfig\r\n  (Nuisance: an ESNIConfig is a list of ESNIKeyses, which brings back the double plural.)\r\n\r\n(While I'm here, fix the remnants of ESNIKeyShares. I'll split that out if this PR is controversial, but GitHub is really bad at dependent PRs, so I've left it together for now.)\r\n\r\n[0] https://tools.ietf.org/html/draft-nygren-dnsop-svcb-httpssvc-00#section-8.1.1",
      "createdAt": "2019-11-06T15:43:10Z",
      "updatedAt": "2019-11-21T10:17:46Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "8395959ed6e17e3b6b91aa132fbce93652ad2ef1",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "esni-configs-2",
      "headRefOid": "72711a8959dcf8f9b63c5c7e041a17b969f5f9ce",
      "closedAt": "2019-11-21T10:17:46Z",
      "mergedAt": "2019-11-21T10:17:46Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "d45d404dd2000740ddef3d7a8a537c7c3b55e7a8"
      },
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> This means the full ESNI config is not reliably available to logic across different layers of the client stack. In particular, the HTTPSSVC spec text in [0] does not work. (@bemasc FYI)\r\n\r\nWhy doesn't it work?  The transport side tries the highest-priority option, and the TLS library is free to reject it, in which case the transport side will try the next option, etc.  All the transport side needs to know is whether the TLS library supports ESNI.\r\n\r\nAre you thinking about a case where the client only supports ESNI version 1, and the server only offers ESNI version 2?",
          "createdAt": "2019-11-06T15:49:26Z",
          "updatedAt": "2019-11-06T15:49:26Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "That presumes your retry loop is integrated up and down the layers. It also means that, unless you shortcircuit things and check ESNI ahead of time, you pay for a TCP roundtrip to the unsupported ESNIConfig addresses. It also doesn't account for cases when the client doesn't support any of the ESNI versions. In that case, it should connect without ESNI (presuming it would be okay doing so without ESNI configs).",
          "createdAt": "2019-11-06T16:02:37Z",
          "updatedAt": "2019-11-06T16:02:55Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> That presumes your retry loop is integrated up and down the layers. It also means that, unless you shortcircuit things and check ESNI ahead of time, you pay for a TCP roundtrip to the unsupported ESNIConfig addresses.\r\n\r\nOK, I agree with all of this.  I'm happy to reduce the required level of integration, if we can find a way.\r\n\r\n> It also doesn't account for cases when the client doesn't support any of the ESNI versions. In that case, it should connect without ESNI (presuming it would be okay doing so without ESNI configs).\r\n\r\nAre you proposing that the TLS library should silently ignore an ESNIConfigs with all unsupported versions/ciphers, and send the SNI in cleartext?  That seems like a recommendation that should go in this draft.  Or are you proposing a fallback check that goes back to the transport layer?",
          "createdAt": "2019-11-06T16:37:00Z",
          "updatedAt": "2019-11-06T16:37:00Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> Are you proposing that the TLS library should silently ignore an ESNIConfigs with all unsupported versions/ciphers, and send the SNI in cleartext? That seems like a recommendation that should go in this draft.\r\n\r\nIt is in the draft. It says you ignore ESNIConfigs you don't understand.",
          "createdAt": "2019-11-06T17:02:26Z",
          "updatedAt": "2019-11-06T17:02:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed in Singapore; no objections. Will merge.",
          "createdAt": "2019-11-21T10:16:39Z",
          "updatedAt": "2019-11-21T10:16:39Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3MjQ0NDQw",
          "commit": {
            "abbreviatedOid": "72711a8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-14T20:38:24Z",
          "updatedAt": "2019-11-14T20:38:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 201,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM3NDI5NTUx",
      "title": "Flatten ESNI negotiation mechanisms",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/201",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "[This was split out of #199 as the possibly more controversial idea. It's a simplification but does make configs larger. Also it sits on top of #198 and #200. Ignore the first two comments to look at it in isolation.]\r\n\r\nWe have two layers of parameter negotiation. Multiple KeyShareEntry values in an ESNIConfig, and multiple ESNIConfig values in an ESNIConfigs. We only need one mechanism, so store only one KeyShareEntry in an ESNIConfig.\r\n\r\nThis simplifies representing client and server configuration, which simplies implementation internals as well as interchange formats. Right now, on the server, configuration has two layers of lists, something like list(tuple(ESNIConfig, list(PrivateKey))). Now the server maintains list(tuple(ESNIConfig, PrivateKey)).\r\n\r\nNote also that draft-farrell-tls-pemesni-00 has this oddity around what to do if the ESNIKeys contains multiple keys. This is particularly a nuisance because a single standalone PRIVATE KEY / ESNIKEY pair is not usable because the server has committed to answering to *all* keys in the ESNIKeys. The server must consume multiple PEM files, match up the ESNIKeyses, and then assert that it has a complete set.\r\n\r\nThe downside is that, in the likely case that the server only supports one version and one set of extensions, the non-key ESNI config bits (notably the public name; the rest is small) are repeated for every named group. However, the public name should not be that large and servers should only need one or two groups (see https://www.imperialviolet.org/2016/05/16/agility.html).",
      "createdAt": "2019-11-06T15:44:17Z",
      "updatedAt": "2020-02-23T13:49:02Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "8395959ed6e17e3b6b91aa132fbce93652ad2ef1",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "esni-configs-flatten",
      "headRefOid": "67a2e15076a4e95c03b125d54e5d1888663e2605",
      "closedAt": "2020-02-23T13:49:01Z",
      "mergedAt": "2020-02-23T13:49:01Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "4d2aa537160d22456a8bc1db9cf7a0295055963c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3MjQ1NzI3",
          "commit": {
            "abbreviatedOid": "67a2e15"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This LGTM -- thanks, David!",
          "createdAt": "2019-11-14T20:40:45Z",
          "updatedAt": "2019-11-14T20:40:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 203,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQxMDkzMTY5",
      "title": "Remove ESNI RRType Considerations",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/203",
      "state": "MERGED",
      "author": "mrsylerpowers",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #202 ",
      "createdAt": "2019-11-14T17:31:37Z",
      "updatedAt": "2019-11-14T20:35:25Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "8395959ed6e17e3b6b91aa132fbce93652ad2ef1",
      "headRepository": "mrsylerpowers/draft-ietf-tls-esni",
      "headRefName": "patch-1",
      "headRefOid": "e9c66fcbe8756a2c86461b70c56975ec71616c55",
      "closedAt": "2019-11-14T20:35:25Z",
      "mergedAt": "2019-11-14T20:35:25Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "811def0f5f7f858a42a2c51cbf70baf0c2562202"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3MjQyOTM3",
          "commit": {
            "abbreviatedOid": "e9c66fc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-14T20:35:20Z",
          "updatedAt": "2019-11-14T20:35:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 207,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg1MjA5NDIy",
      "title": "ESNI -> ECHO",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/207",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This change implements the ESNI -> ECHO design discussed in Singapore. There a couple pending TODOs, particularly around cross-CH HRR binding, but the meat is what's currently being analyzed. \r\n\r\ncc @davidben, @grittygrease, @martinthomson, @karthikbhargavan ",
      "createdAt": "2020-03-08T00:30:29Z",
      "updatedAt": "2020-03-09T21:57:43Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f13e0c956c1b42e4121ee41904a77af1bacebf18",
      "headRepository": "chris-wood/draft-ietf-tls-esni",
      "headRefName": "caw/tunnel",
      "headRefOid": "42c6c489a9bfa7bdceb4b9b8b6c34415dae3ca68",
      "closedAt": "2020-03-09T21:57:43Z",
      "mergedAt": "2020-03-09T21:57:43Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "7d53f5b6985242c18e1a988104090dc1f08a4d74"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxNTU2Mzk3",
          "commit": {
            "abbreviatedOid": "42c6c48"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This still seems a bit rough, but I think better in the spec than out.",
          "createdAt": "2020-03-09T21:56:12Z",
          "updatedAt": "2020-03-09T21:56:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 208,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg3MzI4NjE2",
      "title": "Align client GREASE section with ClientEncryptedCH definition.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/208",
      "state": "MERGED",
      "author": "dmcardle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Also define the length of the randomly-generated \"encrypted_ch\" field.",
      "createdAt": "2020-03-12T16:02:12Z",
      "updatedAt": "2020-03-18T15:17:19Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "7d53f5b6985242c18e1a988104090dc1f08a4d74",
      "headRepository": "dmcardle/draft-ietf-tls-esni",
      "headRefName": "dan-clean-up-grease",
      "headRefOid": "750477aad3b5b19c56d8c1975806309147adfc8f",
      "closedAt": "2020-03-18T15:17:19Z",
      "mergedAt": "2020-03-18T15:17:18Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "db1d9a793c0640f03750612a4fd2be7bfe8f30b5"
      },
      "comments": [
        {
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@davidben @dvorak42",
          "createdAt": "2020-03-12T16:04:57Z",
          "updatedAt": "2020-03-12T16:04:57Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczNjkwNzcy",
          "commit": {
            "abbreviatedOid": "2dd6ff2"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-12T16:03:19Z",
          "updatedAt": "2020-03-12T16:03:19Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Is `padded_length` supposed to be the length for \"encrypted_ch\"? I was unclear on this.",
              "createdAt": "2020-03-12T16:03:19Z",
              "updatedAt": "2020-03-13T15:18:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczNzU3Mjc4",
          "commit": {
            "abbreviatedOid": "2dd6ff2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-12T17:25:35Z",
          "updatedAt": "2020-03-12T17:25:35Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "We should probably table this until we figure out the padding strategy. (Apparently that's still up in the air!) It also occurs to me that the first bullet in this list is obsolete -- we don't have a named group anymore or padded_length anymore:\r\n\r\n```\r\n      struct {\r\n          CipherSuite suite;\r\n          opaque record_digest<0..2^16-1>;\r\n          opaque enc<1..2^16-1>;\r\n          opaque encrypted_ch<1..2^16-1>;\r\n      } ClientEncryptedCH;\r\n```\r\n\r\nCan we just say something like the following? \r\n\r\n\"Set the \"suite\" field to a supported cipher suite. This selection SHOULD vary to exercise all supported configurations, but MAY be constant for successive connections to the same server in the same session.\"",
              "createdAt": "2020-03-12T17:25:35Z",
              "updatedAt": "2020-03-13T15:18:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0MzczMzA1",
          "commit": {
            "abbreviatedOid": "2dd6ff2"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-13T15:04:11Z",
          "updatedAt": "2020-03-13T15:04:12Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Ah, ok. I'll bring the [TODO] back for the length of encrypted_ch.",
              "createdAt": "2020-03-13T15:04:11Z",
              "updatedAt": "2020-03-13T15:18:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2OTY1NTcw",
          "commit": {
            "abbreviatedOid": "750477a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-18T15:17:12Z",
          "updatedAt": "2020-03-18T15:17:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 209,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg4NDM5NjA1",
      "title": "padding scheme text",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/209",
      "state": "MERGED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I've tried to capture what I think is a reasonable way to handle padding now we've changed from ESNI->ECHO.  If we could do something like this, that'd be better than what's in -06.\r\n\r\nNote that I'd be even happier if we entirely eliminated ECHOConfig.minimum_inner_length - I don't think it actually adds any value and it represents yet another way to get a configuration wrong.  ",
      "createdAt": "2020-03-14T21:05:06Z",
      "updatedAt": "2020-05-03T23:58:42Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "7d53f5b6985242c18e1a988104090dc1f08a4d74",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "abd6637cd2910dae0d3001a1d3edd41779dc4be4",
      "closedAt": "2020-05-03T23:58:42Z",
      "mergedAt": "2020-05-03T23:58:42Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "aa15d6e4d5ec406d9c0c8f782284df5b543d0510"
      },
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the fixes. \r\nOn the general point, I think that *if* we keep the flexibility for the client to vary the inner/outer CH however it chooses, then we will also have to depend on clients to figure out how to pad well for whatever they do. If we constrain the inner/outer variance a lot, then we could do better.\r\nIt also strikes me that the minimum_inner_length is sort of in tension with the idea of compression - if a server has to set the minimum_inner_length to 300ish to handle clients that don't compress, then clients that do compress either don't get the benefit or have to ignore the minimum_inner_length.",
          "createdAt": "2020-03-16T15:01:18Z",
          "updatedAt": "2020-03-16T15:03:37Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think this PR works. The server does not have enough information to report a useful value, and the value the server reports is not useful to maintain good anonymity sets.\r\n\r\nThe server does not know that the client supports some large extension or key share type (or lots of cipher suites, ALPN protocols, etc). [Post-quantum key shares](https://www.imperialviolet.org/2018/12/12/cecpq2.html) are especially fun. It also doesn't know which extensions the client will compress from the outer ClientHello and which it will reencode.\r\n\r\nConversely, the value the server sets isn't useful. If the client implementation has a smaller baseline compression and extensions, we waste bytes without much benefit. Worse, if the client implementation has a larger baseline compression and extensions, this PR regresses anonymity. The ClientHello will then exceed `minimum_inner_length` and we don't hide the lengths of the sensitive bits.\r\n\r\nStepping back, we want to hide the distribution of ClientHelloInner lengths within some anonymity set. Most of the contributors to that length come from local client configuration: how many ciphers you support, what ALPN protocols, etc. The client is the one that knows, e.g., it sometimes asks servers for protocols A and B and sometimes for A and C. It largely has enough information to pad itself.\r\n\r\nThe main exception is the server name. Realistically we need to trim anonymity sets down to colocated services, and the client doesn't know that distribution of names. Thus, we want servers to report the value in ECHOConfig. Maybe we'll need more such statistics later, which is what extensions are for. It's annoying this is a bit complicated, but we've signing up to encrypt far more things now.\r\n\r\nI should note this presumes an anonymity set of similarly-configured clients. I think, realistically, that's all we can say rigorous things about. It's nice to reduce visible artifacts of configuration, which is why we *additionally* round up to multiples of 16, but that's something we can burn into the protocol without ECHOConfig support.",
          "createdAt": "2020-03-16T16:02:07Z",
          "updatedAt": "2020-03-16T16:03:17Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\nHiya,\n\nOn 16/03/2020 16:02, David Benjamin wrote:\n> I don't think this PR works. The server does not have enough\n> information to report a useful value, and the value the server\n> reports is not useful to maintain good anonymity sets.\n> \n> The server does not know that the client supports some large\n> extension or key share type (or lots of cipher suites, ALPN\n> protocols, etc). It also doesn't know which extensions the client\n> will compress from the outer ClientHello and which it will reencode.\n> \n> Conversely, the value the server sets isn't useful. If the client\n> implementation has a smaller baseline compression and extensions, we\n> waste bytes without much benefit. Worse, if the client implementation\n> has a larger baseline compression and extensions, this PR regresses\n> anonymity. The ClientHello will then exceed `minimum_inner_length`\n> and we don't hide the lengths of the sensitive bits.\n\nSorry, not seeing that last. The PR just says (or was\nmeant to say) to pad to some multiple of 16 in that\ncase which I agree isn't much guidance, but does allow\ndoing something that works. (As well as allowing things\nthat don't work well;-)\n\n> \n> Stepping back, we want to hide the distribution of ClientHelloInner\n> lengths within some anonymity set. Most of the contributors to that\n> length come from local client configuration: how many ciphers you\n> support, what ALPN protocols, etc. The client is the one that knows,\n> e.g., it sometimes asks servers for protocols A and B and sometimes\n> for A and C. It largely has enough information to pad itself.\n\nI agree that all this really needs to be driven by the\nclient.\n\n> The main exception is the server name. Realistically we need to trim\n> anonymity sets down to colocated services, and the client doesn't\n> know that distribution of names. \n\nWell, yes and no. I don't believe a server config is\nuseful for that, (as I've argued before and still do;-)\nISTM the max server name value will almost always be\nset to 254. May as well tell the client to pad as do\nthat IMO.\n\n> Thus, we want servers to report the\n> value in ECHOConfig. Maybe we'll need more such statistics later,\n> which is what extensions are for. It's annoying this is a bit\n> complicated, but we've signing up to encrypt far more things now.\n> \n> I should note this presumes an anonymity set of similarly-configured\n> clients. I think, realistically, that's all we can say rigorous\n> things about. It's nice to reduce visible artifacts of configuration,\n> which is why we *additionally* round up to multiples of 16, but\n> that's something we can burn into the protocol without ECHOConfig\n> support.\n\nNot quite sure if I agree with that last para or not TBH!\n\nS.\n\n\n> \n",
          "createdAt": "2020-03-16T21:46:18Z",
          "updatedAt": "2020-03-16T21:46:18Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> > Conversely, the value the server sets isn't useful. If the client\r\n> > implementation has a smaller baseline compression and extensions, we\r\n> >  waste bytes without much benefit. Worse, if the client implementation\r\n> > has a larger baseline compression and extensions, this PR regresses\r\n> > anonymity. The ClientHello will then exceed `minimum_inner_length`\r\n> > and we don't hide the lengths of the sensitive bits.\r\n>\r\n> Sorry, not seeing that last. The PR just says (or was\r\n> meant to say) to pad to some multiple of 16 in that\r\n> case which I agree isn't much guidance, but does allow\r\n> doing something that works. (As well as allowing things\r\n> that don't work well;-)\r\n\r\nWell, if we were satisfied just padding names to a multiple of 16, we wouldn't need any of this. We'd just say to pad to a multiple 16 and move on. :-) In the current name-focused spelling, the client is always able to apply a smarter padding decision based on the server's knowledge of the name distribution. With this PR, clients whose local configuration exceeds or is near `minimum_inner_length` lose this and hit the baseline multiple of 16 behavior. Clients whose local configuration is decently below `minimum_inner_length` do hide the name distribution, but using many more bytes than they would with the current text.\r\n\r\n> > The main exception is the server name. Realistically we need to trim\r\n> > anonymity sets down to colocated services, and the client doesn't\r\n> > know that distribution of names.\r\n>\r\n> Well, yes and no. I don't believe a server config is\r\n> useful for that, (as I've argued before and still do;-)\r\n> ISTM the max server name value will almost always be\r\n> set to 254. May as well tell the client to pad as do\r\n> that IMO.\r\n\r\nWe have some metrics in Chrome on the distribution of DNS names. It's nowhere near 254. But, regardless, if you don't believe a server config is even useful for the name and agree with me that other extensions ought to be client-driven, I'm confused, why this PR? This PR seems to go in the opposite direction.\r\n\r\n> > I should note this presumes an anonymity set of similarly-configured\r\n> > clients. I think, realistically, that's all we can say rigorous\r\n> > things about. It's nice to reduce visible artifacts of configuration,\r\n> > which is why we *additionally* round up to multiples of 16, but\r\n> > that's something we can burn into the protocol without ECHOConfig\r\n> > support.\r\n>\r\n> Not quite sure if I agree with that last para or not TBH!\r\n\r\nHehe. Which part?",
          "createdAt": "2020-03-16T22:13:18Z",
          "updatedAt": "2020-03-16T22:13:18Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\nHIya,\n\nOn 16/03/2020 22:13, David Benjamin wrote:\n>>> Conversely, the value the server sets isn't useful. If the\n>>> client implementation has a smaller baseline compression and\n>>> extensions, we waste bytes without much benefit. Worse, if the\n>>> client implementation has a larger baseline compression and\n>>> extensions, this PR regresses anonymity. The ClientHello will\n>>> then exceed `minimum_inner_length` and we don't hide the lengths\n>>> of the sensitive bits.\n>> \n>> Sorry, not seeing that last. The PR just says (or was meant to say)\n>> to pad to some multiple of 16 in that case which I agree isn't much\n>> guidance, but does allow doing something that works. (As well as\n>> allowing things that don't work well;-)\n> \n> Well, if we were satisfied just padding names to a multiple of 16, we\n> wouldn't need any of this. We'd just say to pad to a multiple 16 and\n> move on. :-) In the current name-focused spelling, the client is\n> always able to apply a smarter padding decision based on the server's\n> knowledge of the name distribution. With this PR, clients whose local\n> configuration exceeds or is near `minimum_inner_length` lose this and\n> hit the baseline multiple of 16 behavior. Clients whose local\n> configuration is decently below `minimum_inner_length` do hide the\n> name distribution, but using many more bytes than they would with the\n> current text.\n\nYes. That's IMO the downside of having any server config.\n(To answer your question below, I prefer not having any\nserver config at all but proposed this as I think it's\nbetter than draft-06.)\n\n> \n>>> The main exception is the server name. Realistically we need to\n>>> trim anonymity sets down to colocated services, and the client\n>>> doesn't know that distribution of names.\n>> \n>> Well, yes and no. I don't believe a server config is useful for\n>> that, (as I've argued before and still do;-) ISTM the max server\n>> name value will almost always be set to 254. May as well tell the\n>> client to pad as do that IMO.\n> \n> We have some metrics in Chrome on the distribution of DNS names. It's\n> nowhere near 254. \n\nHaving also looked at some passive DNS stuff, I fully\nagree. But ISTM for many scenarios the entity that\ngenerates the ECHOConfig won't know the distribution\nof names in use (e.g. whoever configures OpenSSL won't,\nsame with Apache etc.) so it's likely they'll have to\ngo for whatever is the max (i.e. 254). Same is true\nfor anyone with a wild-card server cert in play\nsomewhere.\n\n> But, regardless, if you don't believe a server\n> config is even useful for the name and agree with me that other\n> extensions ought to be client-driven, I'm confused, why this PR? This\n> PR seems to go in the opposite direction.\n\nSee above. I'm trying for either a modest improvement\nover draft-06 or for us all to arrive at a real\nimprovement by ditching the server config entirely:-)\n\n> \n>>> I should note this presumes an anonymity set of\n>>> similarly-configured clients. I think, realistically, that's all\n>>> we can say rigorous things about. It's nice to reduce visible\n>>> artifacts of configuration, which is why we *additionally* round\n>>> up to multiples of 16, but that's something we can burn into the\n>>> protocol without ECHOConfig support.\n>> \n>> Not quite sure if I agree with that last para or not TBH!\n> \n> Hehe. Which part?\n\nI like the last sentence. I think I dislike the 1st:-)\n\nCheers,\nS.\n\n> \n",
          "createdAt": "2020-03-16T22:28:24Z",
          "updatedAt": "2020-03-16T22:28:24Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> > [...] With this PR, clients whose local configuration exceeds or is near `minimum_inner_length` lose this and hit the baseline multiple of 16 behavior.  [...trimmed for brevity, but please let me know if I've misinterpreted what 'That' referred to!]\r\n>\r\n> Yes. That's IMO the downside of having any server config.\r\n> (To answer your question below, I prefer not having any\r\n> server config at all but proposed this as I think it's\r\n> better than draft-06.)\r\n\r\nIt's not a downside of the draft-06 formulation, is it? The client learns something targeted to the name and can pad accordingly.\r\n\r\n> >  We have some metrics in Chrome on the distribution of DNS names. It's nowhere near 254.\r\n>\r\n> Having also looked at some passive DNS stuff, I fully\r\n> agree. But ISTM for many scenarios the entity that\r\n> generates the ECHOConfig won't know the distribution\r\n> of names in use (e.g. whoever configures OpenSSL won't,\r\n> same with Apache etc.) so it's likely they'll have to\r\n> go for whatever is the max (i.e. 254). Same is true\r\n> for anyone with a wild-card server cert in play\r\n> somewhere.\r\n\r\nEven with a wildcard server cert, the server should still know the distribution. For instance, `*.github.io` isn't going to see anything terribly long most of the time. (Looks like the registration limit is 39 characters.) For reference, this is how long a 254-character hostname is:\r\n\r\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\r\n\r\nIn order to enjoy wide adoption, ECHO can't be too much of a waste of resources.  I think it thus makes sense to target a different maximum here.\r\n\r\n> See above. I'm trying for either a modest improvement\r\n> over draft-06 or for us all to arrive at a real\r\n> improvement by ditching the server config entirely:-)\r\n\r\nI guess my view is that, because of this issue above, this is a regression over the draft-06 formulation, even though it looks more general.",
          "createdAt": "2020-03-17T19:32:10Z",
          "updatedAt": "2020-03-17T19:32:10Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\nHiya,\n\nOn 17/03/2020 19:32, David Benjamin wrote:\n>>> [...] With this PR, clients whose local configuration exceeds or\n>>> is near `minimum_inner_length` lose this and hit the baseline\n>>> multiple of 16 behavior.  [...trimmed for brevity, but please let\n>>> me know if I've misinterpreted what 'That' referred to!]\n>> \n>> Yes. That's IMO the downside of having any server config. (To\n>> answer your question below, I prefer not having any server config\n>> at all but proposed this as I think it's better than draft-06.)\n> \n> It's not a downside of the draft-06 formulation, is it? The client\n> learns something targeted to the name and can pad accordingly.\n\nDraft-06 assumes that no other inner CH content has the\nproperty that server guidance will help. My claim is that\nthat guidance is useless in practice, and therefore\nunnecessary. I think the server config'd length in the PR\nis a little less useless:-)\n\n> \n>>> We have some metrics in Chrome on the distribution of DNS names.\n>>> It's nowhere near 254.\n>> \n>> Having also looked at some passive DNS stuff, I fully agree. But\n>> ISTM for many scenarios the entity that generates the ECHOConfig\n>> won't know the distribution of names in use (e.g. whoever\n>> configures OpenSSL won't, same with Apache etc.) so it's likely\n>> they'll have to go for whatever is the max (i.e. 254). Same is\n>> true for anyone with a wild-card server cert in play somewhere.\n> \n> Even with a wildcard server cert, the server should still know the\n> distribution. \n\nSome servers will. Some will not. Many (most?) server\nECHOConfig instances will make use of default settings.\nThose'll pick 254 because adding a new VirtualHost to\nan apache instance (or similar) won't be co-ordinated\nwith making a new ECHOConfig in general. And even it\nit were, (but it won't!) we get a TTL's worth of mismatch.\nIf we don't provide a way for clients to handle the case\nwhere the server config is too short, again servers will\npublish 254.\n\n> For instance, `*.github.io` isn't going to see anything\n> terribly long most of the time. \n\nI am more interested in random smaller web sites/hosters\nmyself. I think ECHO should work for those as well as we\ncan make it, (albeit with smaller anonymity sets), and\nthis tie between web server config and ECHOConfig is just\na bad plan for such.\n\n> (Looks like the registration limit is\n> 39 characters.) For reference, this is how long a 254-character\n> hostname is:\n> \n> aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n>\n>  In order to enjoy wide adoption, ECHO can't be too much of a waste\n> of resources. \n\nAFAIK, all current deployments do just that. To be fair,\nthat's largely driven by CF's draft-02 deployment, but\nI think that backs up my argument that if there's a max,\nthat'll almost always be chosen, which implies it's a\nuseless field that leads to the inefficiency you note.\n\n> I think it thus makes sense to target a different\n> maximum here.\n\nThen it can't be the max:-) The 254 value matches the\nmax for server_name IIRC.\n\n> \n>> See above. I'm trying for either a modest improvement over draft-06\n>> or for us all to arrive at a real improvement by ditching the\n>> server config entirely:-)\n> \n> I guess my view is that, because of this issue above, this is a\n> regression over the draft-06 formulation, even though it looks more\n> general.\n\nOk. We disagree. But what do you think the client should\ndo? Draft-06 is IMO plainly incorrect in that it says to\npad in a way that'd expose other lengths should those be\nsensitive. If your answer were pad the SNI to at least\nECHOConfig.maximum_name_length and then make the overall\na multiple of 16, with as many added 16 octets blocks as\nthe client chooses, then a) that's != draft-06 and b) is\nquite close to this PR and c) just failing if the actual\nSNI in the inner CH is longer than the config setting\nseems quite wrong to me and d) hardcodes the assumption\nthat SNI is the only thing where the server may know\nbetter.\n\nCheers,\nS.\n\n\n> \n",
          "createdAt": "2020-03-17T20:06:49Z",
          "updatedAt": "2020-03-17T20:06:49Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> Draft-06 assumes that no other inner CH content has the\r\n> property that server guidance will help. My claim is that\r\n> that guidance is useless in practice, and therefore\r\n> unnecessary. I think the server config'd length in the PR\r\n> is a little less useless:-)\r\n\r\nIf we come up with other places where server guidance is useful, that can be addressed with extensions. But, gotcha, I suppose that is where we disagree. I think server guidance on the overall ClientHello size is entirely useless, while server guidance on the name is may be useful.\r\n\r\n> I am more interested in random smaller web sites/hosters\r\n> myself. I think ECHO should work for those as well as we\r\n> can make it, (albeit with smaller anonymity sets), and\r\n> this tie between web server config and ECHOConfig is just\r\n> a bad plan for such.\r\n\r\nAgreed that it should also work for smaller things. I don't follow how this PR helps in that regard. It seems they still need to come up with a random value or a default, but now it's even less clear how to set it well.\r\n\r\n>> I think it thus makes sense to target a different\r\n>> maximum here.\r\n>\r\n> Then it can't be the max:-) The 254 value matches the\r\n> max for server_name IIRC.\r\n\r\nEr, yes, sorry I meant to say target a different public length. That is, 254 is so far from the maximum domain name in practice (As it should be! Hard length limits ought to be comfortably away from the actual requirement.), so padding up to it is wasteful. I think it would be better to pad up to a tighter value and, if we exceed it, accept that we only have the fallback multiple of 16 padding. (Or maybe a different strategy.) It does result in smaller anonymity sets in edge cases, but I think that a reasonable default tradeoff given other desires like broader deployment and not wasting too much of users' data.\r\n\r\n> Ok. We disagree. But what do you think the client should\r\n> do? Draft-06 is IMO plainly incorrect in that it says to\r\n> pad in a way that'd expose other lengths should those be\r\n> sensitive. If your answer were pad the SNI to at least\r\n> ECHOConfig.maximum_name_length and then make the overall\r\n> a multiple of 16, with as many added 16 octets blocks as\r\n> the client chooses, then a) that's != draft-06 and b) is\r\n> quite close to this PR and c) just failing if the actual\r\n> SNI in the inner CH is longer than the config setting\r\n> seems quite wrong to me and d) hardcodes the assumption\r\n> that SNI is the only thing where the server may know\r\n> better.\r\n\r\nI'm thinking something along the lines of:\r\n\r\n1. For each field, determine how much it makes sense to pad given what kinds of things it sends. If it varies ALPN, maybe round up to the largest of those. Most of this can be determined without server help.\r\n2. For fields where server help is useful, like the name, apply that help. Right now it's simply a `max` function. I'm also open to other strategies.\r\n3. Sum all that padding together.\r\n4. In order to generally reduce entropy across different kinds of clients, maybe apply some additional overall padding, like rounding up to a multiple of 16, which cuts down the state space by 16x and doesn't cost much. (Or maybe we should round up to the nearest `int(64 * 1.1**i)`? That avoids higher resolution on longer values while bounding the fraction of bytes wasted by this step.) That said, it's worth keeping in mind that clients already vary quite a bit in the cleartext portions of the ClientHello. There's a bit of tension between wanting to look like the other clients and wanting to ship new security improvements.\r\n\r\nThis is different from this PR because this PR asks the server to report a value including things it doesn't know anything about (how large the client-controlled parameters are). I don't quite follow (c). It seems this PR and the above proposal has roughly the same failure modes when something is too long. The difference is that `maximum_name_length`'s failure mode is only tripped on particular long names (something the server knows the distribution of), while this PR's equivalent failure mode is based on factors outside the server control, yet the server is responsible for the value.",
          "createdAt": "2020-03-17T22:02:45Z",
          "updatedAt": "2020-03-17T22:02:45Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> For each field\r\n\r\nClarification: this is for each field where the client doesn't reference the outer ClientHello. If the client wishes to do that, it means the client doesn't consider that field secret so there isn't anything to pad.",
          "createdAt": "2020-03-17T22:03:58Z",
          "updatedAt": "2020-03-17T22:03:58Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I like @davidben's suggested algorithm, as an ideal padding function requires input from both the client and server. (Ideally, servers would send padding recommendations for each extension that might vary specifically for them, such as the server name. They don't have insight into anything else, so clients need to make padding decisions based on local configuration.)\r\n\r\n@sftcd, what do you think?",
          "createdAt": "2020-03-18T15:26:40Z",
          "updatedAt": "2020-03-18T15:26:40Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 18/03/2020 15:26, Christopher Wood wrote:\n> I like @davidben's suggested algorithm, as an ideal padding function\n> requires input from both the client and server. (Ideally, servers\n> would send padding recommendations for each extension that might vary\n> specifically for them, such as the server name. They don't have\n> insight into anything else, so clients need to make padding decisions\n> based on local configuration.)\n> \n> @sftcd, what do you think?\n\nCould live with it, but still prefer no server config.\nI'm looking a bit at some numbers and will try make a\nconcrete suggestion later today. If I don't get that\ndone, it seems fair to accept @davidben's algo and move\non.\n\nCheers,\nS.\n\n> \n",
          "createdAt": "2020-03-18T15:29:25Z",
          "updatedAt": "2020-03-18T15:29:25Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "If we can get away with no server config, I'm also entirely happy with that. Fewer moving parts is always great. We certainly could do that by saying names are padded up to 254, but I think that's too wasteful. But if we're happy with some global set of buckets that makes everyone happy (be it multiples of 16, some funny exponential thing), great!",
          "createdAt": "2020-03-18T15:57:47Z",
          "updatedAt": "2020-03-18T15:57:47Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n(trimming violently and responding slowly:-)\n\nOn 17/03/2020 22:02, David Benjamin wrote:\n> I'm thinking something along the lines of:\n\nSo your steps 1-6 is a better scheme than draft-06.\n\nI still think step 2 would be better as something like:\n\n2. ECHOConfig contains max_name_len as before but we\nRECOMMEND it be zero and a) if the name to be padded is\nlonger than max_name_len, then names will be padded as\nfollows: P=32-(len(name)%32)+heads_or_tails*32, or b)\nif the name to be padded is shorter than max_name_len\nthen we just do as the server asked and pad to that\nlength.\n\nThat (hopefully:-) means a default of \"pad out to the\nnext multiple of 32, then toss a coin and add another\n32 if the coin landed as heads.\"\n\nIf we landed somewhere there, I'd be happy to make this\nPR say that or to make a new one or whatever.\n\nAccording to some data I have the CDFs for names and\nfor these padded lengths would be as follows:\n\nLen, CDF, Padded-CDF\n32, 81.28, 40.64\n64, 97.87, 89.57\n96, 99.31, 98.59\n128, 99.87, 99.59\n\nThat means that 81.28 of names are <32 octets long\nand 40.64% of name+name_padding will be 32 octets\nlong. 97.87% of names are <64 octets and 89.57% of\nname+name_padding are 64 octets long.\n\nI think we should RECOMMEND setting max_name_len to\nzero unless an ESNI key generator has a specific\nreason to set it to a non-zero value. ISTM the use-case\nfor non-zero values is where the anonymity set has only\na few very long names that with length differences of\n>32 octets for which it is considered important to use\nECHO. I'm basically fine that we default to not\nserving that use-case wellmby default, as I don't\nbelieve it's real. (But I could be wrong;-)\n\n\nCheers,\nS.\n\n\n\n\n\n\n",
          "createdAt": "2020-03-20T11:34:52Z",
          "updatedAt": "2020-03-20T11:34:52Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Could the sender always pad their packets to at least 1200 bytes or something, using an encrypted extension in the ClientHello?\r\n\r\nI don't understand the focus on server input to a padding function that would ideally fill out one packet.",
          "createdAt": "2020-03-21T02:49:10Z",
          "updatedAt": "2020-03-21T06:31:55Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sftcd what's the value in adding zero or one 32B blocks after rounding? Why not just stick with what was done, say, in RFC8467? (We could make it read something like, \"clients may add zero or one blocks.\" Either way, I'm more or less fine with the suggested change. Would you mind updating this PR to match?)",
          "createdAt": "2020-03-22T16:31:39Z",
          "updatedAt": "2020-03-22T16:34:58Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I don't understand the focus on server input to a padding function that would ideally fill out one packet.\r\n\r\nPer [David's comment](https://github.com/tlswg/draft-ietf-tls-esni/pull/209#issuecomment-600322366) above, clients *could* use help from servers in choosing appropriate padding lengths. (Only servers know their name anonymity set.)",
          "createdAt": "2020-03-22T16:33:49Z",
          "updatedAt": "2020-03-22T16:33:49Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\nHiya,\n\nOn 22/03/2020 16:32, Christopher Wood wrote:\n> @sftcd what's the value in adding zero or one 32B blocks after\n> rounding? Why not just stick with what was done, say, in RFC8467?\n>\n\nSay if the anonymity set has lots of names <32 length\n(~81% of names in the data I have) but a small number\nbetween 32 and 64 (~16% in my data). Then this should\ndisguise the use of the longer names at the expense\nof sending more octets. Would be v. happy to know if\nthat made sense to others.\n\nCheers,\nS.\n\n",
          "createdAt": "2020-03-22T16:39:07Z",
          "updatedAt": "2020-03-22T16:39:07Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\nA friendly amendment below (but one I think is\nimportant)...\n\nOn 22/03/2020 16:34, Christopher Wood wrote:\n>> I don't understand the focus on server input to a padding function\n>> that would ideally fill out one packet.\n> \n> Per [David's\n> comment](https://github.com/tlswg/draft-ietf-tls-esni/pull/209#issuecomment-600322366)\n> above, clients *could* use help from servers in choosing appropriate\n> padding lengths. (Only servers know their name anonymity set.)\n> \n\nI think that last really needs to be \"Only servers can know\ntheir name anonymity set. But many servers will not know\nthat, either due to wildcard certs or because names/vhosts\nare added and removed all the time independent of whatever\nis in the DNS.\"\n\nCheers,\nS.\n",
          "createdAt": "2020-03-22T16:41:47Z",
          "updatedAt": "2020-03-22T16:41:47Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Would be v. happy to know if that made sense to others.\r\n\r\nIt makes sense, I'm just not not sure it's worth the cost. That said, this will always be an imperfect solution, so I'm happy either way.\r\n",
          "createdAt": "2020-03-22T16:44:11Z",
          "updatedAt": "2020-03-22T16:44:20Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 22/03/2020 16:44, Christopher Wood wrote:\n>> Would be v. happy to know if that made sense to others.\n> \n> It makes sense, I'm just not not sure it's worth the cost. \n\nYep. Me neither. It is cheaper than padding to 254 octets\nfor everyone though;-)\n\nPartly, I'm not that sympathetic towards anyone who\nwants to hide a crazily-long server_name. OTOH, I guess\nthere may be a few who can't easily change names so we\nprobably ought try do something for 'em.\n\nCheers,\nS.\n\n> That said,\n> this will always be an imperfect solution, so I'm happy either way.\n> \n> \n",
          "createdAt": "2020-03-22T16:48:26Z",
          "updatedAt": "2020-03-22T16:48:26Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > I don't understand the focus on server input to a padding function that would ideally fill out one packet.\r\n> \r\n> Per [David's comment](https://github.com/tlswg/draft-ietf-tls-esni/pull/209#issuecomment-600322366) above, clients _could_ use help from servers in choosing appropriate padding lengths. (Only servers know their name anonymity set.)\r\n\r\nAgree that only servers could know their name anonymity set. But what is the cost of always padding out the ClientHello so it approaches the MTU? Just trying to understand why the spec attempts to economize on the number of bytes in the ClientHello packet.",
          "createdAt": "2020-03-24T00:19:13Z",
          "updatedAt": "2020-03-24T00:19:13Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> But what is the cost of always padding out the ClientHello so it approaches the MTU?\r\n\r\nAs far as I know, there's no reason other than folks might not want to always \"waste\" these bytes.",
          "createdAt": "2020-03-24T20:34:31Z",
          "updatedAt": "2020-03-24T20:34:31Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Padding the ClientHello up to an MTU isn't free. See the numbers here on what a 400-byte increase costs.\r\nhttps://www.imperialviolet.org/2018/04/11/pqconftls.html\r\n\r\nLikewise, also from that post and a [later experiment](https://www.imperialviolet.org/2019/10/30/pqsivssl.html), post-quantum key shares will likely exceed a packet anyway. I think our padding scheme should be designed with that expectation in mind (e.g., the `minimum_inner_length` mechanism fails this because a PQ key share in the inner ClientHello will blow past the built-in server assumptions on client behavior). Canary builds of Chrome already have code for such a thing behind a flag.\r\n\r\nEdit: Added a link to the later experiment, which I'd forgotten was a separate post.",
          "createdAt": "2020-03-24T21:04:12Z",
          "updatedAt": "2020-03-24T21:07:37Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Padding the ClientHello up to an MTU isn't free. See the numbers here on what a 400-byte increase costs.\r\n> https://www.imperialviolet.org/2018/04/11/pqconftls.html\r\n\r\nIt's not quite clear what's going on in those results. For example, the mobile results are close to zero. Without seeing confidence intervals, and the distributions of the full packet sizes, I don't think this experiment settles this issue (although it could, with more detail). Also, is there a theory on /why/ 400 bytes might add latency?\r\n\r\n> Likewise, also from that post and a [later experiment](https://www.imperialviolet.org/2019/10/30/pqsivssl.html), post-quantum key shares will likely exceed a packet anyway. \r\n\r\nIf we're going to design the padding mechanism with PQ key shares in mind, but not conventional ones, that should be in the document.\r\n",
          "createdAt": "2020-03-25T03:49:27Z",
          "updatedAt": "2020-03-25T03:49:27Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> It's not quite clear what's going on in those results. For example, the mobile results are close to zero. Without seeing confidence intervals, and the distributions of the full packet sizes, I don't think this experiment settles this issue (although it could, with more detail). Also, is there a theory on /why/ 400 bytes might add latency?\r\n\r\n@agl would know the details of that experiment, but I don't think the idea that sending more bytes takes more time would be terribly surprising! :-P\r\n\r\n> If we're going to design the padding mechanism with PQ key shares in mind, but not conventional ones, that should be in the document.\r\n\r\nI don't think anyone's suggested designing without conventional key shares in mind. They are what's deployed today, after all. However, we shouldn't design *only* for a small unpadded ClientHello. PQ key shares will need larger ones. Session tickets also go in the ClientHello, and it's common for TLS servers to stick client certificates inside tickets, so you can already get large ones today already.",
          "createdAt": "2020-03-25T18:06:08Z",
          "updatedAt": "2020-03-25T18:06:08Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > It's not quite clear what's going on in those results. For example, the mobile results are close to zero. Without seeing confidence intervals, and the distributions of the full packet sizes, I don't think this experiment settles this issue (although it could, with more detail). Also, is there a theory on /why/ 400 bytes might add latency?\r\n> \r\n> @agl would know the details of that experiment, but I don't think the idea that sending more bytes takes more time would be terribly surprising! :-P\r\n\r\nLet's assume the results for \"SI\" in the first link actually do show a significant delta. The question is whether per-packet costs dominate or per-byte costs do, and whether the experiment sometimes increased the number of packets (e.g. by sometimes bumping the ultimate ClientHello size above 1280). See Section 5.1 in https://www.usenix.org/system/files/conference/atc12/atc12-final186.pdf for device performance metrics on bytes vs packets.\r\n\r\nLooking at the ClientHello traffic on my computer, I can see that Safari is sending ClientHello messages that are about 500-600 bytes. My copy of Chrome seems to be sending CurveCECPQ2 (16696?) shares, and its ClientHello messages are fragmented.",
          "createdAt": "2020-03-25T19:36:23Z",
          "updatedAt": "2020-03-25T19:36:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sftcd will you be able to update this as above?",
          "createdAt": "2020-03-27T17:42:48Z",
          "updatedAt": "2020-03-27T17:42:48Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "would the spec allow me to put an arbitrarily-sized extension in the encrypted part of the ClientHello? if so, I don't care about the padding schemes.",
          "createdAt": "2020-03-29T05:32:52Z",
          "updatedAt": "2020-03-29T05:32:52Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> would the spec allow me to put an arbitrarily-sized extension in the encrypted part of the ClientHello? if so, I don't care about the padding schemes.\r\n\r\nYes, of course! The padding policies described here are guidance at best.",
          "createdAt": "2020-03-29T15:39:55Z",
          "updatedAt": "2020-03-29T15:39:55Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "I've updated the PR to try reflect the discussion above. Please take a peek and see if it seems useful now.",
          "createdAt": "2020-04-02T13:53:26Z",
          "updatedAt": "2020-04-02T13:53:26Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This looks like the right idea. I'll review this again as well, but it's probably better to wait for @chris-wood's suggestions to be addressed.",
          "createdAt": "2020-04-04T21:17:46Z",
          "updatedAt": "2020-04-04T21:17:46Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for all the changes Chris. I think I've actioned all those as requested. If not, I tried, but failed:-)",
          "createdAt": "2020-04-04T21:33:38Z",
          "updatedAt": "2020-04-04T21:33:38Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sftcd do you need any help moving this forward?",
          "createdAt": "2020-04-07T13:46:51Z",
          "updatedAt": "2020-04-07T13:46:51Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 07/04/2020 14:47, Christopher Wood wrote:\n> @sftcd do you need any help moving this forward?\n>\nDoing other stuff today but feel free to take the text\nand then do more edits. Or I can look at it tomorrow.\nEither's fine by me.\n\nS.\n",
          "createdAt": "2020-04-07T13:51:12Z",
          "updatedAt": "2020-04-07T13:51:12Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> On 07/04/2020 14:47, Christopher Wood wrote: @sftcd do you need any help moving this forward?\r\n> Doing other stuff today but feel free to take the text and then do more edits. \r\n\r\nThanks for taking the time. None of my comments are strongly-held opinions (meaning they only need to be addressed at all if others agree that the issues are important).\r\n\r\n",
          "createdAt": "2020-04-08T00:02:47Z",
          "updatedAt": "2020-04-08T00:02:47Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Strong +1 to @sayrer -- thank you for the work here, @sftcd!",
          "createdAt": "2020-04-08T00:27:26Z",
          "updatedAt": "2020-04-08T00:27:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sftcd can you please resolve conflicts? @ekr @kazuho can you please review?",
          "createdAt": "2020-04-23T21:27:32Z",
          "updatedAt": "2020-04-23T21:27:32Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 24/04/2020 16:07, ekr wrote:\n> @ekr commented on this pull request.\n> \n> I am generally fine with this, with the exception of the random\n> padding, which I think should be omitted. It's hard to analyze and\n> the value is unclear. In particular, many clients will retry if they\n> receive TCP errors, and so the attacker can learn information about\n> the true minimum value by forging TCP RSTs and looking at the new\n> CH.\n\nFair point. The argument I'd make for keeping this\nis that if an anonymity set has ~80% of names <32\noctets, then if we do nothing, passive observation\nwill probably reveal when the server name is in\nthe longest ~20%. And I'd guess that only a few\nnames in that set would be popular/common, so we\ncould be giving away the game whenever an ECHO\nis 32 octets longer than the usual. The random\npadding could mitigate that passive attack but\nyes would be vulnerable to an active reset based\ncounter.\n\nI'd also be fine with just living with the issue\nin which case we might want to note that using\nECHO with uncommonly long names is a bad idea.\n\n> \n>> +and randomly add another 32 octets 50% of the time and then\n>> include that amount\n> +of additional padding.\n> \n> I actually don't think we should recommend the random padding. Let's\n> do the minimum here.\n> \n\n",
          "createdAt": "2020-04-24T15:15:50Z",
          "updatedAt": "2020-04-24T15:15:50Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's just drop the random addition. Servers don't (can't) do a padding check anyway, so clients can always choose to make this longer if desired.",
          "createdAt": "2020-04-24T16:38:05Z",
          "updatedAt": "2020-04-24T16:38:05Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sftcd can you update this PR and resolve the conflicts?",
          "createdAt": "2020-04-24T16:38:18Z",
          "updatedAt": "2020-04-24T16:38:18Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "\"Fair point. The argument I'd make for keeping this\r\nis that if an anonymity set has ~80% of names <32\r\noctets, then if we do nothing, passive observation\r\nwill probably reveal when the server name is in\r\nthe longest ~20%. \"\r\n\r\nWhich is precisely why we want the server to provide the longest name, so the client can pad to it.\r\n",
          "createdAt": "2020-04-24T16:52:49Z",
          "updatedAt": "2020-04-24T16:52:49Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed on today's call, let's do the following:\r\n\r\n1. Resolve merge conflicts.\r\n2. Drop random padding for the SNI. And add text which says that if the client's name is larger than max_name_length, it rounds up to the nearest 32B or 64B boundary.\r\n\r\n@sftcd do you need, or would you like, any help with this?",
          "createdAt": "2020-04-27T21:49:56Z",
          "updatedAt": "2020-04-27T21:49:56Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0ODUwNDM4",
          "commit": {
            "abbreviatedOid": "18d5638"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I think that this approach is generally better, but it runs afoul of divergence in client configuration that could dominate the calculation.  For instance, a client that sends two key shares will have very different padding requirements to one that sends only one.  For that to work, we need to assume that implementation-/deployment-specific variation of the inner CH is largely eliminated as a result of the compression scheme we adopt.  That also assumes that these variations in client behaviour are not privacy-sensitive.  \r\n\r\nI think that we should be directly acknowledging those assumptions if that is indeed the case.\r\n\r\nIf there is a significant variation in size due to client-specific measures, then we're in a bit of an awkward position.  That might render any similarly simple scheme ineffective.  For instance, a client that later supports a set of ALPN identifiers that could vary in length depending on context cannot use this signal directly. It has to apply its own logic about the padding of that extension.  That a client is doing this won't be known to a server that deploys this today. In that case, the advice from the server (which knows most about the anonymity set across which it is hoping to spread the resulting CH), isn't going to be forced through an additional filter at the client.  The results are unlikely to be good without a great deal of care.",
          "createdAt": "2020-03-16T00:11:26Z",
          "updatedAt": "2020-03-16T00:23:38Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "```suggestion\r\nthe plaintext is at least this long.\r\n```",
              "createdAt": "2020-03-16T00:11:27Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 42,
              "body": "```suggestion\r\nGiven that extensions could be defined in the future that reveal sensitive information\r\nthrough their length, we cannot describe all the ways in which length information\r\n```",
              "createdAt": "2020-03-16T00:13:15Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 54,
              "body": "```suggestion\r\n  of the plaintext encoding of ClienHelloInner is greater than\r\n```",
              "createdAt": "2020-03-16T00:14:05Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 59,
              "body": "What about the converse?  Is it an error to send something that is not padded to the minimum length?",
              "createdAt": "2020-03-16T00:14:43Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1Mjk4Mzk4",
          "commit": {
            "abbreviatedOid": "18d5638"
          },
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-16T14:58:33Z",
          "updatedAt": "2020-03-16T14:58:33Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "I think I'd say no, that's maybe better not treated as an error. But I could be convinced otherwise.",
              "createdAt": "2020-03-16T14:58:33Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NzA0OTQ0",
          "commit": {
            "abbreviatedOid": "9103fde"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for the update! This looks like generally what we want. I left some recommendations for editorial improvements. ",
          "createdAt": "2020-04-04T14:39:33Z",
          "updatedAt": "2020-04-04T15:13:08Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Could we move this paragraph to the security considerations? ",
              "createdAt": "2020-04-04T14:39:33Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 32,
              "body": "Could we move this content to its own sub-section, perhaps with the title, \"Recommended Padding Scheme,\" to reflect the fact that it's optional?",
              "createdAt": "2020-04-04T14:43:05Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 36,
              "body": "```suggestion\r\nFuture extensions could reveal sensitive information through their length. Consequently, \r\npadding should be flexible and support arbitrary extension changes. \r\n```",
              "createdAt": "2020-04-04T14:54:38Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 42,
              "body": "```suggestion\r\nThe target padding length of most ClientHello extensions can be determined without server help.\r\n```",
              "createdAt": "2020-04-04T14:55:28Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 48,
              "body": "```suggestion\r\nHowever, the \"server_name\" extension could benefit from server input (ECHOConfig.maximum_name_length). \r\nClients SHOULD compute the padding for this extension as follows:\r\n\r\n1. If ECHOConfig.maximum_name_length is longer than the actual server_name then \r\nclients SHOULD add padding to make up that difference.\r\n2. Otherwise, if ECHOConfig.maximum_name_length is zero or less than the length \r\nof the actual server_name then round the server_name up to a multiple of 32 octets \r\nand randomly add another 32 octets 50% of the time and then include that amount\r\nof additional padding.\r\n```",
              "createdAt": "2020-04-04T15:09:07Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 52,
              "body": "```suggestion\r\nThe amount of padding applied to the ClientHello is then computed as the sum of \r\nall per-extension padding values, rounded up to the nearest multiple of 32. \r\n(This additional rounding step aims to hide variance across different client\r\nimplementations.)\r\n```",
              "createdAt": "2020-04-04T15:09:19Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 58,
              "body": "```suggestion\r\nIn addition to padding ClientHelloInner, clients and servers will also need\r\nto pad all other handshake messages that have sensitive-length fields. For\r\nexample, if a client proposes ALPN values in ClientHelloInner, the\r\nserver-selected value will be returned in an EncryptedExtension, so that\r\nhandshake message also needs to be padded using TLS record layer padding.\r\n```",
              "createdAt": "2020-04-04T15:09:32Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 11,
              "body": "```suggestion\r\nadded or removed from the anonymity set during the lifetime of a particular\r\n```",
              "createdAt": "2020-04-04T15:10:29Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 42,
              "body": "Can we also merge this paragraph with the preceding one?",
              "createdAt": "2020-04-04T15:12:35Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NzYyMzQ2",
          "commit": {
            "abbreviatedOid": "d4fe6f3"
          },
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-04T21:59:52Z",
          "updatedAt": "2020-04-04T22:06:15Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "nit: this is a run-on sentence. Suggest breaking at \"...then this value can be set to zero. In that case, ...\"",
              "createdAt": "2020-04-04T21:59:52Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 42,
              "body": "Is this part right? Do clients need to consider padding for each field, or just the entire encrypted ClientHelloInner?",
              "createdAt": "2020-04-04T22:01:01Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 53,
              "body": "Suggest: \"add at least another 32 octets\".",
              "createdAt": "2020-04-04T22:03:44Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 75,
              "body": "Suggest: \"Variations in the length of the ClientHelloInner ciphertext...\"",
              "createdAt": "2020-04-04T22:05:44Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 64,
              "body": "Is there a good reference for \"TLS record layer padding\"? I think I know what this means, but it could be clearer.",
              "createdAt": "2020-04-04T22:05:49Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4MjgwMTEy",
          "commit": {
            "abbreviatedOid": "d4fe6f3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-06T14:02:29Z",
          "updatedAt": "2020-04-06T14:02:29Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "It's defined in Section 5.4 of RFC8446: https://tools.ietf.org/html/rfc8446#section-5.4",
              "createdAt": "2020-04-06T14:02:29Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4MjgwODI4",
          "commit": {
            "abbreviatedOid": "d4fe6f3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-06T14:03:14Z",
          "updatedAt": "2020-04-06T14:03:14Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Yep -- this is what was discussed way up above in this PR. ",
              "createdAt": "2020-04-06T14:03:14Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4ODk0ODM3",
          "commit": {
            "abbreviatedOid": "d4fe6f3"
          },
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-07T08:27:18Z",
          "updatedAt": "2020-04-07T08:27:18Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Ok, I will re-read this PR, since I don't get it.\r\n\r\nBut, even so, I think this section needs a rationale. It says \"clients need to determine how much to pad given the semantics of that field\", but there is no reason given.",
              "createdAt": "2020-04-07T08:27:18Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4OTAzODcx",
          "commit": {
            "abbreviatedOid": "d4fe6f3"
          },
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-07T08:39:05Z",
          "updatedAt": "2020-04-07T08:39:06Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "Maybe that reference suggests a terminology issue. It says \"All encrypted TLS records can be padded to inflate the size of the TLSCiphertext.\" Does ECHO define things in terms of TLSCiphertext?\r\n\r\nI don't necessarily think there is a problem here, but in the two code bases I've read (rustls and NSS), the encrypted SNI or ClientHello haven't fit in all that cleanly.\r\n\r\nIt seems like the properties of the ClientHelloInner encryption are bit hand-wavy. I understand what's trying to be accomplished (and support that effort), but I think more explanatory text could be called for.\r\n",
              "createdAt": "2020-04-07T08:39:05Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5MDYwMTA0",
          "commit": {
            "abbreviatedOid": "d4fe6f3"
          },
          "author": "jhoyla",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-07T12:22:06Z",
          "updatedAt": "2020-04-07T12:28:11Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Or \"add one or more blocks of 32 octets\" just to exclude behaviours that undo the effect of rounding the padding to a multiple of 32 octets.  ",
              "createdAt": "2020-04-07T12:22:06Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            },
            {
              "originalPosition": 109,
              "body": "Do we need to update GREASE if we are rounding the packet sizes to multiples of 32 octets? If we want GREASE to look like ECHO then it should have the same external properties. ",
              "createdAt": "2020-04-07T12:26:53Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5MTE3OTc2",
          "commit": {
            "abbreviatedOid": "d4fe6f3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-07T13:31:42Z",
          "updatedAt": "2020-04-07T13:31:42Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "\ud83d\udc4d to N >= 1 blocks. Clients can choose the distribution from which they want to sample N.",
              "createdAt": "2020-04-07T13:31:42Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5MTMxODI2",
          "commit": {
            "abbreviatedOid": "d4fe6f3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-07T13:46:36Z",
          "updatedAt": "2020-04-07T13:46:36Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "Yep -- there's a TODO in the GREASE section.",
              "createdAt": "2020-04-07T13:46:36Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5MTQzMzQ5",
          "commit": {
            "abbreviatedOid": "d4fe6f3"
          },
          "author": "jhoyla",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-07T13:58:26Z",
          "updatedAt": "2020-04-07T13:58:27Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "On second thoughts, we should probably match what's done in encrypted DNS, because otherwise we could create a potential leak from correlating the DNS request length with the ECHO length. ",
              "createdAt": "2020-04-07T13:58:26Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxODg3NzEw",
          "commit": {
            "abbreviatedOid": "d4fe6f3"
          },
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-12T19:19:52Z",
          "updatedAt": "2020-04-12T19:19:52Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "I moved that rationale down to the security considerations section as suggested earlier. It could be moved back up, but basically anything where the length could be sensitive may need padding.",
              "createdAt": "2020-04-12T19:19:52Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxODg4MjQx",
          "commit": {
            "abbreviatedOid": "d4fe6f3"
          },
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-12T19:27:03Z",
          "updatedAt": "2020-04-12T19:27:04Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Don't think copying DNS is correct. RFC 8467 calls for queries to be padded to a multiple of 128 octets and could be that the server-name is not the only sensitive name. \r\n\r\nI'm not sure there's a point in recommending against zero additional blocks of 32 - so long as you don't do zero too often it'd be ok. If you look back to the name lengths seen in the data I have it may be that zero additional blocks 50% of the time is ok. \r\n\r\nBut mainly, I'd say we may be better to wait 'till we have a few implementations and then see what makes best sense.",
              "createdAt": "2020-04-12T19:27:04Z",
              "updatedAt": "2020-04-12T19:30:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxODk5MTAz",
          "commit": {
            "abbreviatedOid": "abd6637"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-12T22:09:36Z",
          "updatedAt": "2020-04-12T22:09:36Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "> Don't think copying DNS is correct. RFC 8467 calls for queries to be padded to a multiple of 128 octets and could be that the server-name is not the only sensitive name.\r\n\r\nCan you show that there is no information leakage if the two aren't in sync?\r\n\r\n> I'm not sure there's a point in recommending against zero additional blocks of 32 - so long as you don't do zero too often it'd be ok. If you look back to the name lengths seen in the data I have it may be that zero additional blocks 50% of the time is ok.\r\n\r\nThe proposal above suggests N >= 1, not zero. In any case, as you suggest, spinning our wheels on something for which there is no backing data or analysis (yet) seems premature.",
              "createdAt": "2020-04-12T22:09:36Z",
              "updatedAt": "2020-04-12T22:09:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5NTQ0NTky",
          "commit": {
            "abbreviatedOid": "d4fe6f3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-23T23:26:45Z",
          "updatedAt": "2020-04-23T23:26:45Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Hmm, is this resolved?",
              "createdAt": "2020-04-23T23:26:45Z",
              "updatedAt": "2020-04-23T23:26:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMDMwMTE3",
          "commit": {
            "abbreviatedOid": "abd6637"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I am generally fine with this, with the exception of the random padding, which I think should be omitted. It's hard to analyze and the value is unclear. In particular, many clients will retry if they receive TCP errors, and so the attacker can learn information about the true minimum value by forging TCP RSTs and looking at the new CH.",
          "createdAt": "2020-04-24T15:05:26Z",
          "updatedAt": "2020-04-24T15:07:01Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "I actually don't think we should recommend the random padding. Let's do the minimum here.",
              "createdAt": "2020-04-24T15:05:26Z",
              "updatedAt": "2020-04-24T15:07:01Z"
            }
          ]
        }
      ]
    },
    {
      "number": 210,
      "id": "MDExOlB1bGxSZXF1ZXN0MzkxMTE4OTgz",
      "title": "Fix lingering encrypted_server_name extension references.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/210",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-19T16:50:19Z",
      "updatedAt": "2020-03-19T16:50:56Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "db1d9a793c0640f03750612a4fd2be7bfe8f30b5",
      "headRepository": "chris-wood/draft-ietf-tls-esni",
      "headRefName": "caw/nits",
      "headRefOid": "fd4d0004abb16ecc0ec50b73019d5cae342d64ed",
      "closedAt": "2020-03-19T16:50:56Z",
      "mergedAt": "2020-03-19T16:50:56Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "9dab0e191c85d2043a5a5c835fae0abed30625da"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 211,
      "id": "MDExOlB1bGxSZXF1ZXN0MzkyNDczNzIz",
      "title": "Remove OPEN ISSUE regarding an explicit ECHO negotiated signal.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/211",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-23T15:57:23Z",
      "updatedAt": "2021-04-19T15:52:02Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9dab0e191c85d2043a5a5c835fae0abed30625da",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/require-trial-decryption",
      "headRefOid": "f9ec40b7d40313da6a4da55abb5d9fca39e56696",
      "closedAt": "2020-03-24T21:26:14Z",
      "mergedAt": "2020-03-24T21:26:14Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "4f57a871f670c2b291652ed5bca4c77ec5913f19"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 212,
      "id": "MDExOlB1bGxSZXF1ZXN0MzkyNTY5NDA2",
      "title": "Bind CHOuter to CHInner",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/212",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This makes it so that changes to the outer CH do not affect the inner. If anything does change that might muck with the binder or decryption, then ECHO is ignored. (This should help GREASE.)",
      "createdAt": "2020-03-23T18:43:59Z",
      "updatedAt": "2021-04-19T15:52:03Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9dab0e191c85d2043a5a5c835fae0abed30625da",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/outer-binder",
      "headRefOid": "0c351a6651eb9b2319b5c3e97b82a2226417e713",
      "closedAt": "2020-05-20T15:59:57Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5NzY5Nzky",
          "commit": {
            "abbreviatedOid": "867f908"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-23T19:47:56Z",
          "updatedAt": "2020-03-23T19:47:56Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Just noticed this \"and and\"",
              "createdAt": "2020-03-23T19:47:56Z",
              "updatedAt": "2020-03-23T20:18:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5Nzg5NTcz",
          "commit": {
            "abbreviatedOid": "867f908"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-23T20:17:28Z",
          "updatedAt": "2020-03-23T20:17:28Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Thanks :)",
              "createdAt": "2020-03-23T20:17:28Z",
              "updatedAt": "2020-03-23T20:18:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwNzM1MzU0",
          "commit": {
            "abbreviatedOid": "0c351a6"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-24T22:14:14Z",
          "updatedAt": "2020-03-24T22:21:13Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "This probably wants an extra sentence that you add the identity and binder to the PSK extension. At first I was confused what you did with the binder.",
              "createdAt": "2020-03-24T22:14:15Z",
              "updatedAt": "2020-03-24T22:21:13Z"
            },
            {
              "originalPosition": 43,
              "body": "(Hah. Nice!)",
              "createdAt": "2020-03-24T22:20:47Z",
              "updatedAt": "2020-03-24T22:21:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 213,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAwMTY3MDgz",
      "title": "README: fix links to WG docs",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/213",
      "state": "MERGED",
      "author": "Lekensteyn",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-04-07T10:03:56Z",
      "updatedAt": "2020-04-13T15:04:03Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "4f57a871f670c2b291652ed5bca4c77ec5913f19",
      "headRepository": "Lekensteyn/draft-ietf-tls-esni",
      "headRefName": "pwu/readme-fixes",
      "headRefOid": "0106d1fe3ee5b249ff67fe883fa64c05d3a43e65",
      "closedAt": "2020-04-13T15:04:03Z",
      "mergedAt": "2020-04-13T15:04:03Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "fef6612491aca10725d7ca7f9e1b7a3af8af5aa0"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 221,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA2NjQ4ODE0",
      "title": "Rearrange sentences for better readability",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/221",
      "state": "MERGED",
      "author": "d1vyank",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-04-21T12:41:38Z",
      "updatedAt": "2020-04-24T18:55:04Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "fef6612491aca10725d7ca7f9e1b7a3af8af5aa0",
      "headRepository": "d1vyank/draft-ietf-tls-esni",
      "headRefName": "master",
      "headRefOid": "bdab7ede73b13362fff475c8f7783e8578ade1a6",
      "closedAt": "2020-04-24T18:55:04Z",
      "mergedAt": "2020-04-24T18:55:04Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "6858521382b4c14d6ce1ef4d0b211eab90a45b63"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMTk1MjYx",
          "commit": {
            "abbreviatedOid": "bdab7ed"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-24T18:54:58Z",
          "updatedAt": "2020-04-24T18:54:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 222,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA3MDM5MzQ4",
      "title": "Fix outdated references to ESNIConfig",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/222",
      "state": "MERGED",
      "author": "d1vyank",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-04-22T04:33:39Z",
      "updatedAt": "2020-04-23T21:26:33Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "fef6612491aca10725d7ca7f9e1b7a3af8af5aa0",
      "headRepository": "d1vyank/draft-ietf-tls-esni",
      "headRefName": "nits",
      "headRefOid": "c0fff68851844847d14165fa0d1c1b6e75df5e0a",
      "closedAt": "2020-04-23T21:26:33Z",
      "mergedAt": "2020-04-23T21:26:33Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "188c6a13fe29f468762542aea79f33ccc08170e6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5NDg5MDk2",
          "commit": {
            "abbreviatedOid": "c0fff68"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-23T21:26:26Z",
          "updatedAt": "2020-04-23T21:26:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 224,
      "id": "MDExOlB1bGxSZXF1ZXN0NDEwMzE3ODA5",
      "title": "Replace ECHOConfig TLS ciphersuites with HPKE code points.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/224",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #218.\r\n\r\nA given ECHOConfig now lists a single HPKE public key, with the corresponding\r\nKEM identifier, and a list of acceptable AEAD and KDF algorithm identifiers.\r\nClients may then choose their preferred AEAD and KDF algorithms for ClientHello\r\nencryption.\r\n\r\nWe may need to provide some guidance, either here or in the HPKE document, about acceptable (KEM, KDF, AEAD) tuples. \r\n\r\ncc @bifurcation",
      "createdAt": "2020-04-28T19:36:29Z",
      "updatedAt": "2021-04-19T15:52:24Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "6858521382b4c14d6ce1ef4d0b211eab90a45b63",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/hpke-codepoints",
      "headRefOid": "e7c73326b7c507ef455a0edea3eb24fac73594ce",
      "closedAt": "2020-05-01T23:34:07Z",
      "mergedAt": "2020-05-01T23:34:07Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "1b80857a4c0c7c64c6b2deba4f58574209a25a92"
      },
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I hadn't realized these were separate IDs. Oh well.",
          "createdAt": "2020-05-01T23:33:47Z",
          "updatedAt": "2020-05-01T23:33:47Z"
        },
        {
          "author": "ocheron",
          "authorAssociation": "NONE",
          "body": "HpkeCipherSuite should also be used in ClientEncryptedCH.",
          "createdAt": "2020-05-04T20:26:10Z",
          "updatedAt": "2020-05-04T20:26:10Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Oops -- thanks, @ocheron! Fixed here: https://github.com/tlswg/draft-ietf-tls-esni/pull/231.",
          "createdAt": "2020-05-04T20:38:16Z",
          "updatedAt": "2020-05-04T20:38:25Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 225,
      "id": "MDExOlB1bGxSZXF1ZXN0NDEyMzg0NTYz",
      "title": "Deterministic padding",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/225",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This builds on #209, but removes the probabilistic pieces. I created a fresh PR to make review easier. \r\n\r\ncc @sftcd",
      "createdAt": "2020-05-02T02:04:54Z",
      "updatedAt": "2021-04-19T15:52:22Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1b80857a4c0c7c64c6b2deba4f58574209a25a92",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/padding",
      "headRefOid": "fd78562ba6c9b8f6dd088ce51539dd2af461a04e",
      "closedAt": "2020-05-03T23:58:40Z",
      "mergedAt": "2020-05-03T23:58:40Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "2f891d33205621199ef8e946a6416a9bee470006"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjU1MDI3",
          "commit": {
            "abbreviatedOid": "4cc7421"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-05-03T20:35:28Z",
          "updatedAt": "2020-05-03T20:41:35Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "This text seems a bit confusing because clients typically offer a fixed set of ALPNs for a given application.  Perhaps:\r\n\r\n\"Clients typically support a small number of application profiles. For instance, a browser might support HTTP with ALPN values [\"http/1.1, \"h2\"] and WebRTC media with ALPNs [\"webrtc\", \"c-webrtc\"]. Clients SHOULD pad this extension by rounding up to the total size of the longest ALPN extension across all application profiles\".\r\n",
              "createdAt": "2020-05-03T20:35:28Z",
              "updatedAt": "2020-05-03T23:54:28Z"
            },
            {
              "originalPosition": 78,
              "body": "Say we just padded SNI and L = 0 and D = 10. We then compute the per-extension padding value as 22, but because of this paragraph we pad by 32? If so, I don't think this works, because if D was 11, we would also pad by 32, so now we are leaking the length of D.",
              "createdAt": "2020-05-03T20:40:26Z",
              "updatedAt": "2020-05-03T23:54:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjYzNzM3",
          "commit": {
            "abbreviatedOid": "4cc7421"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-03T22:31:51Z",
          "updatedAt": "2020-05-03T22:31:51Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "Discussed offline -- will remove and consider later on, as this exists to mask fixed-length values across different stacks, and fingerprinting stacks is already pretty trivial.",
              "createdAt": "2020-05-03T22:31:51Z",
              "updatedAt": "2020-05-03T23:54:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjY0NDQ0",
          "commit": {
            "abbreviatedOid": "82e87bc"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2020-05-03T22:41:05Z",
          "updatedAt": "2020-05-03T22:41:05Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjcwMDEy",
          "commit": {
            "abbreviatedOid": "82e87bc"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-03T23:50:59Z",
          "updatedAt": "2020-05-03T23:50:59Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "This might be a little narrow a view.  In a browser, we have a bunch of things we might do.  But that is because the browser is platform.  But the anonymity set on a different platform (say you used the system TLS stack) is potentially wider (all apps) and cannot make the same claim about application profiles.",
              "createdAt": "2020-05-03T23:50:59Z",
              "updatedAt": "2020-05-03T23:54:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjcwMDcx",
          "commit": {
            "abbreviatedOid": "82e87bc"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-03T23:51:39Z",
          "updatedAt": "2020-05-03T23:53:50Z",
          "comments": [
            {
              "originalPosition": 74,
              "body": "```suggestion\r\nhint, i.e., ECHOConfig.maximum_name_length.\r\n```",
              "createdAt": "2020-05-03T23:51:39Z",
              "updatedAt": "2020-05-03T23:54:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjcwMjk3",
          "commit": {
            "abbreviatedOid": "82e87bc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-03T23:54:13Z",
          "updatedAt": "2020-05-03T23:54:13Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "The point is that the \"platform,\" be it the stack used in the browser or in the OS, typically defines the set of values here and should pad accordingly. I'm fine with using the browser as an example here, as it's just a specific instance of that platform.",
              "createdAt": "2020-05-03T23:54:13Z",
              "updatedAt": "2020-05-03T23:54:28Z"
            }
          ]
        }
      ]
    },
    {
      "number": 226,
      "id": "MDExOlB1bGxSZXF1ZXN0NDEyNTE0MTY4",
      "title": "Provide guidance on ECHOConfig extension usage.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/226",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This addresses #216.\r\n\r\ncc @davidben, @bemasc, @mikebishop, @sftcd, @enygren",
      "createdAt": "2020-05-02T22:01:51Z",
      "updatedAt": "2021-04-19T15:52:20Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1b80857a4c0c7c64c6b2deba4f58574209a25a92",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/ext-policy",
      "headRefOid": "de1eb1297d5f9375ae15586a8cb38cd2eb32ab98",
      "closedAt": "2020-05-07T18:43:32Z",
      "mergedAt": "2020-05-07T18:43:32Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f238f70420dbbab6085f959ce970e77d34e506e3"
      },
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This looks fine, though I'll note that since an HTTPSSVC record is public and the outer ClientHello record is public, it's not unreasonable to pull values from there to put in the public fields since the observer already knows (or can get) them.  Restricting them to come only from the ECHOConfig seems unnecessary.\r\n\r\nI think the key observation in this PR is that the outer ClientHello isn't _really_ offering to establish a TLS connection -- it's a not-crazy-looking wrapper for the actual ClientHello inside the ECHO extension, and the vehicle for the recovery flow.  The only things a server can legitimately do are respond to the inner ClientHello or do a recovery handshake.  Thus, most of the things you might set on the outer ClientHello are irrelevant; they can be chosen to look innocuous, chosen at random, or copied from the inner ClientHello as the implementation chooses.",
          "createdAt": "2020-05-04T18:55:14Z",
          "updatedAt": "2020-05-04T18:55:14Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@davidben, does this seem reasonable to you?",
          "createdAt": "2020-05-05T18:32:16Z",
          "updatedAt": "2020-05-05T18:32:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NTc0Mjgx",
          "commit": {
            "abbreviatedOid": "fc838d2"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-03T01:45:14Z",
          "updatedAt": "2020-05-03T01:45:14Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjY4MDgy",
          "commit": {
            "abbreviatedOid": "fc838d2"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-03T23:27:52Z",
          "updatedAt": "2020-05-03T23:30:25Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "features or protections",
              "createdAt": "2020-05-03T23:27:53Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            },
            {
              "originalPosition": 19,
              "body": "Comma",
              "createdAt": "2020-05-03T23:28:17Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            },
            {
              "originalPosition": 38,
              "body": "SHOULD? ",
              "createdAt": "2020-05-03T23:28:58Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            },
            {
              "originalPosition": 43,
              "body": "Except, as we have discussed, the length, though I guess that is a part of the outer, too.",
              "createdAt": "2020-05-03T23:30:20Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjcwNDA0",
          "commit": {
            "abbreviatedOid": "fc838d2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-03T23:55:10Z",
          "updatedAt": "2020-05-03T23:55:11Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Yep, I'm considering that part of the outer.",
              "createdAt": "2020-05-03T23:55:10Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjcwNDQ1",
          "commit": {
            "abbreviatedOid": "fc838d2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-03T23:55:40Z",
          "updatedAt": "2020-05-03T23:55:40Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Isn't protection a feature?",
              "createdAt": "2020-05-03T23:55:40Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjcwNjA0",
          "commit": {
            "abbreviatedOid": "fc838d2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-03T23:57:21Z",
          "updatedAt": "2020-05-03T23:57:22Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Will fix here and elsewhere!",
              "createdAt": "2020-05-03T23:57:22Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjcwNjI4",
          "commit": {
            "abbreviatedOid": "fc838d2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-03T23:57:39Z",
          "updatedAt": "2020-05-03T23:57:40Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I read them both the same, so that works for me.",
              "createdAt": "2020-05-03T23:57:40Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MTE0MzQ3",
          "commit": {
            "abbreviatedOid": "27dcc7b"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-05T20:03:20Z",
          "updatedAt": "2020-05-05T20:05:39Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "functionality?",
              "createdAt": "2020-05-05T20:03:20Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            },
            {
              "originalPosition": 66,
              "body": "Or, I guess, as ECHOConfigV2, right?",
              "createdAt": "2020-05-05T20:05:05Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            },
            {
              "originalPosition": 73,
              "body": "I'm not sure there is a need to be this directive here. Why not leave this for future work.\r\n\r\nAlso, hypothetically, suppose that the extension was like \"make the nonce twice as long\"\r\n\r\n",
              "createdAt": "2020-05-05T20:05:34Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MTE5MzMz",
          "commit": {
            "abbreviatedOid": "27dcc7b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-05T20:11:05Z",
          "updatedAt": "2020-05-05T20:11:06Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Functionality is a bit more general -- let's go with that!",
              "createdAt": "2020-05-05T20:11:06Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MTIyNjY1",
          "commit": {
            "abbreviatedOid": "27dcc7b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-05T20:16:04Z",
          "updatedAt": "2020-05-05T20:16:04Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "Yeah, I'll add that: \"as ECHOConfig extensions, or an entirely new version of ECHOConfig.\"",
              "createdAt": "2020-05-05T20:16:04Z",
              "updatedAt": "2020-05-05T20:29:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MTMzMDI2",
          "commit": {
            "abbreviatedOid": "de1eb12"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-05T20:32:14Z",
          "updatedAt": "2020-05-05T20:32:15Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "That's fair (and a good point). It is a bit... restrictive. I just removed the sentence.",
              "createdAt": "2020-05-05T20:32:15Z",
              "updatedAt": "2020-05-05T20:32:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3NzM4NDA3",
          "commit": {
            "abbreviatedOid": "de1eb12"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Seems reasonable.",
          "createdAt": "2020-05-07T18:41:03Z",
          "updatedAt": "2020-05-07T18:41:03Z",
          "comments": []
        }
      ]
    },
    {
      "number": 227,
      "id": "MDExOlB1bGxSZXF1ZXN0NDEyNTE2Mzc3",
      "title": "Clarify \"do not stick out\" signals.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/227",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #215.\r\n\r\ncc @grittygrease ",
      "createdAt": "2020-05-02T22:23:28Z",
      "updatedAt": "2021-04-19T15:52:22Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1b80857a4c0c7c64c6b2deba4f58574209a25a92",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/signals",
      "headRefOid": "6285d8fc9f4268146fdc6a4ae71f2589021c8641",
      "closedAt": "2020-05-05T20:09:07Z",
      "mergedAt": "2020-05-05T20:09:07Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "1337c6915b0de26ddb98c4c44324d2572dead76f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MTE2MTQw",
          "commit": {
            "abbreviatedOid": "30f0e72"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-05T20:06:03Z",
          "updatedAt": "2020-05-05T20:06:36Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\nsignal indicating use or negotiation of ECHO. Clients MAY GREASE the\r\n```",
              "createdAt": "2020-05-05T20:06:04Z",
              "updatedAt": "2020-05-05T20:08:57Z"
            },
            {
              "originalPosition": 21,
              "body": "This sentence is pretty long. Also, I would not use \"suspicious\" but rather \"unusual\" or \"meaningful\"",
              "createdAt": "2020-05-05T20:06:32Z",
              "updatedAt": "2020-05-05T20:08:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MTE3NTQ5",
          "commit": {
            "abbreviatedOid": "63dccdc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-05T20:08:15Z",
          "updatedAt": "2020-05-05T20:08:15Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Will fix!",
              "createdAt": "2020-05-05T20:08:15Z",
              "updatedAt": "2020-05-05T20:08:57Z"
            }
          ]
        }
      ]
    },
    {
      "number": 228,
      "id": "MDExOlB1bGxSZXF1ZXN0NDEyNTE3MDc5",
      "title": "Clarify need for optional record digests.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/228",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #205.\r\n\r\ncc @huitema ",
      "createdAt": "2020-05-02T22:30:52Z",
      "updatedAt": "2021-04-19T15:52:23Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1b80857a4c0c7c64c6b2deba4f58574209a25a92",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/optional-digests",
      "headRefOid": "3fac6b33e11b9e7e88de96b6c2ca55eaba337598",
      "closedAt": "2020-05-03T14:05:08Z",
      "mergedAt": "2020-05-03T14:05:07Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "02b26097b42890c7273216c196b33d4050565920"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NTY2MTUy",
          "commit": {
            "abbreviatedOid": "3fac6b3"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Works for me.",
          "createdAt": "2020-05-02T22:45:05Z",
          "updatedAt": "2020-05-02T22:45:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 230,
      "id": "MDExOlB1bGxSZXF1ZXN0NDEyNTE4NDc0",
      "title": "Add information about per-client tracking via unique ECHOConfig structures",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/230",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #146.",
      "createdAt": "2020-05-02T22:45:49Z",
      "updatedAt": "2021-04-19T15:52:21Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1b80857a4c0c7c64c6b2deba4f58574209a25a92",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/tracking",
      "headRefOid": "e3df7ba582baa1cfdfd6e910d1b47bba0cc8ea4e",
      "closedAt": "2020-05-05T20:10:26Z",
      "mergedAt": "2020-05-05T20:10:25Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "e8f1fa948d271428e33493e962680fee4adca5e0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjY3NzE3",
          "commit": {
            "abbreviatedOid": "0f32404"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-03T23:23:19Z",
          "updatedAt": "2020-05-03T23:27:12Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "A paragraph break here might be good. You jump from description of the attack to a description of mitigating factors without segue. ",
              "createdAt": "2020-05-03T23:23:19Z",
              "updatedAt": "2020-05-05T20:10:17Z"
            },
            {
              "originalPosition": 13,
              "body": "I don't think the v6 example is good. And none of these are especially strong, except perhaps the DNS one. \r\n\r\nFor me, the question is how targeted the delivery could be, and whether the client can then do anything about that. For instance, a client might decide to flush its ECHO config cache if it moves and wants to be unlinkable.",
              "createdAt": "2020-05-03T23:27:07Z",
              "updatedAt": "2020-05-05T20:10:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjcxMDU0",
          "commit": {
            "abbreviatedOid": "0f32404"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-04T00:02:27Z",
          "updatedAt": "2020-05-04T00:02:27Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "@martinthomson I'll remove the last sentence, not because of v6 (which I do think is a good example), but because it can probably bite us in the future when someone does turn it into a threat. :)\r\n\r\nOn the latter points, how about the following:\r\n\r\nThe cost of this type of attack scales linearly with the desired number of target clients. DNS caching behavior makes targeting individual users for extended periods of time, e.g., using per-client ECHOConfig structures delivered via HTTPSSVC RRs with high TTLs, challenging. Moreover, clients can flush any ECHOConfig state upon changing networks to mitigate potential linkability problems.",
              "createdAt": "2020-05-04T00:02:27Z",
              "updatedAt": "2020-05-05T20:10:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MDA3MDA4",
          "commit": {
            "abbreviatedOid": "7a5943b"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-05T17:32:07Z",
          "updatedAt": "2020-05-05T17:32:08Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Is the thinking here that the client might have some ECHOConfig state outside the DNS cache, or is this just saying the client could flush its DNS cache on network change? An attacker that can distribute per-client ECHOConfigs in DNS could just as easily distribute per-client A/AAAA records in DNS. (Well, A may be hard due to address scarcity, but AAAA should be doable.) So if you're concerned about this attack, you probably want to treat this as a DNS-wide issue and drop the entire DNS cache.",
              "createdAt": "2020-05-05T17:32:07Z",
              "updatedAt": "2020-05-05T20:10:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MDE0ODc4",
          "commit": {
            "abbreviatedOid": "7a5943b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-05T17:42:41Z",
          "updatedAt": "2020-05-05T17:42:41Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Indeed -- in practice it'll likely be the entire cache. I didn't want to include other state (V4 or V6) to make any assumption on what the cache might contain, be it the DNS cache or something else. Is this just too generic for your taste?",
              "createdAt": "2020-05-05T17:42:41Z",
              "updatedAt": "2020-05-05T20:10:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MDIyMjAw",
          "commit": {
            "abbreviatedOid": "7a5943b"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-05T17:52:31Z",
          "updatedAt": "2020-05-05T17:52:31Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Mostly a clarifying question. Though perhaps we should say \"flushing any DNS state\" instead of flushing any ECHOConfig state\". Or perhaps \"flushing any DNS or ECHOConfig state\". Or maybe we leave it along because too many words. :-)",
              "createdAt": "2020-05-05T17:52:31Z",
              "updatedAt": "2020-05-05T20:10:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MDI4NTk2",
          "commit": {
            "abbreviatedOid": "7a5943b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-05T18:00:46Z",
          "updatedAt": "2020-05-05T18:00:47Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I'm fine with \"flushing any DNS or ECHOConfig state\"!",
              "createdAt": "2020-05-05T18:00:46Z",
              "updatedAt": "2020-05-05T20:10:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MDQyODY3",
          "commit": {
            "abbreviatedOid": "7a5943b"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-05T18:20:10Z",
          "updatedAt": "2020-05-05T18:20:10Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "SGTM",
              "createdAt": "2020-05-05T18:20:10Z",
              "updatedAt": "2020-05-05T20:10:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MTE2ODY5",
          "commit": {
            "abbreviatedOid": "bb6c1a3"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-05T20:07:13Z",
          "updatedAt": "2020-05-05T20:07:14Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nRRs with high TTLs, challenging. Clients can help mitigate this problem by\r\n```",
              "createdAt": "2020-05-05T20:07:13Z",
              "updatedAt": "2020-05-05T20:10:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MTE2OTEy",
          "commit": {
            "abbreviatedOid": "bb6c1a3"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-05T20:07:16Z",
          "updatedAt": "2020-05-05T20:07:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 231,
      "id": "MDExOlB1bGxSZXF1ZXN0NDEzMTcyMzA3",
      "title": "Fix remaining HPKE issues.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/231",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-05-04T20:38:06Z",
      "updatedAt": "2021-04-19T15:52:22Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "2f891d33205621199ef8e946a6416a9bee470006",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/hpke-nits",
      "headRefOid": "a5a9ce65e9e196c4e4584fd88c0768fbb8f1688b",
      "closedAt": "2020-05-04T20:38:32Z",
      "mergedAt": "2020-05-04T20:38:31Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f00e1f070cd55813ac56fc9f6c4ac22ab5cb5b56"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 234,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE2NDEyMjk1",
      "title": "Describe known active attacks",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/234",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #229.\r\n\r\nThis is for motivating some of our design decisions (and documenting what we know along the way). I meant to do this a while ago, but never got around to it. In particular, it describes why we have the following three bindings:\r\n\r\n1. Transcript to ECHO secret (to prevent client reaction attacks).\r\n2. CH1 to CH2 (to prevent HRR oracles).\r\n3. ClientHello to resumption PSK binder (to prevent resumption oracles).\r\n\r\nI'm *sure* the language and presentation can be improved, so suggestions to that effect are very much welcome!\r\n\r\ncc @martinthomson, @davidben, @dmcardle, @jhoyla, @kazuho, @karthikbhargavan, @grittygrease ",
      "createdAt": "2020-05-12T00:09:56Z",
      "updatedAt": "2021-04-19T15:52:19Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f238f70420dbbab6085f959ce970e77d34e506e3",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/active-attacks",
      "headRefOid": "df869d1ceac0fcfc951e710006cf078bb06dac3a",
      "closedAt": "2020-05-21T13:07:55Z",
      "mergedAt": "2020-05-21T13:07:55Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "1e7e0d9ef6fc33984240891b0f30cf139c45a193"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the feedback! I incorporated your suggestions and clarified a few more things. I'm merging as-is since they seemed mostly editorial.",
          "createdAt": "2020-05-21T13:07:32Z",
          "updatedAt": "2020-05-21T13:07:32Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1ODI4Mjk4",
          "commit": {
            "abbreviatedOid": "7eb76ae"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-05-21T01:53:59Z",
          "updatedAt": "2020-05-21T02:04:24Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "```suggestion\r\nThis section describes the rationale for ECHO properties and mechanics as defenses\r\n```",
              "createdAt": "2020-05-21T01:53:59Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            },
            {
              "originalPosition": 37,
              "body": "```suggestion\r\nagainst active attacks. In all the attacks below, the attacker is on-path between\r\n```",
              "createdAt": "2020-05-21T01:54:10Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            },
            {
              "originalPosition": 39,
              "body": "```suggestion\r\nabout the inner ClientHello, such as the true SNI value.\r\n```",
              "createdAt": "2020-05-21T01:54:24Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            },
            {
              "originalPosition": 43,
              "body": "```suggestion\r\nThis attack uses the client's reaction to an incorrect certificate as an oracle.\r\n```",
              "createdAt": "2020-05-21T01:54:52Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            },
            {
              "originalPosition": 44,
              "body": "```suggestion\r\nThe attacker intercepts a legitimate ClientHello and replies with a\r\n```",
              "createdAt": "2020-05-21T01:55:14Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            },
            {
              "originalPosition": 52,
              "body": "This isn't the attack I was thinking of. Rather, you withhold CV and so any client which does cert verification first will fail.",
              "createdAt": "2020-05-21T01:58:26Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            },
            {
              "originalPosition": 75,
              "body": "```suggestion\r\nto decrypt the Certificate and abort the connection.\r\n```",
              "createdAt": "2020-05-21T02:00:35Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            },
            {
              "originalPosition": 83,
              "body": "I think you need to say something about how this had to legitimately be an HRR case. Or can the attacker force it?",
              "createdAt": "2020-05-21T02:01:50Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            },
            {
              "originalPosition": 85,
              "body": "Note that this only works if the server (arguably incorrectly) stores the SNI from CH1.",
              "createdAt": "2020-05-21T02:02:27Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            },
            {
              "originalPosition": 85,
              "body": "```suggestion\r\nand HelloRetryRequest exchange with the result that the server encrypts the certificate to the attacker.\r\n```",
              "createdAt": "2020-05-21T02:02:57Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1ODM1MTA2",
          "commit": {
            "abbreviatedOid": "7eb76ae"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-21T02:17:25Z",
          "updatedAt": "2020-05-21T02:17:25Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "That seems like a different variation, so I'll just note it. Thanks!",
              "createdAt": "2020-05-21T02:17:25Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1ODM1MjE3",
          "commit": {
            "abbreviatedOid": "7eb76ae"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-21T02:17:49Z",
          "updatedAt": "2020-05-21T02:17:49Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "Good point. I'll call out that assumption explicitly.",
              "createdAt": "2020-05-21T02:17:49Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1ODM1Mjcy",
          "commit": {
            "abbreviatedOid": "7eb76ae"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-21T02:18:00Z",
          "updatedAt": "2020-05-21T02:18:00Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "Yep! I'll note that, too. ",
              "createdAt": "2020-05-21T02:18:00Z",
              "updatedAt": "2020-05-21T13:06:11Z"
            }
          ]
        }
      ]
    },
    {
      "number": 235,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE4Njg3Nzc4",
      "title": "Suggest size of GREASE encrypted_ch extension value.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/235",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This assumes the GREASE threat model is a misbehaving and lazy middlebox. That is, we aim to prevent ossification. It does nothing more to prevent an active attacker from learning whether or not a particular connection used GREASE. (That problem is probably better suited to something like MASQUE.)\r\n\r\ncc @davidben @ekr @martinthomson",
      "createdAt": "2020-05-15T16:29:25Z",
      "updatedAt": "2021-04-19T15:52:19Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f238f70420dbbab6085f959ce970e77d34e506e3",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/grease-size",
      "headRefOid": "cab69382afbc78bfd4df71f3004d1bc47017b303",
      "closedAt": "2020-05-20T15:58:32Z",
      "mergedAt": "2020-05-20T15:58:32Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "5005670f318da0a19868a8858dc4c473e8bc3825"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Merging for now. We can come back later and address followup extensions if needed!",
          "createdAt": "2020-05-20T15:58:28Z",
          "updatedAt": "2020-05-20T15:58:28Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyODA2NDQ1",
          "commit": {
            "abbreviatedOid": "cab6938"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-15T16:44:03Z",
          "updatedAt": "2020-05-15T16:44:03Z",
          "comments": []
        }
      ]
    },
    {
      "number": 236,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIxNTQ1NDg5",
      "title": "s/ECHO/ECH",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/236",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #232.",
      "createdAt": "2020-05-21T19:44:27Z",
      "updatedAt": "2021-04-19T15:52:18Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1e7e0d9ef6fc33984240891b0f30cf139c45a193",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/ech",
      "headRefOid": "4a37e99a9db136efe1941e2c54b962dbe6f72a77",
      "closedAt": "2020-05-21T19:49:50Z",
      "mergedAt": "2020-05-21T19:49:50Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "c4d4b7f531f85d72f7bb50755d1106f51287bfdc"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NDgyNjAw",
          "commit": {
            "abbreviatedOid": "4a37e99"
          },
          "author": "tfpauly",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-21T20:51:08Z",
          "updatedAt": "2020-05-21T20:51:09Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "TLS Encrypted ClientHello \u2014> TECH!\r\n\r\n(Kidding, kidding)",
              "createdAt": "2020-05-21T20:51:09Z",
              "updatedAt": "2020-05-21T20:51:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NTM4ODY0",
          "commit": {
            "abbreviatedOid": "4a37e99"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-21T22:36:29Z",
          "updatedAt": "2020-05-21T22:36:30Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Hah!",
              "createdAt": "2020-05-21T22:36:29Z",
              "updatedAt": "2020-05-21T22:36:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NjE2NDY3",
          "commit": {
            "abbreviatedOid": "4a37e99"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-22T02:52:55Z",
          "updatedAt": "2020-05-22T02:52:56Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Seeing this, I think that you should remove 1.3 from the title.  Sure, this is 1.3 only, but I think that this design is fine for 1.4 also.  If it isn't, I'm sure we can deal with that eventually.  I don't want to find that we ship a 1.4 (or 4) that is compatible with this and have people tell me that it isn't compatible.",
              "createdAt": "2020-05-22T02:52:56Z",
              "updatedAt": "2020-05-22T02:52:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NjIxNjQw",
          "commit": {
            "abbreviatedOid": "4a37e99"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-22T03:12:04Z",
          "updatedAt": "2020-05-22T03:12:05Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "That's a fair point. I'll make that change in a separate PR!",
              "createdAt": "2020-05-22T03:12:05Z",
              "updatedAt": "2020-05-22T03:12:05Z"
            }
          ]
        }
      ]
    },
    {
      "number": 238,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIzNDY3MjE4",
      "title": "Remove TLS 1.3 from the title, and re-categorize as a ST document.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/238",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Seeing no pushback on the list, this moves the draft from Experimental to ST.",
      "createdAt": "2020-05-26T21:14:10Z",
      "updatedAt": "2020-05-26T21:17:19Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "c4d4b7f531f85d72f7bb50755d1106f51287bfdc",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/retitle-and-recategorize",
      "headRefOid": "d86a8ea8f1c23a6d4e67f384c94dbad3dd3a4268",
      "closedAt": "2020-05-26T21:17:19Z",
      "mergedAt": "2020-05-26T21:17:19Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "a522e66aab86f9db0ce73edb999339887fa5a8ff"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4Njg0ODA0",
          "commit": {
            "abbreviatedOid": "a4fc9e8"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-26T21:15:34Z",
          "updatedAt": "2020-05-26T21:15:34Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "If we are going to change the title, let's make it match the abbrev\r\n\r\n\"TLS Encrypted Client Hello\"",
              "createdAt": "2020-05-26T21:15:34Z",
              "updatedAt": "2020-05-26T21:16:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4Njg0OTIx",
          "commit": {
            "abbreviatedOid": "a4fc9e8"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-26T21:15:45Z",
          "updatedAt": "2020-05-26T21:15:45Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4Njg1MzA4",
          "commit": {
            "abbreviatedOid": "a4fc9e8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-26T21:16:24Z",
          "updatedAt": "2020-05-26T21:16:24Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Works for me!",
              "createdAt": "2020-05-26T21:16:24Z",
              "updatedAt": "2020-05-26T21:16:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 239,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIzNDc1ODk1",
      "title": "Specify encrypted_client_hello and outer_extension codepoints.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/239",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Once we have some implementations that interop, we'll go ahead with early\r\ncodepoint allocation.\r\n\r\nThe new version matches -07, which will be the next draft version we submit.\r\n\r\ncc @martinthomson @grittygrease \r\n\r\nCloses #220.",
      "createdAt": "2020-05-26T21:34:38Z",
      "updatedAt": "2020-05-27T21:48:53Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "a522e66aab86f9db0ce73edb999339887fa5a8ff",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/codepoints",
      "headRefOid": "16070b4d44fdf7a350765ecbe65ef58fe495ba34",
      "closedAt": "2020-05-27T21:48:52Z",
      "mergedAt": "2020-05-27T21:48:52Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "37854299237b63b0731bfd7c2399cbe80f82d662"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 241,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI0MTMzOTIy",
      "title": "Remove stale TODOs.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/241",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The misrouting content no longer applies since the backend server sees the full CH, with the true SNI.",
      "createdAt": "2020-05-27T21:56:17Z",
      "updatedAt": "2021-04-19T15:52:14Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "37854299237b63b0731bfd7c2399cbe80f82d662",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/remove-stale-todos",
      "headRefOid": "32f9d2bff330bb426838540d239e54631c84f377",
      "closedAt": "2020-05-27T21:56:38Z",
      "mergedAt": "2020-05-27T21:56:38Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "24f09934836f920a0f883be65207afb6d40f67be"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 242,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI1NjA3MjQy",
      "title": "Revert to experimental codepoints.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/242",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We'll request early codepoints after we get some implementation experience.",
      "createdAt": "2020-05-31T12:50:33Z",
      "updatedAt": "2021-04-19T15:52:14Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "24f09934836f920a0f883be65207afb6d40f67be",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/exp-codepoints",
      "headRefOid": "bfaf546a247080946e0ecbf45c7d05ece047af34",
      "closedAt": "2020-05-31T18:45:45Z",
      "mergedAt": "2020-05-31T18:45:45Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ed0b844eb2742f2820b9bd6b5829f493c36e628f"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I have no objection to echo_nonce -> echo_nonce_value but did you mean to do it in this PR?\r\n\r\nYeah, as I was specifying the extension codepoint I noticed the collision between this variable, so I figured changing it here was best.",
          "createdAt": "2020-05-31T18:45:41Z",
          "updatedAt": "2020-05-31T18:45:41Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNTE2OTcw",
          "commit": {
            "abbreviatedOid": "bfaf546"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I have no objection to echo_nonce -> echo_nonce_value but did you mean to do it in this PR?",
          "createdAt": "2020-05-31T18:25:47Z",
          "updatedAt": "2020-05-31T18:25:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 243,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI3NTgxMDQ2",
      "title": "empty or random record digest for privacy",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/243",
      "state": "MERGED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed on the list, add a small bit of text in the section 10.3 to outline the behavior of clients seeking to protect server's privacy.",
      "createdAt": "2020-06-04T04:29:30Z",
      "updatedAt": "2020-06-04T23:51:37Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "ed0b844eb2742f2820b9bd6b5829f493c36e628f",
      "headRepository": "huitema/draft-ietf-tls-esni",
      "headRefName": "record-digest-privacy",
      "headRefOid": "acdf2cc48fdbc2b2ff47f103787c9efd0e6c5aef",
      "closedAt": "2020-06-04T23:51:36Z",
      "mergedAt": "2020-06-04T23:51:36Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "a40e95338385ef628cff3896ed61c31939143dd0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0OTAzMTE1",
          "commit": {
            "abbreviatedOid": "e04d483"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for clarifying! I suggested some language tweaks, but the core idea remains. ",
          "createdAt": "2020-06-04T23:30:47Z",
          "updatedAt": "2020-06-04T23:32:43Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "```suggestion\r\n\"encrypted_client_hello\" extension. In such settings, clients send \r\neither an empty record_digest or a randomly generated record_digest\r\nin the ClientEncryptedCH. (The precise implementation choice for this\r\nmechanism is out of scope for this document.) Servers in these settings \r\nmust perform trial decryption since they cannot identify the client's chosen \r\nECH key using the record_digest value. As a result, support for optional \r\nrecord digests may exacerbate DoS attacks.\r\n```",
              "createdAt": "2020-06-04T23:30:47Z",
              "updatedAt": "2020-06-04T23:48:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0OTExMjkz",
          "commit": {
            "abbreviatedOid": "acdf2cc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2020-06-04T23:51:32Z",
          "updatedAt": "2020-06-04T23:51:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 244,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI4MTEyNDE0",
      "title": "Fix typo of \"ClientHelloInner\".",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/244",
      "state": "MERGED",
      "author": "dmcardle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-06-04T21:57:51Z",
      "updatedAt": "2020-06-04T23:27:15Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "ed0b844eb2742f2820b9bd6b5829f493c36e628f",
      "headRepository": "dmcardle/draft-ietf-tls-esni",
      "headRefName": "master",
      "headRefOid": "5264fbf087a9c3c63f444562517522c2662588af",
      "closedAt": "2020-06-04T23:27:15Z",
      "mergedAt": "2020-06-04T23:27:15Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "3dca4fddac8ca04c430ef8348427241a67cca83b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0OTAwODQy",
          "commit": {
            "abbreviatedOid": "5264fbf"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-04T23:27:10Z",
          "updatedAt": "2020-06-04T23:27:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 246,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM2MDE3NDU1",
      "title": "Adopt new HTTPS RR name.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/246",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See https://datatracker.ietf.org/doc/draft-ietf-dnsop-svcb-https/. Hopefully this one sticks.",
      "createdAt": "2020-06-17T18:16:41Z",
      "updatedAt": "2021-04-19T15:52:13Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "a40e95338385ef628cff3896ed61c31939143dd0",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/https-rr",
      "headRefOid": "eb764befd43ec4a827757effb39449d7cf253d25",
      "closedAt": "2020-06-18T02:33:06Z",
      "mergedAt": "2020-06-18T02:33:06Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "cb08c09093b1c6119707516a93ea9a008dc47139"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 247,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM2MDI3OTY3",
      "title": "Expand text around security and privacy goals.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/247",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #245.",
      "createdAt": "2020-06-17T18:39:45Z",
      "updatedAt": "2021-04-19T15:52:12Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "a40e95338385ef628cff3896ed61c31939143dd0",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/expand-goals",
      "headRefOid": "2ce972f8b8236b16ea214fefb0ab925693097598",
      "closedAt": "2020-06-18T02:34:01Z",
      "mergedAt": "2020-06-18T02:34:01Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "675704cf71d2f090368a8dbbf5f50197519a1493"
      },
      "comments": [
        {
          "author": "sharpie7",
          "authorAssociation": "NONE",
          "body": "Thanks. The changes look to cover my point in #245.",
          "createdAt": "2020-06-18T08:48:35Z",
          "updatedAt": "2020-06-18T08:48:35Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNjkyMjAy",
          "commit": {
            "abbreviatedOid": "b59c873"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-17T19:03:01Z",
          "updatedAt": "2020-06-17T19:03:02Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Same ECHConfig is necessary, but not sufficient I think. If the hosts share an ECHConfig but have not other TLS config (the deleted paragraph above), the hosts are distinguishable. (I've lost track of whether the current level of ClientHello binding is sufficient to limit this to anonymity within the negotiated values or the full config...) The third paragraph mentions this, but it seems to be clarifying point (2), but point (2) doesn't actually imply this.",
              "createdAt": "2020-06-17T19:03:01Z",
              "updatedAt": "2020-06-17T19:21:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNjkzMjcz",
          "commit": {
            "abbreviatedOid": "b59c873"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-17T19:04:41Z",
          "updatedAt": "2020-06-17T19:04:41Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Fair :) I was trying to get away without too much text. I can clarify that this is necessary (and rework text accordingly).",
              "createdAt": "2020-06-17T19:04:41Z",
              "updatedAt": "2020-06-17T19:21:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNjk3MDU5",
          "commit": {
            "abbreviatedOid": "c48746c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-17T19:10:08Z",
          "updatedAt": "2020-06-17T19:10:08Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "@davidben, reworked. Please have another look!",
              "createdAt": "2020-06-17T19:10:08Z",
              "updatedAt": "2020-06-17T19:21:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNzAzNjU3",
          "commit": {
            "abbreviatedOid": "1630c00"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-17T19:19:50Z",
          "updatedAt": "2020-06-17T19:20:11Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Super nitpicky nitpick: we can probably trim the \"For example, [...]\" sentence down to:\r\n\r\nFor example, if a client-facing server services many backend origin hosts, only one of which supports some cipher suite, it may be possible to identify that host based on the contents of unencrypted handshake messages.\r\n\r\n(It's already giving an example, and being more specific uses fewer words.)",
              "createdAt": "2020-06-17T19:19:50Z",
              "updatedAt": "2020-06-17T19:21:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNzA0MzEx",
          "commit": {
            "abbreviatedOid": "1630c00"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-17T19:20:48Z",
          "updatedAt": "2020-06-17T19:20:49Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Works for me -- thanks!",
              "createdAt": "2020-06-17T19:20:49Z",
              "updatedAt": "2020-06-17T19:21:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 249,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQwMzA5MTgw",
      "title": "Move to Standards track.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/249",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-06-25T23:39:37Z",
      "updatedAt": "2021-04-19T15:51:44Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "675704cf71d2f090368a8dbbf5f50197519a1493",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/std",
      "headRefOid": "3b4fa8dbe997161eb2ab4eee5e7560c22ecd3fe1",
      "closedAt": "2020-06-27T15:50:41Z",
      "mergedAt": "2020-06-27T15:50:41Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ce728f09363ef83341d77ba6f7d9d9b2732bd053"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 250,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU5NDc3ODQ1",
      "title": "Fix typo caused by rename from ECHO to ECH.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/250",
      "state": "MERGED",
      "author": "orrc",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes a minor search/replace mistake in #236.",
      "createdAt": "2020-07-30T18:25:11Z",
      "updatedAt": "2020-07-31T00:14:24Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "ce728f09363ef83341d77ba6f7d9d9b2732bd053",
      "headRepository": "orrc/draft-ietf-tls-esni",
      "headRefName": "patch-1",
      "headRefOid": "b5bc766a6e44e430779032cf753d661ed61310da",
      "closedAt": "2020-07-31T00:11:28Z",
      "mergedAt": "2020-07-31T00:11:28Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "d322c0f5b695b623f8d0630df6e821ab2a00bae5"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Oops. :-)",
          "createdAt": "2020-07-31T00:11:24Z",
          "updatedAt": "2020-07-31T00:11:24Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4ODQyNjIy",
          "commit": {
            "abbreviatedOid": "b5bc766"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-31T00:11:18Z",
          "updatedAt": "2020-07-31T00:11:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 254,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY0ODIzNzk1",
      "title": "Lint the document",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/254",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR replaces \". \" (period followed by one space) with \".  \" (period followed by two spaces) and ensures each line is at most 80 characters. No other changes (editorial or otherwise) are intended.",
      "createdAt": "2020-08-07T20:54:36Z",
      "updatedAt": "2020-08-10T19:41:40Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "d322c0f5b695b623f8d0630df6e821ab2a00bae5",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "master",
      "headRefOid": "d322c0f5b695b623f8d0630df6e821ab2a00bae5",
      "closedAt": "2020-08-10T19:41:40Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 255,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY1Njk4MTgz",
      "title": "Lint",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/255",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This ensures that each paragraph line breaks at 80 characters. No other change is intended (editorial or otherwise).",
      "createdAt": "2020-08-10T19:53:09Z",
      "updatedAt": "2020-08-11T13:01:41Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "d322c0f5b695b623f8d0630df6e821ab2a00bae5",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "edit1",
      "headRefOid": "1edc81121901c44dda39aba55401aba579aeb4e9",
      "closedAt": "2020-08-10T19:54:16Z",
      "mergedAt": "2020-08-10T19:54:16Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "fca62c225d87cc8403c847358285c2c69c5ef647"
      },
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Do you want to borrow the linter that we use in QUIC?  Just copy [these lines](https://github.com/quicwg/base-drafts/blob/1373d195146a5a0d5ea911816ecb6d813b129545/Makefile#L15-L26) to your Makefile along with [this script](https://github.com/quicwg/base-drafts/blob/master/.lint.py).",
          "createdAt": "2020-08-11T01:40:19Z",
          "updatedAt": "2020-08-11T01:40:19Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Brilliant!",
          "createdAt": "2020-08-11T13:01:41Z",
          "updatedAt": "2020-08-11T13:01:41Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NTMzNDA3",
          "commit": {
            "abbreviatedOid": "1edc811"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-10T19:54:12Z",
          "updatedAt": "2020-08-10T19:54:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 256,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY1NzEyOTU3",
      "title": "Editorial",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/256",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "- Use the term \"plaintext\" consistently.\r\n- Be consistent about the number of spaces following a period. (We'll go with one.)\r\n- Editorial changes to Sec.1-3.",
      "createdAt": "2020-08-10T20:23:46Z",
      "updatedAt": "2021-04-16T19:56:16Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "fca62c225d87cc8403c847358285c2c69c5ef647",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "edit1",
      "headRefOid": "c6a2ae2ee2a783478ba0cefba3dc4ebb932fa520",
      "closedAt": "2020-08-10T23:05:37Z",
      "mergedAt": "2020-08-10T23:05:37Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f182eae1482934f7dfdc4846ff78d2bdcf610b8e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NjE1MjIx",
          "commit": {
            "abbreviatedOid": "ba5b747"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "LGTM modulo some nits. Thanks!",
          "createdAt": "2020-08-10T21:55:35Z",
          "updatedAt": "2020-08-10T22:05:15Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "```suggestion\r\nThe TLS Working Group has studied the problem of protecting the SNI, but has\r\n```",
              "createdAt": "2020-08-10T21:55:36Z",
              "updatedAt": "2020-08-10T22:27:27Z"
            },
            {
              "originalPosition": 36,
              "body": "```suggestion\r\nThe protocol specified by this document takes a different approach. It assumes\r\n```",
              "createdAt": "2020-08-10T21:55:54Z",
              "updatedAt": "2020-08-10T22:27:27Z"
            },
            {
              "originalPosition": 63,
              "body": "```suggestion\r\nThis protocol is designed to operate in one of two topologies illustrated\r\n```",
              "createdAt": "2020-08-10T21:56:47Z",
              "updatedAt": "2020-08-10T22:27:27Z"
            },
            {
              "originalPosition": 98,
              "body": "```suggestion\r\nand backend servers are physically separated.\r\n```",
              "createdAt": "2020-08-10T21:58:18Z",
              "updatedAt": "2020-08-10T22:27:27Z"
            },
            {
              "originalPosition": 131,
              "body": "```suggestion\r\nClientHelloInner message) and then encrypts this message using the ECH public key. It then\r\n```",
              "createdAt": "2020-08-10T22:00:28Z",
              "updatedAt": "2020-08-10T22:27:27Z"
            },
            {
              "originalPosition": 142,
              "body": "```suggestion\r\nUpon receiving ClientHelloOuter, the client-facing server processes the encrypted\r\n```",
              "createdAt": "2020-08-10T22:01:41Z",
              "updatedAt": "2020-08-10T22:27:27Z"
            },
            {
              "originalPosition": 142,
              "body": "Since decryption may fail",
              "createdAt": "2020-08-10T22:01:48Z",
              "updatedAt": "2020-08-10T22:27:27Z"
            },
            {
              "originalPosition": 91,
              "body": "```suggestion\r\nterminates the TLS connection with the client. Importantly, the provider does not have access\r\nto the plaintext of the connection.\r\n```",
              "createdAt": "2020-08-10T22:05:06Z",
              "updatedAt": "2020-08-10T22:27:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NjIzMTg5",
          "commit": {
            "abbreviatedOid": "84cd441"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-10T22:11:44Z",
          "updatedAt": "2020-08-10T22:11:44Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "ack",
              "createdAt": "2020-08-10T22:11:44Z",
              "updatedAt": "2020-08-10T22:27:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NjIzMjQ5",
          "commit": {
            "abbreviatedOid": "84cd441"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-10T22:11:52Z",
          "updatedAt": "2020-08-10T22:11:52Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "fixing",
              "createdAt": "2020-08-10T22:11:52Z",
              "updatedAt": "2020-08-10T22:27:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NjI1MDIw",
          "commit": {
            "abbreviatedOid": "84cd441"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-10T22:15:49Z",
          "updatedAt": "2020-08-10T22:15:50Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "When I first read this document, I thought the fact that the SNI was sent in the clear from the client-facing server to the backend server was an attack. As such, I think we want to be explicit about this assumption. This seems like a reasonable place to do so since we're talking about the parties in the protocol and how they communicate with one another.",
              "createdAt": "2020-08-10T22:15:50Z",
              "updatedAt": "2020-08-10T22:27:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NjI2MDk1",
          "commit": {
            "abbreviatedOid": "907ff3d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-10T22:18:01Z",
          "updatedAt": "2020-08-10T22:18:01Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "There's a couple reasons I push back here: (1) the connection might not be long-lived, and (2) the threat we're mostly concerned with is the client<->client-facing-server snooper (an adversary which sees client-facing-server<->backend connections might learn the SNI if it were not encrypted, but it wouldn't learn the client's IP. Basically, this is too restrictive of a threat model, and somewhat orthogonal to the protocol itself. ",
              "createdAt": "2020-08-10T22:18:01Z",
              "updatedAt": "2020-08-10T22:27:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NjQ0OTk0",
          "commit": {
            "abbreviatedOid": "c6a2ae2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-10T23:05:32Z",
          "updatedAt": "2020-08-10T23:05:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 257,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY2MDkzMzk1",
      "title": "Adopt QUIC linter, and fix some issues flagged.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/257",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Thanks, @martinthomson!",
      "createdAt": "2020-08-11T13:08:05Z",
      "updatedAt": "2021-04-19T15:51:45Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f182eae1482934f7dfdc4846ff78d2bdcf610b8e",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/adopt-quic-linter",
      "headRefOid": "d134dac10ae79ecd680267a95cea7f123e8d6d14",
      "closedAt": "2020-08-11T13:08:59Z",
      "mergedAt": "2020-08-11T13:08:59Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "2d31c5f0a63c4dc238cdfc9d51089ae4a647b75d"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 258,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY2MTE5OTgw",
      "title": "Fix superfluous padding edge cases.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/258",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Thanks, @bemasc, for raising this! ",
      "createdAt": "2020-08-11T13:53:49Z",
      "updatedAt": "2020-08-11T14:12:00Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "2d31c5f0a63c4dc238cdfc9d51089ae4a647b75d",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/fix-padding",
      "headRefOid": "456b6496dfe1d5f74a2d4a272e53f98c3ecf9e1f",
      "closedAt": "2020-08-11T14:12:00Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the improvement.  Note that this formula still has no length ambiguity when L == 31 and D == 32.  It's not clear to me whether that's consistent with the design goal.",
          "createdAt": "2020-08-11T13:59:17Z",
          "updatedAt": "2020-08-11T13:59:17Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing.",
          "createdAt": "2020-08-11T14:12:00Z",
          "updatedAt": "2020-08-11T14:12:00Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 259,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY2MjYyNjIw",
      "title": "WIP: Editorial changes",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/259",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The PR contains several \"TODOs\" that must be resolved for merging this.",
      "createdAt": "2020-08-11T17:57:49Z",
      "updatedAt": "2020-08-13T19:37:30Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "2d31c5f0a63c4dc238cdfc9d51089ae4a647b75d",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "edit",
      "headRefOid": "c9a3ebdd7e0eb458a2eaf04452328a2587cea744",
      "closedAt": "2020-08-13T19:37:30Z",
      "mergedAt": "2020-08-13T19:37:30Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "5f86ef0a0bdcfce58a606de4a216213ebbed1a4d"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Three TODOs remain.\r\nLet me know before you merge, I'd like to roll these into a single commit.",
          "createdAt": "2020-08-13T18:47:01Z",
          "updatedAt": "2020-08-13T18:47:01Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2Mjg3MDQx",
          "commit": {
            "abbreviatedOid": "fb053ab"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-08-12T21:22:43Z",
          "updatedAt": "2020-08-12T21:42:31Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "\u2764\ufe0f ",
              "createdAt": "2020-08-12T21:22:43Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 4,
              "body": "Agreed. Let's make an issue for this (and remove the TODO)!",
              "createdAt": "2020-08-12T21:23:07Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 204,
              "body": "`enc` matches HPKE, so I think we should keep it as is.",
              "createdAt": "2020-08-12T21:26:32Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 33,
              "body": "I'm not sure this level of detail is needed here. Perhaps we can simply say, \"The client determines whether ECH was accepted or rejected and proceeds accordingly. The details for each procedure are described in {{section}}.\"",
              "createdAt": "2020-08-12T21:27:24Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 39,
              "body": "I don't think this is needed (here).",
              "createdAt": "2020-08-12T21:27:46Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 79,
              "body": "That's true. We can rewrite this as a paragraph, e.g., saying \"The remaining contents of the `ECHConfig` structure are an opaque byte string...\"",
              "createdAt": "2020-08-12T21:29:47Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 118,
              "body": "I think we should revert this change. The padding scheme specifically applies to the ClientHelloInner.",
              "createdAt": "2020-08-12T21:30:44Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 159,
              "body": "I don't think this is necessary. The version field speaks for itself, and this section doesn't add much. Can we remove this?",
              "createdAt": "2020-08-12T21:32:28Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 188,
              "body": "That's a good idea, yep!",
              "createdAt": "2020-08-12T21:33:24Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 197,
              "body": "How about `config_digest`?",
              "createdAt": "2020-08-12T21:33:56Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 216,
              "body": "```suggestion\r\nWhen the client-facing server accepts ECH, it does not send this extension. When it\r\n```",
              "createdAt": "2020-08-12T21:34:58Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 235,
              "body": "```suggestion\r\nThis document also defines the \"ech_required\" alert, which clients MUST send\r\n```",
              "createdAt": "2020-08-12T21:35:45Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 239,
              "body": "\ud83d\udc4d ",
              "createdAt": "2020-08-12T21:35:54Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 250,
              "body": "Can we remove this TODO and make it an issue?",
              "createdAt": "2020-08-12T21:36:23Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 278,
              "body": "Good point. We should probably shuffle things around.",
              "createdAt": "2020-08-12T21:36:58Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 276,
              "body": "It probably doesn't. Can you find a better home for it?",
              "createdAt": "2020-08-12T21:37:34Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 300,
              "body": "Yes -- each KDF has an associated hash function.",
              "createdAt": "2020-08-12T21:37:49Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 313,
              "body": "I'm not sure this is correct -- let's remove this and track it in a separate issue.",
              "createdAt": "2020-08-12T21:39:58Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 319,
              "body": "It makes sure that the outer extension contents are not modified.",
              "createdAt": "2020-08-12T21:40:12Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            },
            {
              "originalPosition": 325,
              "body": "By redundant do you mean identical?",
              "createdAt": "2020-08-12T21:40:52Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzAwMjIz",
          "commit": {
            "abbreviatedOid": "c0cd660"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T21:47:02Z",
          "updatedAt": "2020-08-12T21:47:02Z",
          "comments": [
            {
              "originalPosition": 204,
              "body": "Ack, removing TODO",
              "createdAt": "2020-08-12T21:47:02Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzAxMzIw",
          "commit": {
            "abbreviatedOid": "c0cd660"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T21:49:09Z",
          "updatedAt": "2020-08-12T21:49:09Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "The high-level description is incomplete, since it doesn't talk about how the client processes the server's response. I think it's good to be complete, even if high-level.",
              "createdAt": "2020-08-12T21:49:09Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzAyNjk2",
          "commit": {
            "abbreviatedOid": "c0cd660"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T21:51:57Z",
          "updatedAt": "2020-08-12T21:51:58Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "As written, the \"ech_nonce\" section comes out of nowhere, since it's purpose isn't articulated until \"security considerations\". My view is that any code point defined in the spec needs to be mentioned in the overview. In fact, I would include \"outer_extensions\" here, too.",
              "createdAt": "2020-08-12T21:51:58Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzAzMDE5",
          "commit": {
            "abbreviatedOid": "c0cd660"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T21:52:40Z",
          "updatedAt": "2020-08-12T21:52:40Z",
          "comments": [
            {
              "originalPosition": 276,
              "body": "Not until I understand the PSK story. I'll leave this unresolved for now.",
              "createdAt": "2020-08-12T21:52:40Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzAzMzcx",
          "commit": {
            "abbreviatedOid": "c0cd660"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T21:53:22Z",
          "updatedAt": "2020-08-12T21:53:23Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Sure, but this isn't the right place for it. It's a tiny part of the protocol. We can describe inline below when it arises. ",
              "createdAt": "2020-08-12T21:53:23Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzAzNjQ3",
          "commit": {
            "abbreviatedOid": "c0cd660"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T21:53:54Z",
          "updatedAt": "2020-08-12T21:53:54Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "What I proposed was high level, I think. We should avoid redundancies in the spec where possible. ",
              "createdAt": "2020-08-12T21:53:54Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzA2MTAy",
          "commit": {
            "abbreviatedOid": "c0cd660"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T21:58:59Z",
          "updatedAt": "2020-08-12T21:59:00Z",
          "comments": [
            {
              "originalPosition": 300,
              "body": "From the spec, it seems like all that's required of the KDF is that it's an \"extract-then-expand\" KDF:\r\nhttps://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hpke-05#section-4\r\n\r\nIn fact, the currently assigned code points are all for HKDF:\r\nhttps://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hpke-05#section-7.2\r\n\r\nBut AFAICT there's no requirement that the KDF always have some underlying hash function. As an alternative to HKDF, one can imagine a dedicated primitive that satisfies the extract-then-expand API but is not constructed from a hash function.\r\n\r\nSorry if this is nit-picky :) ",
              "createdAt": "2020-08-12T21:58:59Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzA3MTU2",
          "commit": {
            "abbreviatedOid": "c0cd660"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T22:01:03Z",
          "updatedAt": "2020-08-12T22:01:03Z",
          "comments": [
            {
              "originalPosition": 300,
              "body": "I see your point. Let's replace this with `Extract` instead of `Hash` and call it a day.",
              "createdAt": "2020-08-12T22:01:03Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzA3NTg0",
          "commit": {
            "abbreviatedOid": "c0cd660"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T22:01:50Z",
          "updatedAt": "2020-08-12T22:01:51Z",
          "comments": [
            {
              "originalPosition": 319,
              "body": "Is there a specific attack this prevents?",
              "createdAt": "2020-08-12T22:01:51Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzA4NDQ4",
          "commit": {
            "abbreviatedOid": "c0cd660"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T22:03:33Z",
          "updatedAt": "2020-08-12T22:03:34Z",
          "comments": [
            {
              "originalPosition": 325,
              "body": "I mean that I would shallow-copy any extension that appears in both the inner and outer CH. The computational overhead is low, it reduces the size of the outer CH, and it seems simpler than shallow-copying select things. (Suppose someone else invents another big extension after ECH is implemented.)",
              "createdAt": "2020-08-12T22:03:34Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzEwMDA2",
          "commit": {
            "abbreviatedOid": "496800c"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T22:06:55Z",
          "updatedAt": "2020-08-12T22:06:55Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "I think of it as a gentle introduction to the protocol flow, which, IMO, aids understanding later on. I think the slight redundancy is worth it. If you don't think it is, then I'll revert this.",
              "createdAt": "2020-08-12T22:06:55Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzEwMzMy",
          "commit": {
            "abbreviatedOid": "496800c"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T22:07:40Z",
          "updatedAt": "2020-08-12T22:07:41Z",
          "comments": [
            {
              "originalPosition": 300,
              "body": "Well, that would change the protocol. Better to make it an issue?",
              "createdAt": "2020-08-12T22:07:40Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzExNDA3",
          "commit": {
            "abbreviatedOid": "496800c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T22:10:06Z",
          "updatedAt": "2020-08-12T22:10:07Z",
          "comments": [
            {
              "originalPosition": 300,
              "body": "Yep!",
              "createdAt": "2020-08-12T22:10:07Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzExNjcw",
          "commit": {
            "abbreviatedOid": "496800c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T22:10:36Z",
          "updatedAt": "2020-08-12T22:10:37Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Let's flush it out first and then we can decide if it's too deep? I commented on WIP text.",
              "createdAt": "2020-08-12T22:10:36Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzEyNzY0",
          "commit": {
            "abbreviatedOid": "496800c"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T22:12:54Z",
          "updatedAt": "2020-08-12T22:12:54Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Done. https://github.com/tlswg/draft-ietf-tls-esni/issues/260",
              "createdAt": "2020-08-12T22:12:54Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzEzNzY5",
          "commit": {
            "abbreviatedOid": "496800c"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T22:14:57Z",
          "updatedAt": "2020-08-12T22:14:57Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Ack, moving TODO to section on ech_nonce.",
              "createdAt": "2020-08-12T22:14:57Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzE2NDEw",
          "commit": {
            "abbreviatedOid": "496800c"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T22:20:45Z",
          "updatedAt": "2020-08-12T22:20:45Z",
          "comments": [
            {
              "originalPosition": 300,
              "body": "Done. https://github.com/tlswg/draft-ietf-tls-esni/issues/261",
              "createdAt": "2020-08-12T22:20:45Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzIwODQy",
          "commit": {
            "abbreviatedOid": "78254d3"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T22:30:29Z",
          "updatedAt": "2020-08-12T22:30:29Z",
          "comments": [
            {
              "originalPosition": 313,
              "body": "Done. https://github.com/tlswg/draft-ietf-tls-esni/issues/262",
              "createdAt": "2020-08-12T22:30:29Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzIyMTE2",
          "commit": {
            "abbreviatedOid": "6aed3e4"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T22:33:23Z",
          "updatedAt": "2020-08-12T22:33:23Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Sounds good, I don't see your comment though.",
              "createdAt": "2020-08-12T22:33:23Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzQ0NDQ0",
          "commit": {
            "abbreviatedOid": "6aed3e4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T23:32:30Z",
          "updatedAt": "2020-08-12T23:32:30Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "It's the first comment in this thread :) ",
              "createdAt": "2020-08-12T23:32:30Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTMwNjQ2",
          "commit": {
            "abbreviatedOid": "6aed3e4"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T16:35:53Z",
          "updatedAt": "2020-08-13T16:35:54Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Applied your suggested change.",
              "createdAt": "2020-08-13T16:35:53Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTMyNTQw",
          "commit": {
            "abbreviatedOid": "1fc6a35"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T16:38:30Z",
          "updatedAt": "2020-08-13T16:38:31Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "Hmmm, I'm curious though: shouldn't this field have a label?\r\nhttps://tools.ietf.org/html/rfc8446#section-3.8",
              "createdAt": "2020-08-13T16:38:31Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTMzNTAx",
          "commit": {
            "abbreviatedOid": "1fc6a35"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T16:39:44Z",
          "updatedAt": "2020-08-13T16:39:44Z",
          "comments": [
            {
              "originalPosition": 118,
              "body": "Reverted.",
              "createdAt": "2020-08-13T16:39:44Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTM3MTIy",
          "commit": {
            "abbreviatedOid": "1fc6a35"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T16:44:23Z",
          "updatedAt": "2020-08-13T16:44:24Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "Yes, I'll revert this. However, it seems technically incorrect to me: using RFC 8446 as the authoritative standard, the `select` block is only defined for enumerated types. This might be splitting hairs though ... I'm not sure how strict RFCs are about this.",
              "createdAt": "2020-08-13T16:44:23Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTM5NTEw",
          "commit": {
            "abbreviatedOid": "1fc6a35"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T16:47:39Z",
          "updatedAt": "2020-08-13T16:47:40Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "Reverted.",
              "createdAt": "2020-08-13T16:47:40Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTQxNTQ2",
          "commit": {
            "abbreviatedOid": "1fc6a35"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T16:50:22Z",
          "updatedAt": "2020-08-13T16:50:22Z",
          "comments": [
            {
              "originalPosition": 188,
              "body": "Done.",
              "createdAt": "2020-08-13T16:50:22Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTQ2NzE0",
          "commit": {
            "abbreviatedOid": "1fc6a35"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T16:55:29Z",
          "updatedAt": "2020-08-13T16:55:29Z",
          "comments": [
            {
              "originalPosition": 197,
              "body": "I like it. Changed.",
              "createdAt": "2020-08-13T16:55:29Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTY5OTgz",
          "commit": {
            "abbreviatedOid": "ec44304"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:10:01Z",
          "updatedAt": "2020-08-13T17:10:02Z",
          "comments": [
            {
              "originalPosition": 239,
              "body": "Done.",
              "createdAt": "2020-08-13T17:10:01Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTcwNTg2",
          "commit": {
            "abbreviatedOid": "ec44304"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:10:54Z",
          "updatedAt": "2020-08-13T17:10:55Z",
          "comments": [
            {
              "originalPosition": 250,
              "body": "This is addressed by https://github.com/tlswg/draft-ietf-tls-esni/issues/253. But I think it might be worth resolving this issue as part of this PR. Or should we wait?",
              "createdAt": "2020-08-13T17:10:54Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTc1MDEz",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:17:03Z",
          "updatedAt": "2020-08-13T17:17:03Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "It's a union, basically, whose value depends on the type. I don't know what would be the desired label, so I'd be fine with the current text or what's proposed above. ",
              "createdAt": "2020-08-13T17:17:03Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTc1MTUw",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:17:15Z",
          "updatedAt": "2020-08-13T17:17:16Z",
          "comments": [
            {
              "originalPosition": 250,
              "body": "Let's wait.",
              "createdAt": "2020-08-13T17:17:15Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTc1Njgw",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:18:00Z",
          "updatedAt": "2020-08-13T17:18:00Z",
          "comments": [
            {
              "originalPosition": 276,
              "body": "Let's remove the TODO then. ",
              "createdAt": "2020-08-13T17:18:00Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTc2MTAw",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:18:31Z",
          "updatedAt": "2020-08-13T17:18:32Z",
          "comments": [
            {
              "originalPosition": 278,
              "body": "Let's either remove the TODO and file an issue, or address this here.",
              "createdAt": "2020-08-13T17:18:31Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTc5NzE5",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:23:33Z",
          "updatedAt": "2020-08-13T17:23:33Z",
          "comments": [
            {
              "originalPosition": 319,
              "body": "I don't think so. We didn't have analyze this case (yet), so the safe thing was just hash to prevent changes. On reflection, any change in the outer extension values would change the transcript if the inner CH was selected, so maybe it's not needed? This is worth an issue.",
              "createdAt": "2020-08-13T17:23:33Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTgwNDI4",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:24:31Z",
          "updatedAt": "2020-08-13T17:24:31Z",
          "comments": [
            {
              "originalPosition": 325,
              "body": "Right, identical. This would be a change, so let's move it to an issue.",
              "createdAt": "2020-08-13T17:24:31Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTgxNDMw",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:25:54Z",
          "updatedAt": "2020-08-13T17:25:54Z",
          "comments": [
            {
              "originalPosition": 355,
              "body": "I'm not sure I understand the question here. I don't think the text suggests that the group is part of the ciphersuite. We can probably s/\"an appropriate group or\"/\"a\"",
              "createdAt": "2020-08-13T17:25:54Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTgyMTEw",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:26:50Z",
          "updatedAt": "2020-08-13T17:26:50Z",
          "comments": [
            {
              "originalPosition": 406,
              "body": "This specifies how the parameters are populated, which is different from their definitions above. Let's keep it for now.",
              "createdAt": "2020-08-13T17:26:50Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTgyNDgy",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:27:19Z",
          "updatedAt": "2020-08-13T17:27:20Z",
          "comments": [
            {
              "originalPosition": 410,
              "body": "It means the outer CH SNI value contains \"ECHConfig.public_name\".",
              "createdAt": "2020-08-13T17:27:19Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTgyODky",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:27:52Z",
          "updatedAt": "2020-08-13T17:27:52Z",
          "comments": [
            {
              "originalPosition": 416,
              "body": "That seems reasonable. Let's file an issue to expand on those details, and remove this TODO.",
              "createdAt": "2020-08-13T17:27:52Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTgzNTI4",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:28:39Z",
          "updatedAt": "2020-08-13T17:28:40Z",
          "comments": [
            {
              "originalPosition": 424,
              "body": "It's a RECOMMENDED padding scheme. What's the confusion?",
              "createdAt": "2020-08-13T17:28:40Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTg0Mjcy",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:29:42Z",
          "updatedAt": "2020-08-13T17:29:43Z",
          "comments": [
            {
              "originalPosition": 435,
              "body": "Again, this is a RECOMMENDED policy. Clients could alternatively pad their inner CH to 1024B, or something. Padding is needed to hide size metadata. It doesn't affect the protocol mechanics.",
              "createdAt": "2020-08-13T17:29:43Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTg0NTcy",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Left more comments for consideration. Nice edits!",
          "createdAt": "2020-08-13T17:30:05Z",
          "updatedAt": "2020-08-13T17:30:05Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTkxMzcw",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:39:27Z",
          "updatedAt": "2020-08-13T17:39:28Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "What I don't like about your proposal is that the `length` field gives the length of a nameless field. I think `content` would be a reasonable label.",
              "createdAt": "2020-08-13T17:39:28Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTkyMjEy",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:40:36Z",
          "updatedAt": "2020-08-13T17:40:37Z",
          "comments": [
            {
              "originalPosition": 250,
              "body": "Ack, removing TODO.",
              "createdAt": "2020-08-13T17:40:37Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTk0MjA1",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:43:20Z",
          "updatedAt": "2020-08-13T17:43:20Z",
          "comments": [
            {
              "originalPosition": 278,
              "body": "Actually, this is the *only* place in the document where \"ech_accept\" appears. This needs to be defined.",
              "createdAt": "2020-08-13T17:43:20Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTk5MDcx",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:50:18Z",
          "updatedAt": "2020-08-13T17:50:18Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "I see little difference between that and `contents`, so, let's just keep the current text?",
              "createdAt": "2020-08-13T17:50:18Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2OTk5NTc5",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:51:01Z",
          "updatedAt": "2020-08-13T17:51:01Z",
          "comments": [
            {
              "originalPosition": 319,
              "body": "Done. https://github.com/tlswg/draft-ietf-tls-esni/issues/263",
              "createdAt": "2020-08-13T17:51:01Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDAwMzU5",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:52:06Z",
          "updatedAt": "2020-08-13T17:52:06Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "Oh, \"contents\" is fine. The suggested change is to give the variant a label.",
              "createdAt": "2020-08-13T17:52:06Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDAxNTIz",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:53:45Z",
          "updatedAt": "2020-08-13T17:53:45Z",
          "comments": [
            {
              "originalPosition": 276,
              "body": "Done.",
              "createdAt": "2020-08-13T17:53:45Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDAyNzgx",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:55:27Z",
          "updatedAt": "2020-08-13T17:55:28Z",
          "comments": [
            {
              "originalPosition": 355,
              "body": "That works for me.\r\nDone.",
              "createdAt": "2020-08-13T17:55:28Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDAzNDE2",
          "commit": {
            "abbreviatedOid": "b3e54ca"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T17:56:16Z",
          "updatedAt": "2020-08-13T17:56:17Z",
          "comments": [
            {
              "originalPosition": 406,
              "body": "Ack, removing TODO.",
              "createdAt": "2020-08-13T17:56:16Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDIzMDk2",
          "commit": {
            "abbreviatedOid": "114e2b7"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T18:23:45Z",
          "updatedAt": "2020-08-13T18:23:45Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "Hmm, I'm not sure what to here. I'm resolving this and leaving the text as is.",
              "createdAt": "2020-08-13T18:23:45Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDI0NTA0",
          "commit": {
            "abbreviatedOid": "114e2b7"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T18:25:49Z",
          "updatedAt": "2020-08-13T18:25:49Z",
          "comments": [
            {
              "originalPosition": 278,
              "body": "Is this an issue, or shall we define the alert here? I'm not sure how to do this.",
              "createdAt": "2020-08-13T18:25:49Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDI2ODUw",
          "commit": {
            "abbreviatedOid": "114e2b7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T18:29:13Z",
          "updatedAt": "2020-08-13T18:29:13Z",
          "comments": [
            {
              "originalPosition": 278,
              "body": "Let's just make it an issue. It'll be a small change.",
              "createdAt": "2020-08-13T18:29:13Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDI3NTU4",
          "commit": {
            "abbreviatedOid": "114e2b7"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T18:30:14Z",
          "updatedAt": "2020-08-13T18:30:15Z",
          "comments": [
            {
              "originalPosition": 325,
              "body": "Done. https://github.com/tlswg/draft-ietf-tls-esni/issues/265.",
              "createdAt": "2020-08-13T18:30:15Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDMwMDY4",
          "commit": {
            "abbreviatedOid": "114e2b7"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T18:33:55Z",
          "updatedAt": "2020-08-13T18:33:56Z",
          "comments": [
            {
              "originalPosition": 410,
              "body": "Ack, resolving.",
              "createdAt": "2020-08-13T18:33:56Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDMzNDIy",
          "commit": {
            "abbreviatedOid": "114e2b7"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T18:38:56Z",
          "updatedAt": "2020-08-13T18:38:57Z",
          "comments": [
            {
              "originalPosition": 416,
              "body": "Done. https://github.com/tlswg/draft-ietf-tls-esni/issues/266",
              "createdAt": "2020-08-13T18:38:56Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDMzNjU5",
          "commit": {
            "abbreviatedOid": "114e2b7"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T18:39:18Z",
          "updatedAt": "2020-08-13T18:39:19Z",
          "comments": [
            {
              "originalPosition": 424,
              "body": "I'll resolve this TOOD for now.",
              "createdAt": "2020-08-13T18:39:18Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDM0MTUx",
          "commit": {
            "abbreviatedOid": "114e2b7"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T18:40:02Z",
          "updatedAt": "2020-08-13T18:40:03Z",
          "comments": [
            {
              "originalPosition": 435,
              "body": "Resolving for now.",
              "createdAt": "2020-08-13T18:40:02Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDM3NjAw",
          "commit": {
            "abbreviatedOid": "4c9319b"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T18:45:14Z",
          "updatedAt": "2020-08-13T18:45:15Z",
          "comments": [
            {
              "originalPosition": 278,
              "body": "Done. https://github.com/tlswg/draft-ietf-tls-esni/issues/267",
              "createdAt": "2020-08-13T18:45:14Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDQwMTAx",
          "commit": {
            "abbreviatedOid": "8a92f4e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T18:49:07Z",
          "updatedAt": "2020-08-13T18:49:07Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "This is already described in the section you reference, so let's remove this TODO.",
              "createdAt": "2020-08-13T18:49:07Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDQwMjMx",
          "commit": {
            "abbreviatedOid": "8a92f4e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T18:49:20Z",
          "updatedAt": "2020-08-13T18:49:21Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "```suggestion\r\n{{client-behavior}} for details.)\r\n```",
              "createdAt": "2020-08-13T18:49:20Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDQxODMz",
          "commit": {
            "abbreviatedOid": "8a92f4e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T18:51:41Z",
          "updatedAt": "2020-08-13T18:51:41Z",
          "comments": [
            {
              "originalPosition": 362,
              "body": "That seems reasonable -- thanks!",
              "createdAt": "2020-08-13T18:51:41Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDQyNDQy",
          "commit": {
            "abbreviatedOid": "8a92f4e"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T18:52:33Z",
          "updatedAt": "2020-08-13T18:52:33Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Done.",
              "createdAt": "2020-08-13T18:52:33Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDQ1MjMy",
          "commit": {
            "abbreviatedOid": "d67c284"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T18:54:41Z",
          "updatedAt": "2020-08-13T18:54:41Z",
          "comments": [
            {
              "originalPosition": 362,
              "body": "Done.",
              "createdAt": "2020-08-13T18:54:41Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDUxNjk1",
          "commit": {
            "abbreviatedOid": "4d7f789"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T19:04:23Z",
          "updatedAt": "2020-08-13T19:04:23Z",
          "comments": [
            {
              "originalPosition": 217,
              "body": "This is meant to be clarifying, not a spec change. The \"ech_required\" alert MUST be sent in this case, correct?",
              "createdAt": "2020-08-13T19:04:23Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDUyOTk3",
          "commit": {
            "abbreviatedOid": "4d7f789"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T19:06:20Z",
          "updatedAt": "2020-08-13T19:06:20Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Oops, missed this. Shall I make this change?",
              "createdAt": "2020-08-13T19:06:20Z",
              "updatedAt": "2020-08-13T19:34:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDcxOTQ3",
          "commit": {
            "abbreviatedOid": "c9a3ebd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T19:35:27Z",
          "updatedAt": "2020-08-13T19:35:27Z",
          "comments": [
            {
              "originalPosition": 217,
              "body": "\ud83d\udc4d yep!",
              "createdAt": "2020-08-13T19:35:27Z",
              "updatedAt": "2020-08-13T19:35:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDcyMDky",
          "commit": {
            "abbreviatedOid": "c9a3ebd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for these editorial cleanups!",
          "createdAt": "2020-08-13T19:35:42Z",
          "updatedAt": "2020-08-13T19:35:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 268,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY4MzAzNjMz",
      "title": "Fix superfluous padding edge cases.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/268",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Consider the following values for L and D, where L is the server's hint\r\nand D is the length of the domain name.\r\n\r\n~~~\r\n    D1     D2      D3\r\n... -+--|---+---|---+---|----->\r\n        L     32*n   32*(n+1)\r\n~~~\r\n\r\nThis change pads D according to the following rules.\r\n\r\n- D1: D <= L, so round up to L.\r\n- D2: 32*(n-1) <= L < D <= 32*n, round up to 32*(n+1).\r\n- D3: 32*(n-1) <= L <= 32*n < D, round up to 32*(n+1).\r\n\r\nCase D2 exists because the anonymity set of of D, if rounded to 32*n\r\n(instead of 32*(n+1), is less than 32. The new padding algorithm ensures\r\nthat the anonymity set for D whenever D > L is at least 32 elements.\r\n\r\nCloses #252. Thanks, @bemasc!",
      "createdAt": "2020-08-15T12:57:39Z",
      "updatedAt": "2021-04-19T15:51:45Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "5f86ef0a0bdcfce58a606de4a216213ebbed1a4d",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/fix-padding",
      "headRefOid": "1cfe0cc4a61fbc1078aed36cd10c3675825c365b",
      "closedAt": "2020-08-30T15:37:22Z",
      "mergedAt": "2020-08-30T15:37:22Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "3ee7678e12c49cd6015899e675bf227bbb50835b"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "cc @davidben, @kjacobs-moz, @dmcardle, @ekr, @martinthomson",
          "createdAt": "2020-08-19T15:42:07Z",
          "updatedAt": "2020-08-19T15:42:07Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "TBH I am not sure that this is worth it, but I believe it is correct.",
          "createdAt": "2020-08-21T22:41:15Z",
          "updatedAt": "2020-08-21T22:41:15Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4MDExOTkx",
          "commit": {
            "abbreviatedOid": "96942ef"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-08-15T19:03:09Z",
          "updatedAt": "2020-08-15T19:04:27Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Technically this no longer \"rounds D up to the nearest multiple of 32 bytes\".  How about\r\n```suggestion\r\n   multiple of 32 bytes that permits at least 32 bytes of length ambiguity.\r\n```",
              "createdAt": "2020-08-15T19:03:09Z",
              "updatedAt": "2020-08-15T19:12:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4MDEyNDU2",
          "commit": {
            "abbreviatedOid": "96942ef"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-15T19:12:33Z",
          "updatedAt": "2020-08-15T19:12:34Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Better \u2014 thanks!",
              "createdAt": "2020-08-15T19:12:34Z",
              "updatedAt": "2020-08-15T19:12:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4MDE5NzMx",
          "commit": {
            "abbreviatedOid": "1cfe0cc"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-15T21:55:02Z",
          "updatedAt": "2020-08-15T21:55:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 269,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY4OTQ1Njkx",
      "title": "Proposal: Retry-only ECHConfig",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/269",
      "state": "CLOSED",
      "author": "bemasc",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "A server operator always has the option to operate in a retry-only mode, which may be necessary if updating the published ECHConfig is difficult and long-lived keys are undesirable.  This change improves forward-secrecy in that configuration.",
      "createdAt": "2020-08-17T16:45:35Z",
      "updatedAt": "2020-09-21T17:52:55Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "5f86ef0a0bdcfce58a606de4a216213ebbed1a4d",
      "headRepository": "bemasc/draft-ietf-tls-esni",
      "headRefName": "patch-1",
      "headRefOid": "dbb0f87207689ce7684d99286ccadcf26dd54f87",
      "closedAt": "2020-09-21T17:52:55Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Are there folks looking to deploy such a thing? The current retry flow costs 2-RTT (TCP + TLS) on top of a normal handshake. I don't think that's something to encourage. It's currently meant as a recovery flow. I think something meant to be used more frequently would want to look different and, in particular, stay in one connection to keep the overhead at 1-RTT. Possibly even with some client state for subsequent connections, though squaring that with multi-CDN is tricky.\r\n\r\nThat sort of thing came up on the list, but IIRC folks weren't very excited about the complexity involved and we kept it as a simpler, recovery-only story.",
          "createdAt": "2020-08-17T17:18:10Z",
          "updatedAt": "2020-08-17T17:18:10Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree; it's too expensive for normal use, and not worth complicating clients to improve performance.\r\n\r\nI'm thinking of use cases where DNS is not the distribution channel, and updating the ECHConfig is difficult.  It would be nice to be able to see that the ECHConfig is not \"pinning\" a key, and to have a shorter ECHConfig for very constrained distribution channels (e.g. a QR code).\r\n\r\nA client like this might fetch and cache real ECHConfigs once it's connected, but I think we can leave that to the application layer.",
          "createdAt": "2020-08-17T18:15:23Z",
          "updatedAt": "2020-08-17T18:15:23Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like this idea!",
          "createdAt": "2020-08-18T14:52:35Z",
          "updatedAt": "2020-08-18T14:52:35Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "From the interim: we need more clarification of the use case. This can also be addressed in future work as an extension. @bemasc, can we close this and punt to a future change?",
          "createdAt": "2020-09-21T15:52:52Z",
          "updatedAt": "2020-09-21T15:52:52Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think an extension would allow us to _omit_ information as suggested here, but it sounds like there's no consensus to support this so I don't want to create delay.",
          "createdAt": "2020-09-21T17:52:55Z",
          "updatedAt": "2020-09-21T17:52:55Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 270,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY5MDExNjg4",
      "title": "Adjust and generalize cached_info guidance.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/270",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Now that we've switched to encrypting the entire ClientHello, there's\r\nnothing wrong with cached_info in ClientHelloOuter, provided it's based\r\non the public name rather than the inner name. And, more generally,\r\nname-specific extensions take some care.\r\n\r\nReplace the prohibition with more general guidance in Security\r\nConsiderations, with cached_info merely being an example.\r\n\r\nThis addresses issue #266.",
      "createdAt": "2020-08-17T18:55:06Z",
      "updatedAt": "2020-08-17T20:41:24Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "5f86ef0a0bdcfce58a606de4a216213ebbed1a4d",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "cached-info",
      "headRefOid": "4e179fe14da4d16b7b985cdb0c5afa5c9c527d02",
      "closedAt": "2020-08-17T20:41:24Z",
      "mergedAt": "2020-08-17T20:41:24Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "4ab5190580e30318764b92a776bfb8522cbb3ecb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4ODA4OTcw",
          "commit": {
            "abbreviatedOid": "c3cd016"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM with a couple suggestions -- thanks!",
          "createdAt": "2020-08-17T20:26:46Z",
          "updatedAt": "2020-08-17T20:29:38Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "```suggestion\r\ntrue server name. For example, the \"cached_info\" ClientHello extension\r\n```",
              "createdAt": "2020-08-17T20:26:46Z",
              "updatedAt": "2020-08-17T20:38:28Z"
            },
            {
              "originalPosition": 30,
              "body": "```suggestion\r\nClientHelloOuter. It MAY send such values in the ClientHelloInner.\r\n```",
              "createdAt": "2020-08-17T20:28:43Z",
              "updatedAt": "2020-08-17T20:38:28Z"
            },
            {
              "originalPosition": 22,
              "body": "```suggestion\r\nwhich would reveal a sensitive ClientHelloInner property, such as the true\r\nserver name. It MAY send values associated with the public name in the \r\nClientHelloOuter.\r\n```",
              "createdAt": "2020-08-17T20:29:27Z",
              "updatedAt": "2020-08-17T20:38:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4ODE3ODAw",
          "commit": {
            "abbreviatedOid": "4e179fe"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-17T20:41:17Z",
          "updatedAt": "2020-08-17T20:41:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 271,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY5MDM2NDU0",
      "title": "Require the KDF to be HKDF-based",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/271",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The spec makes use of the \"hash function underlying the KDF\", but the\r\nHPKE spec does not require such a function to exist. This resolves the\r\nissue by requiring that HKDF is used for key derivation in ECH.\r\n\r\nThis resolves #261.",
      "createdAt": "2020-08-17T19:52:26Z",
      "updatedAt": "2021-04-16T19:56:19Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "4ab5190580e30318764b92a776bfb8522cbb3ecb",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "hkdf",
      "headRefOid": "96f3cecd473933836155b17badee77b5e0b1165e",
      "closedAt": "2020-08-17T23:43:57Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I rolled up your changes.",
          "createdAt": "2020-08-17T21:19:24Z",
          "updatedAt": "2020-08-17T21:19:24Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In light of @martinthomson's point on the mailing list, we might want to reconsider this PR.",
          "createdAt": "2020-08-17T22:58:52Z",
          "updatedAt": "2020-08-17T22:59:04Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I really don't feel strongly about this. We don't have any other KDFs at the moment, and swapping in a new one later is trivial. ",
          "createdAt": "2020-08-17T23:06:54Z",
          "updatedAt": "2020-08-17T23:06:54Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Dropping this in favor of #276.",
          "createdAt": "2020-08-17T23:43:57Z",
          "updatedAt": "2020-08-17T23:43:57Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4ODMyNTI5",
          "commit": {
            "abbreviatedOid": "6d049d8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM modulo two nits. If and when an alternate KDF comes out and we need and want to support it for ECH, we can write text allowing it. For now, it seems fine to constrain ourselves to HKDF, given how tightly coupled it is to TLS 1.3 as is. ",
          "createdAt": "2020-08-17T21:05:55Z",
          "updatedAt": "2020-08-17T21:07:44Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "```suggestion\r\n  with the HPKE KDF.\r\n```",
              "createdAt": "2020-08-17T21:05:56Z",
              "updatedAt": "2020-08-17T21:19:04Z"
            },
            {
              "originalPosition": 18,
              "body": "```suggestion\r\ni.e., the hash function underlying the HPKE HKDF variant.\r\n```",
              "createdAt": "2020-08-17T21:06:33Z",
              "updatedAt": "2020-08-17T21:19:04Z"
            }
          ]
        }
      ]
    },
    {
      "number": 272,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY5MDQzMTQ1",
      "title": "Remove \"outer_extension\" compression guidance",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/272",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This addresses #265.",
      "createdAt": "2020-08-17T20:08:35Z",
      "updatedAt": "2021-04-16T19:56:18Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "5f86ef0a0bdcfce58a606de4a216213ebbed1a4d",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "compression_guidance",
      "headRefOid": "8f380b9a9b27d865c5eeb34e3b79db70f4e6f924",
      "closedAt": "2020-08-19T22:40:09Z",
      "mergedAt": "2020-08-19T22:40:09Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "b78f62ef04cc47a66bdaad01833bf546f21856ae"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxMDEyNDky",
          "commit": {
            "abbreviatedOid": "8f380b9"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-19T22:39:58Z",
          "updatedAt": "2020-08-19T22:39:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 273,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY5MDQzMjQ1",
      "title": "Update a few citations to RFCs.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/273",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-08-17T20:08:48Z",
      "updatedAt": "2020-08-17T20:19:34Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "5f86ef0a0bdcfce58a606de4a216213ebbed1a4d",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "update-citations",
      "headRefOid": "843793117fa2c7fd786d12ea45794e2805a037d3",
      "closedAt": "2020-08-17T20:19:34Z",
      "mergedAt": "2020-08-17T20:19:33Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "37e0e6a14db945988d21a08f506a3e74a8fc6bb7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4ODA0NTMw",
          "commit": {
            "abbreviatedOid": "8437931"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-17T20:19:28Z",
          "updatedAt": "2020-08-17T20:19:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 276,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY5MTIxMTkz",
      "title": "Resolve mismatch between ECH and HPKE API",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/276",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Per @martinthomson's suggestion, this replaces computations involving the \"hash underlying the KDF\" with evaluation of the KDF itself. This respects the API defined in the HPKE draft.\r\n\r\nThis supersedes #271.",
      "createdAt": "2020-08-17T23:43:36Z",
      "updatedAt": "2021-04-16T19:56:20Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "b78f62ef04cc47a66bdaad01833bf546f21856ae",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "hkdf2",
      "headRefOid": "202ab60e6e43543b6cc18c0e66348bea6961230b",
      "closedAt": "2020-08-26T12:46:17Z",
      "mergedAt": "2020-08-26T12:46:17Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ffdd0db49c096f548aceb9eec05a3d7b189bfd01"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hey @chris-wood and @martinthomson, I rolled up your changes! Please have another look before merging.",
          "createdAt": "2020-08-18T15:09:04Z",
          "updatedAt": "2020-08-18T15:09:04Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Rebased and rolled up.",
          "createdAt": "2020-08-19T19:05:56Z",
          "updatedAt": "2020-08-19T19:05:56Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks -- let's let this stew until Friday, at which point we can merge.",
          "createdAt": "2020-08-19T19:18:19Z",
          "updatedAt": "2020-08-19T19:18:19Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Rebased.",
          "createdAt": "2020-08-20T00:52:29Z",
          "updatedAt": "2020-08-20T00:52:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTA0NTI0",
          "commit": {
            "abbreviatedOid": "f42a0db"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-17T23:54:27Z",
          "updatedAt": "2020-08-17T23:57:36Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "```suggestion\r\nentire ClientHelloInner message as:\r\n```",
              "createdAt": "2020-08-17T23:54:27Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            },
            {
              "originalPosition": 60,
              "body": "```suggestion\r\n  Section 4 of {{!I-D.irtf-cfrg-hpke}}.)\r\n```\r\n\r\n(I had some difficultly locating it without a more specific pointer.)",
              "createdAt": "2020-08-17T23:56:32Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            },
            {
              "originalPosition": 11,
              "body": "Rather than repeat the definition here, what you probably want to do is make a new section under {{outer-extensions}} and cite that.  It's reasonable to do that as a follow-up though.",
              "createdAt": "2020-08-17T23:57:08Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTA2MjM5",
          "commit": {
            "abbreviatedOid": "f42a0db"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T00:00:01Z",
          "updatedAt": "2020-08-18T00:00:01Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "Should we avoid referring to sections numbers in drafts, in case they change?",
              "createdAt": "2020-08-18T00:00:01Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTA0NjY1",
          "commit": {
            "abbreviatedOid": "f42a0db"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-17T23:54:59Z",
          "updatedAt": "2020-08-18T00:00:59Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "```suggestion\r\n: Equal to `Extract(Expand(\"\", config), \"ech_config_digest\", Nh)`, where `config` is the \r\n`ECHConfig` structure, and `Extract`, `Expand`, and `Nh` are as defined by the KDF API in\r\n{{!I-D.irtf-cfrg-hpke}}.\r\n```",
              "createdAt": "2020-08-17T23:54:59Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            },
            {
              "originalPosition": 37,
              "body": "```suggestion\r\n  hash = Extract(Expand(\"\", inner), \"ech_inner_digest\", Nh)\r\n```",
              "createdAt": "2020-08-17T23:55:32Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            },
            {
              "originalPosition": 46,
              "body": "```suggestion\r\nwhere `inner` is the ClientHelloInner structure, and `Extract`, `Expand`, and `Nh` are as \r\ndefined by the KDF API in {{!I-D.irtf-cfrg-hpke}}. Then, the client removes and replaces\r\nextensions from ClientHelloInner with a single \"outer_extensions\" extension. The\r\nlist of `outer_extensions` include those which were removed from\r\nClientHelloInner, in the order in which they were removed. The hash contains the\r\nfull ClientHelloInner hash computed above.\r\n```",
              "createdAt": "2020-08-17T23:55:52Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTA2NzMy",
          "commit": {
            "abbreviatedOid": "f42a0db"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T00:01:27Z",
          "updatedAt": "2020-08-18T00:01:28Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Let's do it in follow up.\r\n\r\nMy view is that the hash should be dropped from outer_extensions: see #263.",
              "createdAt": "2020-08-18T00:01:27Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTA5NTc3",
          "commit": {
            "abbreviatedOid": "f42a0db"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T00:10:17Z",
          "updatedAt": "2020-08-18T00:10:18Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Is the empty string <=> all zero thing a deliberate choice or just an odd quirk of HKDF (via HMAC)?  I agree that in this case the difference isn't important and an empty string is fine, but do we need to be careful about this at all?",
              "createdAt": "2020-08-18T00:10:17Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTEwNDgw",
          "commit": {
            "abbreviatedOid": "dec449e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T00:13:09Z",
          "updatedAt": "2020-08-18T00:13:09Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "For HKDF it's the same (if salt's omitted, HKDF just fills in a zero-length string of Nh bytes), but for other KDFs it might not be. So we decided to just stick with empty strings, and I think we ought to do the same here.",
              "createdAt": "2020-08-18T00:13:09Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTEwODk3",
          "commit": {
            "abbreviatedOid": "dec449e"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T00:14:29Z",
          "updatedAt": "2020-08-18T00:14:30Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "[You have to be careful with the salt length for HKDF](https://hal.inria.fr/hal-02100345). As I recall, a safe choice is the output length of the underlying hash function. (This is `Nh` in the HPKE draft.) This is also what's done in RFC 8446.",
              "createdAt": "2020-08-18T00:14:30Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTExMzUz",
          "commit": {
            "abbreviatedOid": "dec449e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T00:15:57Z",
          "updatedAt": "2020-08-18T00:15:58Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Quoting from the HKDF RFC:\r\n\r\n> salt: if not provided, it is set to a string of HashLen zeros.\r\n\r\nWhat I'm proposing is that we omit this, since we don't want HKDF quirks impacting future KDFs. (This is a deliberate design choice we made for HPKE.)",
              "createdAt": "2020-08-18T00:15:57Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTExODcy",
          "commit": {
            "abbreviatedOid": "dec449e"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T00:17:37Z",
          "updatedAt": "2020-08-18T00:17:37Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Is \"\" the same as Nh-length byte stering? I read \"\" as the 0-length string.",
              "createdAt": "2020-08-18T00:17:37Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTExOTgz",
          "commit": {
            "abbreviatedOid": "dec449e"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T00:18:01Z",
          "updatedAt": "2020-08-18T00:18:02Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "(See above thread.)",
              "createdAt": "2020-08-18T00:18:02Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTEyMTg5",
          "commit": {
            "abbreviatedOid": "dec449e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T00:18:39Z",
          "updatedAt": "2020-08-18T00:18:40Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "It's an empty string, i.e., equivalent to not providing the input. (We could add text clarifying that!)",
              "createdAt": "2020-08-18T00:18:40Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTEyNjM0",
          "commit": {
            "abbreviatedOid": "dec449e"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T00:20:18Z",
          "updatedAt": "2020-08-18T00:20:18Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "What does it look like, syntactically, if the salt isn't provided? Were I reading this, I would think that the salt is the empty string.\r\n\r\nPossible variants:\r\n- `Extract(salt, ikm)` where `salt` is ...\r\n- `Extract(\"\", ikm)` (I read this as the empty string)\r\n- `Extract(0, ikm)` (not sure how to read this, lol)",
              "createdAt": "2020-08-18T00:20:18Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTE3MjA2",
          "commit": {
            "abbreviatedOid": "dec449e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T00:36:08Z",
          "updatedAt": "2020-08-18T00:36:08Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Chatted offline -- `Extract(\"\", ikm)` is the way to go!",
              "createdAt": "2020-08-18T00:36:08Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTE4OTc2",
          "commit": {
            "abbreviatedOid": "dec449e"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T00:42:12Z",
          "updatedAt": "2020-08-18T00:42:12Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Will do with this in the morning!",
              "createdAt": "2020-08-18T00:42:12Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTE5MTg1",
          "commit": {
            "abbreviatedOid": "dec449e"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T00:42:51Z",
          "updatedAt": "2020-08-18T00:42:52Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "We'll go with \"\" == \"\\x00\" * Nh, here and below. I'll add a paranthetical to clarify this the first time we use this.",
              "createdAt": "2020-08-18T00:42:51Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5NTUxNDYy",
          "commit": {
            "abbreviatedOid": "65c7be5"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T15:08:16Z",
          "updatedAt": "2020-08-18T15:08:17Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Done.",
              "createdAt": "2020-08-18T15:08:16Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5NTcwNzc5",
          "commit": {
            "abbreviatedOid": "65c7be5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-08-18T15:27:57Z",
          "updatedAt": "2020-08-18T15:29:43Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "The order is wrong here -- it should be Expand(Extract(...))",
              "createdAt": "2020-08-18T15:27:58Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            },
            {
              "originalPosition": 11,
              "body": "This should be `Extract`, not `Expand`.",
              "createdAt": "2020-08-18T15:28:58Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            },
            {
              "originalPosition": 37,
              "body": "Backwards here, too.",
              "createdAt": "2020-08-18T15:29:05Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            },
            {
              "originalPosition": 69,
              "body": "Since this is no longer a hash function output (and not a digest), perhaps we should rename this to `config_id`, or something. ",
              "createdAt": "2020-08-18T15:29:40Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5NjgyMjQy",
          "commit": {
            "abbreviatedOid": "65c7be5"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T17:38:52Z",
          "updatedAt": "2020-08-18T17:38:52Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "ahh, good catch",
              "createdAt": "2020-08-18T17:38:52Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5NjgzMjQw",
          "commit": {
            "abbreviatedOid": "65c7be5"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T17:40:15Z",
          "updatedAt": "2020-08-18T17:40:16Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Fixed, here and below.",
              "createdAt": "2020-08-18T17:40:15Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5NjgzODY3",
          "commit": {
            "abbreviatedOid": "65c7be5"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T17:41:07Z",
          "updatedAt": "2020-08-18T17:41:08Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Done.",
              "createdAt": "2020-08-18T17:41:07Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5Njg1MTAw",
          "commit": {
            "abbreviatedOid": "65c7be5"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T17:42:48Z",
          "updatedAt": "2020-08-18T17:42:49Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "I'd be ok with this change, though existing issues refer to `config_digest`. Why don't we put this on the stack of editorial TODOs?",
              "createdAt": "2020-08-18T17:42:49Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5Njg1NDAy",
          "commit": {
            "abbreviatedOid": "65c7be5"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T17:43:12Z",
          "updatedAt": "2020-08-18T17:43:13Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Done",
              "createdAt": "2020-08-18T17:43:13Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5ODk4MTQz",
          "commit": {
            "abbreviatedOid": "a6b8bd4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T23:32:41Z",
          "updatedAt": "2020-08-18T23:32:42Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "Yeah, that's fine.",
              "createdAt": "2020-08-18T23:32:41Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5ODk4NTQy",
          "commit": {
            "abbreviatedOid": "a6b8bd4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T23:33:48Z",
          "updatedAt": "2020-08-18T23:33:48Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Let's make a note to change this to something other than `hash`, too. (If we keep it!)",
              "createdAt": "2020-08-18T23:33:48Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5ODk4OTEy",
          "commit": {
            "abbreviatedOid": "a6b8bd4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM with the latest changes. Thanks!",
          "createdAt": "2020-08-18T23:34:43Z",
          "updatedAt": "2020-08-18T23:34:43Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5OTAxNzIz",
          "commit": {
            "abbreviatedOid": "a6b8bd4"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-18T23:43:02Z",
          "updatedAt": "2020-08-18T23:44:08Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "It's easy to fix.  If HPKE was so unstable, I'd be less inclined to depend on it.",
              "createdAt": "2020-08-18T23:43:02Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            },
            {
              "originalPosition": 37,
              "body": "`config_id` ? or, for now: \r\n\r\n```suggestion\r\n  config_digest = Expand(Extract(\"\", inner), \"ech_inner_digest\", Nh)\r\n```",
              "createdAt": "2020-08-18T23:43:30Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5OTA1MzU1",
          "commit": {
            "abbreviatedOid": "a6b8bd4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T23:54:01Z",
          "updatedAt": "2020-08-18T23:54:01Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Well this is the hash of the inner CH, not of the config. Let's just change this name in a separate PR. ",
              "createdAt": "2020-08-18T23:54:01Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5OTUyMDg2",
          "commit": {
            "abbreviatedOid": "a6b8bd4"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-19T00:58:04Z",
          "updatedAt": "2020-08-19T00:58:05Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "Noted.",
              "createdAt": "2020-08-19T00:58:05Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5OTUzNjUx",
          "commit": {
            "abbreviatedOid": "a6b8bd4"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-19T00:59:00Z",
          "updatedAt": "2020-08-19T00:59:01Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Agreed.",
              "createdAt": "2020-08-19T00:59:00Z",
              "updatedAt": "2020-08-20T00:52:03Z"
            }
          ]
        }
      ]
    },
    {
      "number": 277,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY5MTQ2Mjg2",
      "title": "Nit: fix typo: change 'Hkpe' to 'Hpke'.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/277",
      "state": "MERGED",
      "author": "cbartle891",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fix for https://github.com/tlswg/draft-ietf-tls-esni/issues/275.",
      "createdAt": "2020-08-18T01:24:33Z",
      "updatedAt": "2020-08-18T03:54:41Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "4ab5190580e30318764b92a776bfb8522cbb3ecb",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "6b5d04e7b27127527f78ec7152572115915ac6b8",
      "closedAt": "2020-08-18T03:54:41Z",
      "mergedAt": "2020-08-18T03:54:40Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "65f77a332de82ae6c666ed02d893b410b1e9f041"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTMxOTUw",
          "commit": {
            "abbreviatedOid": "6b5d04e"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-18T01:27:57Z",
          "updatedAt": "2020-08-18T01:27:57Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTczNDI1",
          "commit": {
            "abbreviatedOid": "6b5d04e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-18T03:54:35Z",
          "updatedAt": "2020-08-18T03:54:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 279,
      "id": "MDExOlB1bGxSZXF1ZXN0NDcwMTUwOTc3",
      "title": "Fix typo CllientHelloInner",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/279",
      "state": "MERGED",
      "author": "thomwiggers",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR fixes a small typo.",
      "createdAt": "2020-08-19T13:04:33Z",
      "updatedAt": "2020-08-19T14:02:34Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "65f77a332de82ae6c666ed02d893b410b1e9f041",
      "headRepository": null,
      "headRefName": "fix-typo",
      "headRefOid": "32c83a66cdb1de8553add83f9e40ae00eba3b459",
      "closedAt": "2020-08-19T14:02:34Z",
      "mergedAt": "2020-08-19T14:02:34Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "250bd072036d663a39966e8a5ff243d54a3bf49d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcwNDg5NjA1",
          "commit": {
            "abbreviatedOid": "32c83a6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-19T14:02:30Z",
          "updatedAt": "2020-08-19T14:02:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 282,
      "id": "MDExOlB1bGxSZXF1ZXN0NDcwNDU2MTE3",
      "title": "Fix leftover references to 'retry_keys'",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/282",
      "state": "MERGED",
      "author": "kjacobs-moz",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #281 ",
      "createdAt": "2020-08-19T21:05:31Z",
      "updatedAt": "2020-08-19T22:38:00Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "250bd072036d663a39966e8a5ff243d54a3bf49d",
      "headRepository": "kjacobs-moz/draft-ietf-tls-esni",
      "headRefName": "retry_keys_fix",
      "headRefOid": "0680dc293db6da282f4c0bdd4399fee1c96480ed",
      "closedAt": "2020-08-19T22:38:00Z",
      "mergedAt": "2020-08-19T22:38:00Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "dedb887565b4d1a60e396669d4ec39463c398826"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxMDExNzA0",
          "commit": {
            "abbreviatedOid": "0680dc2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2020-08-19T22:37:55Z",
          "updatedAt": "2020-08-19T22:37:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 283,
      "id": "MDExOlB1bGxSZXF1ZXN0NDcxMjgyODA0",
      "title": "Add ECH confirmation (option (3))",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/283",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This changes changes the semantics of the \"encrypted_client_hello\" (aka \"ech\") extension so that the server confirms ECH acceptance. The client adds an \"ech\" extension to ClientHelloInner that contains a random nonce; when the server accepts, it echoes this nonce back.\r\n\r\n**Protocol flow:**\r\n* **On input of the client's outer CH.** If the server accepts ECH, it uses the inner CH; and if the server rejects or does not support ECH, then it uses the outer CH. If the server accepts, then it adds an \"ech\" extension to its SH with nonce sent in the \"ech\" extension of the inner CH; if the server rejects, then it adds an \"ech\" extension to its SH with a random nonce. It may also add and an \"ech\" extension to its EE with the updated ECH configuration.\r\n* **On input of the server's SH, EE, \u2026, Finished.** If the SH has the \"ech\" extension with the payload sent in the inner CH, then it proceeds as if the inner CH was used; otherwise it proceeds as if the outer CH was used, updating its ECH configuration if applicable.\r\n\r\nThis addresses #274. It also makes the naming of extensions defined in the spec consistent.\r\n\r\nREVISED on 9/2.",
      "createdAt": "2020-08-20T23:02:09Z",
      "updatedAt": "2021-04-16T19:56:22Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3426cfbf3f25bd2aa23a13e8700702717c05a42f",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "ech_confirmation",
      "headRefOid": "c229d615d4f40d8584096f33d6884372276c581d",
      "closedAt": "2020-09-03T17:13:16Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OPEN ISSUE: Does the new extension impact the HRR logic? I don't think so, but I'm hoping someone else can have a look.",
          "createdAt": "2020-08-20T23:10:06Z",
          "updatedAt": "2020-08-20T23:10:06Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This design breaks \"split mode\".  The origin server doesn't have the HPKE context, so it can't produce the exported value.  I think this loss is unnecessary and worth avoiding.",
          "createdAt": "2020-08-21T00:23:44Z",
          "updatedAt": "2020-08-21T00:23:44Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The \"ech_confirm\" in the inner CH is sent to the backend server, who echoes it back. (As you suggested.) The backend doesn't need to know the HPKE context. Unless I made a mistake, which is entirely possible --- can you point me to the issue? (A comment on the line you're worried about would be ideal.)",
          "createdAt": "2020-08-21T00:28:16Z",
          "updatedAt": "2020-08-21T00:28:16Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the explanation.  You're right; I didn't understand that it is the _client_ who is performing the export.  That should be fine.\r\n\r\nI'm curious why you specify that the client perform this export operation, as opposed to using an unspecified source of randomness?  Is the server supposed to check that it matches, or ignore the contents?",
          "createdAt": "2020-08-21T00:32:50Z",
          "updatedAt": "2020-08-21T00:32:50Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I share Ben's curiosity -- it seems like the exporter provides no value here beyond what a PRNG would.  The client is differentiating between an echo of the value it provided in CHInner or a randomly-generated value supplied by the server in response to an empty value.  The same could be achieved by simply generating a random nonce and looking for an echo or not.",
          "createdAt": "2020-08-21T01:30:09Z",
          "updatedAt": "2020-08-21T01:30:09Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The same critique applies to the \"ech_nonce\" extension. I think the benefit of using the HPKE context here is reducing dependence on an \"unspecified source of randomness\" (i.e., PRNG).",
          "createdAt": "2020-08-21T14:53:53Z",
          "updatedAt": "2020-08-21T14:58:42Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As I've noted elsewhere, I don't understand why \"ech_nonce\" is needed at all.\r\n\r\nI don't have an informed opinion about the use of the exporter here, but I think we need to be clearer on whether the server is permitted to validate the contents.\r\n\r\nMy preference would be to give it a non-ECH-related name (e.g. \"client_hello_id\"), and require that servers not validate the contents.  I think that would be more conducive to wide deployment, including any future use cases where the applicable ClientHello is unclear.\r\n\r\nWe could also make the use of exporter a \"SHOULD\", if you think it's a good practice but not required for interoperability.",
          "createdAt": "2020-08-21T15:17:04Z",
          "updatedAt": "2020-08-21T15:17:04Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> As I've noted elsewhere, I don't understand why \"ech_nonce\" is needed at all.\r\n\r\nI tend to think \"ech_nonce\" should be removed, but we should confine that discussion to #253.\r\n\r\n> I don't have an informed opinion about the use of the exporter here, but I think we need to be clearer on whether the server is permitted to validate the contents.\r\n\r\nI'd suggest: \"the server MAY verify extension's contents and abort with an \"illegal_parameter\" alert if value is incorrect\".\r\n\r\n> My preference would be to give it a non-ECH-related name (e.g. \"client_hello_id\"), and require that servers not validate the contents. I think that would be more conducive to wide deployment, including any future use cases where the applicable ClientHello is unclear.\r\n\r\nUsage of \"ech_confirm\" implies usage of \"ech\", so I think there needs to be a clear association between the extensions' names. A name like \"client_hello_id\" removes this association. Perhaps it would be more appropriate to have the confirmation request be a field of the existing \"ech\" extension, rather than define a brand new extension for this purpose?\r\n\r\n> We could also make the use of exporter a \"SHOULD\", if you think it's a good practice but not required for interoperability.\r\n\r\nWhat's the value of giving the implementer a choice here? It seems to me that we should *either* use the PRNG *or* use the HPKE context. Since usage of \"ech_confirm\" implies usage of \"ech\", I think it's fine to go with the latter.",
          "createdAt": "2020-08-21T15:47:42Z",
          "updatedAt": "2020-08-21T15:50:07Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> What's the value of giving the implementer a choice here? It seems to me that we should _either_ use the PRNG _or_ use the HPKE context. Since usage of \"ech_confirm\" implies usage of \"ech\", I think it's fine to go with the latter.\r\n\r\nThe reverse argument is equally valid.  There's apparently no value in specifying how the client gets this number, only the properties that it needs to have (i.e. that an observer can't predict it).  If an implementation wants to use an exporter as a source of entropy, that breaks nothing, but any source of entropy will do.\r\n\r\nThe exporter seems primarily useful in the case where one side generates the value and the other side verifies it, which is another way to spell this approach.  It makes the server implementation marginally more complex, though, and I think the echo-or-random spelling is fine.\r\n\r\n> > My preference would be to give it a non-ECH-related name (e.g. \"client_hello_id\"), and require that servers not validate the contents. I think that would be more conducive to wide deployment, including any future use cases where the applicable ClientHello is unclear.\r\n> \r\n> Usage of \"ech_confirm\" implies usage of \"ech\", so I think there needs to be a clear association between the extensions' names. A name like \"client_hello_id\" removes this association. Perhaps it would be more appropriate to have the confirmation request be a field of the existing \"ech\" extension, rather than define a brand new extension for this purpose?\r\n\r\nI think @bemasc is looking to a future where either non-ECH clients include this extension to help ECH stand out less, or where the same mechanism could be used to disambiguate under other circumstances.  In other words, this doesn't inherently need to be an ECH-specific extension, merely one that ECH leverages, so perhaps it shouldn't be.\r\n\r\nOn both questions, I think my response is the same:  Let's not build in constraints that aren't actually accomplishing anything.",
          "createdAt": "2020-08-21T18:31:36Z",
          "updatedAt": "2020-08-21T18:31:36Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> On both questions, I think my response is the same: Let's not build in constraints that aren't actually accomplishing anything.\r\n\r\nWell said. I'm not sure about the name change, but I'm with you on using the PRNG instead of depending on HPKE. I'll change this in the PR.\r\n",
          "createdAt": "2020-08-21T21:29:47Z",
          "updatedAt": "2020-08-21T21:29:47Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Belay that, I forgot about split mode.  Though the duplication of the nonce remains a valid concern.",
          "createdAt": "2020-08-24T06:17:19Z",
          "updatedAt": "2020-08-24T06:17:19Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson:\r\n\r\n>  Though the duplication of the nonce remains a valid concern.\r\n\r\nWe might consider either (a) removing \"ech_nonce\" and replacing it with this or (b) re-purposing \"ech_nonce\". ",
          "createdAt": "2020-08-24T19:59:11Z",
          "updatedAt": "2020-08-24T19:59:11Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This proposes two 16 byte extensions that are generated in effectively identical fashion.  It seems like echoing ech_nonce would achieve the goal you are looking for here, at the cost of making this signaling mandatory.",
          "createdAt": "2020-08-25T00:15:09Z",
          "updatedAt": "2020-08-25T00:15:09Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> This proposes two 16 byte extensions that are generated in effectively identical fashion.  It seems like echoing ech_nonce would achieve the goal you are looking for here, at the cost of making this signaling mandatory.\r\n\r\nHave a look at the most recent changes--- the confirmation tag is now generated differently than \"ech_nonce\". I agree that \"ech_nonce\" is redundant, but I think this needs to be addressed in a separate PR.\r\n\r\n",
          "createdAt": "2020-08-25T17:13:33Z",
          "updatedAt": "2020-08-25T17:13:33Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> It might be nice to explicitly introduce the extension by saying it has three forms and spell them out.\r\n\r\nI'll address this tomorrow morning.",
          "createdAt": "2020-08-25T22:21:19Z",
          "updatedAt": "2020-08-25T22:21:38Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi @martinthomson,\r\n\r\n> We have an `ech` extension that appears in the outer CH and the inner CH. The outer contains HPKE junk, which is good. The inner contains ECHNonce (?). It appears in SH and echoes the value from the inner. It appears in EE and contains fallback info.\r\n\r\nI apologize for the lack of clarity. As @MikeBishop suggested, we should add a table that summarizes all of this information. Perhaps something like this:\r\n\r\n  | Message     | Payload type                            |\r\n  |-----------------|------------------------------------------|\r\n  | outer CH     | ClientECH (contains inner CH) |\r\n  | inner CH     | ECHNonce (random number) |\r\n  | SH              | ECHNonce (echoes inner CH on accept; random number on reject) |\r\n  | EE              | ServerECH (contains retry config) |   \r\n\r\n\r\n> But this still has `ech_nonce` defined, and relatively unchanged. So I'm now completely lost.\r\n\r\nAs I've said, I've been trying to keep changes to \"ech_nonce\" out of this PR. We could overload it by having the SH echo the payload of \"ech_nonce\", as you suggest; but this is a significant change to that extension's semantics. In particular, to mitigate the attack described in [Section 10.9.1](https://tlswg.org/draft-ietf-tls-esni/draft-ietf-tls-esni.html#name-client-reaction-attack-miti), the payload of \"ech_nonce\" needs to be kept secret. This would not be the case if it were echoed in the SH.\r\n\r\nTaking a step back, there's the larger question of whether \"ech_nonce\" is redundant. In particular, if the inner CH.random is independent from the outer CH.random, then the inner CH.random serves the same purpose as the \"ech_nonce\" extension. (See the discussion of issue #253.)\r\n\r\nThis leaves us to options: leave \"ech_nonce\" out of this PR and consider removing it later; or re-purpose \"ech_nonce\" for this PR. I'd be happy with either, but the latter needs to be discussed in the context of #253.\r\n\r\n> (I'm pretty sure that we will need to write a bunch of new code to handle the inner/outer split, but our extension handling code definitely won't like having the same extension in both inner and outer.)\r\n\r\nSomething to keep in mind is that ClientHelloInner is \"synthetic\" in the sense that it doesn't ever appear as a handshake message on the wire. It's consumed by the client-facing server in Shared Mode and used to construct a real ClientHello in Split Mode. Hence, the \"ech\" extension is only offered *on the wire* in CH, SH, and EE.\r\n\r\n",
          "createdAt": "2020-08-26T16:27:38Z",
          "updatedAt": "2020-08-26T17:24:11Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The usual way to present the different options for extension content is to use the `select` syntax.  But the split between inner and outer makes that hard.  Maybe the right thing to do is use ech_nonce for this and echo that in SH.  Then you have ech_nonce as `opaque[16]` and ech only appears in the outer CH and EE.",
          "createdAt": "2020-08-26T22:42:20Z",
          "updatedAt": "2020-08-26T22:42:20Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing in favor of #287.",
          "createdAt": "2020-09-03T17:13:16Z",
          "updatedAt": "2020-09-03T17:13:16Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Isn't there an issue with spoof and replay? Suppose an MITM observes a transaction and block the server's response. Instead, the MITM constructs its own SH, as a response to the outer CH, but sets the first 8 bytes of the server random to a copy of the 1st 8 bytes in the response of the original server. If the server was doing ECH, the connection between client and MITM will fail -- other wise it will succeed, or at least progress. The MITM has thus detected whether the server was doing ECH.",
          "createdAt": "2020-09-03T17:19:30Z",
          "updatedAt": "2020-09-03T17:19:30Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@huitema, your question doesn't apply to this PR. Can you please re-post it to  #287?",
          "createdAt": "2020-09-03T17:23:06Z",
          "updatedAt": "2020-09-03T17:23:06Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMDc1OTE4",
          "commit": {
            "abbreviatedOid": "434b0ac"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Why does this use the same construction as `ech_nonce`?  Wouldn't it be better to have the server produce a new value derived from the same context?  That is, make this `ech_nonce` with a different context string.\r\n\r\nHaving the confirmation optional is a feature you should lose.  Absent some concerns in the discussion that I don't share, it isn't a good idea to build all the options.",
          "createdAt": "2020-08-24T01:49:45Z",
          "updatedAt": "2020-08-24T01:49:45Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczODAyODUx",
          "commit": {
            "abbreviatedOid": "434b0ac"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I haven't had the chance to look at this carefully yet (procrastinating on writing perf review things :-) ), but some surface-level comments below:",
          "createdAt": "2020-08-24T19:42:37Z",
          "updatedAt": "2020-08-24T19:58:57Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "Did you mean to rename the `ExtensionType` value instead?",
              "createdAt": "2020-08-24T19:42:37Z",
              "updatedAt": "2020-09-03T01:18:48Z"
            },
            {
              "originalPosition": 239,
              "body": "HRR right now is quite a headache if the client doesn't match the inner and outer key_share and cipher suite preferences (to the point that I'd argue we should mandate that in the current form). If we're going the new extension route, I think it makes sense to put the indicator in HRR too. But we can sort that out separately.",
              "createdAt": "2020-08-24T19:49:27Z",
              "updatedAt": "2020-09-03T01:18:48Z"
            },
            {
              "originalPosition": 121,
              "body": "Why is this optional? Either it's part of the protocol or not. The spec should pick one. Variations in specs cause complexity throughout the system (every server would need to test both and make sure they work) and should only be there when they're necessary.\r\n\r\nNote also that TLS does not allow unsolicited extensions, so any ServerHello extension either needs to be in the ClientHello (but mandated), or we that if you offer `ech`, an `ech_confirm` response is allowed as a special case. Alternatively...\r\n\r\nHaving two separate extensions at all seems unnecessary. Why not just use the `ech` codepoint? That would avoid this entire mess. There's plenty of precedent for extensions taking different forms in different contexts (`key_share` looks different between ClientHello, HelloRetryRequest, and ServerHello).\r\n\r\n(Hrm. I'm not sure how the unsolicited extensions rule works if the inner ClientHello is chosen and lacks the `ech` extension. Something we may also need to sort out.)",
              "createdAt": "2020-08-24T19:55:22Z",
              "updatedAt": "2020-09-03T01:18:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczODE1MjQ0",
          "commit": {
            "abbreviatedOid": "4962d98"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T20:01:43Z",
          "updatedAt": "2020-08-24T20:01:44Z",
          "comments": [
            {
              "originalPosition": 121,
              "body": "I had the same thought. The problem I see is that we currently use the \"ech\" codepoint for retry keys. We might define a codepoint for \"ech_retry\" so that the confirmation logic is carried by \"ech\". However, the client needs to solicit this extension.\r\n\r\nI'm open to this if it makes more sense!",
              "createdAt": "2020-08-24T20:01:43Z",
              "updatedAt": "2020-09-03T01:18:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczODIyMzQx",
          "commit": {
            "abbreviatedOid": "16b81df"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T20:12:57Z",
          "updatedAt": "2020-08-24T20:12:58Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "Yes, thanks for spotting this!\r\n\r\nI apologize for that careless mistake.",
              "createdAt": "2020-08-24T20:12:57Z",
              "updatedAt": "2020-09-03T01:18:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczODI2Njgx",
          "commit": {
            "abbreviatedOid": "16b81df"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T20:19:54Z",
          "updatedAt": "2020-08-24T20:19:55Z",
          "comments": [
            {
              "originalPosition": 121,
              "body": "The retry keys are carried in EncryptedExtensions while this is ServerHello, right? I don't think we've any precedent yet for an SH + EE extension, but extensions having different format between messages is common and seems fine to me.",
              "createdAt": "2020-08-24T20:19:54Z",
              "updatedAt": "2020-09-03T01:18:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczODI4NDU3",
          "commit": {
            "abbreviatedOid": "16b81df"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T20:22:42Z",
          "updatedAt": "2020-08-24T20:22:43Z",
          "comments": [
            {
              "originalPosition": 121,
              "body": "One nice thing about \"ech\" / \"ech_retry\" is that it aligns ECH with the usual TLS extension logic, since the server can opt-out of both without breaking the protocol. Currently if the client offers \"ech_confirm\", the server MUST respond, or else be non-compliant.",
              "createdAt": "2020-08-24T20:22:42Z",
              "updatedAt": "2020-09-03T01:18:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczODMzMTk2",
          "commit": {
            "abbreviatedOid": "16b81df"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T20:30:07Z",
          "updatedAt": "2020-08-24T20:30:07Z",
          "comments": [
            {
              "originalPosition": 121,
              "body": "> The retry keys are carried in EncryptedExtensions while this is ServerHello, right?\r\n\r\nYes.\r\n\r\n> I don't think we've any precedent yet for an SH + EE extension, but extensions having different format between messages is common and seems fine to me.\r\n\r\nI was under the impression that this is disallowed in TLS 1.3, but looking at RFC 8446 I'm not so sure.\r\n",
              "createdAt": "2020-08-24T20:30:07Z",
              "updatedAt": "2020-09-03T01:18:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczODkzMTIy",
          "commit": {
            "abbreviatedOid": "16b81df"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T22:13:59Z",
          "updatedAt": "2020-08-24T22:14:00Z",
          "comments": [
            {
              "originalPosition": 121,
              "body": "> I was under the impression that this is disallowed in TLS 1.3, but looking at RFC 8446 I'm not so sure.\r\n\r\nTo clarify: I'm aware of extensions in which the server's response may be in one of many messages, but I'm not aware of any case in which the same extension appears in multiple messages in the same flight. I'd be fine with this, though it might be a pain for NSS (cc/ @martinthomson).",
              "createdAt": "2020-08-24T22:13:59Z",
              "updatedAt": "2020-09-03T01:18:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0MDA5NTA2",
          "commit": {
            "abbreviatedOid": "16b81df"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T00:13:39Z",
          "updatedAt": "2020-08-25T00:13:39Z",
          "comments": [
            {
              "originalPosition": 121,
              "body": "I think that we can make it work if we need to.",
              "createdAt": "2020-08-25T00:13:39Z",
              "updatedAt": "2020-09-03T01:18:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0MDA5OTE3",
          "commit": {
            "abbreviatedOid": "16b81df"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T00:14:57Z",
          "updatedAt": "2020-08-25T00:14:58Z",
          "comments": [
            {
              "originalPosition": 121,
              "body": "Right on, I'll update this PR tomorrow morning.",
              "createdAt": "2020-08-25T00:14:58Z",
              "updatedAt": "2020-09-03T01:18:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0Njg1NDM1",
          "commit": {
            "abbreviatedOid": "fd7dabb"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T17:10:57Z",
          "updatedAt": "2020-08-25T17:10:58Z",
          "comments": [
            {
              "originalPosition": 121,
              "body": "Updated! I dropped \"ech_confirm\" and changed the semantics of \"ech\". Specifically, the extension appears in four messageas:\r\n- ClientHelloOuter, same payload as usual;\r\n- CleintHelloInner, with a random ECHNonce;\r\n- ServerHello, with an ECHNonce that is the same as the ClientHelloInner in case of acceptance and a random value otherwise; and\r\n- EncryptedExtensions, with retry ECHConfigs.",
              "createdAt": "2020-08-25T17:10:57Z",
              "updatedAt": "2020-09-03T01:18:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0ODAxODQ2",
          "commit": {
            "abbreviatedOid": "9afc2dd"
          },
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "So just so we're clear, this extension now has three possible forms in four locations:\r\n\r\n- ClientECH in ClientHelloOuter\r\n- ECHNonce in ClientHelloInner and ServerHello\r\n- ServerECH in EncryptedExtensions\r\n\r\nIt might be nice to explicitly introduce the extension by saying it has three forms and spell them out.  They're all there, but it's a little confusing to read a definition followed by an exception followed by an exception to the exception.",
          "createdAt": "2020-08-25T19:49:42Z",
          "updatedAt": "2020-08-25T20:08:35Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "```suggestion\r\nWhen the client offers the \"ech\" extension, the server MAY include an \"ech\"\r\n```",
              "createdAt": "2020-08-25T19:49:42Z",
              "updatedAt": "2020-09-03T01:18:49Z"
            },
            {
              "originalPosition": 244,
              "body": "```suggestion\r\nmessage with a ClientECH value, servers set up their HPKE context and\r\n```",
              "createdAt": "2020-08-25T19:54:52Z",
              "updatedAt": "2020-09-03T01:18:49Z"
            },
            {
              "originalPosition": 433,
              "body": "```suggestion\r\n   \"CH, SH, EE\", and \"Recommended\" column being set to \"Yes\".\r\n```",
              "createdAt": "2020-08-25T20:04:02Z",
              "updatedAt": "2020-09-03T01:18:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0OTQ1ODUz",
          "commit": {
            "abbreviatedOid": "9afc2dd"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T22:05:21Z",
          "updatedAt": "2020-08-25T22:05:21Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "Done.",
              "createdAt": "2020-08-25T22:05:21Z",
              "updatedAt": "2020-09-03T01:18:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0OTQ2NDg1",
          "commit": {
            "abbreviatedOid": "9afc2dd"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T22:06:30Z",
          "updatedAt": "2020-08-25T22:06:30Z",
          "comments": [
            {
              "originalPosition": 244,
              "body": "Done.",
              "createdAt": "2020-08-25T22:06:30Z",
              "updatedAt": "2020-09-03T01:18:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0OTQ3MzQz",
          "commit": {
            "abbreviatedOid": "9afc2dd"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T22:08:12Z",
          "updatedAt": "2020-08-25T22:08:13Z",
          "comments": [
            {
              "originalPosition": 433,
              "body": "Done.",
              "createdAt": "2020-08-25T22:08:12Z",
              "updatedAt": "2020-09-03T01:18:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1MDgwNDA0",
          "commit": {
            "abbreviatedOid": "98bf22f"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This seems very confusing right now.\r\n\r\nWe have an `ech` extension that appears in the outer CH and the inner CH.  The outer contains HPKE junk, which is good.  The inner contains ECHNonce (?).  It appears in SH and echoes the value from the inner.  It appears in EE and contains fallback info.\r\n\r\nBut this still has `ech_nonce` defined, and relatively unchanged.  So I'm now completely lost.\r\n\r\n(I'm pretty sure that we will need to write a bunch of new code to handle the inner/outer split, but our extension handling code definitely won't like having the same extension in both inner and outer.)",
          "createdAt": "2020-08-26T00:58:14Z",
          "updatedAt": "2020-08-26T01:02:43Z",
          "comments": [
            {
              "originalPosition": 157,
              "body": "Is this still here?  This change is a little confusing now.  (I find the document confusing, frankly.)",
              "createdAt": "2020-08-26T00:58:15Z",
              "updatedAt": "2020-09-03T01:18:49Z"
            }
          ]
        }
      ]
    },
    {
      "number": 286,
      "id": "MDExOlB1bGxSZXF1ZXN0NDczNDYyODI4",
      "title": "Add ECH confirmation (option (3), can fall back to (2))",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/286",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is an alternative to #283 where by the server indicates what it confirms in the ECHConfig. Either explicitly it indicates acceptance or rejection, as in option (3); or it indicates rejection only, as in option (2). It also adds an expiration date to the ECH configuration.\r\n\r\nThis PR also adds deployment considerations for server rollback. In particular, for option (2) the server must not rollback ECH until the ECH configuration. expires.\r\n\r\nThis addresses #274.",
      "createdAt": "2020-08-25T20:23:16Z",
      "updatedAt": "2021-04-16T19:56:21Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3ee7678e12c49cd6015899e675bf227bbb50835b",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "ech_confirmation2",
      "headRefOid": "8ccf78255009f33cbc3fbe5d6a9b18e40d75bdee",
      "closedAt": "2020-09-03T17:13:50Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "NOTE: This branch needs to be rebased on #283. Ping me if you'd like me to do this.",
          "createdAt": "2020-09-02T18:18:16Z",
          "updatedAt": "2020-09-02T18:18:16Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing in favor of #287.",
          "createdAt": "2020-09-03T17:13:50Z",
          "updatedAt": "2020-09-03T17:13:50Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 287,
      "id": "MDExOlB1bGxSZXF1ZXN0NDczNDYyOTEy",
      "title": "Add ECH confirmation signal",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/287",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This change provides an explicit confirmation of ECH acceptance. To do so, the backend server overwrites the last 8 bytes of the SH.random with a value derived from ClientHelloInner.random and the first 24 bytes of ServerHello.random.\r\n\r\nThis addresses #274.\r\n\r\nREVISED 9/21.",
      "createdAt": "2020-08-25T20:23:21Z",
      "updatedAt": "2021-04-16T19:56:27Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "375b4587f2981c414b5a737d3e98823c6ce1cba9",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "ech_confirmation3",
      "headRefOid": "213766c135dac70dcf82212cad3a2ccada626b50",
      "closedAt": "2020-09-22T20:44:35Z",
      "mergedAt": "2020-09-22T20:44:35Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "723af1d0f30c1461902716bfda10e050c25b3511"
      },
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Isn't there an issue with spoof and replay? Suppose an MITM observes a transaction and block the server's response. Instead, the MITM constructs its own SH, as a response to the outer CH, but sets the first 8 bytes of the server random to a copy of the 1st 8 bytes in the response of the original server. If the server was doing ECH, the connection between client and MITM will fail -- other wise it will succeed, or at least progress. The MITM has thus detected whether the server was doing ECH.",
          "createdAt": "2020-09-03T17:21:37Z",
          "updatedAt": "2020-09-03T17:21:37Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Providing details of the attack mentioned above, in QUIC context:\r\n```\r\nCH (include ECH) sent in QUIC Initial Packet ---->\r\n              MITM copies and forwards from its own address ------->\r\n                              Server processes CH/ECH, creates SH.\r\n                              If processing ECH, sticks 8 bytes hint in Server Random\r\n                         <--- Server sends packet in QUIC Initial Packet\r\n              MITM creates its own MITM-SH, with 8 bytes of server random copied from real SH\r\n         <--- MITM coalesces Initial packet (MITM-SH) with Hanshake packet (First bytes of encrypted extension)\r\nIf Client accepts SH, client computes handshake key using secrets from outer CH,\r\nSend ACK in Handshake packet --->\r\n              MITM decrypts handshake packet, assesses that EH was not \r\n              used. Drops the connection at that point.\r\n\r\nIf Client recognizes hint, client computes handshake key using secrets from inner ECH,\r\nand cannot decrypt Handshake packet. Client may send Initial ACK, will not\r\nsend Handshake ACK.\r\n              MITM observes that it does not receive handshake ACK,\r\n              May repeat its own Initial and Handshake packets a couple time to be sure.\r\n              After 3-4 repeats, deduces that ECH was used by client and server.\r\n```",
          "createdAt": "2020-09-03T17:53:11Z",
          "updatedAt": "2020-09-03T17:56:25Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am thinking of solutions that are robust against this kind of MITM attack, but they are more complicated than just copying the 8 bytes. You need to make the 8 byte some kind of hash of both the client's hint and the server's key share. That way, anyone replaying the hint has to use the same key share, and cannot hope to decrypt the responses.",
          "createdAt": "2020-09-03T18:07:29Z",
          "updatedAt": "2020-09-03T18:07:29Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@huitema: This mechanism isn't designed to prevent an active attacker from deducing whether ECH was used. Note that there are much simpler attacks for doing so: just probe the target server for the ECH configuration, then observe a handshake between the target client and the server.",
          "createdAt": "2020-09-03T18:15:35Z",
          "updatedAt": "2020-09-03T18:15:35Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@cjpatton I agree that it boils down to \"do we care\". The current ECH design does stick out quite a bit. The MITM can find whether the client sent an ECH extension. So it may make sense to keep it simple, accept the vulnerability, and document it in the ECH security considerations. ",
          "createdAt": "2020-09-03T18:28:18Z",
          "updatedAt": "2020-09-03T18:28:18Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For that matter, you could replay the ClientHello several times and check whether the interesting bytes of the server's keyshare or the extension remain constant for any of these designs, assuming the server doesn't have more general defenses against a replayed ClientHello.  As long as it's a simple echo, I think that criticism is fair against all of these proposals.  Which means either complexity or accepting that such detection is inevitable anyway.",
          "createdAt": "2020-09-03T18:45:16Z",
          "updatedAt": "2020-09-03T18:45:16Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "We can fix the constant aspect by incorporating the rest of the ServerHello.random. But yeah, it's a question of what kind of attacker we're interested in for GREASE. If we want to defeat active attacks, I think we'd need to do things like:\r\n\r\n* Bind the *entire* outer CH into the ECH decryption. Otherwise, there's attacks ranging from the key shares to simply replacing the cipher suite list with garbage. (If the server responds, the server must not have looked at the outer cipher suite.)\r\n* Switch decryption failure to fallback rather than error (#290), otherwise the attacker could perturb the ciphertext and see if the server noticed.\r\n\r\nThen there's whether the attacker is allowed to compare config_ids in two connections, or look up and recognize the particular server's ECH config. For example, if you do a DNS lookup or just trigger the retry flow, you can learn the expected config_id and look for it. The trial decryption option or #177 could work. From there, there's still recognizing the public name from the queried ECH config. (Though that depends on whether the public name is one you'd expect in normal traffic or not.)",
          "createdAt": "2020-09-03T20:29:54Z",
          "updatedAt": "2020-09-03T20:29:54Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Regarding the \"don't stick out\" requirement, the goal of this proposal is *not* to thwart an active distinguisher, but merely to trick a dumb middlebox, which we presume to be passive and ignorant of the configuration. It would be helpful if folks would limit discussion of attacks/mitigations to this narrow threat model and resume discussion of the threat model itself in #274.",
          "createdAt": "2020-09-04T01:17:51Z",
          "updatedAt": "2020-09-04T01:21:20Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I think what @davidben is suggesting is that we address @huitema's attack by computing SH.Random as follows:\r\n\r\n```\r\nSH.Random = R || HMAC(CH.Random, R)\r\n```\r\n\r\nHowever, as he says, there seem to be a lot of active attacks to determine if ECH was used on a single connection.\r\n\r\n\r\n",
          "createdAt": "2020-09-08T02:14:33Z",
          "updatedAt": "2020-09-08T02:14:33Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ekr, I do not think that the fix suggested by @bemasc and @davidben solves the problem. The only change in the attack would be:\r\n```\r\n                         <--- Server sends packet in QUIC Initial Packet\r\n              MITM creates its own MITM-SH, with 8 bytes of server random copied from real SH\r\n                                                 ^\r\n                                                 +-- with 32 bytes...\r\n```\r\nCan we keep this discussion in issue #274?",
          "createdAt": "2020-09-08T04:10:38Z",
          "updatedAt": "2020-09-08T04:11:04Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "From the interim: merge this, and address \"extended\" trial HMAC variants in a followup PR (or extension in the ECHConfig).",
          "createdAt": "2020-09-21T15:12:30Z",
          "updatedAt": "2020-09-21T15:12:30Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwMTE2NzA0",
          "commit": {
            "abbreviatedOid": "0b96eb3"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-01T21:08:19Z",
          "updatedAt": "2020-09-01T21:08:20Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Very minor nitpick: Looks like most other TLS extensions are left unabbreviated. It does mean we lose the nice parallel between `ech_nonce` and `ech_outer_extension`, though if we pick up https://github.com/tlswg/draft-ietf-tls-esni/pull/292, the former will go away. Dunno how important a prefixed `ech_outer_extension` is.",
              "createdAt": "2020-09-01T21:08:19Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwMTEwMjMx",
          "commit": {
            "abbreviatedOid": "0b96eb3"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thanks for writing this up!",
          "createdAt": "2020-09-01T20:58:11Z",
          "updatedAt": "2020-09-01T21:51:57Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "Perhaps add a sentence explaining the purpose of these 8 bytes?\r\n\r\nAlso, can we consider defining the 8-byte payload variant in `ClientECH`'s definition above? I feel like this is a gotcha for implementers.\r\n\r\n\\<digression> The variants wouldn't even need a tag, since we can distinguish based on the length. The smallest normal `ClientECH` is 10 bytes. However, I don't think the TLS presentation language can express C-style unions.",
              "createdAt": "2020-09-01T20:58:12Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            },
            {
              "originalPosition": 173,
              "body": "Nit: s/which/which ClientHello/",
              "createdAt": "2020-09-01T21:19:39Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            },
            {
              "originalPosition": 174,
              "body": "Nit: I would refactor the sentence beginning with \"To do so\". Something like this?\r\n\r\n> The client presumes acceptance if the last 8 bytes of the ServerHello.random are equal to the ClientHelloInner's \"ech\" extension payload. Otherwise, it presumes rejection.",
              "createdAt": "2020-09-01T21:24:38Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            },
            {
              "originalPosition": 355,
              "body": "Style nit: so far, the spec has been hyphenating \"randomly-generated\".",
              "createdAt": "2020-09-01T21:28:29Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            },
            {
              "originalPosition": 394,
              "body": "(I lied, here's the one place we did not hyphenate \"randomly generated\".)",
              "createdAt": "2020-09-01T21:29:29Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            },
            {
              "originalPosition": 421,
              "body": "s/thatthe/that the/",
              "createdAt": "2020-09-01T21:33:25Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMDM4NzE2",
          "commit": {
            "abbreviatedOid": "0b96eb3"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-02T17:20:15Z",
          "updatedAt": "2020-09-02T17:20:16Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "I'll revert to the old name and we can revisit extension naming once the dust settles.",
              "createdAt": "2020-09-02T17:20:15Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMTMxNzg1",
          "commit": {
            "abbreviatedOid": "0b96eb3"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-02T18:09:38Z",
          "updatedAt": "2020-09-02T18:09:38Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "Good idea! Done.\r\n\r\nRe \"digression\": The tag is only a byte, so the minimum ClientECH is 9 bytes.",
              "createdAt": "2020-09-02T18:09:38Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMTM3Nzc3",
          "commit": {
            "abbreviatedOid": "0b96eb3"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-02T18:12:27Z",
          "updatedAt": "2020-09-02T18:12:27Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "Did s/which/which value/. I don't think we should be calling ClientHelloInner a \"ClientHello\", since ClientHelloInner isn't a handshake message on the wire.",
              "createdAt": "2020-09-02T18:12:27Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMTQxOTY2",
          "commit": {
            "abbreviatedOid": "0b96eb3"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-02T18:14:20Z",
          "updatedAt": "2020-09-02T18:14:20Z",
          "comments": [
            {
              "originalPosition": 174,
              "body": "Good idea! Done.",
              "createdAt": "2020-09-02T18:14:20Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMTQzNjU2",
          "commit": {
            "abbreviatedOid": "0b96eb3"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-02T18:15:05Z",
          "updatedAt": "2020-09-02T18:15:05Z",
          "comments": [
            {
              "originalPosition": 355,
              "body": "Done.",
              "createdAt": "2020-09-02T18:15:05Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMTQ1MDc1",
          "commit": {
            "abbreviatedOid": "0b96eb3"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-02T18:15:43Z",
          "updatedAt": "2020-09-02T18:15:43Z",
          "comments": [
            {
              "originalPosition": 421,
              "body": "Done.",
              "createdAt": "2020-09-02T18:15:43Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMTQ3NjQ3",
          "commit": {
            "abbreviatedOid": "0b96eb3"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-02T18:16:53Z",
          "updatedAt": "2020-09-02T18:16:53Z",
          "comments": [
            {
              "originalPosition": 394,
              "body": "Ack. \"randomly generated\" only appears at one point in the text, which is not related to this change.",
              "createdAt": "2020-09-02T18:16:53Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMTY5MTUy",
          "commit": {
            "abbreviatedOid": "8e0668c"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good modulo one comment",
          "createdAt": "2020-09-02T18:45:40Z",
          "updatedAt": "2020-09-02T19:14:01Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Thanks for spelling this out!\r\n\r\nI just realized the \"encrypted_client_hello\" extension is also reused to send `retry_configs` in the ServerHello.  Based on context, we know that the payload is a `ServerECH` rather than a `ClientECH`.\r\n\r\nPerhaps it's fine to use context to distinguish between the ClientHelloOuter's `ClientECH` and the ClientHelloInner's `uint8 accept_confirmation [8]` payload.  You could define a new struct or a type alias.\r\n\r\nSorry to go back on forth on this point. I'm not sure what the better choice is.",
              "createdAt": "2020-09-02T18:45:40Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMjMwOTEw",
          "commit": {
            "abbreviatedOid": "8e0668c"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-02T19:24:09Z",
          "updatedAt": "2020-09-02T19:24:09Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I think it's fine as is. To summarize:\r\n\r\n| Message | Payload |\r\n|--------------|------------|\r\n| ClientHelloOuter | ClientECH (outer variant) |\r\n| ClientHelloInner | ClientECH (inner variant) |\r\n| EncryptedExtensions | ServerECH |",
              "createdAt": "2020-09-02T19:24:09Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxOTc2Mzk0",
          "commit": {
            "abbreviatedOid": "a2672d2"
          },
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-03T15:50:18Z",
          "updatedAt": "2020-09-03T15:50:23Z",
          "comments": [
            {
              "originalPosition": 343,
              "body": "Does this design variant ever send the ECH extension in the ServerHello?  Or is it only in the Encrypted Extensions?",
              "createdAt": "2020-09-03T15:50:18Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxOTkyMjM3",
          "commit": {
            "abbreviatedOid": "a2672d2"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-03T16:06:32Z",
          "updatedAt": "2020-09-03T16:06:32Z",
          "comments": [
            {
              "originalPosition": 343,
              "body": "Only in EE. ",
              "createdAt": "2020-09-03T16:06:32Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyMDU0OTEx",
          "commit": {
            "abbreviatedOid": "a2672d2"
          },
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-03T17:27:52Z",
          "updatedAt": "2020-09-03T17:27:53Z",
          "comments": [
            {
              "originalPosition": 343,
              "body": "```suggestion\r\n   \"CH, EE\", and \"Recommended\" column being set to \"Yes\".\r\n```",
              "createdAt": "2020-09-03T17:27:52Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzNzczMjA2",
          "commit": {
            "abbreviatedOid": "a2672d2"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-08T03:30:36Z",
          "updatedAt": "2020-09-08T03:31:57Z",
          "comments": [
            {
              "originalPosition": 316,
              "body": "```suggestion\r\nserver terminates the connection, but does not process the ech extension: if the last 8 bytes of its ServerHello.random\r\n```",
              "createdAt": "2020-09-08T03:30:36Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MzM2MDAx",
          "commit": {
            "abbreviatedOid": "a2672d2"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-08T17:07:01Z",
          "updatedAt": "2020-09-08T17:07:01Z",
          "comments": [
            {
              "originalPosition": 316,
              "body": "Changed to \"i.e., ECH is rejected or ignored\"",
              "createdAt": "2020-09-08T17:07:01Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5MDM2OTk3",
          "commit": {
            "abbreviatedOid": "2d88f7b"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-15T20:15:59Z",
          "updatedAt": "2020-09-15T20:15:59Z",
          "comments": [
            {
              "originalPosition": 210,
              "body": "s/SrverHello/ServerHello/",
              "createdAt": "2020-09-15T20:15:59Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5OTQ3MTA2",
          "commit": {
            "abbreviatedOid": "2d88f7b"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-16T19:14:29Z",
          "updatedAt": "2020-09-16T19:14:30Z",
          "comments": [
            {
              "originalPosition": 279,
              "body": "s/for/or",
              "createdAt": "2020-09-16T19:14:30Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyNzI0MzUz",
          "commit": {
            "abbreviatedOid": "44b9d41"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-21T15:17:54Z",
          "updatedAt": "2020-09-21T15:17:54Z",
          "comments": [
            {
              "originalPosition": 210,
              "body": "Did we decide that HKDF-Extract was OK? We never use raw HKDF-Extract anywhere else in TLS 1.3.",
              "createdAt": "2020-09-21T15:17:54Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyNzYyODc3",
          "commit": {
            "abbreviatedOid": "44b9d41"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-21T15:59:44Z",
          "updatedAt": "2020-09-21T15:59:45Z",
          "comments": [
            {
              "originalPosition": 210,
              "body": "It seems fine to me, since the ClientHelloInner.random is secret and we need is a pseudorandom string. I'll take another look at the HKDF paper and get back to you. (Also, it would be great to hear from others on this.)",
              "createdAt": "2020-09-21T15:59:44Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyODA4MjU4",
          "commit": {
            "abbreviatedOid": "c870041"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-21T16:56:43Z",
          "updatedAt": "2020-09-21T16:56:44Z",
          "comments": [
            {
              "originalPosition": 210,
              "body": "Judging from [1, Section 6], just using HKDF-Extract might be fine, but it seems rather \"hacky\". I think we should err on the conservative side and use HKDF-Extract-then-Expand. Will update the PR to reflect this.",
              "createdAt": "2020-09-21T16:56:44Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzMzc5NzU4",
          "commit": {
            "abbreviatedOid": "b8e4cc4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Very succinct! I have a couple of requests to clarify things, but other than that this should be good to go.",
          "createdAt": "2020-09-22T11:53:45Z",
          "updatedAt": "2020-09-22T12:10:06Z",
          "comments": [
            {
              "originalPosition": 148,
              "body": "(As on the nonce PR)\r\n\r\n```suggestion\r\n- It MUST include the \"encrypted_client_hello\" extension in its\r\n```",
              "createdAt": "2020-09-22T11:53:46Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            },
            {
              "originalPosition": 209,
              "body": "```suggestion\r\nvalue of ServerHello.random[0:24] is generated as usual by invoking a secure\r\nrandom number generator (see {{RFC8446}}, Section 4.1.2).\r\n```",
              "createdAt": "2020-09-22T11:56:30Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            },
            {
              "originalPosition": 281,
              "body": "```suggestion\r\nNote that the same bytes of the ServerHello.random are used to implement\r\ndowngrade protection for TLS 1.3 (see {{RFC8446}}, Section\r\n4.1.3). The backend server's signal of acceptance does not interfere with this\r\nmechanism because ECH is only supported in TLS 1.3 or higher.\r\n```",
              "createdAt": "2020-09-22T12:01:07Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            },
            {
              "originalPosition": 276,
              "body": "Can we be explicit with the collision probability? (RFC8446 reserves two sentinel values for the downgrade signals.) We might also note that this probability is equivalent to that of network or transport failures, so in practice it's not much of a concern.",
              "createdAt": "2020-09-22T12:04:35Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            },
            {
              "originalPosition": 261,
              "body": "Why is this Abuse? \"ECH Acceptance Signal Collisions\" seems to better capture the text below.",
              "createdAt": "2020-09-22T12:05:23Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            },
            {
              "originalPosition": 266,
              "body": "I understand that technically the active adversary can try to exploit this to find matching sessions, but I think the notion might just confuse readers.\r\n\r\n```suggestion\r\n{{backend-server-behavior}} for details.) This behavior increases the likelihood of the ServerHello.random\r\n```",
              "createdAt": "2020-09-22T12:06:39Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTQzNTEx",
          "commit": {
            "abbreviatedOid": "b8e4cc4"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T14:48:06Z",
          "updatedAt": "2020-09-22T14:48:06Z",
          "comments": [
            {
              "originalPosition": 148,
              "body": "Is MUST appropriate here? SHOULD should suffice, since the client would regard ECH as \"securely disabled\".",
              "createdAt": "2020-09-22T14:48:06Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTQ0MDcw",
          "commit": {
            "abbreviatedOid": "b8e4cc4"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T14:48:39Z",
          "updatedAt": "2020-09-22T14:48:39Z",
          "comments": [
            {
              "originalPosition": 209,
              "body": "Done.",
              "createdAt": "2020-09-22T14:48:39Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTQ1MjM0",
          "commit": {
            "abbreviatedOid": "b8e4cc4"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T14:49:43Z",
          "updatedAt": "2020-09-22T14:49:44Z",
          "comments": [
            {
              "originalPosition": 281,
              "body": "Done.",
              "createdAt": "2020-09-22T14:49:44Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTUxMDM1",
          "commit": {
            "abbreviatedOid": "b8e4cc4"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T14:54:59Z",
          "updatedAt": "2020-09-22T14:54:59Z",
          "comments": [
            {
              "originalPosition": 276,
              "body": "> Can we be explicit with the collision probability?\r\n\r\nDone.\r\n\r\n> (RFC8446 reserves two sentinel values for the downgrade signals.)\r\n\r\nNot sure what this comment is about.\r\n\r\n> We might also note that this probability is equivalent to that of network or transport failures, so in practice it's not much of a concern.\r\n\r\nWould you mind suggesting text for this? I'm not sure I know enough about TCP to be accurate about this.",
              "createdAt": "2020-09-22T14:54:59Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTUyNDc1",
          "commit": {
            "abbreviatedOid": "b8e4cc4"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T14:56:20Z",
          "updatedAt": "2020-09-22T14:56:21Z",
          "comments": [
            {
              "originalPosition": 261,
              "body": "The title is meant to encompass all possible attacks that exploit the acceptance confirmation signal. How about \"Attacks Exploiting Acceptance Confirmation\"?",
              "createdAt": "2020-09-22T14:56:21Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTUzNjI4",
          "commit": {
            "abbreviatedOid": "b8e4cc4"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T14:57:23Z",
          "updatedAt": "2020-09-22T14:57:23Z",
          "comments": [
            {
              "originalPosition": 266,
              "body": "Agreed. Done.",
              "createdAt": "2020-09-22T14:57:23Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTY1MTE3",
          "commit": {
            "abbreviatedOid": "72a029b"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T15:08:16Z",
          "updatedAt": "2020-09-22T15:08:17Z",
          "comments": [
            {
              "originalPosition": 148,
              "body": "Done, in light of your comment on #292.",
              "createdAt": "2020-09-22T15:08:17Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzODMxOTM1",
          "commit": {
            "abbreviatedOid": "72a029b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T20:44:13Z",
          "updatedAt": "2020-09-22T20:44:14Z",
          "comments": [
            {
              "originalPosition": 261,
              "body": "```suggestion\r\n## Attacks Exploiting Acceptance Confirmation\r\n```",
              "createdAt": "2020-09-22T20:44:13Z",
              "updatedAt": "2020-09-22T20:44:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzODMyMDg4",
          "commit": {
            "abbreviatedOid": "213766c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-22T20:44:27Z",
          "updatedAt": "2020-09-22T20:44:27Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzODMyNDU4",
          "commit": {
            "abbreviatedOid": "213766c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T20:44:59Z",
          "updatedAt": "2020-09-22T20:44:59Z",
          "comments": [
            {
              "originalPosition": 276,
              "body": "Ah, missed this. I'll file an issue to add it! ",
              "createdAt": "2020-09-22T20:44:59Z",
              "updatedAt": "2020-09-22T20:44:59Z"
            }
          ]
        }
      ]
    },
    {
      "number": 291,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc3MjYzMjcz",
      "title": "Clarify distinction between rejection and decryption failure",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/291",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In places, the current draft doesn't make a clear distinction between rejection and decryption failure. In particular \"cannot decrypt\" can be interpreted either:\r\n\r\n* \"the client-facing server doesn't recognize the configuration specified by the client\"; \r\n* or \"the client-facing server recognizes the configuration but decryption fails\".\r\n\r\nThis change resolves this ambiguity. Addresses issue #290.\r\n",
      "createdAt": "2020-09-01T18:42:52Z",
      "updatedAt": "2021-04-16T19:56:23Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3426cfbf3f25bd2aa23a13e8700702717c05a42f",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "cannot_decrypt",
      "headRefOid": "629e5ba15ff1bf55d90e79e6c08b962fc788472a",
      "closedAt": "2020-09-18T21:19:23Z",
      "mergedAt": "2020-09-18T21:19:23Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "2a56d1fdac5b80376554cb14b9089f7acb8f1d47"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxNzg3MTA1",
          "commit": {
            "abbreviatedOid": "629e5ba"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-18T21:19:18Z",
          "updatedAt": "2020-09-18T21:19:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 292,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc3MzMwMjI0",
      "title": "Remove \"ech_nonce\" extension and clarify client behavior",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/292",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The purpose of \"ech_nonce\" is to mitigate the \"client reaction\" attack described in security considerations. It is redundant, however, since the ClientHelloInner.random serves the same function. This change removes the \"ech_nonce\" extension and clarifies the client behavior so that securely generating ClientHelloInner.random is an explicit requirement.\r\n\r\nThis addresses #253.\r\n\r\nBased on #287.",
      "createdAt": "2020-09-01T20:56:09Z",
      "updatedAt": "2021-04-16T19:56:29Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "723af1d0f30c1461902716bfda10e050c25b3511",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "remove_ech_nonce",
      "headRefOid": "4995044192c4a3688faa1b3cb53098cd7c9bdbe5",
      "closedAt": "2020-09-22T21:10:01Z",
      "mergedAt": "2020-09-22T21:10:01Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "32ca8ad76a8f2c1ae6e8e29cdacff462664afcb7"
      },
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM",
          "createdAt": "2020-09-21T15:27:09Z",
          "updatedAt": "2020-09-21T15:27:09Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyNjM3NDgw",
          "commit": {
            "abbreviatedOid": "a54e79b"
          },
          "author": "jhoyla",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-21T14:06:11Z",
          "updatedAt": "2020-09-21T14:12:06Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "TLS 1.3 or above.",
              "createdAt": "2020-09-21T14:06:11Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyNTQ3NTAx",
          "commit": {
            "abbreviatedOid": "a54e79b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-09-21T12:29:42Z",
          "updatedAt": "2020-09-21T14:27:50Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "How about \"MUST NOT include a PSK or PSK binder\"?",
              "createdAt": "2020-09-21T12:29:42Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            },
            {
              "originalPosition": 77,
              "body": "Server's don't enforce this padding, and in some situations clients may wish to use a padding scheme that's different from what's in {{padding}}, so I think a MUST a bit too strong here.\r\n\r\n```suggestion\r\n1. It SHOULD contain TLS padding {{!RFC7685}} as described in {{padding}}.\r\n```",
              "createdAt": "2020-09-21T12:32:03Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            },
            {
              "originalPosition": 60,
              "body": "Hmm, without some designation for what's sensitive and what's not, this seems to be hard to interpret as a client. Maybe we move this to a sentence after list, and just say something like, \"Clients can also offer dummy values for extensions deemed sensitive\"?",
              "createdAt": "2020-09-21T12:34:33Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            },
            {
              "originalPosition": 55,
              "body": "```suggestion\r\n1. It MUST offer to negotiate TLS 1.3 or above.\r\n```",
              "createdAt": "2020-09-21T14:27:35Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyODQ0NjI4",
          "commit": {
            "abbreviatedOid": "3074162"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-21T17:45:27Z",
          "updatedAt": "2020-09-21T17:45:27Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "Done.",
              "createdAt": "2020-09-21T17:45:27Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyODQ4NDM2",
          "commit": {
            "abbreviatedOid": "3074162"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-21T17:50:48Z",
          "updatedAt": "2020-09-21T17:50:48Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "Done. The text needs to be updated to reflect this new rule, so I'm adding an \"OPEN ISSUE\" for this here. I'd be happy to do this as part of this PR, but the change will require additional review.",
              "createdAt": "2020-09-21T17:50:48Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyODU2OTIx",
          "commit": {
            "abbreviatedOid": "3074162"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-21T18:02:16Z",
          "updatedAt": "2020-09-21T18:02:16Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "Done. I also think we should offer this guidance. I'm leaving doing so as an \"OPEN ISSUE\".",
              "createdAt": "2020-09-21T18:02:16Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyODU3Mzc0",
          "commit": {
            "abbreviatedOid": "3074162"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-21T18:02:56Z",
          "updatedAt": "2020-09-21T18:02:57Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "Done.",
              "createdAt": "2020-09-21T18:02:56Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzMzczNjM0",
          "commit": {
            "abbreviatedOid": "d1ff96c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "LGTM with some minor changes and reversions requested. (There's also some content from #287 that seems to have bled over here?)",
          "createdAt": "2020-09-22T11:44:38Z",
          "updatedAt": "2020-09-22T11:51:59Z",
          "comments": [
            {
              "originalPosition": 114,
              "body": "```suggestion\r\n1. It MUST NOT include a \"pre_shared_key\" extension. [[OPEN ISSUE: The text needs to be\r\n   updated to reflect this rule.]]\r\n```",
              "createdAt": "2020-09-22T11:44:38Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            },
            {
              "originalPosition": 134,
              "body": "Why substitutes? Why not just drop them from ClientHelloOuter entirely?",
              "createdAt": "2020-09-22T11:46:07Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            },
            {
              "originalPosition": 133,
              "body": "```suggestion\r\noffered in the ClientHelloOuter. [[OPEN ISSUE: We should provide guidance on\r\n```",
              "createdAt": "2020-09-22T11:46:13Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            },
            {
              "originalPosition": 292,
              "body": "Please revert this change -- this MUST was there so clients could rely on this particular version of ECH being deployable. (We can discuss it in a separate issue.)\r\n\r\n```suggestion\r\n- It MUST include the \"encrypted_client_hello\" extension in its\r\n```",
              "createdAt": "2020-09-22T11:48:05Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            },
            {
              "originalPosition": 347,
              "body": "Should the server also assert that the random values are different? ",
              "createdAt": "2020-09-22T11:49:20Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            },
            {
              "originalPosition": 371,
              "body": "This doesn't seem part of this PR?",
              "createdAt": "2020-09-22T11:49:54Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            },
            {
              "originalPosition": 443,
              "body": "Ditto here on this being unrelated to the nonce?",
              "createdAt": "2020-09-22T11:50:31Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            },
            {
              "originalPosition": 501,
              "body": "Let's move this to 0xff04.",
              "createdAt": "2020-09-22T11:51:00Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            },
            {
              "originalPosition": 488,
              "body": "```suggestion\r\nClientHelloInner.random prevents this attack. In particular, since the\r\n```",
              "createdAt": "2020-09-22T11:51:08Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTU4NTYy",
          "commit": {
            "abbreviatedOid": "d1ff96c"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T15:01:59Z",
          "updatedAt": "2020-09-22T15:01:59Z",
          "comments": [
            {
              "originalPosition": 114,
              "body": "Excellent! Done.",
              "createdAt": "2020-09-22T15:01:59Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTU5NTAx",
          "commit": {
            "abbreviatedOid": "d1ff96c"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T15:02:53Z",
          "updatedAt": "2020-09-22T15:02:53Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "\"substitutes\" = \"innocuous values for sensitive extensions\". Is that more clear?",
              "createdAt": "2020-09-22T15:02:53Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTYwMjc0",
          "commit": {
            "abbreviatedOid": "d1ff96c"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T15:03:39Z",
          "updatedAt": "2020-09-22T15:03:39Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "Duh. Done.",
              "createdAt": "2020-09-22T15:03:39Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTYxMjMw",
          "commit": {
            "abbreviatedOid": "d1ff96c"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T15:04:32Z",
          "updatedAt": "2020-09-22T15:04:32Z",
          "comments": [
            {
              "originalPosition": 292,
              "body": "Ack. Fixing in #287, then rebasing here.",
              "createdAt": "2020-09-22T15:04:32Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTY2NTg4",
          "commit": {
            "abbreviatedOid": "8f8b6c4"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T15:09:41Z",
          "updatedAt": "2020-09-22T15:09:41Z",
          "comments": [
            {
              "originalPosition": 371,
              "body": "This PR is based on #287, which is why this text appears here. If you focus your review on the last commit, it should be clear what the changes are.",
              "createdAt": "2020-09-22T15:09:41Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTY3OTI1",
          "commit": {
            "abbreviatedOid": "8f8b6c4"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T15:10:31Z",
          "updatedAt": "2020-09-22T15:10:31Z",
          "comments": [
            {
              "originalPosition": 501,
              "body": "What should we do about \"outer_extension\" (currently 0xff04)?",
              "createdAt": "2020-09-22T15:10:31Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTY5MzA4",
          "commit": {
            "abbreviatedOid": "8f8b6c4"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T15:11:03Z",
          "updatedAt": "2020-09-22T15:11:04Z",
          "comments": [
            {
              "originalPosition": 488,
              "body": "Done.",
              "createdAt": "2020-09-22T15:11:03Z",
              "updatedAt": "2020-09-22T20:57:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzODQxNzg2",
          "commit": {
            "abbreviatedOid": "4995044"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T20:58:39Z",
          "updatedAt": "2020-09-22T20:58:39Z",
          "comments": [
            {
              "originalPosition": 501,
              "body": "Oops, I meant 0xff03. Heh. Let's just revisit these values in a followup PR.",
              "createdAt": "2020-09-22T20:58:39Z",
              "updatedAt": "2020-09-22T20:58:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzODQxOTU5",
          "commit": {
            "abbreviatedOid": "4995044"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T20:58:54Z",
          "updatedAt": "2020-09-22T20:58:55Z",
          "comments": [
            {
              "originalPosition": 347,
              "body": "What would be the purpose?",
              "createdAt": "2020-09-22T20:58:55Z",
              "updatedAt": "2020-09-22T20:58:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzODQ4NzAx",
          "commit": {
            "abbreviatedOid": "4995044"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T21:09:12Z",
          "updatedAt": "2020-09-22T21:09:13Z",
          "comments": [
            {
              "originalPosition": 347,
              "body": "(Chatted offline -- maybe not now!)",
              "createdAt": "2020-09-22T21:09:12Z",
              "updatedAt": "2020-09-22T21:09:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzODQ4ODQw",
          "commit": {
            "abbreviatedOid": "4995044"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-22T21:09:23Z",
          "updatedAt": "2020-09-22T21:09:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 293,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc3NTA3OTAz",
      "title": "Revise \"outer_extension\" (postponed until after -08)",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/293",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The \"outer_extension\" mechanism doesn't preserve the order of extensions in the ClientHelloInner. This change replaces it with a mechanism that does.\r\n\r\nThis addresses #262 and might impact #263.",
      "createdAt": "2020-09-02T01:30:33Z",
      "updatedAt": "2021-04-16T19:56:22Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3426cfbf3f25bd2aa23a13e8700702717c05a42f",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "outer_extensions_compression",
      "headRefOid": "67c93eea32548a8bd170fd82e98539a0b70acbc8",
      "closedAt": "2020-10-14T23:29:29Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson \r\n\r\n> This is going to be the opposite of compression in many cases. This only compresses if an extension payload is greater than Nh + 4, which will severely limit applicability.\r\n\r\nWell, the benefit can be amortized across multiple extensions. So as long as the compressed data exceeds Nh + 2*L, where L is the number of compressed extensions, you've succeeded.\r\n\r\n> How about an alternative design where you list all the compressed extensions in order and then provide a bit list to indicate how tointerleave them with other extensions:\r\n\r\nI had a similar idea ... I think it can work, but it's a bit more complex. Moreover, the current PR is closer to the proposal discussed in #262. But I'm happy to change it if that's where people want to go.",
          "createdAt": "2020-09-02T17:12:33Z",
          "updatedAt": "2020-09-02T18:57:56Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "To recap my comments at the mic: I think we should go back and ask what extensions will actually benefit from this treatment in typical client hello. The only example I am aware of is KeyShare (and principally only PQ). And so my put would be to go with the simplest thing that covers most of these cases. If all we have is KeyShare, then I think requiring things to be contiguous is good enough, in that if we end up with CompressibleExtension2 in future people can just serialize it next to KeyShare.\r\n",
          "createdAt": "2020-09-03T17:54:20Z",
          "updatedAt": "2020-09-03T17:57:28Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing this in favor of @davidben's suggestion in this issue: #323.",
          "createdAt": "2020-10-09T00:20:14Z",
          "updatedAt": "2020-10-09T00:20:14Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sorry, brain fart. This isn't closed by a solution to #323.",
          "createdAt": "2020-10-09T00:22:08Z",
          "updatedAt": "2020-10-09T00:22:08Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think we should go back and ask what extensions will actually benefit from this treatment in typical client hello.\r\n\r\nI'd actually argue the opposite. Most extensions don't actually benefit from being sent twice because they're the same across every connection made by that client. Even an empty extension costs four bytes normally and (marginally) costs two bytes compressed. Shrinking the ciphertext not only saves bytes for ECH ClientHellos, but it makes it cheaper to add GREASE to non-ECH ClientHellos.\r\n\r\nRegardless, I agree with your conclusion:\r\n\r\n>  If all we have is KeyShare, then I think requiring things to be contiguous is good enough, in that if we end up with CompressibleExtension2 in future people can just serialize it next to KeyShare.\r\n\r\nThe only extension with an ordering constraint is PSK, which would never be compressed anyway. The client can fiddle with the order as needed to compress the extensions it wants to compress.\r\n\r\n> Sorry, brain fart. This isn't closed by a solution to #323.\r\n\r\n#323 might open up a few more options by removing inner_digest, like including multiple outer_extensions if you want to compress multiple runs of extensions. (I think that was an earlier design?) That said, I agree with @ekr that the ordering thing isn't a big deal.",
          "createdAt": "2020-10-09T02:16:35Z",
          "updatedAt": "2020-10-09T02:17:45Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ordering is no longer an issue if we're authenticating ClientHelloOuter as described in #323. It does matter to an extent if we're binding outer extensions by hashing the fully formed ClientHelloInner. In particular, the client needs to ensure that inner_digest is the hash of whatever ClientHelloInner is decompressed by the server.\r\n\r\nIn any case, a solution to #323 would make the motivation for this PR largely irrelevant.",
          "createdAt": "2020-10-09T15:19:46Z",
          "updatedAt": "2020-10-09T15:19:46Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "#323 doesn't save you from matching the order. It is a requirement in the handshake itself that the client and server act on a byte-for-byte identical ClientHelloInner. It goes in the handshake transcript.",
          "createdAt": "2020-10-09T15:27:26Z",
          "updatedAt": "2020-10-09T15:29:19Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing this for now. We could revisit it, but my guess is that we're well on our way to squeezing sufficiently many bytes out of the ClientHelloInner.",
          "createdAt": "2020-10-14T23:29:29Z",
          "updatedAt": "2020-10-14T23:29:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwMzQ0MTk5",
          "commit": {
            "abbreviatedOid": "4eb8c24"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This is going to be the opposite of compression in many cases.  This only compresses if an extension payload is greater than Nh + 4, which will severely limit applicability.\r\n\r\nHow about an alternative design where you list all the compressed extensions in order and then provide a bit list to indicate how to interleave them with other extensions:\r\n\r\n0 = use one extension from inner\r\n1 = use one extension from outer\r\n\r\nThen you can bind to the uncompressed expansion.  The only constraint here is that compressed extensions in the outer need to appear in the same order as the inner for this to work.\r\n\r\n(That's just an offhand design; I'm sure that something better can be constructed.)",
          "createdAt": "2020-09-02T02:09:08Z",
          "updatedAt": "2020-09-02T02:15:02Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "```suggestion\r\nthe client and server MUST NOT offer these extensions in any handshake message;\r\n```\r\n\r\n\"MAY NOT\" is not an acceptable form.",
              "createdAt": "2020-09-02T02:09:08Z",
              "updatedAt": "2020-09-03T01:26:30Z"
            },
            {
              "originalPosition": 80,
              "body": "```suggestion\r\n   The payload is set to `inner_digest = Expand(Extract(\"\", inner),\r\n```",
              "createdAt": "2020-09-02T02:09:54Z",
              "updatedAt": "2020-09-03T01:26:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMDMzNTQ2",
          "commit": {
            "abbreviatedOid": "4eb8c24"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-02T17:13:27Z",
          "updatedAt": "2020-09-02T17:13:28Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Done.",
              "createdAt": "2020-09-02T17:13:27Z",
              "updatedAt": "2020-09-03T01:26:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMDM0MTYy",
          "commit": {
            "abbreviatedOid": "0e291dc"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-02T17:14:14Z",
          "updatedAt": "2020-09-02T17:14:15Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "Done.",
              "createdAt": "2020-09-02T17:14:15Z",
              "updatedAt": "2020-09-03T01:26:30Z"
            }
          ]
        }
      ]
    },
    {
      "number": 296,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc3OTIwODA5",
      "title": "s/Unmarshal/Deserialize/ to align with HPKE",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/296",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "draft-irtf-cfrg-hpke-05 switched from Unmarshal to Deserialize. Switch\r\nECH to match. See #294.",
      "createdAt": "2020-09-02T15:55:34Z",
      "updatedAt": "2020-09-02T18:56:57Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3ee7678e12c49cd6015899e675bf227bbb50835b",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "deserialize",
      "headRefOid": "fb3904dbe36236014bed67161ad359d74521d7e1",
      "closedAt": "2020-09-02T18:56:57Z",
      "mergedAt": "2020-09-02T18:56:57Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "317652d989f30f8315ed18feddc60b744d27d1ca"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMDI4ODY4",
          "commit": {
            "abbreviatedOid": "1e11a44"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-02T17:07:16Z",
          "updatedAt": "2020-09-02T17:07:16Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I think we should also drop the \"HPKE.KEM.\" prefix, here and below. This isn't defined in the HPKE spec: instead, \"Deserialize()\" is a method associated with the KEM algorithm.",
              "createdAt": "2020-09-02T17:07:16Z",
              "updatedAt": "2020-09-02T18:49:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMTcyMTMw",
          "commit": {
            "abbreviatedOid": "fb3904d"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-02T18:49:49Z",
          "updatedAt": "2020-09-02T18:49:49Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Done. I agree with you HPKE.KEM isn't defined, though I'm a little worried that Deserialize is too generic. I adjusted the paragraph below in hopes of helping that.",
              "createdAt": "2020-09-02T18:49:49Z",
              "updatedAt": "2020-09-02T18:49:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMTc3MDcx",
          "commit": {
            "abbreviatedOid": "fb3904d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-02T18:56:48Z",
          "updatedAt": "2020-09-02T18:56:48Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMTc3MTc0",
          "commit": {
            "abbreviatedOid": "fb3904d"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-02T18:56:56Z",
          "updatedAt": "2020-09-02T18:56:57Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Looks good.",
              "createdAt": "2020-09-02T18:56:56Z",
              "updatedAt": "2020-09-02T18:56:57Z"
            }
          ]
        }
      ]
    },
    {
      "number": 298,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc4MTI0MTEz",
      "title": "Narrow the size of possible configuration identifiers.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/298",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Also, rename config_digest to config_id to avoid confusion with cryptographic hash digests.\r\n\r\nCloses #288. cc @cjpatton, @davidben, @martinthomson ",
      "createdAt": "2020-09-02T19:42:30Z",
      "updatedAt": "2021-04-19T15:51:46Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "317652d989f30f8315ed18feddc60b744d27d1ca",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/config-id-and-size",
      "headRefOid": "3069de421aa76234e34782d4f530f1bd8ab74575",
      "closedAt": "2020-09-02T20:48:24Z",
      "mergedAt": "2020-09-02T20:48:24Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "3426cfbf3f25bd2aa23a13e8700702717c05a42f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMjQ5MjM3",
          "commit": {
            "abbreviatedOid": "00db98f"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-02T19:50:40Z",
          "updatedAt": "2020-09-02T19:50:40Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMjc0MTY3",
          "commit": {
            "abbreviatedOid": "00db98f"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-09-02T20:27:34Z",
          "updatedAt": "2020-09-02T20:28:58Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "nit: s/0..2^-1/0..255/ for consistency with the rest of the spec.",
              "createdAt": "2020-09-02T20:27:34Z",
              "updatedAt": "2020-09-02T20:46:20Z"
            },
            {
              "originalPosition": 25,
              "body": "This section doesn't exist, which is why CI is failing.",
              "createdAt": "2020-09-02T20:28:51Z",
              "updatedAt": "2020-09-02T20:46:20Z"
            }
          ]
        }
      ]
    },
    {
      "number": 299,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc4MjQ5NzU5",
      "title": "Fix the alerts reference.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/299",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "{#alerts} is cited over in {#encrypted-client-hello} but points to the wrong section.",
      "createdAt": "2020-09-02T23:53:01Z",
      "updatedAt": "2020-09-18T21:12:00Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3426cfbf3f25bd2aa23a13e8700702717c05a42f",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "alerts-ref",
      "headRefOid": "35328efc3656e2c8d88b8b4d504655ff32df4126",
      "closedAt": "2020-09-18T21:12:00Z",
      "mergedAt": "2020-09-18T21:12:00Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "141a7bef46cb506e0e69e70e9a9278c38550f34b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxNzgzNzc1",
          "commit": {
            "abbreviatedOid": "35328ef"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-18T21:11:55Z",
          "updatedAt": "2020-09-18T21:11:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 302,
      "id": "MDExOlB1bGxSZXF1ZXN0NDg5NTQyMTI4",
      "title": "Fix a misrepresentation of \"encrypted_ch\"",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/302",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Resolves #301.",
      "createdAt": "2020-09-18T21:09:31Z",
      "updatedAt": "2021-04-16T19:56:24Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3426cfbf3f25bd2aa23a13e8700702717c05a42f",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "nit1",
      "headRefOid": "a7fa0ec1b76d998b7e50400a5e9f1db35bf3138b",
      "closedAt": "2020-09-18T21:11:14Z",
      "mergedAt": "2020-09-18T21:11:14Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "61062036c9551392d1c15068d513dd36058e227a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxNzgzNDE1",
          "commit": {
            "abbreviatedOid": "a7fa0ec"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-18T21:11:10Z",
          "updatedAt": "2020-09-18T21:11:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 303,
      "id": "MDExOlB1bGxSZXF1ZXN0NDg5NTQ1NzY1",
      "title": "Lock ECHConfig.version to the codepoint and advance to 0xff08.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/303",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses https://github.com/tlswg/draft-ietf-tls-esni/issues/297.",
      "createdAt": "2020-09-18T21:19:36Z",
      "updatedAt": "2021-04-16T19:56:25Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "2a56d1fdac5b80376554cb14b9089f7acb8f1d47",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "lock_version_to_codepoint",
      "headRefOid": "597c1cd4f7657e8f14a434c8094a8b26520c78bf",
      "closedAt": "2020-09-18T21:30:46Z",
      "mergedAt": "2020-09-18T21:30:46Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "60572fbaec969b520288e997347af81981b000ad"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxNzkxOTc3",
          "commit": {
            "abbreviatedOid": "597c1cd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-18T21:30:42Z",
          "updatedAt": "2020-09-18T21:30:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 304,
      "id": "MDExOlB1bGxSZXF1ZXN0NDg5NTQ4MjIy",
      "title": "Remove reference to \"'ech_accept' response type\"",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/304",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Resolves #267.",
      "createdAt": "2020-09-18T21:27:00Z",
      "updatedAt": "2021-04-16T19:56:26Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "2a56d1fdac5b80376554cb14b9089f7acb8f1d47",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "nit2",
      "headRefOid": "84f75756bfd7990773d1e647dd05bea4625dc8a1",
      "closedAt": "2020-09-18T21:31:04Z",
      "mergedAt": "2020-09-18T21:31:04Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "375b4587f2981c414b5a737d3e98823c6ce1cba9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxNzkyMDk0",
          "commit": {
            "abbreviatedOid": "84f7575"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-18T21:30:57Z",
          "updatedAt": "2020-09-18T21:30:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 305,
      "id": "MDExOlB1bGxSZXF1ZXN0NDkwOTExODcz",
      "title": "Rewrite security and privacy goals",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/305",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #260.\r\n\r\ncc @cjpatton ",
      "createdAt": "2020-09-22T12:41:17Z",
      "updatedAt": "2021-04-19T15:51:47Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "573dc6af51be3c633022bae6ae31f1b2b31646db",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/goals",
      "headRefOid": "7203bc0fe956e6e85762886ec483b8c2f4d109da",
      "closedAt": "2020-09-22T21:25:43Z",
      "mergedAt": "2020-09-22T21:25:43Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "044792db0b118e41089b05c6b1f2f9c641376114"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTA2ODk4",
          "commit": {
            "abbreviatedOid": "9ad2327"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-09-22T14:14:53Z",
          "updatedAt": "2020-09-22T14:43:42Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "\"form\" -> \"comprise\"",
              "createdAt": "2020-09-22T14:14:53Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 12,
              "body": "\"that protects SNIs\" -> \"sensitive ClientHello parameters, including the SNI,\"\r\n",
              "createdAt": "2020-09-22T14:19:49Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 12,
              "body": "\"for all of the domains\" -> \"on behalf of all domains\"",
              "createdAt": "2020-09-22T14:20:07Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 30,
              "body": "\"a\" -> \"the\"\r\n\"is ensuring\" -> \"is to ensure\"",
              "createdAt": "2020-09-22T14:24:19Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 19,
              "body": "\"SNI protection\" -> \"Usage of this mechanism\" ",
              "createdAt": "2020-09-22T14:26:35Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 20,
              "body": "\"a particular service provider without revealing the specific private serer from the anonymity set\" -> \"a particular service provider, but does not reveal which server terminates the connection\".",
              "createdAt": "2020-09-22T14:28:36Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 32,
              "body": "\"modulo traffic analysis\": I would suggest cutting this and leaving it to Security Considerations. It's a matter that a sophisticated service provider might try to address, so we don't want to exclude this here.",
              "createdAt": "2020-09-22T14:30:20Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 5,
              "body": "I think the term \"anonymity set\" needs to be more clearly defined here. It warrants a short paragraph.",
              "createdAt": "2020-09-22T14:31:01Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 52,
              "body": "A more important example of an active attacker is the one that tries to break the primary security goal of ECH. A cesnor is an example of a \"don't stick out\" attacker. I suggest replacing the last line with something like this: \r\n\r\n> In short, an active attacker corresponds to the conventional threat model for TLS ({{RFC8446}}, Section ??).",
              "createdAt": "2020-09-22T14:34:30Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 70,
              "body": "\"a specific uses or negotiates ECH\" -> \"ECH was accepted in a particular connection\".",
              "createdAt": "2020-09-22T14:35:42Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 72,
              "body": "I would replace this enum list with a one-liner at the end of the preceding paragraph. E.g.,:\r\n\r\n> This protocol aims to achieve both properties, assuming the attacker is passive and does not know the set of ECH configurations offered by the server. It does not achieve these goals for active attackers.",
              "createdAt": "2020-09-22T14:38:55Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 79,
              "body": "Add reference to {{grease-extensions}}",
              "createdAt": "2020-09-22T14:39:43Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 68,
              "body": "The text below should have a reference to the \"don't stick out\" doc.",
              "createdAt": "2020-09-22T14:42:03Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 87,
              "body": "I think we should elaborate on this a bit more. Readers might take issue with the claim that ECH is not suitable for censorship circumvention. In particular, there may be deployment scenarios in which keeping the ECH configuration a secret is feasible, and \"don't stick out\" security against active adversaries might be possible in that setting.",
              "createdAt": "2020-09-22T14:43:34Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTg4MDIy",
          "commit": {
            "abbreviatedOid": "9ad2327"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T15:28:38Z",
          "updatedAt": "2020-09-22T15:28:39Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "We can, but I don't think we need to do that here (in this PR).",
              "createdAt": "2020-09-22T15:28:39Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTkwNDEx",
          "commit": {
            "abbreviatedOid": "9ad2327"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T15:31:02Z",
          "updatedAt": "2020-09-22T15:31:02Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "At a minimum, I would suggest removing this line. We can have a new PR for language around censorship circumvention.",
              "createdAt": "2020-09-22T15:31:02Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTkzMjUw",
          "commit": {
            "abbreviatedOid": "9ad2327"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T15:34:02Z",
          "updatedAt": "2020-09-22T15:34:02Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "That works for me!",
              "createdAt": "2020-09-22T15:34:02Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTkzNDc3",
          "commit": {
            "abbreviatedOid": "9ad2327"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T15:34:16Z",
          "updatedAt": "2020-09-22T15:34:16Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "It's defined where it's used, no?",
              "createdAt": "2020-09-22T15:34:16Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTk1MDY5",
          "commit": {
            "abbreviatedOid": "9ad2327"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T15:35:54Z",
          "updatedAt": "2020-09-22T15:35:54Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "I'll add that, instead of replace the censor example.",
              "createdAt": "2020-09-22T15:35:54Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTk3Mzk0",
          "commit": {
            "abbreviatedOid": "9ad2327"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T15:38:17Z",
          "updatedAt": "2020-09-22T15:38:18Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "Wouldn't hurt!",
              "createdAt": "2020-09-22T15:38:18Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTk5MTEz",
          "commit": {
            "abbreviatedOid": "9ad2327"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T15:40:04Z",
          "updatedAt": "2020-09-22T15:40:04Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "Nice! I'll do that.",
              "createdAt": "2020-09-22T15:40:04Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNjAwMzA2",
          "commit": {
            "abbreviatedOid": "9ad2327"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T15:41:17Z",
          "updatedAt": "2020-09-22T15:41:17Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "We also have not done the analysis to know if it is possible in that setting. So, for now, I'd prefer we just be up front about this.",
              "createdAt": "2020-09-22T15:41:17Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNjAwMzIx",
          "commit": {
            "abbreviatedOid": "9ad2327"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T15:41:17Z",
          "updatedAt": "2020-09-22T15:41:17Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Yeah, better to put it where it's first defined. I guess my issue is how it's defined. It's not that they have the same configuration ... what matters is simply that the ClientHello protection service is provided on their behalf. Maybe replace \"wherein all elements have a consistent configuration...\" with \"of servers for which the service is provided\".",
              "createdAt": "2020-09-22T15:41:17Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNjAxNjQ3",
          "commit": {
            "abbreviatedOid": "9ad2327"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T15:42:39Z",
          "updatedAt": "2020-09-22T15:42:39Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "Ack.",
              "createdAt": "2020-09-22T15:42:39Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNjkzMjMw",
          "commit": {
            "abbreviatedOid": "7fdcc97"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T17:31:20Z",
          "updatedAt": "2020-09-22T17:31:20Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Chatted offline -- will improve the definition in a separate issue!",
              "createdAt": "2020-09-22T17:31:20Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzODUxMTA4",
          "commit": {
            "abbreviatedOid": "7fdcc97"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-09-22T21:13:06Z",
          "updatedAt": "2020-09-22T21:18:52Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "```suggestion\r\ne.g., the set of supported application protocols, ciphersuites, TLS versions, and\r\n```",
              "createdAt": "2020-09-22T21:13:06Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 36,
              "body": "```suggestion\r\nsame anonymity set are indistinguishable from one another without affecting any existing security properties of TLS 1.3. See\r\n{{goals}} for more details about the ECH security and privacy goals.\r\n```",
              "createdAt": "2020-09-22T21:13:58Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 36,
              "body": "No need to say what kind of attacker if it's both.",
              "createdAt": "2020-09-22T21:14:09Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 55,
              "body": "```suggestion\r\nTLS 1.3 {{RFC8446}}.\r\n```\r\nI would just stay out of censorship. I think some censors are maybe passive?\r\n",
              "createdAt": "2020-09-22T21:16:48Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 80,
              "body": "```suggestion\r\nbecause the latter used a GREASE \"encrypted_client_hello\" extension (as\r\n```\r\n\r\nI don't think i.e., is adding much here.",
              "createdAt": "2020-09-22T21:17:55Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 84,
              "body": "Well, sort of. If they have connection memory they can see that everyone is using different config hashes.\r\n\r\nActually, I wonder if we should salt the hash.",
              "createdAt": "2020-09-22T21:18:30Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            },
            {
              "originalPosition": 89,
              "body": "I would also not say \"censor\" here.",
              "createdAt": "2020-09-22T21:18:47Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzODU2MTk3",
          "commit": {
            "abbreviatedOid": "3772499"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T21:21:33Z",
          "updatedAt": "2020-09-22T21:21:33Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "We can, yeah, but let's do that in a separate PR. (I'm assuming \"without the ECH configuration\" means it doesn't keep state.)",
              "createdAt": "2020-09-22T21:21:33Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzODU2NTgz",
          "commit": {
            "abbreviatedOid": "3772499"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T21:22:15Z",
          "updatedAt": "2020-09-22T21:22:16Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "OK",
              "createdAt": "2020-09-22T21:22:15Z",
              "updatedAt": "2020-09-22T21:24:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 306,
      "id": "MDExOlB1bGxSZXF1ZXN0NDkwOTE2MTY3",
      "title": "Add MTI cipher suite based on x25519, HKDF-SHA256, and AES-128-GCM.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/306",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #251.\r\n\r\ncc @cjpatton @ekr @fredericjacobs",
      "createdAt": "2020-09-22T12:48:49Z",
      "updatedAt": "2021-04-19T15:51:47Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "375b4587f2981c414b5a737d3e98823c6ce1cba9",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/mti",
      "headRefOid": "ad06b45a92d68d49ed327385f7ff9b23266b6262",
      "closedAt": "2020-09-22T21:11:30Z",
      "mergedAt": "2020-09-22T21:11:30Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "573dc6af51be3c633022bae6ae31f1b2b31646db"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good, presuming the HPKE draft is stable and the section numbers won't change.",
          "createdAt": "2020-09-22T14:13:58Z",
          "updatedAt": "2020-09-22T14:13:58Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 308,
      "id": "MDExOlB1bGxSZXF1ZXN0NDkxOTQ2NjYz",
      "title": "Address minor spec issues",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/308",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Based on my experience implementing this extension (see https://github.com/cloudflare/go/pull/30), I'd like to recommend a few changes to the spec. Most notably:\r\n1. Change the constants so that they're consistent.\r\n1. Specify the client/server behavior in a few failure scenarios.\r\n\r\nThere are also some editorial changes:\r\n1. Rename \"HpkeCipherSuite\" to \"ECHCipherSuite\". (An HPKE cipher suite consists of a KEM, KDF, and AEAD, but here a cipher suite is a KDF and an AEAD.)\r\n1. Rename \"OuterExtensions.hash\" to \"OuterExtensions.inner_digest\".\r\n1. Rename \"ClientECH.encrypted_ch\" to \"ClientECH.payload\".\r\n\r\nPartially addresses https://github.com/tlswg/draft-ietf-tls-esni/issues/285.",
      "createdAt": "2020-09-23T18:00:27Z",
      "updatedAt": "2021-04-16T19:56:29Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "044792db0b118e41089b05c6b1f2f9c641376114",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "nits",
      "headRefOid": "46073397b27d9bbe1f8d356e2406d0f053a30619",
      "closedAt": "2020-09-24T18:07:54Z",
      "mergedAt": "2020-09-24T18:07:54Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "4b6f0d7079813fd8f109e38fea77846ece4c666a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1MDYxODEz",
          "commit": {
            "abbreviatedOid": "a22e235"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Couple of very small nits!",
          "createdAt": "2020-09-23T21:28:23Z",
          "updatedAt": "2020-09-23T23:19:31Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "Good catch. We can remove this entire rule!",
              "createdAt": "2020-09-23T21:28:23Z",
              "updatedAt": "2020-09-24T16:04:20Z"
            },
            {
              "originalPosition": 180,
              "body": "Assuming this is what was meant:\r\n\r\n```suggestion\r\nClientHello but not the first, then the client MUST abort the handshake with an\r\n```",
              "createdAt": "2020-09-23T21:29:10Z",
              "updatedAt": "2020-09-24T16:04:20Z"
            },
            {
              "originalPosition": 229,
              "body": "+1 -- let's drop it!",
              "createdAt": "2020-09-23T23:17:20Z",
              "updatedAt": "2020-09-24T16:04:20Z"
            },
            {
              "originalPosition": 275,
              "body": "Perhaps this can say that servers MUST NOT use this PSK if ECH is rejected?",
              "createdAt": "2020-09-23T23:19:09Z",
              "updatedAt": "2020-09-24T16:04:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1NjMyODM0",
          "commit": {
            "abbreviatedOid": "a22e235"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-24T14:27:34Z",
          "updatedAt": "2020-09-24T14:27:34Z",
          "comments": [
            {
              "originalPosition": 229,
              "body": "I'm revising it to: \"If offered, the server MUST ignore the \"pre_shared_key\" extension sent in the ClientHello.\"",
              "createdAt": "2020-09-24T14:27:34Z",
              "updatedAt": "2020-09-24T16:04:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1NjM1NTM1",
          "commit": {
            "abbreviatedOid": "a22e235"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-24T14:30:03Z",
          "updatedAt": "2020-09-24T14:30:04Z",
          "comments": [
            {
              "originalPosition": 275,
              "body": "That's ensured by the rule change above, correct? If so, then the server won't send a NewSessionTicket message.",
              "createdAt": "2020-09-24T14:30:04Z",
              "updatedAt": "2020-09-24T16:04:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1Njc5Njc0",
          "commit": {
            "abbreviatedOid": "30ce5bb"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-24T15:13:09Z",
          "updatedAt": "2020-09-24T15:13:09Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1Njc5OTM1",
          "commit": {
            "abbreviatedOid": "30ce5bb"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-24T15:13:24Z",
          "updatedAt": "2020-09-24T15:13:25Z",
          "comments": [
            {
              "originalPosition": 275,
              "body": "Yep!",
              "createdAt": "2020-09-24T15:13:24Z",
              "updatedAt": "2020-09-24T16:04:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1NzMxNjU2",
          "commit": {
            "abbreviatedOid": "30ce5bb"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-24T16:08:21Z",
          "updatedAt": "2020-09-24T16:08:21Z",
          "comments": [
            {
              "originalPosition": 275,
              "body": "I dropped the TODO and left the text as-is for now.",
              "createdAt": "2020-09-24T16:08:21Z",
              "updatedAt": "2020-09-24T16:08:21Z"
            }
          ]
        }
      ]
    },
    {
      "number": 311,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk0MzQyNTM3",
      "title": "Clarify HRR behavior",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/311",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "It is an error for the client to offer ECH after HRR but not before. Likewise, it is an error for the client to offer ECH before HRR but not after. This change ensures the server aborts in this case.",
      "createdAt": "2020-09-28T19:04:03Z",
      "updatedAt": "2021-04-16T19:56:30Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "4b6f0d7079813fd8f109e38fea77846ece4c666a",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "hrr_behavior",
      "headRefOid": "97f86ab349e5fff45bce6245352ed762e27b5e30",
      "closedAt": "2020-09-30T22:47:14Z",
      "mergedAt": "2020-09-30T22:47:14Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "2ae8aca2a4ffb48d550cbe713e98951ef7a0919a"
      },
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Suppose we hit one of the messy HRR cases (https://github.com/tlswg/draft-ietf-tls-esni/issues/233#issuecomment-697949177), where the HRR is valid for the outer ClientHello, but not the inner ClientHello. The client then cannot construct a valid inner ClientHello. How would that square with this text? Are you envisioning the client just generates a random ECH extension, or...?",
          "createdAt": "2020-09-28T20:23:21Z",
          "updatedAt": "2020-09-28T20:23:21Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": ">  How would that square with this text? Are you envisioning the client just generates a random ECH extension, or...?\r\n\r\nI don't think this is a *new* problem. I see the PR as clarifying existing behavior. \r\n\r\nCan you please propose text for the HRR nightmare in #233? :-)",
          "createdAt": "2020-09-28T20:26:58Z",
          "updatedAt": "2020-09-28T20:26:58Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, you're right. Sorry, I misread this PR as introducing this requirement. In principle, we only need the server to require ECH in CH2 if it decided to accept ECH on CH1. That would allow the client to not send ECH the second time, but maybe we don't want to do that, depending on what we do for #233...\r\n\r\nDo we know what we want to do for #233? Simplest seems to be saying clients MUST align them. (Though how does that work with later HRR-sensitive extensions? Are funny ECH-adding proxies a thing?) Or maybe it's just a SHOULD? Or maybe we come up with some other protocol trick so ECH acceptance is visible at HRR (which would probably reopen the don't-stick-out can of worms yet again). Of these, only the MUST avoids collision with this PR's (existing) client requirement.",
          "createdAt": "2020-09-28T21:00:31Z",
          "updatedAt": "2020-09-28T21:00:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Do we know what we want to do for #233? Simplest seems to be saying clients MUST align them.\r\n\r\nYeah, that's my preference. This logic is already complicated enough. The primary pain point I see is enumerating (and prescribing) what is a HRR-sensitive field. ",
          "createdAt": "2020-09-28T21:08:03Z",
          "updatedAt": "2020-09-28T21:08:03Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Same, with that pain point being the big question in my head. Whether an HRR is valid for a ClientHello isn't an implementation decision, so in theory it's enumerable. But more extensions may come in later.\r\n\r\nAnd in the other direction, even a very strong SHOULD means we need to pick a client behavior for the weird case and allow for it in server behavior.",
          "createdAt": "2020-09-28T21:23:05Z",
          "updatedAt": "2020-09-28T21:23:05Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Regardless of where we land on #233, this PR seems appropriate to me.",
          "createdAt": "2020-09-29T18:50:49Z",
          "updatedAt": "2020-09-29T18:50:49Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3ODI3MjAz",
          "commit": {
            "abbreviatedOid": "1c5800a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-28T19:21:32Z",
          "updatedAt": "2020-09-28T19:23:27Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nIf the client offered ECH in the first ClientHello, then it MUST offer ECH in the\r\n```",
              "createdAt": "2020-09-28T19:21:32Z",
              "updatedAt": "2020-09-28T19:24:16Z"
            }
          ]
        }
      ]
    },
    {
      "number": 312,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk0Mzk2MzE4",
      "title": "Match legacy_session_id values.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/312",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #310.",
      "createdAt": "2020-09-28T20:54:11Z",
      "updatedAt": "2020-09-29T00:46:14Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "4b6f0d7079813fd8f109e38fea77846ece4c666a",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "compat-mode",
      "headRefOid": "550b5c66f2fa2db9cebf9bcaee935c3fc0d53e9b",
      "closedAt": "2020-09-29T00:46:06Z",
      "mergedAt": "2020-09-29T00:46:06Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "b58aa3af62cc7e9eb9b9292e0500fa13aef19413"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks!",
          "createdAt": "2020-09-29T00:46:14Z",
          "updatedAt": "2020-09-29T00:46:14Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3OTg4ODc4",
          "commit": {
            "abbreviatedOid": "550b5c6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-29T00:46:02Z",
          "updatedAt": "2020-09-29T00:46:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 313,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk1NzEzMzE2",
      "title": "Replace record-level padding with handshake-level padding",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/313",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #264.",
      "createdAt": "2020-09-30T18:51:06Z",
      "updatedAt": "2023-11-06T08:52:24Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "29b11353f3de0b21134eb820e537e30c466a7e69",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "server_side_padding",
      "headRefOid": "f69516342f307b7fa6aaf74f2e13071560336361",
      "closedAt": "2023-11-06T08:52:23Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> How does handshake_padding differ from RFC 7685, less this one sentence: \"The server MUST NOT echo the extension.\" and some clarification about EE/CR/C/?\r\n\r\nThat's basically it. ",
          "createdAt": "2020-10-06T01:49:27Z",
          "updatedAt": "2020-10-06T01:49:27Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "And the concern is that clients will enforce that MUST, so that you can't use extension 21 here?",
          "createdAt": "2020-10-06T05:15:15Z",
          "updatedAt": "2020-10-06T05:15:15Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> And the concern is that clients will enforce that MUST, so that you can't use extension 21 here?\r\n\r\nFrom discussion in #264, it seems overall simpler to just burn an extension code point rather than change existing behavior in code and text.",
          "createdAt": "2020-10-06T12:32:15Z",
          "updatedAt": "2020-10-06T12:32:15Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "BoringSSL clients enforce that MUST. Dunno about others. (In general, we don't allow server extensions we don't expect, and we don't expect server padding extensions.)",
          "createdAt": "2020-10-08T19:03:41Z",
          "updatedAt": "2020-10-08T19:03:41Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Rebased.",
          "createdAt": "2021-02-15T20:56:49Z",
          "updatedAt": "2021-02-15T20:56:49Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Rebased.",
          "createdAt": "2021-06-11T18:00:04Z",
          "updatedAt": "2021-06-11T18:00:04Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Rebased.",
          "createdAt": "2021-06-30T21:38:58Z",
          "updatedAt": "2021-06-30T21:38:58Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closed per decision at IETF 118 to close the issue.",
          "createdAt": "2023-11-06T08:52:23Z",
          "updatedAt": "2023-11-06T08:52:23Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5ODI0MzEy",
          "commit": {
            "abbreviatedOid": "c070516"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Only did a cursory pass over it since it's late in the day here.",
          "createdAt": "2020-09-30T21:26:29Z",
          "updatedAt": "2020-09-30T21:47:52Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Nit: I think this should be `{{?RFC7685}}` to mark it as an informational reference rather than a normative reference.",
              "createdAt": "2020-09-30T21:26:29Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            },
            {
              "originalPosition": 31,
              "body": "Meh. I'd drop that second sentence. The extension is perfectly compatible with TLS 1.2. The server will just ignore it as with any other unknown extension.",
              "createdAt": "2020-09-30T21:27:33Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            },
            {
              "originalPosition": 21,
              "body": "This should go in IANA Considerations, with a suitable TLS 1.3 column (all the messages).",
              "createdAt": "2020-09-30T21:28:39Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            },
            {
              "originalPosition": 41,
              "body": "I was going to suggest we go ahead and stick it into the other messages too for the client Finished, but maybe that's better deferred until later. Though we'd have to explicitly say it's not allowed in any other \"request\" messages but we may define what it means later, whereas any \"response\" messages we forbid it from now will be stuck. So that's just a mess.\r\n\r\nIn particular, if we believe in compressed certificates staying as-is, any client certificates story will need client EncryptedExtensions. That said, at least in the client EncryptedExtensions formulation we're pondering for ALPS, the signal would be in the wrong place so it's a mess all around. (https://github.com/vasilvv/tls-alps/pull/5. It's possible we came up with the wrong formulation---I still need to email the about it.)\r\n\r\n@ekr, do you have thoughts?\r\n\r\n(FWIW, a Padding message would avoid all this because it wouldn't need to interact with how each message fits into extension request/response patterns. ;-) We'd need to communicate a single boolean in either direction and then everyone is free to pad to their heart's content anywhere.)",
              "createdAt": "2020-09-30T21:46:38Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            },
            {
              "originalPosition": 132,
              "body": "This should probably be clear this is going in EncryptedExtensions, not Certificate, as they both carry padding.",
              "createdAt": "2020-09-30T21:47:32Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5ODUxNTMy",
          "commit": {
            "abbreviatedOid": "c070516"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-30T22:18:43Z",
          "updatedAt": "2020-09-30T22:18:43Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Hmm, the server's reply appears in the EncryptedExtensions message, so the server behavior is ill-defined in TLS<=1.2. I suppose the answer is \"who cares\"?",
              "createdAt": "2020-09-30T22:18:43Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5ODUyMjY4",
          "commit": {
            "abbreviatedOid": "c070516"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-30T22:20:23Z",
          "updatedAt": "2020-09-30T22:20:24Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": " Good catch, thanks!",
              "createdAt": "2020-09-30T22:20:23Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDg0ODE2",
          "commit": {
            "abbreviatedOid": "4afb7a7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T22:49:25Z",
          "updatedAt": "2020-10-02T22:54:34Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Given that the client-side piece is orthogonal to ECH, I think it's probably best to defer that until we figure out the client EE/ALPS story. ",
              "createdAt": "2020-10-02T22:49:25Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            },
            {
              "originalPosition": 143,
              "body": "Is this the Certificate message after compression, or before? I assume the former, though it would be good to clarify.",
              "createdAt": "2020-10-02T22:51:25Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            },
            {
              "originalPosition": 134,
              "body": "What about `CertificateVerify`?",
              "createdAt": "2020-10-02T22:51:46Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            },
            {
              "originalPosition": 128,
              "body": "I'd recommend pulling this out into a separate issue entirely. The client-side padding policy took a while to get consensus, so trying to spell the server-side story here might delay landing of the general mechanism. Can we do that?",
              "createdAt": "2020-10-02T22:53:12Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            },
            {
              "originalPosition": 126,
              "body": "I'd recommend pulling this out into a separate issue entirely. The client-side padding policy took a while to get consensus, so trying to spell the server-side story here might delay landing of the general mechanism. Can we do that and replace this with an open issue?\r\n\r\n```suggestion\r\n[[OPEN ISSUE: provide server-side padding policy based on Certificate, CertificateVerify(?), ALPN list, and\r\npossibly other (future) parameters.]]\r\n```",
              "createdAt": "2020-10-02T22:54:30Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDkxMjU4",
          "commit": {
            "abbreviatedOid": "fd1b2ad"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T23:15:24Z",
          "updatedAt": "2020-10-02T23:15:24Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Removed. I also removed \"the server MUST ignore [the] extension if it negotiates TLS 1.2 or below\".",
              "createdAt": "2020-10-02T23:15:24Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDkxODMy",
          "commit": {
            "abbreviatedOid": "fd1b2ad"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T23:18:02Z",
          "updatedAt": "2020-10-02T23:18:02Z",
          "comments": [
            {
              "originalPosition": 143,
              "body": "The former. More precisely, what's intended is the Certificate message as it appears on the wire. I'll clarify this. Can you provide me a reference for certificate compression? I'm unfamiliar with that spec.",
              "createdAt": "2020-10-02T23:18:02Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDkyODIy",
          "commit": {
            "abbreviatedOid": "fd1b2ad"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T23:23:04Z",
          "updatedAt": "2020-10-02T23:23:05Z",
          "comments": [
            {
              "originalPosition": 143,
              "body": "Sure -- [here you go](https://datatracker.ietf.org/doc/draft-ietf-tls-certificate-compression/)! The reference {{?I-D.ietf-tls-certificate-compression}} should work.",
              "createdAt": "2020-10-02T23:23:05Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDkzMTIx",
          "commit": {
            "abbreviatedOid": "fd1b2ad"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T23:24:22Z",
          "updatedAt": "2020-10-02T23:24:23Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "I'm not sure we should RECOMMEND that. On the one hand, the length of CertificateVerify would leak is the (parameters of the) signature algorithm, On the other hand, an RSA signature is much longer than ECDSA-P256. Hence, the downside is lots of extra padding to protect clients/servers that need to support RSA.",
              "createdAt": "2020-10-02T23:24:23Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDkzNDEw",
          "commit": {
            "abbreviatedOid": "fd1b2ad"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T23:25:39Z",
          "updatedAt": "2020-10-02T23:25:40Z",
          "comments": [
            {
              "originalPosition": 128,
              "body": "In that case, I think we should postpone this change until affter -08.",
              "createdAt": "2020-10-02T23:25:40Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDkzOTY3",
          "commit": {
            "abbreviatedOid": "fd1b2ad"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T23:28:08Z",
          "updatedAt": "2020-10-02T23:28:08Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "I think it's fine to RECOMMEND something that is obsoleted by a better idea later on. But as I mentioned above, if this change is likely to be controversial, then we should take it to the list. In addition, I think we should consider publishing -08 beforehand. There's already substantial changes.",
              "createdAt": "2020-10-02T23:28:08Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDk1NjQw",
          "commit": {
            "abbreviatedOid": "45fa615"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T23:36:27Z",
          "updatedAt": "2020-10-02T23:36:28Z",
          "comments": [
            {
              "originalPosition": 128,
              "body": "Yeah, that seems reasonable. Do you want to flag the issue (and PR) as such?",
              "createdAt": "2020-10-02T23:36:27Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDk1ODAy",
          "commit": {
            "abbreviatedOid": "45fa615"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T23:37:21Z",
          "updatedAt": "2020-10-02T23:37:21Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "Eh, true, but I don't think the cost is that great.",
              "createdAt": "2020-10-02T23:37:21Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDk4MTEx",
          "commit": {
            "abbreviatedOid": "45fa615"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T23:50:10Z",
          "updatedAt": "2020-10-02T23:50:10Z",
          "comments": [
            {
              "originalPosition": 128,
              "body": "This PR already has an associated issue (https://github.com/tlswg/draft-ietf-tls-esni/issues/264). Why don't I just add a comment there?",
              "createdAt": "2020-10-02T23:50:10Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMDk1MzM3",
          "commit": {
            "abbreviatedOid": "45fa615"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-05T14:09:46Z",
          "updatedAt": "2020-10-05T14:09:46Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "Yeah, I expect this to be controversial. I'd take it to the list.",
              "createdAt": "2020-10-05T14:09:46Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMDk1NjAy",
          "commit": {
            "abbreviatedOid": "45fa615"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-05T14:10:03Z",
          "updatedAt": "2020-10-05T14:10:03Z",
          "comments": [
            {
              "originalPosition": 128,
              "body": "That's what I was thinking, yeah. ",
              "createdAt": "2020-10-05T14:10:03Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyNTI5OTM2",
          "commit": {
            "abbreviatedOid": "45fa615"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "How does handshake_padding differ from RFC 7685, less this one sentence: \"The server MUST NOT echo the extension.\" and some clarification about EE/CR/C/?",
          "createdAt": "2020-10-06T01:44:54Z",
          "updatedAt": "2020-10-06T01:46:18Z",
          "comments": [
            {
              "originalPosition": 92,
              "body": "```suggestion\r\n(ECHConfig.maximum_name_length) when computing the padding length as follows:\r\n```",
              "createdAt": "2020-10-06T01:44:54Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NTc0NTI3",
          "commit": {
            "abbreviatedOid": "8ca7de2"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-08T19:47:38Z",
          "updatedAt": "2020-12-08T19:47:39Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Should this be ClientHelIoInner?",
              "createdAt": "2020-12-08T19:47:38Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NTc1OTQ1",
          "commit": {
            "abbreviatedOid": "8ca7de2"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-08T19:49:38Z",
          "updatedAt": "2020-12-08T19:49:38Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "s/zeros bytes/zero bytes/?",
              "createdAt": "2020-12-08T19:49:38Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NTc3MDY1",
          "commit": {
            "abbreviatedOid": "8ca7de2"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-08T19:51:09Z",
          "updatedAt": "2020-12-08T19:51:09Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "When *and only when* solicited by the client? If so, why?",
              "createdAt": "2020-12-08T19:51:09Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NTc3NTU0",
          "commit": {
            "abbreviatedOid": "8ca7de2"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-08T19:51:48Z",
          "updatedAt": "2020-12-08T19:51:49Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Why not SHOULD?",
              "createdAt": "2020-12-08T19:51:48Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNzQ5NjI0",
          "commit": {
            "abbreviatedOid": "6586841"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-15T20:59:31Z",
          "updatedAt": "2021-02-15T20:59:32Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Yes, due to the rule in TLS !.3 that the server not send unsolicited extensions (with a few, well-specified exceptions). There'd be no need to allow this behavior anyway: if the client failing to pad leads to a confidentiality breach, it's unlikely that the server can mitigate this much by padding unilaterally.",
              "createdAt": "2021-02-15T20:59:31Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNzUwMjAw",
          "commit": {
            "abbreviatedOid": "6586841"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-15T21:01:04Z",
          "updatedAt": "2021-02-15T21:01:04Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "IIRC the intent is for the the \"handshake_padding\" to be general purpose, i.e., not specific to ECH.",
              "createdAt": "2021-02-15T21:01:04Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNzUwNDg3",
          "commit": {
            "abbreviatedOid": "6586841"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-15T21:01:55Z",
          "updatedAt": "2021-02-15T21:01:55Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I think MAY is more appropriate given the intended generality of the extension.",
              "createdAt": "2021-02-15T21:01:55Z",
              "updatedAt": "2021-02-15T21:02:17Z"
            }
          ]
        }
      ]
    },
    {
      "number": 314,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk1ODMxMTEx",
      "title": "Fix a line break (and make CI happy)",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/314",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-09-30T22:50:19Z",
      "updatedAt": "2021-04-16T19:56:31Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "2ae8aca2a4ffb48d550cbe713e98951ef7a0919a",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "nit/ci",
      "headRefOid": "6e0491f66b1f43ac1e0aaafec8441f1cb7bb40b9",
      "closedAt": "2020-09-30T22:51:08Z",
      "mergedAt": "2020-09-30T22:51:08Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "0403ebf7200b700d9c455437947328f1bed7915e"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 315,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk1ODM2MTQx",
      "title": "Bump ech_hrr_key length to 32 bytes to align with latest HPKE changes.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/315",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/159, and the related [CFRG thread](https://mailarchive.ietf.org/arch/msg/cfrg/mxBzZq85ijSMNMUwyI3gA3B0U4U/).\r\n\r\ncc @cjpatton ",
      "createdAt": "2020-09-30T23:06:28Z",
      "updatedAt": "2021-04-19T15:51:48Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "e9c1bbd1acd13f1683f34fe0a51752da2c55cb6c",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/ech-hrr-key",
      "headRefOid": "dd2e5aad2eb6cec18afc20f3b856bc42c54bb894",
      "closedAt": "2020-10-08T18:04:25Z",
      "mergedAt": "2020-10-08T18:04:24Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "28c02428ce2e46dad0106a93eeb98655608bf29f"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "~Looks good to me.~ There are two places you need to change the length. This PR just changes it in one.",
          "createdAt": "2020-09-30T23:44:25Z",
          "updatedAt": "2020-09-30T23:45:53Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good!",
          "createdAt": "2020-10-01T00:12:44Z",
          "updatedAt": "2020-10-01T00:12:44Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5ODkwNjQ2",
          "commit": {
            "abbreviatedOid": "05798ce"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-09-30T23:46:43Z",
          "updatedAt": "2020-09-30T23:46:48Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "You also need to change this above.\r\n\r\ns/context.Export(\"tls13 ech hrr key\", 16)/context.Export(\"tls13 ech hrr key\", 32)",
              "createdAt": "2020-09-30T23:46:43Z",
              "updatedAt": "2020-10-01T00:00:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5OTEzOTgx",
          "commit": {
            "abbreviatedOid": "dd2e5aa"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T00:01:00Z",
          "updatedAt": "2020-10-01T00:01:01Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Grr, I thought caught them all. Thanks!",
              "createdAt": "2020-10-01T00:01:01Z",
              "updatedAt": "2020-10-01T00:01:01Z"
            }
          ]
        }
      ]
    },
    {
      "number": 316,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk1ODQzMzg5",
      "title": "Require HRR-sensitive parameters match in ClientHello(Outer|Inner).",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/316",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #233.\r\n\r\nThis is limited to parameters applicable to TLS 1.3 and beyond. For example,\r\nTLS 1.2 ciphersuites may appear in ClientHelloOuter, so long as all TLS 1.3\r\nciphersuites in ClientHelloOuter match that in ClientHelloInner.\r\n\r\ncc @davidben, @cjpatton",
      "createdAt": "2020-09-30T23:25:50Z",
      "updatedAt": "2021-04-19T15:51:51Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9f485e939b99814f9a73c1e94ec5e44f0a8d4806",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/require-hrr-match",
      "headRefOid": "d6408d375c3073b9f7d8b9a3b46ea91fb13bc9ec",
      "closedAt": "2020-11-19T00:10:06Z",
      "mergedAt": "2020-11-19T00:10:06Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f5e18954a19565611c86a817e4414b0d282062b5"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@cjpatton, @davidben, @martinthomson: this is ready for another look.",
          "createdAt": "2020-10-22T00:53:18Z",
          "updatedAt": "2020-10-22T00:53:18Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not totally sure this is the right outcome. I can imagine situations where you might want CHOuter and CHInner to be different. I wonder if we can use a similar PRF() trick for HRR to tell which one it was, though I appreciate that this is in conflict with folding the secret into random.\r\n\r\n",
          "createdAt": "2020-11-03T21:14:41Z",
          "updatedAt": "2020-11-03T21:14:41Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I think there're three issues we'd want to sort out, to allow a mismatch.\r\n1. Without an ECH acceptance signal in HRR, the error gets deferred and that seems like a huge mess. I think this is the issue you have in mind with the PRF trick?\r\n2. If the HRR matches CHInner and is inconsistent with CHOuter, we still need to construct *some* CHOuter. The current draft says you don't follow the RFC8446 rules, but that can't be right because we need the cookie to appear in CHOuter even if CHOuter can't be constructed.\r\n3. Even if a mismatch is allowed, I think we should have text encouraging a match, so implementers know to avoid a complexity cliff if they don't need it.\r\n\r\n(It's also possible this would interact with #333, if we want some goofy HRRInner vs HRROuter scheme...)",
          "createdAt": "2020-11-03T21:22:10Z",
          "updatedAt": "2020-11-03T21:22:36Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, I am trying to fix #1 with the PRF trick.\r\n\r\nAnd yes, there is some possibility of a goofy HRRInner/HRROuter\r\n\r\n",
          "createdAt": "2020-11-03T22:30:23Z",
          "updatedAt": "2020-11-03T22:30:23Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5OTM2MDgw",
          "commit": {
            "abbreviatedOid": "7bf7979"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-10-01T00:15:09Z",
          "updatedAt": "2020-10-01T00:15:18Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "An editorial suggestion: I would have the bullet simply read \"It MUST ensure that all HelloRetryRequest-sensitive parameters applicable to TLS 1.3 and higher versions in ClientHelloInner match that in ClientHelloOuter. See {{hrr}} for the list of these parameters.\" and I would enumerate the HRR-sensitive parameters in {{hrr}}. Moreover, this change likely impacts the text in {{hrr}}.",
              "createdAt": "2020-10-01T00:15:09Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNTQzMzA4",
          "commit": {
            "abbreviatedOid": "9e244c8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T16:55:46Z",
          "updatedAt": "2020-10-01T16:55:47Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "Should be done!",
              "createdAt": "2020-10-01T16:55:46Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNTUyMDIy",
          "commit": {
            "abbreviatedOid": "9e244c8"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T17:07:13Z",
          "updatedAt": "2020-10-01T17:07:13Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "s/and/or",
              "createdAt": "2020-10-01T17:07:13Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNTQ1NzU5",
          "commit": {
            "abbreviatedOid": "9e244c8"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T16:58:51Z",
          "updatedAt": "2020-10-01T17:10:18Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "supported_versions itself is also HRR-sensitive, but the matching rule is a little weird. The HRR specifies the TLS version (suppose 1.4, 1.5, and 1.6 exist and all have HRR), so if the client preferences are different between the two, things will break.",
              "createdAt": "2020-10-01T16:58:51Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            },
            {
              "originalPosition": 17,
              "body": "Suppose a server decrypts ClientHelloOuter and sees that its parameters differ from ClientHelloInner. Should it reject the connection or continue because we don't want the server to bother looking at the other ClientHello very much?\r\n\r\nI ask because it occurred to me we might want to extend this in the future where the client doesn't care about the ClientHelloOuter and retry case. This is disastrous from a recoverability perspective, but if it's a predictive connection or has some other fallback available already, maybe that's fine. In that case, the ClientHelloOuter only needs to be the bare minimum to pass syntactically.\r\n\r\nI think we can freely specify that later, so it doesn't really matter whether this is a SHOULD or MUST on the client, but the server behavior would constrain this.",
              "createdAt": "2020-10-01T17:10:10Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNzUwNjM2",
          "commit": {
            "abbreviatedOid": "9e244c8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T22:07:07Z",
          "updatedAt": "2020-10-01T22:07:07Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Yeah, I think leaving this as a MUST for now and possibly relaxing later is fine, provided we don't constrain ourselves by forcing a server-side check here. So, let's leave this as is?",
              "createdAt": "2020-10-01T22:07:07Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNzUxNzk5",
          "commit": {
            "abbreviatedOid": "07589cf"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T22:09:38Z",
          "updatedAt": "2020-10-01T22:09:38Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "I added \"supported_versions\" to the list!",
              "createdAt": "2020-10-01T22:09:38Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDQzMzM5",
          "commit": {
            "abbreviatedOid": "07589cf"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T20:57:43Z",
          "updatedAt": "2020-10-02T20:57:43Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Sorry, I should have been clearer. So the reason supported_versions is a huge headache is that it *doesn't* match between the inner and outer. The inner ClientHello is forbidden from offering TLS 1.2, while the outer one may still offer it. I think the rule is something like they need to match, after you drop 1.0-1.2 from the outer list, which is weird.",
              "createdAt": "2020-10-02T20:57:43Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDQ2MDM5",
          "commit": {
            "abbreviatedOid": "07589cf"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T21:03:00Z",
          "updatedAt": "2020-10-02T21:03:01Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Yeah, I figured this was covered by saying these are \"parameters applicable to TLS 1.3 or higher\". Do you not think that's enough? If not, would you mind proposing text to clarify?",
              "createdAt": "2020-10-02T21:03:00Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDYwNTg1",
          "commit": {
            "abbreviatedOid": "07589cf"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T21:34:57Z",
          "updatedAt": "2020-10-02T21:34:57Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Ah I see. Yeah, I didn't interpret that to apply to the individual details like that. Do you think this would be clearer?\r\n\r\n> 1. TLS 1.3 {{!RFC8446}} ciphersuites in the ClientHello.cipher_suites list\r\n> 1. The \"key_share\" and \"supported_groups\" extensions\r\n{{RFC8446}}. (These extensions may be copied from ClientHelloOuter into\r\nClientHelloInner as described in {{send-ech}}.)\r\n> 1. Versions in the \"supported_versions\" extension, excluding TLS 1.2 and earlier. Note the ClientHelloOuter MAY include these older versions, while the ClientHelloInner MUST omit them.",
              "createdAt": "2020-10-02T21:34:57Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDc5NDky",
          "commit": {
            "abbreviatedOid": "07589cf"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T22:29:40Z",
          "updatedAt": "2020-10-02T22:29:40Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Yep, that is more clear! ",
              "createdAt": "2020-10-02T22:29:40Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDk0ODYw",
          "commit": {
            "abbreviatedOid": "7b41099"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T23:32:22Z",
          "updatedAt": "2020-10-02T23:32:22Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "\"non-ECH PSK\": does this term still exist? I know we talked about this already but I forgot where we landed :)",
              "createdAt": "2020-10-02T23:32:22Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDk2MzE2",
          "commit": {
            "abbreviatedOid": "7b41099"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T23:40:01Z",
          "updatedAt": "2020-10-02T23:40:01Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "It's addressed in another PR.",
              "createdAt": "2020-10-02T23:40:01Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyNTY0Mzcz",
          "commit": {
            "abbreviatedOid": "7b41099"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "More evidence that we don't have a good shared understanding of what HRR is for, sadly.\r\n\r\nThe primary thing of concern here is the ability for HRR to cause a client to change their expressed preferences or how those preferences are expressed (specifically for key shares).  This pull request is phrased differently in terms of what might cause a server to send HRR, which isn't that.  The HRR is the only thing that a client should allow to change its preferences, but focus on HRR seems wrong.\r\n\r\nTo avoid problems we have two options: the preference cannot change (which is the ideal choice if we can manage it), or the preference can change, but any change is authenticated.  To that end, this is a reasonable design choice, I just would prefer we concentrate on the critical property.\r\n\r\nAlso, I'm fairly sure that this means that 8446 needs to be updated by this.",
          "createdAt": "2020-10-06T03:48:39Z",
          "updatedAt": "2020-10-06T04:07:27Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Does HRR-sensitive mean \"all extensions or parameters that might change in response to receiving HRR\"?  If it does, then maybe say that.",
              "createdAt": "2020-10-06T03:48:40Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            },
            {
              "originalPosition": 28,
              "body": "Isn't the primary consideration whether they might change between subsequent ClientHellos?  That these might cause a server to send HelloRetryRequest is merely consequential.",
              "createdAt": "2020-10-06T03:51:05Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            },
            {
              "originalPosition": 17,
              "body": "This connects parameters that might change in response to HRR to whether they appear inside or outside.  This assumes that they appear in both places (and that they are the same).\r\n\r\nThere's an implicit constraint here that probably needs to be explicit: HelloRetryRequest can only be sent to affect a change in a ClientHello that affects key negotiation.  This is recognizing a new constraint on the design that was essentially always true, but not mandatory.  In principle, prior to this, HRR could affect a new extension that didn't affect key negotiation.\r\n\r\nConveniently, we already have a proxy for that.  Extensions that are CH/SH (as opposed to CH/EE) are those that HRR can change.  In theory there could be some that appear in CH alone, but that is unlikely to be true for a new extension given our systemic rejection of trial decryption.\r\n\r\nThis should probably be reflected somewhere, probably by updating RFC 8446.",
              "createdAt": "2020-10-06T04:01:35Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyOTY2MTcx",
          "commit": {
            "abbreviatedOid": "7b41099"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-06T13:33:32Z",
          "updatedAt": "2020-10-06T13:33:32Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "We could rewrite this as, \"Future extensions that might change across first and second ClientHello messages in response to a HelloRetryRequest MUST match,\" as you suggest.",
              "createdAt": "2020-10-06T13:33:32Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyOTY2NDgy",
          "commit": {
            "abbreviatedOid": "7b41099"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-06T13:33:48Z",
          "updatedAt": "2020-10-06T13:33:48Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "That seems like an improvement, yeah. I'll take it.",
              "createdAt": "2020-10-06T13:33:48Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyOTcyNTI2",
          "commit": {
            "abbreviatedOid": "7b41099"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-06T13:39:25Z",
          "updatedAt": "2020-10-06T13:39:26Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "I agree with the above, but it's not clear to me what specifically you're suggesting. The *intent* of this change is to encompass any CH/SH extension that might change due to HRR, and we refer to those as \"HRR-sensitive\" parameters. \r\n\r\nCan you please clarify what specifically what you're looking for, ideally with suggested text?\r\n\r\n> This should probably be reflected somewhere, probably by updating RFC 8446.\r\n\r\nI don't think this needs to update RFC8446. The HRR language in that document is somewhat unclear as-is, so it probably makes more sense to tackle this in rfc8446-bis.",
              "createdAt": "2020-10-06T13:39:25Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3NzczOTU4",
          "commit": {
            "abbreviatedOid": "7b41099"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-13T19:47:36Z",
          "updatedAt": "2020-10-13T19:55:51Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Is it parameters that would change in response to HRR, or parameters that would change which HRRs you accept? The latter captures the issue a bit more directly, since the issue is a goofy mechanical one of needing to process an HRR for two ClientHellos concurrently, and the error cases being a mess. (If the HRR matches inner but not outer, how do you construct a new outer ClientHello?)\r\n\r\nAlso a strict reading of \"parameters that might change in response to receiving HRR\" would include PSKs, which isn't what we want. RFC8446 has this odd corner case:\r\nhttps://tools.ietf.org/html/rfc8446#section-4.1.2\r\n\r\n>  -  Updating the \"pre_shared_key\" extension if present by recomputing\r\n>      the \"obfuscated_ticket_age\" and binder values and (optionally)\r\n>      removing any PSKs which are incompatible with the server's\r\n>      indicated cipher suite.\r\n\r\n(This was to save clients from recomputing binders for a hash they aren't using. Something something crypto agility is a headache.)\r\n\r\nA strict reading would also exclude cipher suite preferences, since the client doesn't change them on HRR, even though the server has already committed to one.",
              "createdAt": "2020-10-13T19:47:37Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            },
            {
              "originalPosition": 28,
              "body": "Per comment above, perhaps \"Future extensions that influence the set of HelloRetryRequest values that the clients would accept\"? Though that is definitely kinda weird to say. :-/",
              "createdAt": "2020-10-13T19:55:43Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNTkzOTYz",
          "commit": {
            "abbreviatedOid": "ef01697"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I think this PR is close to what we want. Perhaps we could be more upfront about the fact that future changes to HRR need to be reconciled with ECH.",
          "createdAt": "2020-10-16T15:48:30Z",
          "updatedAt": "2020-10-16T16:28:48Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\n   ClientHelloOuter. See {{client-hrr}} for the list of these parameters.\r\n```",
              "createdAt": "2020-10-16T15:48:30Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            },
            {
              "originalPosition": 16,
              "body": "Grammar suggestion: \"parameters of the ClientHelloInner that are applicable to TLS 1.3 or higher match those of the ClientHelloOuter.\"",
              "createdAt": "2020-10-16T15:51:50Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            },
            {
              "originalPosition": 17,
              "body": "The server doesn't enforce this MUST, as far as I can tell. For context, note that #339 merely requires that the server checks ECH usage doesn't change across HRR.",
              "createdAt": "2020-10-16T16:10:35Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            },
            {
              "originalPosition": 21,
              "body": "Does this text allow implementations to use different DH key shares? E.g., `g^x` in ClientHelloInner and `g^y` in ClientHelloOuter, where `g` is the generator of the group?",
              "createdAt": "2020-10-16T16:22:21Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            },
            {
              "originalPosition": 28,
              "body": "Maybe we should be more upfront about this? In particular, we could mention this prior to listing the known HRR-senstive parameters. That would prompt the reader to realize that ECH interacts with future changes to HRR.",
              "createdAt": "2020-10-16T16:27:00Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            },
            {
              "originalPosition": 17,
              "body": "I think @martinthomson's point is that this PR is overly prescriptive about the semantics of HRR? If so, I disagree. It aims to address HRR-sensitive parameters that are known today, but there's line about how to address future changes to the HRR code path. Maybe we should be more upfront about this.",
              "createdAt": "2020-10-16T16:27:04Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0Mjg3MzAx",
          "commit": {
            "abbreviatedOid": "99e2965"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-22T00:50:44Z",
          "updatedAt": "2020-10-22T00:50:44Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "No, I think that's the point. ",
              "createdAt": "2020-10-22T00:50:44Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0Mjg3ODEx",
          "commit": {
            "abbreviatedOid": "aeb1618"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-22T00:52:13Z",
          "updatedAt": "2020-10-22T00:52:13Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "I rewrote per my suggestion above, based on MT's comment. Please have a look, @martinthomson!",
              "createdAt": "2020-10-22T00:52:13Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0Mjg4MDcy",
          "commit": {
            "abbreviatedOid": "aeb1618"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-22T00:52:57Z",
          "updatedAt": "2020-10-22T00:52:58Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I applied the suggestion above!",
              "createdAt": "2020-10-22T00:52:58Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0MzU5MTI2",
          "commit": {
            "abbreviatedOid": "aeb1618"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Much better \ud83d\udc4d \r\nI have some more suggestions, but hopefully these are more concrete here.",
          "createdAt": "2020-10-22T04:57:17Z",
          "updatedAt": "2020-10-22T05:01:08Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\nextensions or parameters that might change in response to receiving a\r\nHelloRetryRequest have the same values in ClientHelloInner and \r\nClientHelloOuter. These parameters include:\r\n```\r\n\r\nI'm using \"same values\" rather than \"match\", which I think works if you allow the value to be filled in by following a reference.\r\n\r\nDo you really need to call out anything from earlier versions?  None of those change.  By definition you are implementing TLS 1.3 already, so mentioning earlier versions seems unnecessary.\r\n\r\nI wonder if it is worth adding:\r\n\r\n> That is, if a HelloRetryRequest causes a value to be changed, the same change is applied to both ClientHelloInner and ClientHelloOuter.",
              "createdAt": "2020-10-22T04:57:17Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            },
            {
              "originalPosition": 19,
              "body": "Do we really need to say this?  My understanding is that you don't change the ciphersuite list in response to HRR, so calling this out might be confusing.",
              "createdAt": "2020-10-22T04:58:03Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0NzMwMjUy",
          "commit": {
            "abbreviatedOid": "aeb1618"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-22T13:33:23Z",
          "updatedAt": "2020-10-22T13:33:23Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I think this is where \"parameters that change in response to HRR\" isn't quite the right criteria.\r\nhttps://github.com/tlswg/draft-ietf-tls-esni/pull/316#discussion_r504213701\r\n\r\nIf the client has different inner vs. outer cipher suites, then the set of HRRs that it will accept between the two is different. That means we need to describe what happens if the HRR is valid for the inner CH but not the outer and vice versa. TLS doesn't say how you construct a CH in response to an invalid HRR. (It's also just generally annoying to implement on the client because you need to defer reacting to an error in one of two parallel handshakes.)",
              "createdAt": "2020-10-22T13:33:23Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0ODA4NzEz",
          "commit": {
            "abbreviatedOid": "aeb1618"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-22T14:45:11Z",
          "updatedAt": "2020-10-22T14:45:11Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I don't get this.  I can see why you might filter out cipher suites from TLS 1.2 and earlier, but to say that the set of ciphersuites is different is strange.\r\n\r\nAlso, you aren't allowed to change the set of ciphersuites you offer in response to HRR.",
              "createdAt": "2020-10-22T14:45:11Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0ODMxOTA1",
          "commit": {
            "abbreviatedOid": "aeb1618"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-22T15:06:11Z",
          "updatedAt": "2020-10-22T15:06:12Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I think maybe we're not on the same page as to the problem being solved. The one I have in mind is this:\r\nhttps://github.com/tlswg/draft-ietf-tls-esni/issues/233#issuecomment-697949177\r\n\r\nHelloRetryRequest contains the cipher suite. If, as a client, you have different cipher suite preferences in ClientHelloOuter and ClientHelloInner, the set of valid HRR messages varies. The same is true if you have different supported_groups or key_shares preferences. That means it is possible to receive a HelloRetryRequest that is valid for ClientHelloInner, but not ClientHelloOuter, and vice versa. The client needs to do something coherent in that case. Specifically...\r\n\r\n* It needs to note that one of the parallel handshake flows has an error, but not act on it yet.\r\n* When it sees ServerHello, if the server picked the ClientHello with a deferred error, it needs to retroactively act on that error.\r\n* If HRR was good for inner but bad for outer, the client needs to send a second ClientHello with an updated ClientHelloInner (easy), but contained in *some* ClientHelloOuter. What ClientHelloOuter does it construct? This gets especially thorny given HRR cookies, though note #333.\r\n* If the HRR was good for the outer but bad for the inner, the client I guess can stop offering ECH in the second CH, but that contradicts [this text](https://tlswg.org/draft-ietf-tls-esni/draft-ietf-tls-esni.html#section-7.1.1-2.1). Or the client can, as above, construct some dummy ClientHelloInner. (What does it construct?)\r\n\r\nOr the client can avoid all this disaster by matching the inner and outer preferences wherever it would affect HRR *acceptance*. Having an invisible complexity cliff in the spec is bad, so we should either:\r\n* Write down how to avoid this problem as a MUST and leave it at that -or-\r\n* Write down how to avoid this problem as a SHOULD and *also* write down what you do if you want to do the hard thing anyway.\r\n\r\n(We could partially simplify this by working an ECH acceptance signal into HRR somehow, but it wouldn't solve the dummy ClientHello problem, just the deferred error problem.)",
              "createdAt": "2020-10-22T15:06:11Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1MTIwMDA0",
          "commit": {
            "abbreviatedOid": "aeb1618"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-22T21:07:55Z",
          "updatedAt": "2020-10-22T21:07:56Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "My point is far narrower.\r\n\r\nThe rules for cipher suites are restrictive: CHOuter can include many cipher suites.  CHInner can only include the subset of those cipher suites that are supported in TLS 1.3 (or higher).  Furthermore, the rules for HRR don't permit changing the set of offered cipher suites in the second ClientHello (either!).",
              "createdAt": "2020-10-22T21:07:56Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxNzk1MzY0",
          "commit": {
            "abbreviatedOid": "aeb1618"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T16:33:04Z",
          "updatedAt": "2020-11-02T16:33:04Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Hrm, I get the feeling we're still not talking about the same thing, but maybe I'm woefully confused. :-)\r\n\r\nI agree we want CHInner to only include the TLS 1.3+ cipher suites in CHOuter. I claim, to avoid the half-error HRR problem, we also want it to include all of those cipher suites.\r\n\r\nIn the draft as-is, I don't think either rule is in there. The spec allows for your CHInner and CHOuter cipher suites to be totally unrelated, thus the half-error HRR problem. My understanding was this PR was meant to fix this.\r\n\r\nI agree that cipher suites don't change in response to HRR and so including cipher suites in such a list is incorrect. But I think the problem isn't in the list itself (which is correct to avoid the half-HRR problem), but in the description of the list. I.e. \"extensions or parameters [...] that might change in response to receiving HelloRetryRequest\" isn't actually the criteria we want for this PR.",
              "createdAt": "2020-11-02T16:33:04Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyODgwNjg4",
          "commit": {
            "abbreviatedOid": "aeb1618"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Just one minor nit, plus an endorsement of a couple of @martinthomson's suggestions. It seems like this PR will leave an OPEN ISSUE, which we need to note.",
          "createdAt": "2020-11-17T22:54:13Z",
          "updatedAt": "2020-11-17T23:00:48Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "```suggestion\r\nin response to a HelloRetryRequest MUST have the same value.\r\n```",
              "createdAt": "2020-11-17T22:54:14Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            },
            {
              "originalPosition": 17,
              "body": "> I'm using \"same values\" rather than \"match\", which I think works if you allow the value to be filled in by following a reference.\r\n\r\nI like this idea.\r\n\r\n> I wonder if it is worth adding:\r\n> \r\n> > That is, if a HelloRetryRequest causes a value to be changed, the same change is applied to both ClientHelloInner and ClientHelloOuter.\r\n\r\nI also like this idea.\r\n\r\n",
              "createdAt": "2020-11-17T22:55:51Z",
              "updatedAt": "2020-11-18T03:09:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzMTEwMzU0",
          "commit": {
            "abbreviatedOid": "d6408d3"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-18T05:16:34Z",
          "updatedAt": "2020-11-18T05:16:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 317,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk1ODYzNTg3",
      "title": "Simplify session resumption logic.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/317",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #285.\r\n\r\nWe need to decide if we want to allow a GREASE+ticket distinguisher, and if not, how we GREASE the \"pre_shared_key\" extension in a meaningful way. The latter seems like somewhat of a cat and mouse game, so I'm not really enthusiastic about trying to specify that behavior, but I'd like to hear what others think.\r\n\r\ncc @davidben, @cjpatton, @martinthomson ",
      "createdAt": "2020-09-30T23:55:46Z",
      "updatedAt": "2021-04-19T15:51:49Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "856b7fe98915102ceb7796dfec41cb1b627b8b9e",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/simpler-resumption",
      "headRefOid": "df683d4c0730ebab2e9a757664cd5e6ce9de274b",
      "closedAt": "2020-10-07T23:00:44Z",
      "mergedAt": "2020-10-07T23:00:44Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "e3a6b583b47c0907774bdb04d45df881270df17e"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This looks good. I still feel that there are a lot of ways that ECH usage might stick out, even to passive observers. \"pre_shared_key\" is one of many. If anything I would change the \"OPEN ISSUE\" to encompass top-to-bottom \"don't stick out\" review.",
          "createdAt": "2020-10-07T17:07:12Z",
          "updatedAt": "2020-10-07T17:07:12Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5OTI3MTM0",
          "commit": {
            "abbreviatedOid": "700bfc6"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T00:09:18Z",
          "updatedAt": "2020-10-01T00:09:18Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "I suggest leaving this OPEN ISSUE open and address it post -08. This is one way that real ECH sticks out from covertext, but there are likely others. What is needed is a big picture \"don't stick out\" review of ECH.",
              "createdAt": "2020-10-01T00:09:18Z",
              "updatedAt": "2020-10-07T15:34:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5OTI4OTQ3",
          "commit": {
            "abbreviatedOid": "700bfc6"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T00:10:28Z",
          "updatedAt": "2020-10-01T00:10:28Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "nit: \"outer ClientHello\" -> \"the ClientHelloOuter\". Here and below.",
              "createdAt": "2020-10-01T00:10:28Z",
              "updatedAt": "2020-10-07T15:34:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5OTI5OTYx",
          "commit": {
            "abbreviatedOid": "700bfc6"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T00:11:07Z",
          "updatedAt": "2020-10-01T00:11:07Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "Is \"ECH PSK\" an obsolete term?",
              "createdAt": "2020-10-01T00:11:07Z",
              "updatedAt": "2020-10-07T15:34:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5OTM3OTUx",
          "commit": {
            "abbreviatedOid": "42ba0a7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T00:21:54Z",
          "updatedAt": "2020-10-01T00:21:55Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "We use it when noting tickets/PSKs associated with an ECH accepted connection.",
              "createdAt": "2020-10-01T00:21:54Z",
              "updatedAt": "2020-10-07T15:34:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5OTM3OTkw",
          "commit": {
            "abbreviatedOid": "42ba0a7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T00:22:03Z",
          "updatedAt": "2020-10-01T00:22:04Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "I made this change more broadly.",
              "createdAt": "2020-10-01T00:22:04Z",
              "updatedAt": "2020-10-07T15:34:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5OTM4MDk3",
          "commit": {
            "abbreviatedOid": "42ba0a7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T00:22:28Z",
          "updatedAt": "2020-10-01T00:22:29Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "I'm fine with that, I think, though we may want to reconsider it before the GREASE experiments commence.",
              "createdAt": "2020-10-01T00:22:28Z",
              "updatedAt": "2020-10-07T15:34:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNDk4ODcy",
          "commit": {
            "abbreviatedOid": "42ba0a7"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T16:01:04Z",
          "updatedAt": "2020-10-01T16:01:04Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "(Noticed this while looking at the text for something else: the list below also has a reference to \"non-ECK PSK\" that should be dropped here.)",
              "createdAt": "2020-10-01T16:01:04Z",
              "updatedAt": "2020-10-07T15:34:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNTAxODAw",
          "commit": {
            "abbreviatedOid": "d8efb6e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T16:04:31Z",
          "updatedAt": "2020-10-01T16:04:32Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I explicitly kept that, but I don't really feel strongly about keeping it. So I just removed it. ",
              "createdAt": "2020-10-01T16:04:31Z",
              "updatedAt": "2020-10-07T15:34:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNTMwNDY1",
          "commit": {
            "abbreviatedOid": "d8efb6e"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T16:39:04Z",
          "updatedAt": "2020-10-01T16:39:04Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Hehe, I mean this PR removes the definition of \"ECH PSK\" and \"non-ECH PSK\" so we probably shouldn't reference them. :-) I was hoping we'd no longer have to associate this extra boolean with each session.",
              "createdAt": "2020-10-01T16:39:04Z",
              "updatedAt": "2020-10-07T15:34:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0Mjc5MjYz",
          "commit": {
            "abbreviatedOid": "df683d4"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I think this looks good modulo the PSK oracle section seeming kinda odd to begin with.",
          "createdAt": "2020-10-07T21:25:46Z",
          "updatedAt": "2020-10-07T21:29:25Z",
          "comments": [
            {
              "originalPosition": 123,
              "body": "I think this section might be anchoring too much on PSKs. I think it's actually a general attack mitigated by a more general fix.\r\n\r\nBack when it was ESNI, the final ClientHello was malleable. An attacker could change some parameters while carrying over the secret server name. If the server interprets the influenced parameters differently based on the secret server name, the attacker can use that as an oracle. The most natural vector is the PSK, because resumptions may be SNI-partitioned. But if you have, say, different ALPN preferences by hostname, that would also equally be a vector.\r\n\r\nWe've fixed this by:\r\n1. Encrypting the entire ClientHello gives us a convenient way to bundle all parameters together, so it's natural that servers don't look at the outer CH. (The section talks about a server that mixes the two CHs up, which is totally bizarre.)\r\n2. Everything that goes into the final ClientHello is directly or indirectly authenticated by the AEAD. (OuterExtensions.inner_digest or #323.)\r\n\r\nI'll take a stab at a replacement for this section...",
              "createdAt": "2020-10-07T21:25:46Z",
              "updatedAt": "2020-10-07T22:24:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0Mjk5MTUx",
          "commit": {
            "abbreviatedOid": "df683d4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-07T22:02:30Z",
          "updatedAt": "2020-10-07T22:02:31Z",
          "comments": [
            {
              "originalPosition": 123,
              "body": "> (The section talks about a server that mixes the two CHs up, which is totally bizarre.)\r\n\r\nIMO, this is why we kept the section. I agree that it's bizarre, but not much of a stretch from the original attack vector. I'd like to keep some mention of this mix-and-match problem for historical reasons, though I'm definitely happy to look at simpler text!",
              "createdAt": "2020-10-07T22:02:30Z",
              "updatedAt": "2020-10-07T22:02:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MzAxNTE2",
          "commit": {
            "abbreviatedOid": "df683d4"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-07T22:07:18Z",
          "updatedAt": "2020-10-07T22:07:19Z",
          "comments": [
            {
              "originalPosition": 123,
              "body": "Dunno if it's simpler, but it's hopefully more general. I think the description of the mitigation should touch on OuterExtensions.inner_digest's role in authenticating the inner ClientHello, which would have answered #263. That is, if we allowed you to compress pre_shared_keys for whatever reason, this attack would still be impossible because of that hash.\r\n\r\n(Not that you'd want to compress pre_shared_key since a compressed is public and leaking the actual ticket gives you a different kind of oracle. That falls under \"things that depend on secret things are also secret\".)",
              "createdAt": "2020-10-07T22:07:19Z",
              "updatedAt": "2020-10-07T22:07:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MzA0NjUz",
          "commit": {
            "abbreviatedOid": "df683d4"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-07T22:13:47Z",
          "updatedAt": "2020-10-07T22:13:47Z",
          "comments": [
            {
              "originalPosition": 123,
              "body": "https://github.com/tlswg/draft-ietf-tls-esni/pull/327",
              "createdAt": "2020-10-07T22:13:47Z",
              "updatedAt": "2020-10-07T22:13:47Z"
            }
          ]
        }
      ]
    },
    {
      "number": 318,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk1ODY3ODM4",
      "title": "Clarify our lack of concern around 2^{-64} acceptance signal collision probabilities",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/318",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #307.\r\n\r\ncc @tfpauly, @martinthomson ",
      "createdAt": "2020-10-01T00:10:48Z",
      "updatedAt": "2021-04-19T15:51:48Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "e9c1bbd1acd13f1683f34fe0a51752da2c55cb6c",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/negligible",
      "headRefOid": "278603817d14ff6391058ae76e88063d366834cd",
      "closedAt": "2020-10-07T14:35:46Z",
      "mergedAt": "2020-10-07T14:35:46Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "856b7fe98915102ceb7796dfec41cb1b627b8b9e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzOTQ4OTUz",
          "commit": {
            "abbreviatedOid": "2786038"
          },
          "author": "tfpauly",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-07T14:35:20Z",
          "updatedAt": "2020-10-07T14:35:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 319,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk1ODg3NTIz",
      "title": "Clarify client-facing server GREASE behavior",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/319",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This change resolves a couple points of friction around GREASE.\r\n\r\n1. Remove the client-facing server's mandate to abort the connection if it receives the ECH extension but cannot negotiate 1.3 or higher. Presuming that a client MAY send a dummy (i.e., GREASEd) ECH extension without indicating support for 1.3, this mandate doesn't make much sense.\r\n1. Mandate that the client-facing server ignore the ECH extension if the SNI does not match the public name of any known ECH configuration. It is safe to presume GREASE in this case, since the client MUST set the outer SNI to the public name of its selected ECH config (see {{client-behavior}}).\r\n\r\nThis addresses https://github.com/tlswg/draft-ietf-tls-esni/issues/295.\r\n",
      "createdAt": "2020-10-01T01:20:53Z",
      "updatedAt": "2021-04-16T19:56:31Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "e9c1bbd1acd13f1683f34fe0a51752da2c55cb6c",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "client_facing_behavior",
      "headRefOid": "04e27550933ad6d129151bb05ed82b71affbe8fa",
      "closedAt": "2020-10-01T17:13:43Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> Instead, I think all we need is to clarify the client behavior.\r\n\r\nI think https://github.com/tlswg/draft-ietf-tls-esni/pull/321 should resolve the problem.",
          "createdAt": "2020-10-01T16:37:39Z",
          "updatedAt": "2020-10-01T16:37:39Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Is the idea with this PR that the server wouldn't send retry keys based on the public name match?\r\n\r\nThe reason for this change is to allow the server to disambiguate between the following cases:\r\n1. Client sends GREASE ECH; want bypass (ignore the extension and continue as usual).\r\n2. Client sends real but stale ECH; want rejection.\r\n\r\nAs far as I can tell, there's currently no way for the server to disambiguate these, other than by using the public name. In particular, for (1.) it's true that SNI == public_name, and for (2.) it's true that SNI != public_name. I could be wrong about this, though :)\r\n\r\n> It doesn't cover if you're actually trying to visit the public name.\r\n\r\nIf you visit the public name with GREASE, then you'll get ECH rejection. If you want ECH to bypassed, then you MUST NOT send GREASE. For what it's worth, it's not clear to me why one would want to visit the client-facing server. It's sole purpose is to terminate the connection on the ECH rejection path.\r\n\r\n> And it closes off more specialized clients being more flexible in the public name in the future.\r\n\r\nThe spec is already inflexible about this. From 6.1, construction of CHOuter: 'The value of \"ECHConfig.public_name\" MUST be placed in the \"server_name\" extension.' Though I agree that if we want to relax this MUST to a SHOULD, then this PR needs to be changed.\r\n\r\n> Instead, I think all we need is to clarify the client behavior.\r\n> \r\n>     1. Retain the current text which says servers send retry keys, GREASE or no. Don't try to detect if it's GREASE vs. key mismatch.\r\n\r\nI believe detecting this is necessary on the part of the server, since the server takes needs to take a different action. In the first case, it wants to bypass ECH, and in the second it wants to reject it.",
          "createdAt": "2020-10-01T16:38:12Z",
          "updatedAt": "2020-10-01T16:38:12Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think the public name necessarily needs to be a throwaway domain. Indeed, it's better for sticking out purposes if it isn't. ECH rejection isn't fatal, precisely to support GREASE. The server handshakes with the public name however it would have. If it gets an HTTP request over that connection, great. Go respond to those.\r\n\r\nThe retry keys are a non-fatal \"hey, by the way, if you actually wanted that inner ClientHello, use these instead\". If the client wanted ECH, it will then terminate the connection with ech_required. If not, it just happily uses the connection and continues. That's why this sentence is there:\r\n\r\n> Note that an unrecognized ClientECH.config_id value may be a GREASE ECH extension (see {{grease-extensions}}), so it is necessary for servers to proceed with the connection and rely on the client to abort if ECH was required. In particular, the unrecognized value alone does not indicate a misconfigured ECH advertisement ({{misconfiguration}}). Instead, servers can measure occurrences of the \"ech_required\" alert to detect this case.",
          "createdAt": "2020-10-01T16:43:50Z",
          "updatedAt": "2020-10-01T16:43:50Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I don't think the public name necessarily needs to be a throwaway domain. Indeed, it's better for sticking out purposes if it isn't. ECH rejection isn't fatal, precisely to support GREASE. The server handshakes with the public name however it would have. If it gets an HTTP request over that connection, great. Go respond to those.\r\n\r\nGood point.\r\n\r\n> The retry keys are a non-fatal \"hey, by the way, if you actually wanted that inner ClientHello, use these instead\". If the client wanted ECH, it will then terminate the connection with ech_required.\r\n\r\nHrm, I guess I was envisioning a much clearer signal of ECH rejection. As is, it can only be known that ECH was rejected once the client sends the \"ech_required\" alert. I suppose this is doable, if a little annoying on the server side. In any case, the points you raise outweigh the benefits of this PR, so let's drop it.\r\n\r\nOne thing I would like to emphasizes is that we currently mandate that the client MUST set the outer SNI to the public_name when offering ECH. If we want to support future implementations that are flexible about the public name, then we'll need to relax this.\r\n",
          "createdAt": "2020-10-01T16:57:53Z",
          "updatedAt": "2020-10-01T16:57:53Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closed in favor of #321.",
          "createdAt": "2020-10-01T17:13:43Z",
          "updatedAt": "2020-10-01T17:13:43Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNDQ5MzEy",
          "commit": {
            "abbreviatedOid": "04e2755"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "> This addresses #295.\r\n\r\nIs the idea with this PR that the server wouldn't send retry keys based on the public name match? The PR is unclear on that but, more importantly, that doesn't seem a good solution. It doesn't cover if you're actually trying to visit the public name. And it closes off more specialized clients being more flexible in the public name in the future.\r\n\r\nInstead, I think all we need is to clarify the client behavior.\r\n1. Retain the current text which says servers send retry keys, GREASE or no. Don't try to detect if it's GREASE vs. key mismatch.\r\n2. Clarify that clients don't process retry keys if they're sending GREASE. That was the intent. I agree the text isn't clear, but we should fix that rather than workaround at the server.",
          "createdAt": "2020-10-01T15:09:17Z",
          "updatedAt": "2020-10-01T15:25:35Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "What's the reason for checking the public name? It seems the server can just ignore it.",
              "createdAt": "2020-10-01T15:09:17Z",
              "updatedAt": "2020-10-01T15:25:35Z"
            },
            {
              "originalPosition": 12,
              "body": "That's not true. We may also just have a key mismatch, which was the original reason all this stuff was added. For instance, maybe the client picked up a very stale key from the DNS, or this server didn't get a new key config despite it being published in the DNS already.",
              "createdAt": "2020-10-01T15:11:19Z",
              "updatedAt": "2020-10-01T15:25:35Z"
            },
            {
              "originalPosition": 11,
              "body": "Seems this new text is redundant with the text right below it. \"If the ClientECH value does not match any known ECHConfig structure, it [...]\".",
              "createdAt": "2020-10-01T15:12:02Z",
              "updatedAt": "2020-10-01T15:25:35Z"
            },
            {
              "originalPosition": 25,
              "body": "\"First\" is plausible in the case below I guess, but if you've got a config_id, there should be just the one match.",
              "createdAt": "2020-10-01T15:12:58Z",
              "updatedAt": "2020-10-01T15:25:35Z"
            },
            {
              "originalPosition": 7,
              "body": "Hrm. Actually this whole bit is kind of odd now, because the inner and outer ClientHellos no longer have the same version list. I think it's something that wasn't updated in the ESNI to ECH change.\r\n\r\nFWIW, I don't think it needed changes for GREASE. A client greasing ECH presumably supports TLS 1.3, and any server that implements this specification would also support TLS 1.3. But it might need some tweaks on account of ECH. It seems the version check should happen after you've chosen to use the inner ClientHello, and ECH wants to get resolved extremely early, before you've actually locked in a version.",
              "createdAt": "2020-10-01T15:21:55Z",
              "updatedAt": "2020-10-01T15:25:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNTA0ODMy",
          "commit": {
            "abbreviatedOid": "04e2755"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T16:08:03Z",
          "updatedAt": "2020-10-01T16:08:03Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "If the outer SNI doesn't match the public name, then the server presumes GREASE and ignores the ECH extension. If it does match, then the server presumes real ECH. ",
              "createdAt": "2020-10-01T16:08:03Z",
              "updatedAt": "2020-10-01T16:08:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNTA5MjAx",
          "commit": {
            "abbreviatedOid": "04e2755"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T16:13:10Z",
          "updatedAt": "2020-10-01T16:13:10Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "What's your proposal? If the we add a rule that says the client MUST NOT (or at least SHOULD NOT) offer GREASE in TLS 1.2 or below, then I'm happy to revert to aborting the handshake here.",
              "createdAt": "2020-10-01T16:13:10Z",
              "updatedAt": "2020-10-01T16:13:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNTEyOTg3",
          "commit": {
            "abbreviatedOid": "04e2755"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T16:17:34Z",
          "updatedAt": "2020-10-01T16:17:34Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I don't think the public key being stale is at issue here. Is your point that the the public_name of the ECH config might be stale? ",
              "createdAt": "2020-10-01T16:17:34Z",
              "updatedAt": "2020-10-01T16:17:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNTEzNjI4",
          "commit": {
            "abbreviatedOid": "04e2755"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T16:18:23Z",
          "updatedAt": "2020-10-01T16:18:23Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "The public name not matching is not the same as the ClientECH not matching a known ECHConfig. In particular, the former does not imply the latter.",
              "createdAt": "2020-10-01T16:18:23Z",
              "updatedAt": "2020-10-01T16:18:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNTE4NTMy",
          "commit": {
            "abbreviatedOid": "04e2755"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T16:24:21Z",
          "updatedAt": "2020-10-01T16:24:21Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I'll upload a PR for this. I don't think either the old or new text is right. (See https://github.com/tlswg/draft-ietf-tls-esni/issues/309#issuecomment-702233855)",
              "createdAt": "2020-10-01T16:24:21Z",
              "updatedAt": "2020-10-01T16:24:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNTIyMTE3",
          "commit": {
            "abbreviatedOid": "04e2755"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T16:28:42Z",
          "updatedAt": "2020-10-01T16:28:43Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "See top-level comment. I don't think that works in general and we can resolve #295 much more simply. (The intent was already for this not to be an issue. I just did a bad job of describing the client behavior.)",
              "createdAt": "2020-10-01T16:28:42Z",
              "updatedAt": "2020-10-01T16:28:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNTIzOTg4",
          "commit": {
            "abbreviatedOid": "04e2755"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T16:30:55Z",
          "updatedAt": "2020-10-01T16:30:56Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "https://github.com/tlswg/draft-ietf-tls-esni/pull/320",
              "createdAt": "2020-10-01T16:30:55Z",
              "updatedAt": "2020-10-01T16:30:56Z"
            }
          ]
        }
      ]
    },
    {
      "number": 320,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk2MzkwOTE2",
      "title": "Fix ECH and version negotiation order.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/320",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The version check on the outer ClientHello doesn't make much sense\r\nsince, when ECH is accepted, the version is based on the inner\r\nClientHello anyway. See\r\nhttps://github.com/tlswg/draft-ietf-tls-esni/issues/309#issuecomment-702233855.\r\n\r\nI've left a TODO since it seems weird to have a client requirement like\r\nthat be so load-bearing without a corresponding server check. Not sure\r\nwhere we should go there.",
      "createdAt": "2020-10-01T16:30:47Z",
      "updatedAt": "2020-10-07T14:32:47Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "e9c1bbd1acd13f1683f34fe0a51752da2c55cb6c",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "versions",
      "headRefOid": "74ac381fc96ff4982b1d4ea74146589fddec2f77",
      "closedAt": "2020-10-07T14:32:47Z",
      "mergedAt": "2020-10-07T14:32:47Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f19f56700c3b8e3a3e7fb2f7d8b04f36585f15d1"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like this change, but it might be worth resolving the TODO.",
          "createdAt": "2020-10-01T22:13:55Z",
          "updatedAt": "2020-10-01T22:13:55Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'm fine with omitting a check on the server. \r\n\r\nRemoved the TODO in favor of some clarifying text on the client side.",
          "createdAt": "2020-10-02T20:55:17Z",
          "updatedAt": "2020-10-02T20:55:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNzQxMTEz",
          "commit": {
            "abbreviatedOid": "b873b9f"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T21:47:05Z",
          "updatedAt": "2020-10-01T21:47:05Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Which ClientHello?",
              "createdAt": "2020-10-01T21:47:05Z",
              "updatedAt": "2020-10-02T20:54:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNzQyNjQ4",
          "commit": {
            "abbreviatedOid": "b873b9f"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T21:50:06Z",
          "updatedAt": "2020-10-01T21:50:06Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "s/can decrypt it/can accept ECH/, since \"accept ECH\" is a well-defined term.",
              "createdAt": "2020-10-01T21:50:06Z",
              "updatedAt": "2020-10-02T20:54:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNzQ1OTMw",
          "commit": {
            "abbreviatedOid": "b873b9f"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T21:56:49Z",
          "updatedAt": "2020-10-01T21:56:49Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Why is this hard in Split Mode? Couldn't we mandate that if the backend server observes the empty ECH extension (sent in the ClientHelloInner in order to signal the backend server to confirm acceptance), it aborts unless it can negotiate 1.3 or higher?",
              "createdAt": "2020-10-01T21:56:49Z",
              "updatedAt": "2020-10-02T20:54:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMDk2MjUy",
          "commit": {
            "abbreviatedOid": "b873b9f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "> I've left a TODO since it seems weird to have a client requirement like that be so load-bearing without a corresponding server check. Not sure where we should go there.\r\n\r\nI'm fine with omitting a check on the server. I don't see much difference between a client implementation choosing to ignore the MUST in generating its ClientHelloInner supported_versions list, and a client implementation not supporting ECH at all. Plus, I could see future extensions or variants of ECH where we allow TLS 1.2 for the backend, and the server's handshake traffic is tunneled between the client and client-facing-server, and a check might make that difficult to do. ",
          "createdAt": "2020-10-02T12:37:13Z",
          "updatedAt": "2020-10-02T12:53:00Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\ndetermines if it will accept ECH, prior to negotiating any other TLS parameters.\r\n```",
              "createdAt": "2020-10-02T12:37:13Z",
              "updatedAt": "2020-10-02T20:54:55Z"
            },
            {
              "originalPosition": 17,
              "body": "Presumably the inner, given below.",
              "createdAt": "2020-10-02T12:44:42Z",
              "updatedAt": "2020-10-02T20:54:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMzk2MDky",
          "commit": {
            "abbreviatedOid": "b873b9f"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T19:31:48Z",
          "updatedAt": "2020-10-02T19:31:49Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Yeah, the backend server doesn't see the outer one.",
              "createdAt": "2020-10-02T19:31:48Z",
              "updatedAt": "2020-10-02T20:54:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMzk2NTg0",
          "commit": {
            "abbreviatedOid": "f130e9d"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T19:32:37Z",
          "updatedAt": "2020-10-02T19:32:38Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "(Resolved by committing @chris-wood's suggestion.)",
              "createdAt": "2020-10-02T19:32:38Z",
              "updatedAt": "2020-10-02T20:54:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzOTQ1OTkz",
          "commit": {
            "abbreviatedOid": "74ac381"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-07T14:32:36Z",
          "updatedAt": "2020-10-07T14:32:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 321,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk2Mzk0NTM5",
      "title": "Clarify client handling of retry keys with GREASE.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/321",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The intent was that the server always sends the retry keys (it cannot\r\ndistinguish stale keys from GREASE when the client is actually trying to\r\nconnect to the public name), while the client just ignores them, but I\r\ndid a poor job of describing this, so add a key sentence.\r\n\r\nThis addresses #295.",
      "createdAt": "2020-10-01T16:37:06Z",
      "updatedAt": "2020-10-01T17:10:22Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "e9c1bbd1acd13f1683f34fe0a51752da2c55cb6c",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "clarify-grease",
      "headRefOid": "01b53b3366e2e52796df186581b2ab6ceddd536f",
      "closedAt": "2020-10-01T17:10:22Z",
      "mergedAt": "2020-10-01T17:10:21Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "32ce20a4a0e256733d03ec56cd8081df1d794012"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(_EDITED._) To recap the discussion on #319, your point is that the client-facing server needn't attempt to distinguish GREASE from non-GREASE based on outer SNI, because if the outer SNI != public name, then the client knows to ignore the retry config and continue as usual. \r\n\r\nI think this is weird because if rejection was the intent, then the client is supposed to abort with \"ech_required\". So the server only knows that non-GREASE was intended once it receives this signal.",
          "createdAt": "2020-10-01T16:45:33Z",
          "updatedAt": "2020-10-01T16:49:33Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I mean, yeah, that's how this was designed and is what we merged to the spec. :-)\r\n\r\nThis formulation, in particular, does not break if the client tries to connect to the public name (it's a perfectly valid URL) without knowing the ECH config (maybe it the HTTPS record didn't get through Do53) but still sends GREASE (because the intent is that every client can GREASE). It seems to me #319 breaks this. Do you have an alternate formulation which keeps this working?\r\n\r\nConnecting to the public name is especially important if the public name is a non-throwaway domain. The only requirement on the public name is that it's some name which knows about and serves the client-facing server's config. (I.e. this particular backend server is the same entity as the client-facing server.) #319 doesn't relax this requirement, since the public name continues to be the entity trusted to replace, and possibly disable, ECH on config mismatch.",
          "createdAt": "2020-10-01T16:57:09Z",
          "updatedAt": "2020-10-01T16:57:09Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think this is weird because if rejection was the intent, then the client is supposed to abort with \"ech_required\". So the server only knows that non-GREASE was intended once it receives this signal.\r\n\r\nI don't see this as an issue. If the client sends GREASE, it doesn't expect to use ECH, so it won't abort. The text here only requires that the client check the extension if present, and ignore it if absent.",
          "createdAt": "2020-10-01T17:06:00Z",
          "updatedAt": "2020-10-01T17:06:00Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't have an alternative formulation. I was evnisioning the public name only being verified on the ECH rejection path, or when neither real nor dummy ECH was offered to the client-facing server.\r\n\r\nI'm fine with rejection not being known until \"ech_required\". I support this PR as the resolution to #295.",
          "createdAt": "2020-10-01T17:06:31Z",
          "updatedAt": "2020-10-01T17:06:31Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 327,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk5NTQ1NDg5",
      "title": "Rewrite \"Resumption PSK Oracle Mitigation\".",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/327",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I think this is a more general attack and deserves a more general description of the mitigation. See https://github.com/tlswg/draft-ietf-tls-esni/pull/317#discussion_r501319277 and #263.\r\n\r\n@chris-wood ",
      "createdAt": "2020-10-07T22:13:35Z",
      "updatedAt": "2020-10-07T23:03:41Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "e3a6b583b47c0907774bdb04d45df881270df17e",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "ch-malleability",
      "headRefOid": "b7533f478742cf91b0002ffbfbbc88633aa9b842",
      "closedAt": "2020-10-07T23:03:41Z",
      "mergedAt": "2020-10-07T23:03:41Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "61b11b92583f170bcd348f3c09bbb927aa56d19c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MzI2MTI4",
          "commit": {
            "abbreviatedOid": "d558a7a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-07T23:02:52Z",
          "updatedAt": "2020-10-07T23:02:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 328,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAwMjk3NjEy",
      "title": "Define error-handling for missing outer extension",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/328",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Looks like this was missing.",
      "createdAt": "2020-10-09T02:04:08Z",
      "updatedAt": "2020-10-11T11:23:12Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "172ab91cc20dc5e3046d946ddad28a951673f2e7",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "missing-outer-extension",
      "headRefOid": "67431a639f1f9d65569db4503c81fd53d53d2bc8",
      "closedAt": "2020-10-11T11:23:12Z",
      "mergedAt": "2020-10-11T11:23:12Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f38a6100acfc1f46f820db2eadfe614bd61afcb3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1OTc0MzQ1",
          "commit": {
            "abbreviatedOid": "67431a6"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-09T20:36:35Z",
          "updatedAt": "2020-10-09T20:36:35Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MTY5NzM1",
          "commit": {
            "abbreviatedOid": "67431a6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-11T11:23:06Z",
          "updatedAt": "2020-10-11T11:23:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 330,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAwMzEwODQ4",
      "title": "Consistently construct ClientHelloInner before ClientHelloOuter.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/330",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #329.",
      "createdAt": "2020-10-09T02:58:34Z",
      "updatedAt": "2020-10-11T11:22:43Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "172ab91cc20dc5e3046d946ddad28a951673f2e7",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "inner-before-outer",
      "headRefOid": "5d8096db40b58804eadf10692f7e3f7357768668",
      "closedAt": "2020-10-11T11:22:43Z",
      "mergedAt": "2020-10-11T11:22:43Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "8eea39d2ea732c534a6344fde12cf504011dced9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1ODExODI5",
          "commit": {
            "abbreviatedOid": "0759a65"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-09T16:09:44Z",
          "updatedAt": "2020-10-09T16:09:45Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "This rule could be made more clear. Suggestion:\r\n> Any extension that appears in the payload of the \"outer_extensions\" extension of the ClientHelloInner MUST appear in the ClientHelloOuter.",
              "createdAt": "2020-10-09T16:09:45Z",
              "updatedAt": "2020-10-09T18:59:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1ODU3MDk1",
          "commit": {
            "abbreviatedOid": "0759a65"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-09T17:16:50Z",
          "updatedAt": "2020-10-09T17:16:50Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "I didn't want to talk about outer_extensions specifically appearing in ClientHelloInner because of #331. The ClientHelloInner doesn't really have outer_extensions, only the payload of the ECH extension. We haven't settled yet on text there, or a processing order of actually encrypting things (I'll need to fiddle with that as part of #323), so for now I figure citing the actual process was the least ambiguous.\r\n\r\nThe distinction is important because of which is actually used in the handshake. (Transcript and whatnot.)",
              "createdAt": "2020-10-09T17:16:50Z",
              "updatedAt": "2020-10-09T18:59:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1ODU4ODQw",
          "commit": {
            "abbreviatedOid": "0759a65"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-09T17:19:33Z",
          "updatedAt": "2020-10-09T17:19:33Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Then I would just leave an \"OPEN ISSUE\" so we know to fix this later. ",
              "createdAt": "2020-10-09T17:19:33Z",
              "updatedAt": "2020-10-09T18:59:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1OTIxMjM2",
          "commit": {
            "abbreviatedOid": "5d8096d"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-09T18:59:41Z",
          "updatedAt": "2020-10-09T18:59:41Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Done.",
              "createdAt": "2020-10-09T18:59:41Z",
              "updatedAt": "2020-10-09T18:59:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1OTc0MTMy",
          "commit": {
            "abbreviatedOid": "5d8096d"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-09T20:36:08Z",
          "updatedAt": "2020-10-09T20:36:08Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MTY5NzAy",
          "commit": {
            "abbreviatedOid": "5d8096d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-11T11:22:38Z",
          "updatedAt": "2020-10-11T11:22:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 332,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAwNjg0NzA5",
      "title": "Note -05 of HPKE for this version of ECH.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/332",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @cjpatton, @davidben ",
      "createdAt": "2020-10-09T16:00:03Z",
      "updatedAt": "2021-04-19T15:51:49Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "172ab91cc20dc5e3046d946ddad28a951673f2e7",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/note-05",
      "headRefOid": "dd583361acb0cc9d0e1097a225f22267d1d109e8",
      "closedAt": "2020-10-09T17:18:14Z",
      "mergedAt": "2020-10-09T17:18:14Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "066dc0a46a4a56adb84169504b4e24b8f77007f6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1ODA1OTE3",
          "commit": {
            "abbreviatedOid": "ea5b749"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-09T16:01:42Z",
          "updatedAt": "2020-10-09T16:01:42Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nECH uses draft-05 of HPKE for public key encryption {{!I-D.irtf-cfrg-hpke}}.\r\n```",
              "createdAt": "2020-10-09T16:01:42Z",
              "updatedAt": "2020-10-09T16:03:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1ODMxMjE1",
          "commit": {
            "abbreviatedOid": "dd58336"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-09T16:37:26Z",
          "updatedAt": "2020-10-09T16:37:26Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1ODU3NTc5",
          "commit": {
            "abbreviatedOid": "dd58336"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-09T17:17:37Z",
          "updatedAt": "2020-10-09T17:17:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 334,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAxMTY3NTM3",
      "title": "Resolve missing outer ClientHello guidance.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/334",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I noticed there's an OPEN ISSUE to add ClientHelloOuter guidance, but there's already a section for it. Link to it and flesh it out a little more.\r\n\r\nSadly, in doing so, I've traded one OPEN ISSUE for another OPEN ISSUE, but hopefully that'll be closed shortly.",
      "createdAt": "2020-10-11T16:40:21Z",
      "updatedAt": "2020-10-14T20:09:54Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f38a6100acfc1f46f820db2eadfe614bd61afcb3",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "outer-ch-guidance",
      "headRefOid": "3ce7475acccb160c1796d18a7dde1ae2a2153779",
      "closedAt": "2020-10-14T20:09:54Z",
      "mergedAt": "2020-10-14T20:09:54Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f9eb1a5b40b3c5770b2350b499623e659286f251"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2OTM2OTY0",
          "commit": {
            "abbreviatedOid": "3ce7475"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-12T21:45:32Z",
          "updatedAt": "2020-10-12T21:45:32Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4NjkwNzkz",
          "commit": {
            "abbreviatedOid": "3ce7475"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-14T20:09:45Z",
          "updatedAt": "2020-10-14T20:09:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 335,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAxMTc0MDA1",
      "title": "Disambiguate the encoded vs actual ClientHelloInner.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/335",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #331. Along the way, I've made two additional tweaks:\r\n\r\n- Renamed outer_extension to outer_extensions, now that it contains multiple extensions. One of the diagrams even already referred to \"outer_extensions\" because I didn't realize it was called \"outer_extension\".\r\n\r\n- Clarified in compression process and ClientHelloInner construction rules that the to-be-compressed extensions must be consecutive. Hopefully that helps with #262.",
      "createdAt": "2020-10-11T17:22:30Z",
      "updatedAt": "2020-10-14T20:07:50Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f38a6100acfc1f46f820db2eadfe614bd61afcb3",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "encoded-inner",
      "headRefOid": "caa2fa30c90f5f0ae7087e2e9076416929672c2d",
      "closedAt": "2020-10-14T20:07:50Z",
      "mergedAt": "2020-10-14T20:07:50Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "44aaa7e051ff27cf20b2adf8dcfd86ce7b3bd73e"
      },
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> Clarified in compression process and ClientHelloInner construction rules that the to-be-compressed extensions must be consecutive. Hopefully that helps with #262.\r\n\r\n@cjpatton FYI. I'm hoping this will help clarify why the ordering thing isn't actually a big deal.",
          "createdAt": "2020-10-11T17:31:33Z",
          "updatedAt": "2020-10-11T17:31:33Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I've updated the PR to include text to disambiguate the serialization.\r\n\r\nIt's ambiguous whether the encoding includes the 4-byte (12-byte in DTLS) header from the Handshake structure or is just the body, from the ClientHello structure. I've picked the smaller one. This also saves having to answer, in DTLS, what happens when the inner sequence number is wrong.",
          "createdAt": "2020-10-11T18:26:17Z",
          "updatedAt": "2020-10-11T18:26:17Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MTk5NzEw",
          "commit": {
            "abbreviatedOid": "d1cca1d"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-11T17:23:01Z",
          "updatedAt": "2020-10-11T17:23:01Z",
          "comments": [
            {
              "originalPosition": 156,
              "body": "Should the TLS 1.3 column be \"\" instead of \"CH\"? It's not *really* a ClientHello extension.",
              "createdAt": "2020-10-11T17:23:01Z",
              "updatedAt": "2020-10-13T01:09:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2OTM5OTYy",
          "commit": {
            "abbreviatedOid": "bcf01d9"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-12T21:52:23Z",
          "updatedAt": "2020-10-12T21:52:24Z",
          "comments": [
            {
              "originalPosition": 156,
              "body": "I think so.",
              "createdAt": "2020-10-12T21:52:23Z",
              "updatedAt": "2020-10-13T01:09:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2OTQzMzE5",
          "commit": {
            "abbreviatedOid": "bcf01d9"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-12T22:00:29Z",
          "updatedAt": "2020-10-12T22:00:30Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "It should be possible to relax this for the existing \"inner_digest\" mechanism. However, I suspect this is will be essential once #336 lands.",
              "createdAt": "2020-10-12T22:00:29Z",
              "updatedAt": "2020-10-13T01:09:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2OTQ0NDA4",
          "commit": {
            "abbreviatedOid": "bcf01d9"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-12T22:03:20Z",
          "updatedAt": "2020-10-12T22:03:20Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2OTY4NzA1",
          "commit": {
            "abbreviatedOid": "bcf01d9"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-12T23:09:19Z",
          "updatedAt": "2020-10-12T23:09:19Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "Hrm, I'm not sure I follow. I was thinking less a security requirement and more a correctness/syntax one. The outer_extensions mechanism, inner digest or AAD, can't express more than one consecutive chunk of elided extensions. That means that when you assemble the ClientHello, you need to adjust the order to fit your intended compression.",
              "createdAt": "2020-10-12T23:09:19Z",
              "updatedAt": "2020-10-13T01:09:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2OTcwOTc0",
          "commit": {
            "abbreviatedOid": "bcf01d9"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-12T23:16:33Z",
          "updatedAt": "2020-10-12T23:16:34Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "My point is that the map from ClientHelloInner to EncodedClientHelloInner need not be invertible. To compute \"inner_digest\", the client just needs to be able to compute the same map from EncodedClientHelloInner to ClientHelloInner that the server does. I don't think it's not necessary that the extensions be consecutive, although it would be much easier to implement this correctly if they were.\r\n\r\nIn any case, I'm happy with this rule.",
              "createdAt": "2020-10-12T23:16:33Z",
              "updatedAt": "2020-10-13T01:09:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2OTg5OTM5",
          "commit": {
            "abbreviatedOid": "bcf01d9"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-13T00:12:39Z",
          "updatedAt": "2020-10-13T00:12:39Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "I'm still a little confused. Just double-checking that the text is clear enough and we're on the same page... (If we're both happy with the text, but because we interpreted it differently, that's not very helpful!)\r\n\r\nI am saying it *is* important that ClientHelloInner to EncodedClientHelloInner is invertible. This is true in the status quo, and it remains true after #336. Handshake correctness requires that the server reconstruct the *exact* same value, byte-for-byte. Even though the extension order isn't very meaningful semantically, it changes what goes in the transcript and binders, so both sides need to agree. So if the client first assembles:\r\n\r\n`ClientHelloInner = (key_share, supported_versions, supported_groups, pre_shared_keys)`\r\n\r\nthen it compresses key_share + supported_groups as:\r\n\r\n`EncodedClientHelloInner = (outer_extensions(key_share, supported_groups), supported_versions, pre_shared_keys)`\r\n\r\nThe server will reconstruct:\r\n\r\n`ClientHelloInner' = (key_share, supported_groups, supported_versions, pre_shared_keys)`\r\n\r\nThese don't match, so the handshake will fail, both at the transcript and at checking the PSK binders. This isn't a security question because we haven't gotten there yet. It's a basic correctness question.\r\n\r\nNow, the thing that went wrong here is that the entire process of swapping extensions out for outer_extensions *only works if the removed extensions are consecutive*. Thus, this PR adds \"Removed extensions MUST be ordered consecutively in ClientHelloInner\" to EncodedClientHelloInner construction. For that precondition to hold, the client must have ordered the extensions it wanted to compress, thus we add a matching rule, this sentence, to ClientHelloInner construction. Now everything works out and the compression process is correct.",
              "createdAt": "2020-10-13T00:12:39Z",
              "updatedAt": "2020-10-13T01:09:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2OTkwNDgx",
          "commit": {
            "abbreviatedOid": "bcf01d9"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-13T00:14:37Z",
          "updatedAt": "2020-10-13T00:14:38Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "Oh, I think I might see the misunderstanding.\r\n\r\n> [...] the client just needs to be able to compute the same map from EncodedClientHelloInner to ClientHelloInner that the server does.\r\n\r\nThis does not work. The client does not compute EncodedClientHelloInner to ClientHelloInner at all. It cannot. By the time we've gotten this far, we've already generated all the PSK binders.",
              "createdAt": "2020-10-13T00:14:37Z",
              "updatedAt": "2020-10-13T01:09:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3MDAxMzc2",
          "commit": {
            "abbreviatedOid": "bcf01d9"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-13T00:55:26Z",
          "updatedAt": "2020-10-13T00:55:27Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "Oof, I forgot about the PSK binders :D Thanks for taking the time to clarify my misunderstanding.",
              "createdAt": "2020-10-13T00:55:26Z",
              "updatedAt": "2020-10-13T01:09:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3MDA1MjE0",
          "commit": {
            "abbreviatedOid": "caa2fa3"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-13T01:09:58Z",
          "updatedAt": "2020-10-13T01:09:58Z",
          "comments": [
            {
              "originalPosition": 156,
              "body": "Switched to \"\"",
              "createdAt": "2020-10-13T01:09:58Z",
              "updatedAt": "2020-10-13T01:09:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4Njg5MDYy",
          "commit": {
            "abbreviatedOid": "caa2fa3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-14T20:07:18Z",
          "updatedAt": "2020-10-14T20:07:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 336,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAxMTg0NjM1",
      "title": "Replace inner_digest with ClientHelloOuterAAD",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/336",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #323. The first commit shaves 33 bytes (or 49 with SHA-384) from the ciphertext by replacing inner_digest with ClientHelloOuterAAD. This also allows for more compact ClientHelloInner encodings when non-extension fields are expected to match. The second commit shaves a further 32 bytes.\r\n\r\nWe could probably further optimize the encoding but I've left it alone here. In particular, if we merge #316, all non-extension fields may as well be implicit. We could then replace the encryption payload with a plain extensions block.",
      "createdAt": "2020-10-11T18:29:21Z",
      "updatedAt": "2020-10-16T18:57:53Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "17ac85d3a0a9c4a0bbb93060df0e360ede4dac3c",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "bind-outer-ch",
      "headRefOid": "5603439bbcc302addbaaac51b63639d71ca844b3",
      "closedAt": "2020-10-16T18:57:53Z",
      "mergedAt": "2020-10-16T18:57:52Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "a643df2dc8921c5e089d5a7e64492aa5f92e7cf1"
      },
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> We could then replace the encryption payload with a plain extensions block.\r\n\r\nI guess that doesn't quite work, but we could replace it with the new random value, and an extensions block. Something like:\r\n\r\n```\r\nstruct {\r\n  Random random;\r\n  Extension extensions<8..2^16-1>;\r\n} EncodedClientHelloInner;\r\n```\r\n\r\nAnyway, a topic for a later PR, depending on how strongly we want to match cipher suites for #316. The size savings are a bit more marginal beyond that.",
          "createdAt": "2020-10-12T20:55:36Z",
          "updatedAt": "2020-10-12T20:55:36Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like this change a lot. At some point while implementing ECH, I noted that it would be nice to have an explicit binding of CHOuter to the handshake in case of ECH acceptance. This provides that.",
          "createdAt": "2020-10-12T22:24:13Z",
          "updatedAt": "2020-10-12T22:24:13Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased and review comments addressed. The PR should also no longer be in a confusing state if you look at the diff.",
          "createdAt": "2020-10-14T20:36:32Z",
          "updatedAt": "2020-10-14T20:36:32Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2OTQ2MTAx",
          "commit": {
            "abbreviatedOid": "2bc7c8f"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-12T22:07:44Z",
          "updatedAt": "2020-10-12T22:07:44Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "s/to the encryption/for AEAD encryption.",
              "createdAt": "2020-10-12T22:07:44Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2OTQ4MTc2",
          "commit": {
            "abbreviatedOid": "2bc7c8f"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-12T22:12:48Z",
          "updatedAt": "2020-10-12T22:12:49Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "`ClientHelloOuterAAD` is a bit different than we discussed in #323. In particular, I thought it was decided that we should predict the length of the \"encrypted_client_hello\" extension and authenticate as many zeros. What changed your mind? For the record, the approach is here seems a lot simpler to me :)",
              "createdAt": "2020-10-12T22:12:48Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2OTQ4NTgx",
          "commit": {
            "abbreviatedOid": "2bc7c8f"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-12T22:13:53Z",
          "updatedAt": "2020-10-12T22:13:53Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "Suggestion: s/Outer ClientHello/ClientHelloOuter.",
              "createdAt": "2020-10-12T22:13:53Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2OTQ5MTAz",
          "commit": {
            "abbreviatedOid": "12842c1"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-12T22:15:09Z",
          "updatedAt": "2020-10-12T22:15:10Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Suggestion: s/Inner ClientHello/ClientHelloInner.",
              "createdAt": "2020-10-12T22:15:09Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2OTQ5NjMx",
          "commit": {
            "abbreviatedOid": "12842c1"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-12T22:16:33Z",
          "updatedAt": "2020-10-12T22:16:34Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Does this mean to send a 0-length `legacy_session_id`, or does this mean to send a `legacy_session_id` with the same length, but with all zeros? Presumably you mean the former?",
              "createdAt": "2020-10-12T22:16:33Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2OTY5NTIz",
          "commit": {
            "abbreviatedOid": "12842c1"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-12T23:11:46Z",
          "updatedAt": "2020-10-12T23:11:47Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "Oh I probably was just unclear in that discussion. I never preferred the zeros formulation. :-) That was more me musing on how annoying it would be if there were another reason to prefer it. I like this better because, as you say, it's simpler.",
              "createdAt": "2020-10-12T23:11:47Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3NjEwOTM0",
          "commit": {
            "abbreviatedOid": "12842c1"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-13T16:17:12Z",
          "updatedAt": "2020-10-13T16:17:13Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "(Will deal with uploading a new revision after base PRs go through, since Github makes a mess of these.)\r\n\r\nWorks for me, though it's unclear to me how much we like sticking identifiers in section titles, which is why I used the words instead. E.g. RFC8446's section titles say things like \"Supported Versions\" and this document had \"Incorporating Outer Extensions\" rather than \"outer_extensions\". Although, admittedly, \"ClientHello\" is itself an identifier, but I figured it was a more established one (elsewhere we have \"Sending an encrypted ClientHello\").\r\n\r\n\u00af\\\\\\_(\u30c4)_/\u00af",
              "createdAt": "2020-10-13T16:17:13Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3NjExOTAw",
          "commit": {
            "abbreviatedOid": "12842c1"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-13T16:18:17Z",
          "updatedAt": "2020-10-13T16:18:17Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "Oh, and we have \"Outer ClientHello\" as a section title down in Security Considerations, though I suppose that too is my fault. :-)",
              "createdAt": "2020-10-13T16:18:17Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4NjkxOTc4",
          "commit": {
            "abbreviatedOid": "12842c1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-14T20:11:28Z",
          "updatedAt": "2020-10-14T20:11:29Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n## Encoding ClientHelloInner {#encoding-inner-clienthello}\r\n```",
              "createdAt": "2020-10-14T20:11:29Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4NjkyNTM4",
          "commit": {
            "abbreviatedOid": "12842c1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-14T20:12:15Z",
          "updatedAt": "2020-10-14T20:12:15Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "```suggestion\r\n## Authenticating ClientHelloOuter {#authenticating-outer-clienthello}\r\n```",
              "createdAt": "2020-10-14T20:12:15Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4NzA3NjMy",
          "commit": {
            "abbreviatedOid": "cd11d51"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-14T20:34:38Z",
          "updatedAt": "2020-10-14T20:34:39Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "Done. Though I used HPKE encryption since it looks like the rest of the document mostly refers to HPKE rather than the internal AEAD.",
              "createdAt": "2020-10-14T20:34:39Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4NzA3ODQ2",
          "commit": {
            "abbreviatedOid": "cd11d51"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-14T20:34:57Z",
          "updatedAt": "2020-10-14T20:34:57Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "Done.",
              "createdAt": "2020-10-14T20:34:57Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4NzA3OTE5",
          "commit": {
            "abbreviatedOid": "cd11d51"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-14T20:35:03Z",
          "updatedAt": "2020-10-14T20:35:03Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Done.",
              "createdAt": "2020-10-14T20:35:03Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4NzA4MDg3",
          "commit": {
            "abbreviatedOid": "cd11d51"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-14T20:35:18Z",
          "updatedAt": "2020-10-14T20:35:19Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Reworded to be clearer.",
              "createdAt": "2020-10-14T20:35:19Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4NzA4NDcw",
          "commit": {
            "abbreviatedOid": "cd11d51"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-14T20:35:51Z",
          "updatedAt": "2020-10-14T20:35:52Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Applied manually since I needed to rebase.",
              "createdAt": "2020-10-14T20:35:51Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4NzA4NTU3",
          "commit": {
            "abbreviatedOid": "cd11d51"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-14T20:35:58Z",
          "updatedAt": "2020-10-14T20:35:59Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "Applied manually since I needed to rebase.",
              "createdAt": "2020-10-14T20:35:58Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4ODA5OTE3",
          "commit": {
            "abbreviatedOid": "cd11d51"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-14T22:19:37Z",
          "updatedAt": "2020-10-14T22:19:37Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNTg0NjQ2",
          "commit": {
            "abbreviatedOid": "bd3f76b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-16T15:36:50Z",
          "updatedAt": "2020-10-16T17:05:32Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "What is an empty value?",
              "createdAt": "2020-10-16T15:36:51Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            },
            {
              "originalPosition": 81,
              "body": "```suggestion\r\nderiving a ClientHelloOuterAAD value. This is computed by serializing ClientHelloOuter\r\nwith the \"encrypted_client_hello\" extension removed.\r\n```",
              "createdAt": "2020-10-16T15:39:47Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            },
            {
              "originalPosition": 42,
              "body": "```suggestion\r\nfirst making a copy of ClientHelloInner. It then replaces the legacy\\_session\\_id\r\n```",
              "createdAt": "2020-10-16T15:40:58Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            },
            {
              "originalPosition": 134,
              "body": "```suggestion\r\nforbidden in ClientHelloOuter.\r\n```",
              "createdAt": "2020-10-16T17:04:42Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjcwMjQ2",
          "commit": {
            "abbreviatedOid": "bd3f76b"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T17:32:06Z",
          "updatedAt": "2020-10-16T17:32:06Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "The empty string. I previously wrote \"clears the value\", but @cjpatton objected to that one. :-P How about s/empty value/empty string/? We haven't introduced a new encoded structure yet (https://github.com/tlswg/draft-ietf-tls-esni/pull/336#issuecomment-707341408), so we need to put *something* in there.",
              "createdAt": "2020-10-16T17:32:06Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjcyMTQ3",
          "commit": {
            "abbreviatedOid": "c286376"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T17:34:03Z",
          "updatedAt": "2020-10-16T17:34:03Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "So a zero-length string, as opposed to a 32 byte string of zeroes? (Whatever makes that more clear is fine by me.)",
              "createdAt": "2020-10-16T17:34:03Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjc2MzEw",
          "commit": {
            "abbreviatedOid": "c286376"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T17:38:15Z",
          "updatedAt": "2020-10-16T17:38:15Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "I mean the point is to encode fewer bytes, so yeah. I feel like, given the field is defined by `opaque legacy_session_id<0..32>`, it would be unreasonable to interpret \"empty value\" or \"empty string\" as a 32-byte string of zeros. :-P\r\n\r\nI dunno, I think all the options so far have been pretty clear, so I'm not the best judge here. The intent is to stick the zero-length string in there. Which one do you prefer?\r\n* clears the legacy_session_id field\r\n* replaces the legacy_session_id field with an empty value\r\n* replaces the legacy_session_id field with a zero-length value\r\n* replaces the legacy_session_id field with an empty string\r\n* replaces the legacy_session_id field with a zero-length string",
              "createdAt": "2020-10-16T17:38:15Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjgxNTEx",
          "commit": {
            "abbreviatedOid": "c286376"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T17:45:22Z",
          "updatedAt": "2020-10-16T17:45:23Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "+1 \"replaces the legacy_session_id field with an empty string\"",
              "createdAt": "2020-10-16T17:45:23Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjgyMTkw",
          "commit": {
            "abbreviatedOid": "c286376"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T17:46:25Z",
          "updatedAt": "2020-10-16T17:46:26Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "nit: Adjust margins in this paragraph so each line breaks at 80 characters.",
              "createdAt": "2020-10-16T17:46:26Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjg0MjQz",
          "commit": {
            "abbreviatedOid": "c286376"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T17:49:34Z",
          "updatedAt": "2020-10-16T17:49:34Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Okay, empty string it is. I don't care, just pick one. :-)",
              "createdAt": "2020-10-16T17:49:34Z",
              "updatedAt": "2020-10-16T17:50:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjg0NjE0",
          "commit": {
            "abbreviatedOid": "5603439"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T17:50:10Z",
          "updatedAt": "2020-10-16T17:50:10Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Done.",
              "createdAt": "2020-10-16T17:50:10Z",
              "updatedAt": "2020-10-16T17:50:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjg0Njk0",
          "commit": {
            "abbreviatedOid": "5603439"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T17:50:17Z",
          "updatedAt": "2020-10-16T17:50:18Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Done.",
              "createdAt": "2020-10-16T17:50:18Z",
              "updatedAt": "2020-10-16T17:50:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjg5MDMx",
          "commit": {
            "abbreviatedOid": "5603439"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-16T17:56:37Z",
          "updatedAt": "2020-10-16T17:56:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 337,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAyNTQ3ODMw",
      "title": "Tweak section titles and comparison against criteria.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/337",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We use a mix of sentence case and title case in the document. The RFC style guide says to use title case. This PR aligns with that.\r\nhttps://tools.ietf.org/html/rfc7322#section-3.4\r\n\r\nAdditionally, the ESNI criteria document has changed slightly since the comparison against criteria section was written. I've aligned the titles with the final wording in RFC8744. RFC8744 has also merged \"Proper security context\" and \"Split server spoofing\", so I've done the same here. \"Support Multiple Protocols\" also now talks about transport protocols and ALPN, so I've added a few words about that.",
      "createdAt": "2020-10-13T16:34:02Z",
      "updatedAt": "2020-10-14T20:04:56Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "b58478b19d3ba85f6a386fdd7b8fea11e08ee4c2",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "section-titles",
      "headRefOid": "332b51f45bce91a8d5ca8078badeb543664354ee",
      "closedAt": "2020-10-14T20:04:56Z",
      "mergedAt": "2020-10-14T20:04:56Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "63e32c26407276842bb160633775993f8951f3d5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3ODQyMjcz",
          "commit": {
            "abbreviatedOid": "4cfe40c"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-13T21:28:41Z",
          "updatedAt": "2020-10-13T21:28:42Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "s/party/Party/ ?",
              "createdAt": "2020-10-13T21:28:42Z",
              "updatedAt": "2020-10-14T20:04:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3ODQ0OTUx",
          "commit": {
            "abbreviatedOid": "4cfe40c"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-13T21:33:20Z",
          "updatedAt": "2020-10-13T21:33:20Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "Yeah, I thought that too, but RFC8744 does it this way.\r\nhttps://www.rfc-editor.org/rfc/rfc8744.html#name-enable-multi-party-security\r\n\r\n\u00af\\\\\\_(\u30c4)_/\u00af",
              "createdAt": "2020-10-13T21:33:20Z",
              "updatedAt": "2020-10-14T20:04:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4Njg2OTg2",
          "commit": {
            "abbreviatedOid": "4cfe40c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-14T20:04:13Z",
          "updatedAt": "2020-10-14T20:04:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 338,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAyODMxNjY1",
      "title": "Add an OPEN ISSUE for stateless HRR and split mode.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/338",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Issue #333.",
      "createdAt": "2020-10-13T20:56:12Z",
      "updatedAt": "2020-10-14T20:03:31Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f38a6100acfc1f46f820db2eadfe614bd61afcb3",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "stateless-hrr-open-issue",
      "headRefOid": "4c4db5a95ad794ac23dc7dc99e31d0f4b16b258f",
      "closedAt": "2020-10-14T20:03:31Z",
      "mergedAt": "2020-10-14T20:03:31Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "b58478b19d3ba85f6a386fdd7b8fea11e08ee4c2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3ODM2NDc0",
          "commit": {
            "abbreviatedOid": "4c4db5a"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-13T21:18:58Z",
          "updatedAt": "2020-10-13T21:18:58Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4Njg2NDAz",
          "commit": {
            "abbreviatedOid": "4c4db5a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-14T20:03:24Z",
          "updatedAt": "2020-10-14T20:03:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 339,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAzNzA4MTI5",
      "title": "Clarify client-facing server HRR behavior",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/339",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #325.",
      "createdAt": "2020-10-14T23:22:28Z",
      "updatedAt": "2021-04-16T19:56:32Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f9eb1a5b40b3c5770b2350b499623e659286f251",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "more-hrr-behavior",
      "headRefOid": "418065c62ea780260f98d3296010f9f94b785b5a",
      "closedAt": "2020-10-16T15:29:12Z",
      "mergedAt": "2020-10-16T15:29:11Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "a5bbe40119ebab9a12718811ba0c8120f22adc26"
      },
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "A related PR that we probably should make sure flow together: https://github.com/tlswg/draft-ietf-tls-esni/pull/341",
          "createdAt": "2020-10-15T19:19:23Z",
          "updatedAt": "2020-10-15T19:19:23Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5NjA0NzY1",
          "commit": {
            "abbreviatedOid": "5886956"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T17:21:11Z",
          "updatedAt": "2020-10-15T17:31:47Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I found this a little hard to interpret. It suggests equality of the ClientHellos themselves, which isn't what we want. It's also a little odd since CH1' and CH2' are functions of both what the client sent and what the server chose to do what in response. But it would be less enforcing an invariant on the latter and more maintaining it. WDYT about:\r\n\r\n> In case a HelloRetryRequest (HRR) is sent, the client-facing server MUST consistently accept or decline ECH between the two ClientHellos, using the same ECHConfig, and fail the handshake if this is not possible. This is achieved as follows.",
              "createdAt": "2020-10-15T17:21:11Z",
              "updatedAt": "2020-10-15T22:52:09Z"
            },
            {
              "originalPosition": 36,
              "body": "Nit: I don't think we need to add well-formed ClientECH structure to the precondition. The client-facing server is should already fail the connection with a decode_error if the extension doesn't parse.",
              "createdAt": "2020-10-15T17:22:24Z",
              "updatedAt": "2020-10-15T22:52:09Z"
            },
            {
              "originalPosition": 38,
              "body": "Does the server need to check the config identifier if it declines ECH, or just if it accepts ECH? What happens if the client and server use the trial decryption mode, where the config ID is empty and you only determine the config by using it? Perhaps this should be phrased in terms of the ECHConfig used. WDYT about:\r\n\r\n> If the client-facing server accepts ECH in response to CH1, it MUST check that the ClientECH.config_id parameter is the same between CH1 and CH2. If they differ, the server MUST abort the connection with an \"illegal_parameter\" alert. It then MUST decrypt the extension using the previously-selected ECHConfig and, if decryption fails, abort the connection with a \"decrypt_error\" alert. Note that, if the connection used the trial decryption mode with an empty ClientECH.config_id value, the server does not continue to try other configurations on decryption error.\r\n\r\nThough this means, if the server believes in trial decryption, you need to remember *both* the ECHConfig *and* whether to expect an empty or matching config_id value.\r\n\r\n(As an aside, this admits another GREASE-distinguishing active attack, and one I don't see any way of avoiding. But it only applies to connections that would naturally trip HRR.)",
              "createdAt": "2020-10-15T17:31:28Z",
              "updatedAt": "2020-10-15T22:52:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5NzAyMTU4",
          "commit": {
            "abbreviatedOid": "5886956"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T19:30:24Z",
          "updatedAt": "2020-10-15T19:30:25Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I like it. Replacing my paragraph with yours. (Changed \"fail the handshake\" to \"abort the handshake\".)",
              "createdAt": "2020-10-15T19:30:25Z",
              "updatedAt": "2020-10-15T22:52:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5NzA1MzI5",
          "commit": {
            "abbreviatedOid": "5886956"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T19:34:48Z",
          "updatedAt": "2020-10-15T19:34:48Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "A semi-related change that might make it easier to phrase this paragraph: https://github.com/davidben/draft-ietf-tls-esni/commit/f9b3aaf56b9c759c3ba3ab3dee4f99da34b2e460",
              "createdAt": "2020-10-15T19:34:48Z",
              "updatedAt": "2020-10-15T22:52:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5NzE4MzY0",
          "commit": {
            "abbreviatedOid": "5886956"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T19:47:57Z",
          "updatedAt": "2020-10-15T19:47:57Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "> Does the server need to check the config identifier if it declines ECH, or just if it accepts ECH?\r\n\r\nIt needs to check the config in both cases.\r\n\r\n> What happens if the client and server use the trial decryption mode, where the config ID is empty and you only determine the config by using it?\r\n\r\nI hadn't considered this case. \r\n\r\n> A semi-related change that might make it easier to phrase this paragraph: https://github.com/davidben/draft-ietf-tls-esni/commit/f9b3aaf56b9c759c3ba3ab3dee4f99da34b2e460\r\n\r\nI think this will help. Let's land that PR and then come back to this.\r\n",
              "createdAt": "2020-10-15T19:47:57Z",
              "updatedAt": "2020-10-15T22:52:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNTc4MDc5",
          "commit": {
            "abbreviatedOid": "418065c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-16T15:28:51Z",
          "updatedAt": "2020-10-16T15:28:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 340,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA0MjkwMjQ5",
      "title": "Remove remnant of ECH PSKs and non-ECH PSKs.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/340",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This clause is a remnant of when we tried to partition the resumption space across ECH negotiation, which was simplified in #317.",
      "createdAt": "2020-10-15T18:16:38Z",
      "updatedAt": "2020-10-15T18:48:39Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f9eb1a5b40b3c5770b2350b499623e659286f251",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "psk-remnant",
      "headRefOid": "44a79be65b12a8ed2555dc93b7d6650b4ad11c08",
      "closedAt": "2020-10-15T18:48:39Z",
      "mergedAt": "2020-10-15T18:48:39Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "01674f4ac07fd532fd90634701d36db042235875"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5NjczMDE2",
          "commit": {
            "abbreviatedOid": "44a79be"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-15T18:48:34Z",
          "updatedAt": "2020-10-15T18:48:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 341,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA0MzIxNzMw",
      "title": "Fix up description of server message forwarding.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/341",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This fixes a few issues with the  \"Upon determining the true SNI\"\r\nparagraph:\r\n\r\n- It talkes about determining the \"true SNI\", but we should probably\r\n  talk about the ClientHelloInner more generally.\r\n\r\n- It refers to behavior in \"the following section\" which no longer\r\n  matches. This is a remnant of before Shared Mode was described as a\r\n  special case of Split Mode, so remove it.\r\n\r\n- It says the server forwards messages unmodified, which isn't true. It\r\n  needs to forward the decrypted ClientHello. It also needs to process\r\n  HRR.\r\n\r\nI've cited the HRR section for the modified decryption procedure, which\r\ndoesn't really exist right now, but #339 is handling that.",
      "createdAt": "2020-10-15T19:17:49Z",
      "updatedAt": "2020-10-15T23:27:52Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "01674f4ac07fd532fd90634701d36db042235875",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "fix-forwarding",
      "headRefOid": "0f0e11b69c9ec3c16cd5c682a3d010845d2085e0",
      "closedAt": "2020-10-15T23:27:52Z",
      "mergedAt": "2020-10-15T23:27:52Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "17ac85d3a0a9c4a0bbb93060df0e360ede4dac3c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5NzI0NjMx",
          "commit": {
            "abbreviatedOid": "0f0e11b"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Yup, this aligns with my understanding!",
          "createdAt": "2020-10-15T19:51:28Z",
          "updatedAt": "2020-10-15T19:51:28Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODc2Mjcz",
          "commit": {
            "abbreviatedOid": "0f0e11b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-15T23:27:43Z",
          "updatedAt": "2020-10-15T23:27:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 343,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA0OTg2OTU5",
      "title": "Pick from an unassigned range.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/343",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #322.\r\n\r\ncc @davidben, @cjpatton ",
      "createdAt": "2020-10-16T17:13:54Z",
      "updatedAt": "2021-04-19T15:51:50Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "a5bbe40119ebab9a12718811ba0c8120f22adc26",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/codepoints",
      "headRefOid": "82e4c85d37e836fa82e7aaa09034694e4a586116",
      "closedAt": "2020-10-16T18:57:12Z",
      "mergedAt": "2020-10-16T18:57:12Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ce2cd200d039d782e60cf21e078521b273721631"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> What will be our policy if we need to add additional extension points, e.g., to address #264? Do we start incrementing from 0xfe00?\r\n\r\nYeah, that's what I figured. I doubt we'll need more than 8, but we can pick a different range if that works?",
          "createdAt": "2020-10-16T17:24:10Z",
          "updatedAt": "2020-10-16T17:24:10Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, this works for me. I don't see any reason why we should keep the code points dense.",
          "createdAt": "2020-10-16T17:27:16Z",
          "updatedAt": "2020-10-16T17:27:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjYxNDQ1",
          "commit": {
            "abbreviatedOid": "69239a2"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "What will be our policy if we need to add additional extension points, e.g., to address #264? Do we start incrementing from `0xfe00`?",
          "createdAt": "2020-10-16T17:19:23Z",
          "updatedAt": "2020-10-16T17:19:23Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjY5NDY5",
          "commit": {
            "abbreviatedOid": "82e4c85"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-16T17:31:10Z",
          "updatedAt": "2020-10-16T17:31:10Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjg2MzI0",
          "commit": {
            "abbreviatedOid": "82e4c85"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Sure, those work. I usually `random.randint(0, 0xffff)` to avoid thinking about it, but whatever. :-)",
          "createdAt": "2020-10-16T17:52:42Z",
          "updatedAt": "2020-10-16T17:52:42Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjg2NDc3",
          "commit": {
            "abbreviatedOid": "82e4c85"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-16T17:52:55Z",
          "updatedAt": "2020-10-16T17:52:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 344,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA1MDQ0NDQ5",
      "title": "Trial decryption and ECHConfig binding fixes",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/344",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The spec describes an optional trial decryption mode, but most of the text contradicts it. This PR fixes the text up and tries to unify their processing models. In doing so, it flips the error handling from decrypt_error to fallback to be consistent. This, combined with the ClientHelloOuterAAD change, plugs an active sticking out attack for free. It also makes #342 easier because GREASE config_id collisions with real config_ids are now harmless.\r\n\r\nAlong the way, @chris-wood and @cjpatton observed that we're not authenticating the ECHConfig at all. (It used to be authenticated by way of the config_id, which was a digest.) Instead, just pass the ECHConfig into the info field of the HPKE context. They also noticed the server rule about PSKs on ClientHelloOuter didn't work with GREASE. Instead, we can simply remove it.",
      "createdAt": "2020-10-16T19:08:03Z",
      "updatedAt": "2020-10-16T21:39:03Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "eab2c685c1065dc6fd2b3ced5d3034f0615709f6",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "unify-trial-decrypt",
      "headRefOid": "58fa6832d95ab49505d0e65beb06530bfd385a37",
      "closedAt": "2020-10-16T21:39:03Z",
      "mergedAt": "2020-10-16T21:39:03Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "2360040a6fdc182427d740f8a8971a255226020c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNzM5MjYz",
          "commit": {
            "abbreviatedOid": "068c268"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "This is pretty close!",
          "createdAt": "2020-10-16T19:17:17Z",
          "updatedAt": "2020-10-16T19:36:12Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "I wonder if `\\0` is the right way to right the null byte. (RFC8446 doesn't encode 0x00 in a string at all: see [RFC8446, 4.4.3](https://tools.ietf.org/html/rfc8446#section-4.4.3).) I'm fine with it as-is, since I think it's pretty clear what you mean ... I just wanted flag it in case there's a \"correct\" way to write this.",
              "createdAt": "2020-10-16T19:17:18Z",
              "updatedAt": "2020-10-16T21:29:45Z"
            },
            {
              "originalPosition": 48,
              "body": "Let's drop \"randomly generated\"? I think this would be OK, given how client-facing server behavior is specified. But I don' think we want to put this idea in people's head as a viable option. (Yet.)",
              "createdAt": "2020-10-16T19:21:24Z",
              "updatedAt": "2020-10-16T21:29:45Z"
            },
            {
              "originalPosition": 50,
              "body": "Suggest changing \"MUST NOT use this mode\" to \"MUST compute config_id as specified in {{whatever-section-describes-ClientECH}}\".",
              "createdAt": "2020-10-16T19:22:01Z",
              "updatedAt": "2020-10-16T21:29:45Z"
            },
            {
              "originalPosition": 143,
              "body": "s/determined in/determined by/",
              "createdAt": "2020-10-16T19:25:51Z",
              "updatedAt": "2020-10-16T21:29:45Z"
            },
            {
              "originalPosition": 230,
              "body": "This works for me. However, to align with the new text above, if decryption fails here then the server should ignore ECH and continue with ClientHelloOuter.",
              "createdAt": "2020-10-16T19:35:28Z",
              "updatedAt": "2020-10-16T21:29:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODA0MTE1",
          "commit": {
            "abbreviatedOid": "5f592d6"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T21:18:50Z",
          "updatedAt": "2020-10-16T21:18:50Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Tweaked the syntax a bit. I've also kept the prose at the bottom that clarifies it.",
              "createdAt": "2020-10-16T21:18:50Z",
              "updatedAt": "2020-10-16T21:29:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODA0MjE0",
          "commit": {
            "abbreviatedOid": "5f592d6"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T21:19:04Z",
          "updatedAt": "2020-10-16T21:19:04Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Oh? {{optional-configs}} has explicitly said it can be random for a while now. (GREASE prescribes a random one too.)",
              "createdAt": "2020-10-16T21:19:04Z",
              "updatedAt": "2020-10-16T21:29:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODA0MjUy",
          "commit": {
            "abbreviatedOid": "5f592d6"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T21:19:08Z",
          "updatedAt": "2020-10-16T21:19:08Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Done.",
              "createdAt": "2020-10-16T21:19:08Z",
              "updatedAt": "2020-10-16T21:29:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODA0MzA2",
          "commit": {
            "abbreviatedOid": "5f592d6"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T21:19:14Z",
          "updatedAt": "2020-10-16T21:19:15Z",
          "comments": [
            {
              "originalPosition": 143,
              "body": "Done.",
              "createdAt": "2020-10-16T21:19:15Z",
              "updatedAt": "2020-10-16T21:29:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODA0Nzc1",
          "commit": {
            "abbreviatedOid": "5f592d6"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T21:20:16Z",
          "updatedAt": "2020-10-16T21:20:17Z",
          "comments": [
            {
              "originalPosition": 230,
              "body": "I think this one needs to be a decrypt_error (which is why there's text here, to cancel the new text above). This is the second ClientHello, so the server can't switch to the outer one. Otherwise we break the invariant you set up. :-)",
              "createdAt": "2020-10-16T21:20:16Z",
              "updatedAt": "2020-10-16T21:29:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODA0OTA0",
          "commit": {
            "abbreviatedOid": "5f592d6"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T21:20:33Z",
          "updatedAt": "2020-10-16T21:20:33Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "You're right! My bad. No action needed here.",
              "createdAt": "2020-10-16T21:20:33Z",
              "updatedAt": "2020-10-16T21:29:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODA2NDAz",
          "commit": {
            "abbreviatedOid": "5f592d6"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T21:23:49Z",
          "updatedAt": "2020-10-16T21:23:49Z",
          "comments": [
            {
              "originalPosition": 239,
              "body": "s/ClientHelloOuter/ClientHelloInner/?",
              "createdAt": "2020-10-16T21:23:49Z",
              "updatedAt": "2020-10-16T21:29:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODA2NDE2",
          "commit": {
            "abbreviatedOid": "5f592d6"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T21:23:50Z",
          "updatedAt": "2020-10-16T21:23:51Z",
          "comments": [
            {
              "originalPosition": 230,
              "body": "Right again! ",
              "createdAt": "2020-10-16T21:23:50Z",
              "updatedAt": "2020-10-16T21:29:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODA2NTg1",
          "commit": {
            "abbreviatedOid": "5f592d6"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "One last thing to check.",
          "createdAt": "2020-10-16T21:24:13Z",
          "updatedAt": "2020-10-16T21:24:13Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODA3OTY3",
          "commit": {
            "abbreviatedOid": "5f592d6"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T21:27:22Z",
          "updatedAt": "2020-10-16T21:27:23Z",
          "comments": [
            {
              "originalPosition": 239,
              "body": "Hah! I meant to write \"decrypt the second ClientHelloOuter [into the second ClientHelloInner]\", but I guess you more naturally read it as \"decrypt the second ClientHelloInner [from the second ClientHelloOuter]\". Which means I should probably find a different wording all together. Will wordsmith.",
              "createdAt": "2020-10-16T21:27:22Z",
              "updatedAt": "2020-10-16T21:29:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODA5MDI5",
          "commit": {
            "abbreviatedOid": "58fa683"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T21:29:51Z",
          "updatedAt": "2020-10-16T21:29:51Z",
          "comments": [
            {
              "originalPosition": 239,
              "body": "How's this new version?",
              "createdAt": "2020-10-16T21:29:51Z",
              "updatedAt": "2020-10-16T21:29:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODA5ODM4",
          "commit": {
            "abbreviatedOid": "58fa683"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T21:31:48Z",
          "updatedAt": "2020-10-16T21:31:48Z",
          "comments": [
            {
              "originalPosition": 239,
              "body": "LGTM!",
              "createdAt": "2020-10-16T21:31:48Z",
              "updatedAt": "2020-10-16T21:31:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODExMDU3",
          "commit": {
            "abbreviatedOid": "58fa683"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-16T21:34:38Z",
          "updatedAt": "2020-10-16T21:34:38Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODEyNzkw",
          "commit": {
            "abbreviatedOid": "58fa683"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-16T21:38:58Z",
          "updatedAt": "2020-10-16T21:38:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 345,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA1MDQ5NjQ3",
      "title": "Only extract 8 bytes for the config_id",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/345",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This doesn't bind anything, so no sense wasting bytes. Closes #342.\r\n\r\n(Note: this is orthogonal to #344, but it makes more sense with that PR.)",
      "createdAt": "2020-10-16T19:17:49Z",
      "updatedAt": "2020-11-03T20:52:43Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "6e359b6dcf7e20511cf28052005151fc804037d2",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "truncate-config-id",
      "headRefOid": "0f181404a0769b8b1e24545343bc926b90d19bdd",
      "closedAt": "2020-11-03T20:52:43Z",
      "mergedAt": "2020-11-03T20:52:42Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "7f7b61e4a7c5e1e403212e0c798de472c8b47e2a"
      },
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I guess this makes the text in #344 a little odd because \"Compare ClientECH.config_id against identifiers of known ECHConfigs and select *the* one that matches, if any, as a candidate.\", is a little less clear. If we want to do this, it maybe should say \"and select any that match\", even though there'll really just be one match.",
          "createdAt": "2020-10-16T19:24:24Z",
          "updatedAt": "2020-10-16T19:24:24Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "(Rebased and made the text talk about multiple potential matches.)",
          "createdAt": "2020-11-02T17:33:36Z",
          "updatedAt": "2020-11-02T17:33:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODU1MTM3",
          "commit": {
            "abbreviatedOid": "0f18140"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I agree this is fine.",
          "createdAt": "2020-11-03T20:35:31Z",
          "updatedAt": "2020-11-03T20:35:31Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODY1MzY2",
          "commit": {
            "abbreviatedOid": "0f18140"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-03T20:52:36Z",
          "updatedAt": "2020-11-03T20:52:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 346,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA2MjQ1MzQ4",
      "title": "Fix some editorial issues",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/346",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "A few editorial things that we missed before -08.",
      "createdAt": "2020-10-19T20:05:11Z",
      "updatedAt": "2021-04-16T19:56:33Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "2360040a6fdc182427d740f8a8971a255226020c",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "editorial",
      "headRefOid": "c310e9677e48917034e5cedea5f46c06eaf9084a",
      "closedAt": "2020-10-20T22:15:07Z",
      "mergedAt": "2020-10-20T22:15:07Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "88c61a613c90090d402d8360491f95627d3a4031"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMTkxMzgx",
          "commit": {
            "abbreviatedOid": "0549ac5"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T22:01:45Z",
          "updatedAt": "2020-10-19T22:09:45Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Between #330 and #335, I spent a bit of time trying to make sure the order here was consistent throughout the document. I don't particularly care what the order is, just that it's consistent. If we change it, we'll need to adjust several things in tandem:\r\n\r\n* Line 462 (\"If it compressed any extensions in [...]\") is written assuming the other order. That'll want to read more like \"If it intends to compress any extensions [...]\" from line 455. \r\n\r\n* {{encoding-inner}} itself also needs to change. \"When sending ClientHello, the client first [...] It then computes a new value, the EncodedClientHelloInner, by [...]\" and \"The client then MAY substitute extensions which it knows will be duplicated in ClientHelloOuter\".",
              "createdAt": "2020-10-19T22:01:46Z",
              "updatedAt": "2020-10-20T22:14:39Z"
            },
            {
              "originalPosition": 48,
              "body": "\"at least one of the values\" doesn't work with the use of \"that value\" later on in the paragraph. The wording should probably align with the first paragraph of {{send-ech}}.",
              "createdAt": "2020-10-19T22:09:20Z",
              "updatedAt": "2020-10-20T22:14:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMTk5OTEy",
          "commit": {
            "abbreviatedOid": "0549ac5"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T22:18:42Z",
          "updatedAt": "2020-10-19T22:18:43Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Reverted. (Apologies for stepping on your toes here, I had forgotten there was a particular order.)",
              "createdAt": "2020-10-19T22:18:42Z",
              "updatedAt": "2020-10-20T22:14:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMjA3OTEy",
          "commit": {
            "abbreviatedOid": "0549ac5"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T22:35:35Z",
          "updatedAt": "2020-10-19T22:35:35Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Updated the text here to clarify that the client is meant to retry with retry configurations supplied by the server. I also updated the first paragraph of {{send-ech}} to clarify that a \"supported configuration\" is one for which `ECHConfig.version` indicates a version of ECH known to the client.",
              "createdAt": "2020-10-19T22:35:35Z",
              "updatedAt": "2020-10-20T22:14:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMTczMTAz",
          "commit": {
            "abbreviatedOid": "f86e1cd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-20T22:11:53Z",
          "updatedAt": "2020-10-20T22:13:07Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "```suggestion\r\nthe cipher suite it will use for encryption. It MUST NOT choose a cipher suite\r\nor version not advertised by the configuration.\r\n```",
              "createdAt": "2020-10-20T22:11:53Z",
              "updatedAt": "2020-10-20T22:14:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 347,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA2Mjc0MDkw",
      "title": "Fix ServerHello.random behavior in older TLS versions.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/347",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As written, the backend server performs this ServerHello.random modification unconditionally when it sees an empty ECH extension. Although the client is required to only offer TLS 1.3, the backend server doesn't check this.\r\n\r\nHowever, as noted elsewhere in the document, these same 8 bytes are used for the TLS 1.3 downgrade protection mechanism. That mechanism only works if the server *never* produces a TLS 1.2 ServerKeyExchange signature without the signal, so it's important that the server *not* signal ECH acceptance. Write this down.",
      "createdAt": "2020-10-19T21:00:23Z",
      "updatedAt": "2020-10-20T22:15:22Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "2360040a6fdc182427d740f8a8971a255226020c",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "server-random-clarify",
      "headRefOid": "d0deb8d3b4e3c25229a0ffb924de2aa2f32dde5e",
      "closedAt": "2020-10-20T22:15:22Z",
      "mergedAt": "2020-10-20T22:15:22Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "6e359b6dcf7e20511cf28052005151fc804037d2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMjEzMDkz",
          "commit": {
            "abbreviatedOid": "d0deb8d"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Yup, this is a good idea.",
          "createdAt": "2020-10-19T22:48:05Z",
          "updatedAt": "2020-10-19T22:48:05Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMTc0Nzg2",
          "commit": {
            "abbreviatedOid": "d0deb8d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Oops. Good catch!",
          "createdAt": "2020-10-20T22:15:16Z",
          "updatedAt": "2020-10-20T22:15:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 350,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA3NzAwODU3",
      "title": "Clarify client and server roles",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/350",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Partially addresses #348.\r\n\r\nWhether the client offers ECH or sends GREASE ECH depends on whether it\r\ncan find a suitable ECH config. Whether the server acts like the\r\nclient-facing server or the backend server depends on whether it has\r\ncustody of a set of ECH configs. This change clarifies these decision\r\nmaking processes.\r\n\r\nAs a bonus, this change also cleans up the section titles and levels a bit.",
      "createdAt": "2020-10-21T16:34:41Z",
      "updatedAt": "2021-04-16T19:57:54Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "6e359b6dcf7e20511cf28052005151fc804037d2",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "client-server-roles",
      "headRefOid": "b9aa266c7531e0db9c82c25bce99ec59230925d8",
      "closedAt": "2020-11-03T21:03:42Z",
      "mergedAt": "2020-11-03T21:03:42Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "384dc60929a56d5f743e1345ac5438a6607a19fc"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "{{encrypted-client-hello}} now stipulates that the ECH payload may be empty.",
          "createdAt": "2020-10-21T19:01:42Z",
          "updatedAt": "2020-10-21T19:01:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@davidben, can you please have another look?",
          "createdAt": "2020-10-27T23:20:08Z",
          "updatedAt": "2020-10-27T23:20:08Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0MDI4Njk2",
          "commit": {
            "abbreviatedOid": "32dc3ee"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This PR is good, but I don't think it fully addresses the issue. *Syntactically* the spec doesn't even support the behavior we want. I think we should say when defining the extension that it can be *either* empty or a ClientECH structure, and then define handling for both. Otherwise we'll trip decode_errors before we get far enough.",
          "createdAt": "2020-10-21T17:52:28Z",
          "updatedAt": "2020-10-21T18:00:32Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "Nit: To be less opinionated as to purpose (I see it as a general anti-ossification strategy), perhaps:\r\n\r\nClients doing the latter do not offer to negotiate ECH. Instead, they send a dummy ECH extension to reduce ossification in the ecosystem.",
              "createdAt": "2020-10-21T17:52:28Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            },
            {
              "originalPosition": 109,
              "body": "s/If not/If no/",
              "createdAt": "2020-10-21T17:53:03Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            },
            {
              "originalPosition": 177,
              "body": "Not sure the last two sentences are right. Even if it has ECH configs, it might still act as a backend server if it sees an empty ECH extension (which we need text for).",
              "createdAt": "2020-10-21T17:58:26Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0MDg2MTU0",
          "commit": {
            "abbreviatedOid": "32dc3ee"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-21T18:56:22Z",
          "updatedAt": "2020-10-21T18:56:23Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "Yours is also opinionated, I think. Changed to: \"Clients of the latter type do not negotiate ECH. Instead, they generate a dummy ECH extension that is ignored by the server.\"",
              "createdAt": "2020-10-21T18:56:22Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0MDg5NTg2",
          "commit": {
            "abbreviatedOid": "32dc3ee"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-21T19:00:06Z",
          "updatedAt": "2020-10-21T19:00:07Z",
          "comments": [
            {
              "originalPosition": 177,
              "body": "The first paragraph of {{client-facing-server}} says the client-facing server behaves as described in {{backend-server}} if the ECH extension is empty.",
              "createdAt": "2020-10-21T19:00:07Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4MDkwODM1",
          "commit": {
            "abbreviatedOid": "1fb1045"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-27T19:54:58Z",
          "updatedAt": "2020-10-27T20:00:53Z",
          "comments": [
            {
              "originalPosition": 111,
              "body": "```suggestion\r\nif it is in possession of a compatible ECH configuration and sends GREASE ECH\r\n```",
              "createdAt": "2020-10-27T19:54:58Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            },
            {
              "originalPosition": 123,
              "body": "```suggestion\r\nor version not advertised by the configuration. If no compatible configuration is\r\n```",
              "createdAt": "2020-10-27T19:55:53Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            },
            {
              "originalPosition": 177,
              "body": "Perhaps we can clarify?\r\n\r\n```suggestion\r\nOtherwise, if the server does not have a set of ECH configurations, or if the \r\n`ClientECH` extension is empty, the server plays the role of the backend server.\r\n```",
              "createdAt": "2020-10-27T19:58:21Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            },
            {
              "originalPosition": 203,
              "body": "```suggestion\r\nfollows.\r\n```",
              "createdAt": "2020-10-27T19:58:53Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            },
            {
              "originalPosition": 259,
              "body": "```suggestion\r\nfollows.\r\n```",
              "createdAt": "2020-10-27T19:59:35Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4MjE2NDYx",
          "commit": {
            "abbreviatedOid": "328c528"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-27T23:09:33Z",
          "updatedAt": "2020-10-27T23:09:33Z",
          "comments": [
            {
              "originalPosition": 259,
              "body": "Changed to \"as described in this section\".",
              "createdAt": "2020-10-27T23:09:33Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4MjE4MTE2",
          "commit": {
            "abbreviatedOid": "c294156"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-27T23:13:47Z",
          "updatedAt": "2020-10-27T23:13:48Z",
          "comments": [
            {
              "originalPosition": 203,
              "body": "Changed to \"as described in this section\".",
              "createdAt": "2020-10-27T23:13:48Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4MjIwMzk1",
          "commit": {
            "abbreviatedOid": "c294156"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This LGTM!",
          "createdAt": "2020-10-27T23:19:51Z",
          "updatedAt": "2020-10-27T23:19:51Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODk4ODk1",
          "commit": {
            "abbreviatedOid": "c294156"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T18:38:52Z",
          "updatedAt": "2020-11-02T19:01:58Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "Maybe \"true server name\"? \"Backend server\" means something in the context of the server deployment, but I think we usually talk about the \"true server name\" elsewhere for the client. (Maybe want to check me on this, I just sampled a few bits of the text unscientifically.)",
              "createdAt": "2020-11-02T18:38:52Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            },
            {
              "originalPosition": 192,
              "body": "This paragraph still reads strangely. We're saying:\r\n\r\n- The server is a client-facing server if it has ECH configs\r\n- Otherwise [i.e. if it does not have ECH configs], if it does not have ECH configs or if the ClientECH extension is empty, the server is a backend server.\r\n\r\nThe use of \"Otherwise\" contradicts the text immediately after it.\r\n\r\nHow about keying it on the client extension instead? That way we don't need to restate all the decryption logic and include a jump between sections. Something like this...\r\n\r\n> Servers that that implement the ECH extension play one of two roles, depending on the form of the ECH extension in the ClientHello. If the extension value is non-empty, the server acts as a client-facing server and proceeds as described in {{client-facing-server}} to extract a ClientHelloInner if available.  If the extension value is empty, the server acts as a backend server and proceeds as described in {{backend-server}}.\r\n\r\nFrom there I think we can revert most of the changes at the start of {{client-facing-server}}, and just stick the adjective \"non-empty\" in the first sentence. {{backend-server}} probably wants to just use your second paragraph, and maybe clarify that the backend server just runs this logic unconditionally, so a potential client-facing server (the client may have just sent an empty ECH extension for no reason) and backend don't need to communicate much.",
              "createdAt": "2020-11-02T18:47:55Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            },
            {
              "originalPosition": 170,
              "body": "I don't particularly care which one we do, but we should be consistent about whether we're spelling out messages With Separate Words, or MatchingTheMessageName. In particular, I think you requested {{encoding-inner}} and {{authenticating-outer}} be written as \"Encoding the ClientHelloInner\" and \"Authenticating the ClientHelloOuter\". Whatever we do, those  should match.\r\n\r\n(FWIW, I think MatchingTheMessageName is the tidiest, though RFC8446 does it With Separate Words.)",
              "createdAt": "2020-11-02T18:59:29Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            },
            {
              "originalPosition": 249,
              "body": "Point 1 in this section also doesn't really account for empty vs non-empty extensions. (Which is why I was pondering if we should just use a separate codepoint. Although #352 simplifies this anyway, so we could also leave it alone and fix it separately. But in that case maybe we should leave #348 open. This PR is currently set to close it.)",
              "createdAt": "2020-11-02T19:01:42Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxOTI4MjQ0",
          "commit": {
            "abbreviatedOid": "c294156"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T19:23:44Z",
          "updatedAt": "2020-11-02T19:23:45Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "Good catch. We're kinda inconsistent about this, I think, but I'll change it to \"true server name\".",
              "createdAt": "2020-11-02T19:23:44Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxOTM1Njg2",
          "commit": {
            "abbreviatedOid": "c294156"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T19:35:07Z",
          "updatedAt": "2020-11-02T19:35:07Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "Changed to \"Handling HelloRetryRequest\", here and below.",
              "createdAt": "2020-11-02T19:35:07Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxOTM4NDEy",
          "commit": {
            "abbreviatedOid": "c294156"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T19:39:19Z",
          "updatedAt": "2020-11-02T19:39:19Z",
          "comments": [
            {
              "originalPosition": 249,
              "body": "Let's leave the issue open. (I changed the top comment above to reflect this.)",
              "createdAt": "2020-11-02T19:39:19Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxOTQxMTY2",
          "commit": {
            "abbreviatedOid": "c294156"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T19:43:48Z",
          "updatedAt": "2020-11-02T19:43:48Z",
          "comments": [
            {
              "originalPosition": 192,
              "body": "Good idea. Although I'm not sure what you mean here:\r\n> {{backend-server}} probably wants to just use your second paragraph, and maybe clarify that the backend server just runs this logic unconditionally, so a potential client-facing server (the client may have just sent an empty ECH extension for no reason) and backend don't need to communicate much.\r\n\r\nI updated the first paragraph of {{server-behavior}} with your suggestion and revised {{client-facing-server}} and {{backend-server}} so that the former applies only to non-empty values and the latter applies only to empty values.",
              "createdAt": "2020-11-02T19:43:48Z",
              "updatedAt": "2020-11-02T19:54:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxOTUxMTMw",
          "commit": {
            "abbreviatedOid": "b9aa266"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T19:59:05Z",
          "updatedAt": "2020-11-02T19:59:05Z",
          "comments": [
            {
              "originalPosition": 249,
              "body": "SGTM.",
              "createdAt": "2020-11-02T19:59:05Z",
              "updatedAt": "2020-11-02T19:59:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxOTUxMzc1",
          "commit": {
            "abbreviatedOid": "b9aa266"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T19:59:26Z",
          "updatedAt": "2020-11-02T19:59:27Z",
          "comments": [
            {
              "originalPosition": 249,
              "body": "(Oh, apparently I can't mark threads as resolved. Feel free to close this out.)",
              "createdAt": "2020-11-02T19:59:26Z",
              "updatedAt": "2020-11-02T19:59:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyMDEwNDcz",
          "commit": {
            "abbreviatedOid": "b9aa266"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T21:36:48Z",
          "updatedAt": "2020-11-02T21:36:49Z",
          "comments": [
            {
              "originalPosition": 192,
              "body": "Oh, that was a far too complicated suggestion on my part as to how to revise that text. Yours works too. :-)\r\n\r\nThe bit about \"maybe clarify that [...]\" was that we could optionally add something to the effect of:\r\n\r\n> The backend server confirms acceptance based solely on the presence of an empty \"encrypted_client_hello\" extension. This allows the ECH negotiation to complete in Split Mode with minimal coordination between the client-facing server and backend server. Note, however, if the backend server is directly accessible to clients, it is possible for a client to send an empty \"encrypted_client_hello\" extension without a client-facing server decrypting a ClientHelloInner. The backend server will confirm acceptance in this case too.\r\n\r\n(@dmcardle since we were talking about this odd implication of the ECH acceptance signal today.)",
              "createdAt": "2020-11-02T21:36:49Z",
              "updatedAt": "2020-11-02T21:36:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyMDEwOTY4",
          "commit": {
            "abbreviatedOid": "b9aa266"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-02T21:37:43Z",
          "updatedAt": "2020-11-02T21:37:43Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODcwMDA0",
          "commit": {
            "abbreviatedOid": "b9aa266"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-03T20:59:45Z",
          "updatedAt": "2020-11-03T20:59:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 351,
      "id": "MDExOlB1bGxSZXF1ZXN0NTEyNzMyMDgx",
      "title": "Rearrange the server HRR text.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/351",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Now that we have separate client HRR and server HRR sections, move some\r\nserver text to the server section. Also clarify that the second\r\nClientHelloOuterAAD is computed from the second ClientHelloOuter, not\r\nreusing the first value.\r\n\r\n(Some cleanup in advance of writing up the HPKE context reuse version.)",
      "createdAt": "2020-10-30T03:23:49Z",
      "updatedAt": "2020-11-03T20:53:55Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "6e359b6dcf7e20511cf28052005151fc804037d2",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "hrr-server-fixup",
      "headRefOid": "f4808ac2f3e75eff57fa5c9e300a438d4ff7d964",
      "closedAt": "2020-11-03T20:53:55Z",
      "mergedAt": "2020-11-03T20:53:55Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "30ee958bfeb419cf8dffc1d3849c206d40ec6c2b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODUzNjc2",
          "commit": {
            "abbreviatedOid": "f4808ac"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Can we merge this? The number of PRs is getting confusing.\r\n\r\n@chris-wood ",
          "createdAt": "2020-11-03T20:33:11Z",
          "updatedAt": "2020-11-03T20:33:11Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODY2MTU4",
          "commit": {
            "abbreviatedOid": "f4808ac"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-03T20:53:51Z",
          "updatedAt": "2020-11-03T20:53:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 352,
      "id": "MDExOlB1bGxSZXF1ZXN0NTEyNzUyNTg0",
      "title": "Use the same HPKE context between the two ClientHellos",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/352",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "(Note: this PR sits on top of #351, though hopefully the combined diff is also readable enough.)\r\n\r\nCloses #349. This achieves the same security properties of ech_hrr_key, but gives us a few improvements:\r\n\r\n- Client-facing servers that offload their HPKE operations to RPCs do not need to worry about race conditions with rotation between the two ClientHellos. (See #325.)\r\n\r\n- We only perform one addition asymmetric operation with ECH, rather than sometimes two. For servers with offloaded ECH keys, this also avoids an extra RPC call.\r\n\r\n- HPKE implementations for ECH only need SetupBase* and not SetupPSK*.\r\n\r\n- The description of HRR handling in general can be greatly simplified. Rather than running the server's CH1 algorithm with various modifications, we can just write a straightforward, simpler algorithm.\r\n\r\nThis PR also adds some missing text for GREASE on HRR, which closes #356. (Although it's worth noting that HRR connections can be easily distinguished by an active attacker anyway. This PR doesn't change this, but makes it much clearer.)",
      "createdAt": "2020-10-30T04:39:21Z",
      "updatedAt": "2020-11-17T23:21:01Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3b2b8cd7e8c10fadcd79e087238d67e44048584f",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "hrr-reuse-context",
      "headRefOid": "c2b52617755b87ec401f67d68d9d2d6cc44f0d2b",
      "closedAt": "2020-11-17T23:21:00Z",
      "mergedAt": "2020-11-17T23:21:00Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "9f485e939b99814f9a73c1e94ec5e44f0a8d4806"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This is much simpler, but, if I understand it correctly, I think it *might* be a little bit of a regression. The previous export-then-inject design forced the server to process both ECH configs and encapsulated keys in both CH1 and CH2, whereas here the server just ignores those in CH2 and uses the values from CH1. That lets clients change these fields in CH2 without any effect. Now, I don't really know of anything that *could* go wrong here, but it smells like the sort of \"insufficient binding\" problem we've continually run into before. (For example, I think an on-path attacker could modify the `enc` or `config_id` fields in CH2, without touching anything else. Decryption would succeed, as the server used CH1's `enc` value, and the transcript is unaffected since the server would choose the CH inner value. Is that a way for an on-path attacker to quickly check if the connection is real or fake ECH?)\r\n\r\nChris asked if we should require servers to verify these match, and as you pointed out, that's a mess. (We also acknowledged that servers missing these checks is something we should expect to happen in the wild, which is somewhat why we are concerned about this re-binding attack in the first place.)\r\n\r\nI wonder if we can solve this in a different way: [put these ECH extension fields in the AAD](https://github.com/tlswg/draft-ietf-tls-esni/issues/326). That would prevent the modification above, I think, and shouldn't be *too* bad in terms of additional complexity.",
          "createdAt": "2020-11-04T01:08:50Z",
          "updatedAt": "2020-11-04T01:08:50Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> This is much simpler, but, if I understand it correctly, I think it might be a little bit of a regression. The previous export-then-inject design forced the server to process both ECH configs and encapsulated keys in both CH1 and CH2, whereas here the server just ignores those in CH2 and uses the values from CH1. That lets clients change these fields in CH2 without any effect. Now, I don't really know of anything that could go wrong here, but it smells like the sort of \"insufficient binding\" problem we've continually run into before.\r\n\r\nI think allowing the actual client to change ignored fields is a general property of HelloRetryRequest. Because we don't expect servers to check consistency between CH1 and CH2, a client that goes out of their way to send something inconsistent may find that their (CH1, CH2) tuple is interpreted ambiguously. But the transcript reflects the whole tuple, so, as far as the handshake itself, the client is just causing its own preferences to be misrepresented here.\r\n\r\nIdeally ambiguous things would be unrepresentable and consistently treated as errors but HRR is what it is. :-/\r\n\r\n> (For example, I think an on-path attacker could modify the enc or config_id fields in CH2, without touching anything else. Decryption would succeed, as the server used CH1's enc value, and the transcript is unaffected since the server would choose the CH inner value. Is that a way for an on-path attacker to quickly check if the connection is real or fake ECH?)\r\n\r\nI think real vs. fake ECH on HRR connections is entirely hopeless, short of completely redoing HRR. If CH1 uses ECH, we need to require CH2 also use ECH. That means ECH decryption failures in CH2 are fatal, and you can distinguish the two by simply replaying CH1 and perturbing the ciphertext in CH2. (That said, note that CHOuterAAD means whether a ClientHello triggers HRR is not under attacker control. So if a client/server pair doesn't trigger HRR, the attacker can't try to do this.)\r\n\r\nThat said, I think there's a variant of this on CH1 in the optional config_id mode. (See below.)\r\n\r\n> Chris asked if we should require servers to verify these match, and as you pointed out, that's a mess. (We also acknowledged that servers missing these checks is something we should expect to happen in the wild, which is somewhat why we are concerned about this re-binding attack in the first place.)\r\n\r\nYeah, this is the \"I think we got HRR wrong and have to live with it\" problem. :-)\r\n\r\n> I wonder if we can solve this in a different way: put these ECH extension fields in the AAD. That would prevent the modification above, I think, and shouldn't be too bad in terms of additional complexity.\r\n\r\nI don't think I believe this matters for HRR (only attack I can see is real vs fake ECH, which is hopeless with HRR anyway), but now that you mention it, I think there *is* a variant of this for the optional config_id mode in the non-HRR case.\r\n\r\nIn CH1, we don't bind config_id, enc, and cipher_suite to the encryption, so a priori an attacker might be able to perturb them without breaking the decryption. Perturbing enc and cipher_suite seems likely to break decryption anyway, but config_id is interesting. In the normal mode, it too will break decryption. In the optional config_id mode, config_id is just a placeholder. That means an attacker can distinguish optional config_id ECH from {GREASE or config_id ECH} by flipping the config_id, sending it to the server, and seeing if the client can decrypt the result.\r\n\r\n(Of course, all this is relative to an unclear and undefined \"don't stick out\" model.)\r\n\r\nComplexity-wise, I think it's fine, but note it changes the processing order somewhat interestingly, both for the spec and implementations. Right now the spec says:\r\n\r\n1. Make your CHInner. This should largely be running through your usual CH assembly logic.\r\n2. Encode it with the extensions you expect to compress.\r\n3. Make your CHOuter, minus the ECH extension. This should largely run through your existing CH assembly logic and computes CHOuterAAD.\r\n4. Take EncodedCHInner and CHOuterAAD and run through the Deserialize, SetupBaseS, context.Seal logic to assemble the final CHOuter.\r\n\r\nIn order to put these fields in AAD, we'd need to say:\r\n\r\n1. Make your CHInner. This should largely be running through your usual CH assembly logic.\r\n2. Encode it with the extensions you expect to compress.\r\n3. Make your CHOuter, minus the ECH extension. This should largely run through your existing CH assembly logic.\r\n4. Run Deserialize and SetupBaseS.\r\n5. Compute CHOuterAAD with half an ECH extension.\r\n6. Take EncodedCHInner and CHOuterAAD and run through the context.Seal logic to assemble the final CHOuter.",
          "createdAt": "2020-11-04T16:10:11Z",
          "updatedAt": "2020-11-04T16:16:41Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> In CH1, we don't bind config_id, enc, and cipher_suite to the encryption, so a priori an attacker might be able to perturb them without breaking the decryption. Perturbing enc and cipher_suite seems likely to break decryption anyway, but config_id is interesting. In the normal mode, it too will break decryption. In the optional config_id mode, config_id is just a placeholder. That means an attacker can distinguish optional config_id ECH from {GREASE or config_id ECH} by flipping the config_id, sending it to the server, and seeing if the client can decrypt the result.\r\n\r\nA similar \"don't stick out\" distinguisher: Flip a bit of ClientECH.payload in CH2. The client-facing server will abort with \"decrypt_error\" if real-ECH is in use but not if grease-ECH is in use. This attack is unavoidable if we want to ensure that the server doesn't change from CHInner to CHOuter across the HRR. (Enforcing this invariant seems like a good idea to me.)\r\n\r\n> In order to put these fields in AAD, we'd need to say:\r\n> -    Make your CHInner. This should largely be running through your usual CH assembly logic.\r\n> -    Encode it with the extensions you expect to compress.\r\n> -    Make your CHOuter, minus the ECH extension. This should largely run through your existing CH assembly logic.\r\n> -    Run Deserialize and SetupBaseS.\r\n> -    Compute CHOuterAAD with half an ECH extension.\r\n> -    Take EncodedCHInner and CHOuterAAD and run through the context.Seal logic to assemble the final CHOuter.\r\n\r\nThis seems like a sensible idea, although I'm not super concerned about the \"don't stick out\" attack it mitigates. I would vote we land this change as-is and follow up with a new PR.",
          "createdAt": "2020-11-04T19:09:02Z",
          "updatedAt": "2020-11-04T19:22:46Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Right, I mentioned that HRR attack above. ( \"I think real vs. fake ECH on HRR connections is entirely hopeless [...]\".)\r\n\r\nSince avoiding this is hopeless in HRR, I don't think we should use it as a justification for binding bits of CH2's ClientECH or checking they match (which don't actually do the same thing). Whereas attacks on CH1 are interesting because that situation is less obviously hopeless. So maybe we want to add more things to CHOuterAAD for that, though that is orthogonal to this PR, so I think we should deal with it separately. (CHOuterAAD was originally intended to fix the ClientHello malleability attack, in a way that avoids burning 32 bytes on an inner_digest.)",
          "createdAt": "2020-11-04T19:22:43Z",
          "updatedAt": "2020-11-04T19:23:38Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed. (I was in the middle of editing my comment above to say the same thing when I saw your message!)",
          "createdAt": "2020-11-04T19:24:01Z",
          "updatedAt": "2020-11-04T19:24:01Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": ">This attack is unavoidable if we want to ensure that the server doesn't change from CHInner to CHOuter across the HRR. \r\n\r\nYeah, this morning I came to the conclusion that mitigating this sort of distinguisher for HRR was not really possible unless we relax the inner/outer matching invariant. I'm fine pursuing more AAD as a separate change on top of this, since it's strictly an improvement (and HRR is hopeless).",
          "createdAt": "2020-11-04T19:31:00Z",
          "updatedAt": "2020-11-04T19:31:00Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@davidben can you please resolve conflicts?",
          "createdAt": "2020-11-04T19:31:09Z",
          "updatedAt": "2020-11-04T19:31:09Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased.",
          "createdAt": "2020-11-04T19:46:46Z",
          "updatedAt": "2020-11-04T19:46:46Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwMzcyNjEw",
          "commit": {
            "abbreviatedOid": "fb1bcea"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-30T04:40:04Z",
          "updatedAt": "2020-10-30T04:40:04Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "This fields also don't matter. I wonder if we should say you empty them instead...\r\n\r\n(Insert usual remark that I think we got HelloRetryRequest wrong. :-) )",
              "createdAt": "2020-10-30T04:40:04Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxMDMxNjgx",
          "commit": {
            "abbreviatedOid": "fb1bcea"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-30T20:57:47Z",
          "updatedAt": "2020-10-30T20:57:48Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "Self-review: \"After sending a HelloRetryRequest\" is slightly odd because, on ECH accept, the client-facing server forwards the HRR from the backend server. At the same time, this section also talks about ECH reject, since we want to clarify that you don't process ECH on the second ClientHello as usual.\r\n\r\nPerhaps: \"After sending or forwarding a HelloRetryRequest\"?",
              "createdAt": "2020-10-30T20:57:48Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODM5MDk5",
          "commit": {
            "abbreviatedOid": "fb1bcea"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T17:17:37Z",
          "updatedAt": "2020-11-02T17:17:38Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "They need to be present in order for stateless-HRR servers to correctly re-compute the HPKE context, right? Incidentally, how do stateless-HRR servers correctly compute the nonce? The sequence number changes after HRR.\r\n\r\nPerhaps this PR should stipulate that (some representation of) the HPKE context ought to appear in the \"cooke\".",
              "createdAt": "2020-11-02T17:17:37Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODQ3NjM5",
          "commit": {
            "abbreviatedOid": "fb1bcea"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T17:28:04Z",
          "updatedAt": "2020-11-02T17:28:04Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Stateless-HRR servers don't work at all right now anyway (#333), so we can't really talk about what goes in the cookie because there's no way for the client-facing server to contribute to the cookie right now. When we do, yes, we should say something about this. (See also https://github.com/tlswg/draft-ietf-tls-esni/issues/349#issuecomment-713724970)\r\n\r\nAs to what the stateless-HRR server needs, it needs to store *something* that allows it to recreate the HPKE context on the second ClientHello. Things that would work:\r\n\r\n* Store the HPKE encryption key, nonce, and sequence number. (Alternatively, know the sequence number is always 1...)\r\n* Store the client `enc` value and sequence number (or assume 1), and some handle to the ECHConfig private key, so it can recreate the HPKE context and fast-forward the context to the right sequence number.\r\n* Store a hash of the client `enc` value, check it matches, and then do as above.\r\n\r\nOnly the last of these actually needs the client to send `enc` again. Note what would not work great is blindly recomputing the `enc` value, given {{flow-hrr-hijack}}. Given #325, my inclination is the first option is most straightforward anyway.",
              "createdAt": "2020-11-02T17:28:04Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODY2Nzc4",
          "commit": {
            "abbreviatedOid": "fb1bcea"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T17:53:22Z",
          "updatedAt": "2020-11-02T17:53:22Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "> Stateless-HRR servers don't work at all right now anyway (#333), so we can't really talk about what goes in the cookie because there's no way for the client-facing server to contribute to the cookie right now.\r\n\r\nIsn't this only true for Split Mode / stateless-HRR? \r\n",
              "createdAt": "2020-11-02T17:53:22Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODc2NDE3",
          "commit": {
            "abbreviatedOid": "fb1bcea"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T18:06:49Z",
          "updatedAt": "2020-11-02T18:06:49Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "That sounds good to me.",
              "createdAt": "2020-11-02T18:06:49Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxODg1Mjgy",
          "commit": {
            "abbreviatedOid": "fb1bcea"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T18:19:21Z",
          "updatedAt": "2020-11-02T18:19:22Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "As long as \"cipher_suite\", \"config_id\", \"enc\" are retransmitted in CH2, should the server verify that they don't change?",
              "createdAt": "2020-11-02T18:19:21Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxOTE4MDQ1",
          "commit": {
            "abbreviatedOid": "fb1bcea"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T19:07:35Z",
          "updatedAt": "2020-11-02T19:07:35Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "It's true for both. There's no text supporting Shared Mode / stateless-HRR right now because Shared Mode is treated as a special-case of Split Mode. It's \"obvious\" what they're supposed to do, but without any text to support it, we can't talk about what goes in the cookie.\r\n\r\nAs part of #333, we'll need to address all of that. In the meantime, this PR doesn't change things because we already have no text talking about how ech_hrr_key goes in the cookie. All of that is #333.",
              "createdAt": "2020-11-02T19:07:35Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxOTE5Mzg0",
          "commit": {
            "abbreviatedOid": "fb1bcea"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T19:09:47Z",
          "updatedAt": "2020-11-02T19:09:47Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "Checking CH1 and CH2 consistency is a huge mess to do. We completely got the design of HRR wrong in RFC8446, and it's too late to do anything about that now. Rather than expend a whole lot of energy on everyone's part, from spec text to implementations to constantly having this discussion, I'd rather we follow RFC8446's example here and leave it alone.",
              "createdAt": "2020-11-02T19:09:47Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxOTIzNjQy",
          "commit": {
            "abbreviatedOid": "fb1bcea"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T19:16:29Z",
          "updatedAt": "2020-11-02T19:16:29Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "That is, RFC8446 is already quite restrictive about CH1/CH2 consistency, yet servers are not required to (and in practice do not) check consistency for much, if any, of it.\r\nhttps://tools.ietf.org/html/rfc8446#section-4.1.2\r\n\r\nIndeed if you think about what a server would need to do here, it's clear we just got the design wrong. A server that is capable of checking some individual field most likely stored the value of the field, in which case there was no reason for the client to re-send it in the first place! (This grew organically from an earlier design where the server actually reconstructed CH1 from CH2, but that had all kinds of attacks and was generally a mess. When we dropped that, we probably should have stopped to reevaluate it. Oh well.)",
              "createdAt": "2020-11-02T19:16:29Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxOTQxNzg5",
          "commit": {
            "abbreviatedOid": "fb1bcea"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-02T19:44:44Z",
          "updatedAt": "2020-11-02T19:44:45Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Ack. You can resolve this comment.",
              "createdAt": "2020-11-02T19:44:44Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODczNTcy",
          "commit": {
            "abbreviatedOid": "fb1bcea"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This seems generally good. I'm not sure why we didn't do this in the first place. Are reusable contexts new?",
          "createdAt": "2020-11-03T21:05:32Z",
          "updatedAt": "2020-11-03T21:06:56Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "This seems like it's orthogonal, right?",
              "createdAt": "2020-11-03T21:05:33Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODg3NDkw",
          "commit": {
            "abbreviatedOid": "fb1bcea"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-03T21:28:57Z",
          "updatedAt": "2020-11-03T21:28:57Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "Well, the question is whether we mandate the server check the redundant fields. I think my default is to prefer matching rfc8446 in not saying much. (With a side of grumpiness about how weird HRR is. :-) ) We probably need to do a better job describing HRR in rfc8446bis. I figure the less other specs say about it, the more room we have to figure out what we actually want to require.",
              "createdAt": "2020-11-03T21:28:57Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyOTY4NTk3",
          "commit": {
            "abbreviatedOid": "fb1bcea"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-04T00:31:36Z",
          "updatedAt": "2020-11-04T13:38:51Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "```suggestion\r\nAfter sending or forwarding a HelloRetryRequest, the client-facing server does not repeat the\r\n```",
              "createdAt": "2020-11-04T00:31:37Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            },
            {
              "originalPosition": 140,
              "body": "(Assuming this is what you meant...)\r\n\r\n```suggestion\r\ncontinues with the ECHConfig selection from the first ClientHelloOuter as follows:\r\n```",
              "createdAt": "2020-11-04T00:40:38Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            },
            {
              "originalPosition": 165,
              "body": "```suggestion\r\nproceeds with the connection as usual, without decrypting the new\r\n```",
              "createdAt": "2020-11-04T00:48:58Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNTE2NTU5",
          "commit": {
            "abbreviatedOid": "fb1bcea"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-04T16:15:12Z",
          "updatedAt": "2020-11-04T16:15:12Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "Hrm. I wrote \"any\" so that this text also works for the no ECH extension case and the \"if any\" version had lots of clauses and commas. :-)\r\n\r\n> If the client-facing server rejected ECH, or if the first ClientHello did not\r\n> include an \"encrypted_client_hello\" extension, the client-facing server\r\n> proceeds with the connection as usual, without decrypting the new\r\n> ClientECH.payload value, if any.\r\n\r\nGiven that, are you happy with \"any new ClientECH.payload value\"? Or do you prefer \", if any\" or maybe some other wording altogether?",
              "createdAt": "2020-11-04T16:15:12Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNTMwMDM4",
          "commit": {
            "abbreviatedOid": "3790580"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-04T16:29:04Z",
          "updatedAt": "2020-11-04T16:29:05Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "\"Any\" to me implied \"possibly one of the many new values,\" but the CH only has one value.",
              "createdAt": "2020-11-04T16:29:05Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNTYwNDIz",
          "commit": {
            "abbreviatedOid": "3790580"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-04T17:02:18Z",
          "updatedAt": "2020-11-04T17:02:19Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "Hehe. I read \"any ClientECH.payload value [singular]\" to mean zero or one, but maybe that's not the right way to use that word. :-)\r\n\r\nHow about:\r\n\r\n> If the client-facing server rejected ECH, or if the first ClientHello did not\r\n> include an \"encrypted_client_hello\" extension, the client-facing server\r\n> proceeds with the connection as usual. The server does not decrypt the\r\n> second ClientHello's ClientECH.payload value, if one was included.",
              "createdAt": "2020-11-04T17:02:18Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNTY2MTEz",
          "commit": {
            "abbreviatedOid": "3790580"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-04T17:08:55Z",
          "updatedAt": "2020-11-04T17:08:55Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "Perfect!",
              "createdAt": "2020-11-04T17:08:55Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNjI1NTM1",
          "commit": {
            "abbreviatedOid": "d1db526"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-04T18:25:12Z",
          "updatedAt": "2020-11-04T18:25:13Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "Reworded.",
              "createdAt": "2020-11-04T18:25:12Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNjY4MjM0",
          "commit": {
            "abbreviatedOid": "d1db526"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-04T19:24:49Z",
          "updatedAt": "2020-11-04T19:24:49Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1MzE0ODgy",
          "commit": {
            "abbreviatedOid": "fb1bcea"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-06T16:36:55Z",
          "updatedAt": "2020-11-06T16:36:55Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Unresolving this since we only resolved @cjpatton's clarification question, not the actual issue.\r\n\r\nThinking about this some more, I think we actually should require `enc` be empty on CH2. The reason is, of the three stateless implementation options listed above, only the first one is robust. The second and third rely on the server performing a check that, if they forget, still interops. But if they forget the check, {{flow-hrr-hijack}} applies again. Given @cjpatton's question, I also suspect this mistake is reasonably likely.\r\n\r\nClearing `enc` forces servers to pick the first option, which is the more robust one. We're also guaranteed that a server, stateful or stateless, does not need `enc` (or `cipher_suite`) because you need to process ECH on CH1 regardless. Thus, I propose:\r\n\r\n* CH2's `enc` MUST be empty. Servers check this when parsing (now that it's empty rather than copied over, it's easy).\r\n* CH2's  `cipher_suite` MUST be {copied over, zero; not sure which}. Servers check this one too, just because it's really easy.\r\n\r\nEven more minimal would be if CH2's extension contained `payload` and nothing else, but we don't have any precedent for extension syntaxes varying between CH1 and CH2, so probably we shouldn't go down that route.\r\n\r\n@ekr, I'm curious what your thoughts on this are.",
              "createdAt": "2020-11-06T16:36:55Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1MzI1NTYz",
          "commit": {
            "abbreviatedOid": "b4137af"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-06T16:50:35Z",
          "updatedAt": "2020-11-06T16:50:35Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Oh same probably goes for `config_id` in CH2. Force the server to use the same ECHConfig rather than accidentally swapping it. (Except it's not really using the ECHConfig since it's just reusing the HPKE context and not worrying about it.)",
              "createdAt": "2020-11-06T16:50:35Z",
              "updatedAt": "2020-11-06T21:20:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1NTAxNDE3",
          "commit": {
            "abbreviatedOid": "c2b5261"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-06T21:21:43Z",
          "updatedAt": "2020-11-06T21:21:43Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "I have no idea when we use quotation marks or backticks, but we seem to use backticks when referring to ClientECH fields?",
              "createdAt": "2020-11-06T21:21:43Z",
              "updatedAt": "2020-11-06T21:21:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1NTAxNjg1",
          "commit": {
            "abbreviatedOid": "c2b5261"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-06T21:22:13Z",
          "updatedAt": "2020-11-06T21:22:13Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "(Updated the PR with this version.)",
              "createdAt": "2020-11-06T21:22:13Z",
              "updatedAt": "2020-11-06T21:22:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1NTAxODcx",
          "commit": {
            "abbreviatedOid": "c2b5261"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-06T21:22:36Z",
          "updatedAt": "2020-11-06T21:22:37Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "(Supposing we go with https://github.com/tlswg/draft-ietf-tls-esni/pull/352#discussion_r518868173, the redundant fields are gone and this is moot.)",
              "createdAt": "2020-11-06T21:22:36Z",
              "updatedAt": "2020-11-06T21:22:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NjQ2NDQ4",
          "commit": {
            "abbreviatedOid": "c2b5261"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-10T22:06:51Z",
          "updatedAt": "2020-11-10T22:06:52Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "I've been going with backticks for structures and their fields and quotes for extension names.",
              "createdAt": "2020-11-10T22:06:52Z",
              "updatedAt": "2020-11-10T22:06:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyODcyOTU4",
          "commit": {
            "abbreviatedOid": "c2b5261"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM.",
          "createdAt": "2020-11-17T22:40:38Z",
          "updatedAt": "2020-11-17T22:40:38Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyODkzOTU0",
          "commit": {
            "abbreviatedOid": "c2b5261"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-17T23:20:48Z",
          "updatedAt": "2020-11-17T23:20:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 353,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE0MzQ0MjI3",
      "title": "Derive accept confirmation from the handshake secret ",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/353",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "[Originally suggested by Karthik Bhargavan](https://mailarchive.ietf.org/arch/msg/tls/XsWf4f7-apwOlehe4j0_qKB3zV4/), this change mitigates an active \"don't stick out\" attack [pointed out by Christian Huitema](https://mailarchive.ietf.org/arch/msg/tls/EAeKCNq7JAFm8DFaoe2MwSslZTQ/). The attack is as follows.\r\n\r\n```\r\nClient                       Attacker             Server\r\nCH\r\n +encrypted_client_hello\r\n +key_share (g^x)        --> CH -->               SH\r\n                                                   +key_share (g^y)\r\n                             SH'              <-- EE\r\n                              +key_share (g^a)\r\n                         <-- EE'\r\n```\r\n\r\n1. The attacker intercepts the client's first flow (`CH`) and forwards it to the\r\n   server.\r\n2. The attacker intercepts the server's first flow and transforms `SH` and `EE` into\r\n   `SH'` and `EE'` respectively, as follows. `SH'` is just like `SH` except that the\r\n   key share `g^y` is replaced with key share `g^a`, where `a` is known to the\r\n   attacker. `EE'` is a malformed handshake message encrypted using a key derived\r\n   from `g^xa`. Finally, it sends `SH'..EE'` to the client.\r\n3. If the client aborts with a \"bad_record_mac\" alert, then the attacker guesses\r\n   that real-ECH was used. Otherwise, it guesses that grease-ECH was used.",
      "createdAt": "2020-11-02T21:46:35Z",
      "updatedAt": "2021-04-16T19:57:58Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3b2b8cd7e8c10fadcd79e087238d67e44048584f",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "accept-binder",
      "headRefOid": "50506ef3c99ab65f6aa9a0c0fcd1c1340940031c",
      "closedAt": "2020-11-17T22:11:42Z",
      "mergedAt": "2020-11-17T22:11:42Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "e4c80070fe32f8a6339053b481b92c7078b15da7"
      },
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I have really mixed feelings about this. On the one hand, it's kind of annoying extra complexity. OTOH, given how hard a time we have had by reasoning about the security of ECH, I think better safe than sorry.",
          "createdAt": "2020-11-03T20:31:42Z",
          "updatedAt": "2020-11-03T20:31:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@cjpatton can you please rebase this PR?",
          "createdAt": "2020-11-04T01:11:41Z",
          "updatedAt": "2020-11-04T01:11:41Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@cjpatton this is nice -- thanks! I think the new type name for the special SH is fine, though if someone has an idea for a better name, let's consider it.",
          "createdAt": "2020-11-04T13:38:15Z",
          "updatedAt": "2020-11-04T13:38:15Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @ekr: I have really mixed feelings about this. On the one hand, it's kind of annoying extra complexity. OTOH, given how hard a time we have had by reasoning about the security of ECH, I think better safe than sorry.\r\n\r\nThis change is definitely more invasive than the existing signal, but not all that hard to implement. (E.g., https://github.com/cloudflare/go/pull/38.)\r\n\r\ncc/ @dmcardle, @davidben ",
          "createdAt": "2020-11-11T00:18:37Z",
          "updatedAt": "2020-11-11T00:18:59Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @cjpatton! @dmcardle and @kjacobs-moz, if you can also comment on the implementation difficulty, we can try and land this soon.",
          "createdAt": "2020-11-11T01:00:57Z",
          "updatedAt": "2020-11-11T01:01:08Z"
        },
        {
          "author": "kjacobs-moz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This seems pretty straightforward. I don't think it would be too difficult to do in NSS.",
          "createdAt": "2020-11-11T19:23:51Z",
          "updatedAt": "2020-11-11T19:23:51Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I think on balance we should do this.",
          "createdAt": "2020-11-17T06:39:06Z",
          "updatedAt": "2020-11-17T06:39:06Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyMTQxNzc0",
          "commit": {
            "abbreviatedOid": "198671e"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-03T01:26:56Z",
          "updatedAt": "2020-11-03T01:26:56Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "nit: s/.../../",
              "createdAt": "2020-11-03T01:26:56Z",
              "updatedAt": "2020-11-04T19:27:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyOTgwNTc4",
          "commit": {
            "abbreviatedOid": "198671e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-04T01:12:02Z",
          "updatedAt": "2020-11-04T01:12:03Z",
          "comments": [
            {
              "originalPosition": 280,
              "body": "```suggestion\r\nSection 7.1 and ClientHelloInner..ServerHelloECHConf refers to the sequence of\r\n```",
              "createdAt": "2020-11-04T01:12:02Z",
              "updatedAt": "2020-11-04T19:27:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzY0MjIx",
          "commit": {
            "abbreviatedOid": "ef03c58"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-04T13:35:40Z",
          "updatedAt": "2020-11-04T13:35:41Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "```suggestion\r\n                      \"ech accept confirmation\",\r\n```",
              "createdAt": "2020-11-04T13:35:40Z",
              "updatedAt": "2020-11-04T19:27:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzY1NzAw",
          "commit": {
            "abbreviatedOid": "ef03c58"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-04T13:37:22Z",
          "updatedAt": "2020-11-04T13:37:23Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "```suggestion\r\nThe backend server begins by generating a message ServerHelloECHConf, which is identical\r\nin content to a ServerHello message with the exception that ServerHelloECHConf.random is\r\n```",
              "createdAt": "2020-11-04T13:37:22Z",
              "updatedAt": "2020-11-04T19:27:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzc1OTQ0",
          "commit": {
            "abbreviatedOid": "ef03c58"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-04T13:49:30Z",
          "updatedAt": "2020-11-04T13:49:30Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "The relevant text here notes that active attackers can distinguish real from fake ECH, which, as written, is probably still true with this change. (It could probe for the outer name, and then memcmp that to what's in a packet, for example.) So I might drop this TODO and address overhauling this section as part of #354.",
              "createdAt": "2020-11-04T13:49:30Z",
              "updatedAt": "2020-11-04T19:27:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNjQxMTkw",
          "commit": {
            "abbreviatedOid": "a90b642"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-04T18:46:29Z",
          "updatedAt": "2020-11-04T18:46:29Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "Done.",
              "createdAt": "2020-11-04T18:46:29Z",
              "updatedAt": "2020-11-04T19:27:04Z"
            }
          ]
        }
      ]
    },
    {
      "number": 355,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE1MDE0MjQ5",
      "title": "Bump HPKE-05 to -06",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/355",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-11-03T22:00:37Z",
      "updatedAt": "2021-04-16T19:57:57Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "384dc60929a56d5f743e1345ac5438a6607a19fc",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "hpke-06",
      "headRefOid": "8f7646d3157fe0b7b8c8dd79b12dbff5c9aee7de",
      "closedAt": "2020-11-03T22:01:25Z",
      "mergedAt": "2020-11-03T22:01:25Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "3b2b8cd7e8c10fadcd79e087238d67e44048584f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyOTA2MTI3",
          "commit": {
            "abbreviatedOid": "8f7646d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-03T22:01:21Z",
          "updatedAt": "2020-11-03T22:01:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 357,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE2OTIyMTk4",
      "title": "Correcting incorrect integer equivalents for ECH and outer_extensions",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/357",
      "state": "MERGED",
      "author": "sudheesh001",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Sudheesh Singanamalla <sudheesh@cloudflare.com>",
      "createdAt": "2020-11-06T18:54:57Z",
      "updatedAt": "2020-11-06T20:29:57Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3b2b8cd7e8c10fadcd79e087238d67e44048584f",
      "headRepository": "sudheesh001/draft-ietf-tls-esni",
      "headRefName": "int_fixes",
      "headRefOid": "06e3e2d2f7477bdf53bc44195f4a34168ee0cc71",
      "closedAt": "2020-11-06T19:02:40Z",
      "mergedAt": "2020-11-06T19:02:40Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "a70b9770debf7bc94570dd6250dbbb1929e1212f"
      },
      "comments": [
        {
          "author": "sudheesh001",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood This is ready for review.",
          "createdAt": "2020-11-06T18:58:40Z",
          "updatedAt": "2020-11-06T18:58:40Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think this is right. It's not an integer equivalent but a max value for sizing the enum.\r\nhttps://tools.ietf.org/html/rfc8446#section-3.5\r\n\r\n(The TLS presentation syntax is sometimes confusing.)",
          "createdAt": "2020-11-06T19:11:32Z",
          "updatedAt": "2020-11-06T19:11:32Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh, well that's annoying. And confusing. I'll revert this.",
          "createdAt": "2020-11-06T19:16:34Z",
          "updatedAt": "2020-11-06T19:16:34Z"
        },
        {
          "author": "sudheesh001",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah that was confusing. Apologies.",
          "createdAt": "2020-11-06T20:29:57Z",
          "updatedAt": "2020-11-06T20:29:57Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1NDE3Mjc3",
          "commit": {
            "abbreviatedOid": "06e3e2d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-06T19:02:35Z",
          "updatedAt": "2020-11-06T19:02:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 360,
      "id": "MDExOlB1bGxSZXF1ZXN0NTIyMDY2NzYy",
      "title": "Add is_client_hello_inner extension.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/360",
      "state": "MERGED",
      "author": "cbartle891",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Resolves a second issue detailed in https://github.com/tlswg/draft-ietf-tls-esni/issues/348. Replaces the empty encrypted_client_hello extension with a new extension, is_client_hello_inner, to indicate that the ClientHello is a ClientHelloInner.\r\n\r\nLet me know if I've completely misunderstood what the issue was or what the fix was supposed to be.",
      "createdAt": "2020-11-17T00:54:38Z",
      "updatedAt": "2020-11-19T00:06:14Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "496b50b24d466c24f2d895cce0a8eb3472fc2ba1",
      "headRepository": "cbartle891/draft-ietf-tls-esni",
      "headRefName": "cdb/is_client_hello_inner",
      "headRefOid": "82093ee4a61ec632afda4a8c0464c1ec26f66fdd",
      "closedAt": "2020-11-19T00:06:14Z",
      "mergedAt": "2020-11-19T00:06:14Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "c789ca42e2672dbdec20648866041f483d5082d5"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@cbartle891, would you remind rebasing?",
          "createdAt": "2020-11-17T22:16:23Z",
          "updatedAt": "2020-11-17T22:16:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@cbartle891, can you please resolve conflicts?",
          "createdAt": "2020-11-18T05:10:32Z",
          "updatedAt": "2020-11-18T05:10:32Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxOTQ0NDk0",
          "commit": {
            "abbreviatedOid": "98f1913"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "\ud83d\udc4d Thank you! I'll let others chime in and bike shed the name. My two main points of concern are (1) about the *focus* of the extension (does it simply instruct the server to apply the confirmation signal, or does it intend to do more?) and (2) what to do when both the outer and inner \"ech\" extensions are present.",
          "createdAt": "2020-11-17T01:01:51Z",
          "updatedAt": "2020-11-17T01:06:35Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "I don't feel strongly about the name, though this extension seems to me more about \"swizzling\" ServerHello.random (by setting the confirmation signal), and less about the fact that the CH is of type ClientHelloInner. Unless there's other things that backend servers need to do in response to a CHInner (beyond putting in the acceptance signal), I'd refocus this extension so it targets just that piece.",
              "createdAt": "2020-11-17T01:01:51Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            },
            {
              "originalPosition": 79,
              "body": "If it's empty, I think we can omit this piece.\r\n\r\n```suggestion\r\n```",
              "createdAt": "2020-11-17T01:03:31Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            },
            {
              "originalPosition": 105,
              "body": "What if both extensions are present? I suppose the server MUST abort with illegal_parameter in that case? (I see below that it's suggested for servers to ignore the inner one, but it seems better to fail loudly here, since this is not permitted client behavior.)",
              "createdAt": "2020-11-17T01:04:14Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            },
            {
              "originalPosition": 120,
              "body": "(As above, I'd abort in this case.)",
              "createdAt": "2020-11-17T01:05:10Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxOTUzMjI2",
          "commit": {
            "abbreviatedOid": "98f1913"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-17T01:24:34Z",
          "updatedAt": "2020-11-17T01:24:34Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "I basically had to do most of this entire change to understand what David meant by the \"swizzle\" comment, and I imagine it would be equally confusing for people who are new to this. To me, it's clearer to say \"this extension is just a sign that this ClientHello is an inner ClientHello,\" and then explain what the backend server does in reaction to that in that section.",
              "createdAt": "2020-11-17T01:24:34Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyMDY3Nzk5",
          "commit": {
            "abbreviatedOid": "98f1913"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-17T07:03:02Z",
          "updatedAt": "2020-11-17T07:03:03Z",
          "comments": [
            {
              "originalPosition": 151,
              "body": "My bike shed proposal is to use the following names:\r\n1. \"encrypted_client_hello\"\r\n2. \"ech_is_inner\"\r\n3. \"ech_outer_extensions\"\r\n\r\nThat way the extensions that are only meaningful to ECH have names that indicates as much.",
              "createdAt": "2020-11-17T07:03:03Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyMDcwMDU4",
          "commit": {
            "abbreviatedOid": "98f1913"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-17T07:07:55Z",
          "updatedAt": "2020-11-17T07:07:56Z",
          "comments": [
            {
              "originalPosition": 151,
              "body": "Ack, dangit, I forgot to change \"outer_extensions.\" Sorry about that!",
              "createdAt": "2020-11-17T07:07:55Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyMDczMDEy",
          "commit": {
            "abbreviatedOid": "98f1913"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-17T07:14:17Z",
          "updatedAt": "2020-11-17T07:14:18Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "> ... but it seems better to fail loudly here, since this is not permitted client behavior.\r\n\r\nThis seems to be true in general, but elsewhere in the draft we deal with client misbehavior by rejecting. For example, if ClientECH.cipher_suite isn't a valid cipher suite for the ECHConfig indicated by ClientECH.config_id, then the client-facing server skips this ECHConfig and moves on to the next. This done for \"don't stick out\" reasons. I think it makes sense to follow the same pattern here.\r\n\r\nTL;DR: I think the text is better as-is.",
              "createdAt": "2020-11-17T07:14:17Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyMDc1NjA1",
          "commit": {
            "abbreviatedOid": "98f1913"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-17T07:19:36Z",
          "updatedAt": "2020-11-17T07:19:36Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "But a difference in algorithm is not the same as an actual implementation bug on the client side. It could be because of a server misconfiguration. This edge case (sending both extensions) is a flat out bug, no?",
              "createdAt": "2020-11-17T07:19:36Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyMTI0MDM1",
          "commit": {
            "abbreviatedOid": "98f1913"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-17T08:30:33Z",
          "updatedAt": "2020-11-17T08:30:33Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "It doesn't add anything to the protocol, but should it be fatal? (I chose to ignore it just for leniency/flexibility but I'm fine with making it a fatal error instead.)",
              "createdAt": "2020-11-17T08:30:33Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyMTI1OTc4",
          "commit": {
            "abbreviatedOid": "98f1913"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-17T08:33:16Z",
          "updatedAt": "2020-11-17T08:33:16Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "I would argue that choosing a cipher suite other than one that is indicated by the ECHConfig is also an implementation bug. (Though I should add that I don't have a strong opinion about aborting or not here.)",
              "createdAt": "2020-11-17T08:33:16Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNTIwNDgw",
          "commit": {
            "abbreviatedOid": "98f1913"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-17T15:57:00Z",
          "updatedAt": "2020-11-17T15:57:00Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "I think other people need to weigh in here. @davidben, penny for your thoughts?",
              "createdAt": "2020-11-17T15:57:00Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNTUzOTQ5",
          "commit": {
            "abbreviatedOid": "98f1913"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-17T16:29:05Z",
          "updatedAt": "2020-11-17T16:29:06Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "I think let's require failure.",
              "createdAt": "2020-11-17T16:29:06Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyODYxODEw",
          "commit": {
            "abbreviatedOid": "98f1913"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "This is pretty good! Most of my suggestions are editorial.",
          "createdAt": "2020-11-17T22:21:38Z",
          "updatedAt": "2020-11-17T22:30:30Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "- Let's promote this subsubsection to a subsection and make it a subsection of {{encrypted-client-hello}}\r\n- In order to be consistent with the other subsections, I suggest using a title that's suggestive of the code points purpose. E.g., `Differentiating between the ClientHelloInner and the ClientHelloOuter`.",
              "createdAt": "2020-11-17T22:21:39Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            },
            {
              "originalPosition": 72,
              "body": "I like the name, for the record.",
              "createdAt": "2020-11-17T22:25:34Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            },
            {
              "originalPosition": 151,
              "body": "No biggy!",
              "createdAt": "2020-11-17T22:28:25Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzMTAxMzQ5",
          "commit": {
            "abbreviatedOid": "ff7374d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-18T04:46:54Z",
          "updatedAt": "2020-11-18T04:47:16Z",
          "comments": [
            {
              "originalPosition": 92,
              "body": "```suggestion\r\nIf the client offers the \"ech_is_inner\" extension ({{is-inner}})\r\nin addition to the \"encrypted_client_hello\" extension, the server MUST abort\r\nwith an \"illegal_parameter\" alert.\r\n```",
              "createdAt": "2020-11-18T04:46:54Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzMTAzNjUy",
          "commit": {
            "abbreviatedOid": "ff7374d"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T04:54:53Z",
          "updatedAt": "2020-11-18T04:54:53Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "> make it a subsection of {{encrypted-client-hello}}\r\n\r\nI'm not sure about this because `ech_is_inner` isn't part of the `encrypted_client_hello` extension.",
              "createdAt": "2020-11-18T04:54:53Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzMTAzOTU3",
          "commit": {
            "abbreviatedOid": "dd982fc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T04:56:00Z",
          "updatedAt": "2020-11-18T04:56:00Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "I'd leave it as-is for now. We can move it around later if needed.",
              "createdAt": "2020-11-18T04:56:00Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzMTA0Mzcw",
          "commit": {
            "abbreviatedOid": "dd982fc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T04:57:13Z",
          "updatedAt": "2020-11-18T04:57:13Z",
          "comments": [
            {
              "originalPosition": 106,
              "body": "```suggestion\r\n### ClientHelloInner Indication Extension {#is-inner}\r\n```",
              "createdAt": "2020-11-18T04:57:13Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzMTA5Mzky",
          "commit": {
            "abbreviatedOid": "4dc9cc9"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T05:13:32Z",
          "updatedAt": "2020-11-18T05:13:33Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "Fine with me.",
              "createdAt": "2020-11-18T05:13:33Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzMTA5NTc5",
          "commit": {
            "abbreviatedOid": "4dc9cc9"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-18T05:14:13Z",
          "updatedAt": "2020-11-18T05:14:13Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzOTc4NzI5",
          "commit": {
            "abbreviatedOid": "58b697f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-19T00:01:40Z",
          "updatedAt": "2020-11-19T00:01:41Z",
          "comments": [
            {
              "originalPosition": 136,
              "body": "```suggestion\r\nServers that support ECH play one of two roles, depending on the extension\r\n```",
              "createdAt": "2020-11-19T00:01:40Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzOTc5NzA4",
          "commit": {
            "abbreviatedOid": "58b697f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-19T00:03:49Z",
          "updatedAt": "2020-11-19T00:03:50Z",
          "comments": [
            {
              "originalPosition": 167,
              "body": "```suggestion\r\nclient by computing its ServerHello as described here. If both the \"ech_is_inner\" \r\nextension and \"encrypted_client_hello\" extensions are present in the ClientHello, \r\nthe backend server MUST abort with an \"illegal_parameter\" alert.\r\n```",
              "createdAt": "2020-11-19T00:03:50Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzOTc5Nzgw",
          "commit": {
            "abbreviatedOid": "58b697f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-19T00:04:00Z",
          "updatedAt": "2020-11-19T00:04:01Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "```suggestion\r\nUpon receipt of an \"ech_is_inner\" extension in a ClientHello, if the backend\r\n```",
              "createdAt": "2020-11-19T00:04:00Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzOTgwMDkz",
          "commit": {
            "abbreviatedOid": "dd95a13"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-19T00:04:48Z",
          "updatedAt": "2020-11-19T00:04:48Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "```suggestion\r\nand \"encrypted_client_hello\" extensions are present in the ClientHello, the backend \r\nserver MUST abort with an \"illegal_parameter\" alert.\r\n```",
              "createdAt": "2020-11-19T00:04:48Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzOTgwMTk3",
          "commit": {
            "abbreviatedOid": "dd95a13"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-19T00:05:05Z",
          "updatedAt": "2020-11-19T00:05:06Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "```suggestion\r\nextension and \"encrypted_client_hello\" extensions are present in the ClientHello,\r\n```",
              "createdAt": "2020-11-19T00:05:05Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzOTgwNDE4",
          "commit": {
            "abbreviatedOid": "20d8af3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-19T00:05:38Z",
          "updatedAt": "2020-11-19T00:05:38Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "```suggestion\r\nand \"encrypted_client_hello\" extensions are present in the ClientHello, the backend\r\n```",
              "createdAt": "2020-11-19T00:05:38Z",
              "updatedAt": "2020-11-19T00:05:43Z"
            }
          ]
        }
      ]
    },
    {
      "number": 361,
      "id": "MDExOlB1bGxSZXF1ZXN0NTIyNzg0MTY0",
      "title": "Copy the entire extension on HRR + GREASE for now.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/361",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a temporary mitigation for the compatibility risks from #358, as\r\nany clients experimenting with GREASE will impact servers that otherwise\r\ndon't expect ECH. To resolve this issue overall, we may need a more\r\ninvolved solution.",
      "createdAt": "2020-11-18T00:05:46Z",
      "updatedAt": "2020-11-19T12:08:37Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9f485e939b99814f9a73c1e94ec5e44f0a8d4806",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "hrr-bandaid",
      "headRefOid": "f288d98e489d2603244b11626beabcb73850a074",
      "closedAt": "2020-11-19T12:08:37Z",
      "mergedAt": "2020-11-19T12:08:37Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "8b2dd889525ac50c703d9c3267d1c61db6d7a81c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzODQyNDg0",
          "commit": {
            "abbreviatedOid": "f288d98"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T20:19:35Z",
          "updatedAt": "2020-11-18T20:19:36Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I'm confused by the word \"match\" here. Do you mean to say that greased ECH looks different from real ECH after HRR?",
              "createdAt": "2020-11-18T20:19:35Z",
              "updatedAt": "2020-11-18T20:19:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzODUwNjA4",
          "commit": {
            "abbreviatedOid": "f288d98"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T20:30:58Z",
          "updatedAt": "2020-11-18T20:30:59Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Yes. This is #358. There is a potential compatibility issue with changing CH2's ECH extension when talking to a server that doesn't expect ECH. We also need to change CH2's ECH extension when actually speaking ECH.\r\n\r\nThis PR resolves the compatibility issue, just so we can get this out of the way of draft-09. It does not resolve the bulk of #358 which interacts with every other HRR problem.",
              "createdAt": "2020-11-18T20:30:58Z",
              "updatedAt": "2020-11-18T20:30:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzODYyNTE2",
          "commit": {
            "abbreviatedOid": "f288d98"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T20:47:46Z",
          "updatedAt": "2020-11-18T20:47:47Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I think this is a good idea for ECH-09, I'm merely suggesting that the wording of the OPEN ISSUE could be clearer.",
              "createdAt": "2020-11-18T20:47:46Z",
              "updatedAt": "2020-11-18T20:47:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzODc4ODQw",
          "commit": {
            "abbreviatedOid": "f288d98"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T21:10:39Z",
          "updatedAt": "2020-11-18T21:10:40Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Ah. What wording would you prefer? Perhaps: \"OPEN ISSUE: The extension value is not copied when sending a real ECH extension. See issue #358.\"",
              "createdAt": "2020-11-18T21:10:39Z",
              "updatedAt": "2020-11-18T21:10:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzOTMwODYw",
          "commit": {
            "abbreviatedOid": "f288d98"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T22:23:24Z",
          "updatedAt": "2020-11-18T22:23:24Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "That's better, but I think we should make this an explicit don't-stick-out issue. Slight revision: \"OPEN ISSUE: The extension value is not copied when sending a real ECH extension, causing this code path to stick out. See issue #358.\"\r\n\r\n",
              "createdAt": "2020-11-18T22:23:24Z",
              "updatedAt": "2020-11-18T22:23:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzOTM5NTY4",
          "commit": {
            "abbreviatedOid": "f288d98"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T22:38:02Z",
          "updatedAt": "2020-11-18T22:38:02Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "It's not just about sticking out. ECH acceptance and ECH rejection currently also violate the RFC8446 requirement. This PR doesn't change it because it would break them, and it's mostly okay compatibility-wise because it would only affect servers that have opted in via DNS. (But only mostly. The recovery flow on a strictly enforcing server is broken.)",
              "createdAt": "2020-11-18T22:38:02Z",
              "updatedAt": "2020-11-18T22:38:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzOTM5ODUx",
          "commit": {
            "abbreviatedOid": "f288d98"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T22:38:32Z",
          "updatedAt": "2020-11-18T22:38:33Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "That's why I specifically wanted this to just be a quick summary and then a pointer to the issue where we'll capture the actual discussion in a more fluid form.",
              "createdAt": "2020-11-18T22:38:32Z",
              "updatedAt": "2020-11-18T22:38:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzOTUyMzgy",
          "commit": {
            "abbreviatedOid": "f288d98"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T23:02:25Z",
          "updatedAt": "2020-11-18T23:02:25Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Ah I see, you wanted the comment to reflect that as well. It's a big vague, but I'm fine leaving it as is.",
              "createdAt": "2020-11-18T23:02:25Z",
              "updatedAt": "2020-11-18T23:02:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0MzY3MTI5",
          "commit": {
            "abbreviatedOid": "f288d98"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Given the compatibility concerns @davidben found, and based on discussion in IETF 109, I think this is prudent to merge for -09. Doing so now.",
          "createdAt": "2020-11-19T12:07:41Z",
          "updatedAt": "2020-11-19T12:08:30Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Yeah, I think the comment is fine as-is.",
              "createdAt": "2020-11-19T12:07:41Z",
              "updatedAt": "2020-11-19T12:08:30Z"
            }
          ]
        }
      ]
    },
    {
      "number": 362,
      "id": "MDExOlB1bGxSZXF1ZXN0NTIzNDAzMjk2",
      "title": "Bind the context handle to encrypted payload",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/362",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #326.",
      "createdAt": "2020-11-18T18:56:37Z",
      "updatedAt": "2021-04-16T19:57:59Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9f485e939b99814f9a73c1e94ec5e44f0a8d4806",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "cjpatton/context-handle-binding",
      "headRefOid": "a2e213788b9673e9758b913371f76f4f949a42e6",
      "closedAt": "2020-11-18T23:57:21Z",
      "mergedAt": "2020-11-18T23:57:21Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "496b50b24d466c24f2d895cce0a8eb3472fc2ba1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzODEwMzM5",
          "commit": {
            "abbreviatedOid": "f85ca22"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T19:38:08Z",
          "updatedAt": "2020-11-18T19:39:04Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I think we're better off writing this a bit more explicitly in TLS syntax, given we already have way to describe the length prefixes.\r\n\r\nAlternatively, should we say it's the ClientHelloOuter, but with the `payload` field of the encrypted_client_hello extension replaced with the empty string?",
              "createdAt": "2020-11-18T19:38:09Z",
              "updatedAt": "2020-11-18T22:58:34Z"
            },
            {
              "originalPosition": 50,
              "body": "ClientHelloOuterAAD is only used to compute ech_aad anyway. Seems the new text would be better off in {{authenticating-outer}} and then we only need to cite one section and variable name as before.",
              "createdAt": "2020-11-18T19:38:57Z",
              "updatedAt": "2020-11-18T22:58:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzODI2MTg3",
          "commit": {
            "abbreviatedOid": "f85ca22"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T19:59:02Z",
          "updatedAt": "2020-11-18T19:59:02Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I think using TLS syntax is a good idea.",
              "createdAt": "2020-11-18T19:59:02Z",
              "updatedAt": "2020-11-18T22:58:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzOTQ5MTQ0",
          "commit": {
            "abbreviatedOid": "f85ca22"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T22:55:44Z",
          "updatedAt": "2020-11-18T22:55:44Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Done.",
              "createdAt": "2020-11-18T22:55:44Z",
              "updatedAt": "2020-11-18T22:58:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzOTQ5Mjg4",
          "commit": {
            "abbreviatedOid": "f85ca22"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-18T22:56:00Z",
          "updatedAt": "2020-11-18T22:56:01Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Done.",
              "createdAt": "2020-11-18T22:56:00Z",
              "updatedAt": "2020-11-18T22:58:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzOTc2ODg5",
          "commit": {
            "abbreviatedOid": "a2e2137"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-18T23:57:14Z",
          "updatedAt": "2020-11-18T23:57:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 363,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI0OTYxNzU1",
      "title": "Move some text around in Server Behavior.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/363",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The text for servers rejecting both extensions present is under Backend\r\nServer, but the Server Behavior text gates that section under just the\r\none extension. Likewise, the client-facing server text allows for both\r\nextensions to be present.\r\n\r\nMove the illegal_parameter text around and write out the four cases.",
      "createdAt": "2020-11-20T21:29:49Z",
      "updatedAt": "2020-11-20T22:10:31Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "8b2dd889525ac50c703d9c3267d1c61db6d7a81c",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "both-xtns",
      "headRefOid": "771c948abfff773df1044ff86f8640834a00aa16",
      "closedAt": "2020-11-20T22:10:31Z",
      "mergedAt": "2020-11-20T22:10:31Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "44aab0c68e1d39f41377db648aa1e6bf0481c483"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 364,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI0OTk3Nzcz",
      "title": "Remove backticks from empty string literal.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/364",
      "state": "MERGED",
      "author": "dmcardle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The backtick-quoted empty string translates to \"\"\"\" in the text output.",
      "createdAt": "2020-11-20T22:59:53Z",
      "updatedAt": "2020-11-21T18:04:52Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "44aab0c68e1d39f41377db648aa1e6bf0481c483",
      "headRepository": "dmcardle/draft-ietf-tls-esni",
      "headRefName": "master",
      "headRefOid": "c8835c0f1b68bfbe1dfdaf33bb5d7d42d4c3df35",
      "closedAt": "2020-11-21T18:04:52Z",
      "mergedAt": "2020-11-21T18:04:51Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "13f66e2e01999ccfa341d47f292416fe9f01f772"
      },
      "comments": [
        {
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Not sure if this is the best solution, but the quadruple quote in the txt is goofy.",
          "createdAt": "2020-11-20T23:04:04Z",
          "updatedAt": "2020-11-20T23:04:04Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This seems fine, yeah. Thanks for catching it!",
          "createdAt": "2020-11-21T18:04:48Z",
          "updatedAt": "2020-11-21T18:04:48Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1OTg0MzY2",
          "commit": {
            "abbreviatedOid": "c8835c0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-21T18:04:39Z",
          "updatedAt": "2020-11-21T18:04:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 365,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI1MDE3NzMy",
      "title": "Quick editorial pass.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/365",
      "state": "MERGED",
      "author": "dmcardle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Tried to clarify some text, PTAL :)\r\n\r\nFor the backend server, I think the `ClientHelloInner..ServerHelloECHConf` notation is a little confusing (pedantically, shouldn't it be `...`?). Can't we just concatenate the two messages and call it a day?",
      "createdAt": "2020-11-21T00:05:45Z",
      "updatedAt": "2020-11-24T12:50:25Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "48662e26fbdc766471a211eb6038a742736fd69b",
      "headRepository": "dmcardle/draft-ietf-tls-esni",
      "headRefName": "dan-edits",
      "headRefOid": "efafbd8a696a35056df3540b746edd669eb3e9eb",
      "closedAt": "2020-11-24T12:50:25Z",
      "mergedAt": "2020-11-24T12:50:25Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "da3338fbcf62adb832445b8b3ce2c741f8f460b4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1OTg0NjMy",
          "commit": {
            "abbreviatedOid": "f692185"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "The simplified notation LGTM. @cjpatton, please have look!",
          "createdAt": "2020-11-21T18:08:16Z",
          "updatedAt": "2020-11-21T18:08:16Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NjAyNDc1",
          "commit": {
            "abbreviatedOid": "f692185"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "- I like `..` because it's consistent with RFC 8446 (See the key schedule section.)\r\n- `make` fails because of lines that exceed 80 characters.",
          "createdAt": "2020-11-23T15:49:13Z",
          "updatedAt": "2020-11-23T15:52:02Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "Actually, the `..` notation is meant to denote the sequence of messages between `ClientHelloInner` and `ServerHelloECHConf`. This sequence is empty here, but I think we should use the notation nonetheless, in order to be consistent with RFC8446.",
              "createdAt": "2020-11-23T15:49:14Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            },
            {
              "originalPosition": 141,
              "body": "If we revert the above change, don't forget to revert this change as well.",
              "createdAt": "2020-11-23T15:49:47Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NjA2ODU5",
          "commit": {
            "abbreviatedOid": "f692185"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-23T15:53:42Z",
          "updatedAt": "2020-11-23T15:53:42Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "I don\u2019t think this is necessary. || is more clear in this context given that the sequence is always empty.",
              "createdAt": "2020-11-23T15:53:42Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NjUzNDY4",
          "commit": {
            "abbreviatedOid": "f692185"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-23T16:40:25Z",
          "updatedAt": "2020-11-23T16:40:26Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "What about incorporating the CH1 hash? Isn't that also something that's implied by the `..` notation?",
              "createdAt": "2020-11-23T16:40:26Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NjkyNjI4",
          "commit": {
            "abbreviatedOid": "f692185"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-23T17:25:01Z",
          "updatedAt": "2020-11-23T17:25:02Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "In this section, it might be clearer to refer to `ECHConfig.contents.kem_id`, since `ECHConfig` has been defined, but `ECHConfigContents` only implicitly refers to `ECHConfig.contents`. (Here and below.)",
              "createdAt": "2020-11-23T17:25:02Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NzM4NTUw",
          "commit": {
            "abbreviatedOid": "f692185"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-23T18:26:02Z",
          "updatedAt": "2020-11-23T18:26:03Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "In other words, this needs to denotes the whole transcript from ClientHelloInner to ServerHelloECHConf, including the messages on the HRR path.",
              "createdAt": "2020-11-23T18:26:02Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NzYyOTgz",
          "commit": {
            "abbreviatedOid": "f692185"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-23T19:01:17Z",
          "updatedAt": "2020-11-23T19:01:17Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "(@chris-wood and I spoke offline and we agreed that the `..` notation should stay as-is.)",
              "createdAt": "2020-11-23T19:01:17Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2OTE3Mjc4",
          "commit": {
            "abbreviatedOid": "f692185"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-23T23:10:58Z",
          "updatedAt": "2020-11-23T23:10:58Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "I find the range syntax a bit confusing here. If there were messages in between, it's not clear to me which variant of those messages would be selected, or whether some transformation would be applied to them.\r\n\r\nI don't feel really strongly about this. Happy to revert it, but to be fully pedantic, I want to point out that RFC 8446 uses three dots between messages. I'll go ahead and use three dots here, unless two dots has a different meaning that I don't understand.",
              "createdAt": "2020-11-23T23:10:58Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2OTE4Nzkx",
          "commit": {
            "abbreviatedOid": "f692185"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-23T23:14:13Z",
          "updatedAt": "2020-11-23T23:14:14Z",
          "comments": [
            {
              "originalPosition": 141,
              "body": "Done!",
              "createdAt": "2020-11-23T23:14:14Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2OTI2ODI2",
          "commit": {
            "abbreviatedOid": "81a03a7"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-23T23:32:19Z",
          "updatedAt": "2020-11-23T23:32:20Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Agreed, made this change for the whole \"Offering ECH\" section.",
              "createdAt": "2020-11-23T23:32:19Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2OTQ3OTQw",
          "commit": {
            "abbreviatedOid": "81a03a7"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-24T00:25:01Z",
          "updatedAt": "2020-11-24T00:25:01Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "Oops, three dots is right! https://tools.ietf.org/html/rfc8446#section-7.1\r\n\r\nI think my dyslexic brain is removing  a dot. ",
              "createdAt": "2020-11-24T00:25:01Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2OTQ4NTky",
          "commit": {
            "abbreviatedOid": "81a03a7"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Looks good, modulo minor nits! ",
          "createdAt": "2020-11-24T00:26:46Z",
          "updatedAt": "2020-11-24T00:29:24Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "Is `ECHConfig.config.maximum_name_length` more appropriate here?",
              "createdAt": "2020-11-24T00:26:47Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            },
            {
              "originalPosition": 91,
              "body": "`ECHConfig.contents.maximum_name_length`?",
              "createdAt": "2020-11-24T00:27:00Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            },
            {
              "originalPosition": 100,
              "body": "`ECHConfig.contents.public_name`?",
              "createdAt": "2020-11-24T00:27:12Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            },
            {
              "originalPosition": 136,
              "body": "Nice catch!",
              "createdAt": "2020-11-24T00:27:56Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            },
            {
              "originalPosition": 49,
              "body": "Do these lines break 80 characters?",
              "createdAt": "2020-11-24T00:28:41Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2OTYxNzU0",
          "commit": {
            "abbreviatedOid": "81a03a7"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-24T01:01:31Z",
          "updatedAt": "2020-11-24T01:01:31Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Yep, good catch! Reflowing the paragraph in a new commit.",
              "createdAt": "2020-11-24T01:01:31Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2OTY1MTAz",
          "commit": {
            "abbreviatedOid": "0e9bc1a"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-24T01:10:32Z",
          "updatedAt": "2020-11-24T01:10:33Z",
          "comments": [
            {
              "originalPosition": 100,
              "body": "Done",
              "createdAt": "2020-11-24T01:10:32Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2OTY1MTIy",
          "commit": {
            "abbreviatedOid": "0e9bc1a"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-24T01:10:36Z",
          "updatedAt": "2020-11-24T01:10:37Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "Done",
              "createdAt": "2020-11-24T01:10:36Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2OTY1MTkx",
          "commit": {
            "abbreviatedOid": "0e9bc1a"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-24T01:10:48Z",
          "updatedAt": "2020-11-24T01:10:48Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "Seems reasonable, done.",
              "createdAt": "2020-11-24T01:10:48Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM3MDA0MTE5",
          "commit": {
            "abbreviatedOid": "0e9bc1a"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-11-24T01:40:43Z",
          "updatedAt": "2020-11-24T01:41:21Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "This line and the one below it are longer than 80 characters. (Sorry if this is annoying ... lines that are longer than 80 characters cause `make` to fail. In fact, you should be getting emails from CI telling you that the build is failing.)",
              "createdAt": "2020-11-24T01:40:43Z",
              "updatedAt": "2020-11-24T02:26:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM3MDI5Mzcz",
          "commit": {
            "abbreviatedOid": "efafbd8"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-24T02:27:34Z",
          "updatedAt": "2020-11-24T02:27:34Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "Aha, I hadn't run make in a few commits, my bad. Fixed now.",
              "createdAt": "2020-11-24T02:27:34Z",
              "updatedAt": "2020-11-24T02:27:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM3MDM2OTE1",
          "commit": {
            "abbreviatedOid": "efafbd8"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2020-11-24T02:48:18Z",
          "updatedAt": "2020-11-24T02:48:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 366,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI1OTE1MDIz",
      "title": "Editorial pass and advance ECHConfig.version to ECH-09",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/366",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-11-23T18:22:49Z",
      "updatedAt": "2021-04-16T19:58:00Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "13f66e2e01999ccfa341d47f292416fe9f01f772",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "cjpatton/edit",
      "headRefOid": "3078ffac538fe8b2fe8dc151a5d2f1f308336cc4",
      "closedAt": "2020-11-23T22:13:39Z",
      "mergedAt": "2020-11-23T22:13:39Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "7cf17ec836c19bf05778f693b5be935331317713"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2ODg2MzQx",
          "commit": {
            "abbreviatedOid": "3078ffa"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-23T22:13:34Z",
          "updatedAt": "2020-11-23T22:13:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 367,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI2MDQ3ODEx",
      "title": "Specify the backend server's behavior when \"ech_is_inner\" is not empty",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/367",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "~It's sufficient to ignore it, I think.~ The backend server enforces the extension's emptiness. ",
      "createdAt": "2020-11-23T23:01:06Z",
      "updatedAt": "2021-06-11T17:36:12Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "7cf17ec836c19bf05778f693b5be935331317713",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "cjpatton/nits",
      "headRefOid": "d1a244474073af56b816553d94cc6a6c0d995a97",
      "closedAt": "2020-11-23T23:21:49Z",
      "mergedAt": "2020-11-23T23:21:49Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "48662e26fbdc766471a211eb6038a742736fd69b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2OTIyMjM5",
          "commit": {
            "abbreviatedOid": "d1a2444"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-23T23:21:45Z",
          "updatedAt": "2020-11-23T23:21:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 368,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI2MDc1MzM3",
      "title": "Fix ClientHelloOuterAAD.outer_hello length",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/368",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Per RFC8446, Section 4, handshake messages, including ClientHello, may\r\nbe up to 2^24-1 bytes in length.",
      "createdAt": "2020-11-24T00:21:41Z",
      "updatedAt": "2021-06-11T17:36:14Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "48662e26fbdc766471a211eb6038a742736fd69b",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "cjpatton/inner-hello-aad-length",
      "headRefOid": "96874f4420b02045c82e53e4ac596cf95784d282",
      "closedAt": "2020-11-24T12:51:19Z",
      "mergedAt": "2020-11-24T12:51:19Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "314f2067bc540a5992fb37496746355086956c3b"
      },
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "(I think the maximum possible ClientHello is 2^17 bytes plus some loose change, but who's counting? :-) 2^24-1 is less thinking.)",
          "createdAt": "2020-11-24T00:34:52Z",
          "updatedAt": "2020-11-24T00:35:15Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2OTQ3MjE2",
          "commit": {
            "abbreviatedOid": "96874f4"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-24T00:23:11Z",
          "updatedAt": "2020-11-24T00:23:11Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM3NDU5MzQ5",
          "commit": {
            "abbreviatedOid": "96874f4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-24T12:51:15Z",
          "updatedAt": "2020-11-24T12:51:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 370,
      "id": "MDExOlB1bGxSZXF1ZXN0NTMwNjg0NjE0",
      "title": "Clarify ClientHelloOuterAAD serialization",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/370",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Clarifies that serialization of this structure doesn't include the message type and length. We do the same thing for the serialization of EncodedClientHelloInner, but this makes it explicit in case it's not clear from context.",
      "createdAt": "2020-12-02T01:49:37Z",
      "updatedAt": "2021-06-11T17:36:17Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "314f2067bc540a5992fb37496746355086956c3b",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "cjpatton/nit",
      "headRefOid": "e67e59b6c7bc94120aeb58eade15930e9ee9c74b",
      "closedAt": "2020-12-02T02:55:55Z",
      "mergedAt": "2020-12-02T02:55:55Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "7a5c68faf36dcc749a4ab763bf3a600239849b4f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyNDYwNzMy",
          "commit": {
            "abbreviatedOid": "e67e59b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-02T02:55:50Z",
          "updatedAt": "2020-12-02T02:55:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 371,
      "id": "MDExOlB1bGxSZXF1ZXN0NTM3MTc4MTMy",
      "title": "Clarify privacy goal scope",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/371",
      "state": "MERGED",
      "author": "kjacobs-moz",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #369",
      "createdAt": "2020-12-11T17:22:16Z",
      "updatedAt": "2020-12-16T14:31:24Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "7a5c68faf36dcc749a4ab763bf3a600239849b4f",
      "headRepository": "kjacobs-moz/draft-ietf-tls-esni",
      "headRefName": "clarify-goal-scope",
      "headRefOid": "054eed3e0e95322c3ca8f38a87014e21de83806b",
      "closedAt": "2020-12-16T14:31:23Z",
      "mergedAt": "2020-12-16T14:31:23Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "985f09bd6f53425b5b3cf009a826f786f47ae412"
      },
      "comments": [
        {
          "author": "kjacobs-moz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Done. Thanks!",
          "createdAt": "2020-12-11T18:10:35Z",
          "updatedAt": "2020-12-11T18:10:35Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwMzg2NTIw",
          "commit": {
            "abbreviatedOid": "5c8665c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This LGTM. I have a slight rephrasing, but feel free to reject!",
          "createdAt": "2020-12-11T18:01:06Z",
          "updatedAt": "2020-12-11T18:05:10Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nAttacks that rely on non-ECH traffic to infer server identity in an ECH connection are \r\nout of scope for this document. For example, a client that connects to a particular host \r\nprior to ECH deployment may later resume a connection to that same host after ECH \r\ndeployment, thereby linking the resulting ECH connection to the original non-ECH \r\nconnection.\r\n```",
              "createdAt": "2020-12-11T18:04:45Z",
              "updatedAt": "2020-12-11T18:09:06Z"
            }
          ]
        }
      ]
    },
    {
      "number": 372,
      "id": "MDExOlB1bGxSZXF1ZXN0NTM5ODcyODkz",
      "title": "Bump HPKE-06 to -07",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/372",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "TODO: Ensure that the section numbers referenced in the HPKE draft are still correct.",
      "createdAt": "2020-12-14T23:49:16Z",
      "updatedAt": "2021-04-16T19:57:14Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "7a5c68faf36dcc749a4ab763bf3a600239849b4f",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "bump-hpke",
      "headRefOid": "7d2a4e6ec5d56fb0e22325bba6993381eb7b1fc2",
      "closedAt": "2020-12-16T14:28:55Z",
      "mergedAt": "2020-12-16T14:28:55Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "78b75e6cf34eabb6435a99132cc70bbe5be15fa9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNzM4NTU2",
          "commit": {
            "abbreviatedOid": "9db02ad"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-16T14:28:19Z",
          "updatedAt": "2020-12-16T14:28:20Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "These are the same in the latest draft. :-)\r\n```suggestion\r\n```",
              "createdAt": "2020-12-16T14:28:19Z",
              "updatedAt": "2020-12-16T14:28:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNzM5MDQ0",
          "commit": {
            "abbreviatedOid": "7d2a4e6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-16T14:28:51Z",
          "updatedAt": "2020-12-16T14:28:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 376,
      "id": "MDExOlB1bGxSZXF1ZXN0NTYxNDczNDQw",
      "title": "Move to a key identity in lieu of the config identifier hash.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/376",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We may want to change how we deal with GREASE (does a randomly selected byte stick out?), but this should address the issue for now. I think we can (should) treat these issues separately, and focus just on the `key_id` simplification here.\r\n\r\nCloses #375.\r\n\r\ncc @davidben, @cjpatton, @martinthomson, @ekr",
      "createdAt": "2021-01-26T01:48:24Z",
      "updatedAt": "2021-02-15T20:08:02Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "ee94206ba488d702a9acae30386875e14a5bb2a7",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/config_id-to-key_id",
      "headRefOid": "ce8a04539acf0655a87ed57aa422c795aa8c6fd6",
      "closedAt": "2021-02-15T20:08:01Z",
      "mergedAt": "2021-02-15T20:08:01Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "c1a3d71f20f6fa69da00fa5ee7fa1a11abc291de"
      },
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "My intuition is that one byte is too short; I think 32 bits would be wiser. However, this is a slightly less serious problem than usual because we can rev the ECHConfig version number and the ECH extension if we find something longer is needed.",
          "createdAt": "2021-01-26T02:32:34Z",
          "updatedAt": "2021-01-26T02:32:34Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> My intuition is that one byte is too short; I think 32 bits would be wiser. However, this is a slightly less serious problem than usual because we can rev the ECHConfig version number and the ECH extension if we find something longer is needed.\r\n\r\nYep, that sounds reasonable to me.",
          "createdAt": "2021-01-26T02:34:44Z",
          "updatedAt": "2021-01-26T02:34:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> But in order to minimize the collision probability, we ought to stick with the current length of 8 bytes.\r\n\r\nThis is somewhat of a bike shed, but 8 bytes seems quite large for something that will only have a handful of possible values at any given point in time. Is there a reason to make this longer beyond the performance cost of decryption failing as a result of collisions?",
          "createdAt": "2021-01-26T18:00:37Z",
          "updatedAt": "2021-01-26T18:00:37Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> This is somewhat of a bike shed, but 8 bytes seems quite large for something that will only have a handful of possible values at any given point in time. Is there a reason to make this longer beyond the performance cost of decryption failing as a result of collisions?\r\n\r\nI guess the only reason I can see is that we've settled on q^2 / 2^64 as our threshold for operational risks. In particular, the \"acceptance\" signal in the SH.random is 8 bytes (https://tools.ietf.org/html/draft-ietf-tls-esni-09#section-10.7). I suppose we could get away with a smaller identifier, since the q is much smaller in this case.\r\n\r\n",
          "createdAt": "2021-01-26T18:14:37Z",
          "updatedAt": "2021-01-26T18:14:37Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I guess the only reason I can see is that we've settled on q^2 / 2^64 as our threshold for operational risks. In particular, the \"acceptance\" signal in the SH.random is 8 bytes (https://tools.ietf.org/html/draft-ietf-tls-esni-09#section-10.7). I suppose we could get away with a smaller identifier, since the q is much smaller in this case.\r\n\r\nThis seems different from acceptance signal collision, which actually causes breakage. In contrast, a key_id collision here just means that the server wastes cycles attempting decryption, right? ",
          "createdAt": "2021-01-26T18:16:07Z",
          "updatedAt": "2021-01-26T18:16:07Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> This seems different from acceptance signal collision, which actually causes breakage. In contrast, a key_id collision here just means that the server wastes cycles attempting decryption, right?\r\n\r\nA config collision is bad because the server has to figure out which config the client used. It can only do so by trial decryption.",
          "createdAt": "2021-01-26T18:17:43Z",
          "updatedAt": "2021-01-26T18:17:43Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> A config collision is bad because the server has to figure out which config the client used. It can only do so by trial decryption.\r\n\r\nEh? If there's a collision, the server *knows* which key to try (the one it collided with!), and it will do so, fail to decrypt, and move on as per usual. (There's no trial decryption here, but maybe I'm missing something.)",
          "createdAt": "2021-01-26T18:19:08Z",
          "updatedAt": "2021-01-26T18:19:08Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just to put a fine point on this: the spec SHOULD NOT require that implementations support trial decryption. In particular, we ought to ensure that, with high probability, configuration identifiers don't collide. A one-byte, randomly-generated identifier would make collisions inevitable, meaning that implementations will have to support trial decryption.",
          "createdAt": "2021-01-26T18:52:26Z",
          "updatedAt": "2021-01-26T18:52:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Just to put a fine point on this: the spec SHOULD NOT require that implementations support trial decryption. In particular, we ought to ensure that, with high probability, configuration identifiers don't collide. A one-byte, randomly-generated identifier would make collisions inevitable, meaning that implementations will have to support trial decryption.\r\n\r\nYeah, that's reasonable. If we're going to abide by this, then the ID needs to be at least 8 bytes. I'd be fine with that that for now assuming others are too. (@ekr suggested it be longer at the top anyway, so many we should just do it.)",
          "createdAt": "2021-01-26T18:53:55Z",
          "updatedAt": "2021-01-27T13:15:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@cjpatton we're now at 8 bytes :-) ",
          "createdAt": "2021-01-26T18:57:28Z",
          "updatedAt": "2021-01-26T18:57:28Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> Just to put a fine point on this: the spec SHOULD NOT require that implementations support trial decryption. In particular, we ought to ensure that, with high probability, configuration identifiers don't collide. A one-byte, randomly-generated identifier would make collisions inevitable, meaning that implementations will have to support trial decryption.\r\n\r\nI don't think one-byte necessary collides. First, note that the number of configs a server needs to have at a time is relatively small. Past the config's DNS TTL, you can retire it. That means you only need O(dns_ttl / time_between_rotation) configs at once. (From #177, I think the exact value is 1 + ceil(dns_ttl / time_between_rotation). Maybe add a little bit of leeway for people using stale DNS caches, though note we have a recovery flow so you only need to cover most, not all, of stale caches.) This means we don't need to worry about that many values.\r\n\r\nAdditionally, everything here is server-allocated. Whether you're worried about a birthday bound depends on how you allocate IDs. If it's random, you have a birthday bound, yes. If you cycle through a counter, you get the full range. (Compare how QUIC and DTLS 1.3 only send the low-order bits of the epoch.) If it's random, but you check for duplicates at key issuance, you also get the full range.\r\n\r\nThe counters or duplicate checks are trickier to issue, of course, though you can implement the trial decryption as a safety net. As of #344, the trial decryption and config_id modes are already unified. Specifically, decryption failure falls back to the outer ClientHello.",
          "createdAt": "2021-01-26T21:19:58Z",
          "updatedAt": "2021-01-26T21:19:58Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with everything you said, but want to drill in on this:\r\n\r\n> The counters or duplicate checks are trickier to issue, of course, though you can implement the trial decryption as a safety net. As of #344, the trial decryption and config_id modes are already unified. Specifically, decryption failure falls back to the outer ClientHello.\r\n\r\nThis seems to be key. I agree that the fallback case is clear and well understood, though one consideration is the case wherein a client attempts GREASE to a server that actually supports ECH. The probability of collision in that scenario is high, and if that scenario happens often, then decryption failure and fallback to the outer CH happens quite regularly. Bumping the length back to eight bytes removes the collision probability for that scenario, I think. \r\n\r\nI'd like to propose we treat the two problems here separately. That is, let's first see if we can land the key ID change (from a client-computed hash to a server-selected ID). And then let's see if we can safely make that ID smaller in size. I don't think we need to address both here. Would that work?",
          "createdAt": "2021-01-26T22:46:03Z",
          "updatedAt": "2021-01-26T22:46:03Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that the only thing that pushes toward a larger identifier space for me is the risk of grease colliding with an active key.  I agree with David, that your likely number of keys is ~2 (I might go as high as 4 if the server is in an extended period of offering two types of KEM).  With a one-byte identifier, that's only 1/64 greased sessions hitting the expensive decryption code.\r\n\r\nFlexibility here seems appealing, but I'm not sure that this is a place that needs it.  Operationally, this seems very much dependent on centralization, so I'm not buying any story based on loose coordination.  I also note that very small spaces reduce the options servers have for targeted tracking through the use of keys (though it is impossible to eliminate tracking, small spaces make the cost higher to operate tracking at any reasonable scale).\r\n\r\nThat is why I was motivated to go as low as 1 byte.  If you prefer a much lower probability of having to deal with failed decryption in response to greasing, then 2 bytes gets that down to lower than your likely failed connection rate at 1/16k.",
          "createdAt": "2021-01-27T05:40:18Z",
          "updatedAt": "2021-01-27T05:43:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> With a one-byte identifier, that's only 1/64 greased sessions hitting the expensive decryption code.\r\n\r\nIndeed, this is why I propose we separate these issues. Specifically, let's use this PR to land the server-chosen key ID, and then make it smaller (as needed) in a followup change. (Personally, I'm fine with one, two, or four bytes here, as I think the decryption failure case is unavoidable.) I'll file an issue for the size of the ID in a bit.\r\n\r\n@davidben, @martinthomson, @ekr, @cjpatton: what say you? :-)",
          "createdAt": "2021-01-27T13:06:38Z",
          "updatedAt": "2021-01-27T14:07:39Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> Happy to have the identifier discussion separately. It is unfortunately not important or clear enough to lead to easy agreement. I can live with any outcome.\r\n\r\nDitto.",
          "createdAt": "2021-01-29T18:28:51Z",
          "updatedAt": "2021-01-29T18:28:51Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc2NTkyNTI0",
          "commit": {
            "abbreviatedOid": "15d8adb"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "If we're going to use a single byte to identify an ECH config, then we should choose the byte deterministically. But because this may complicate greasing (the grease client needs to know the procedure by which identities are chosen), my preference would be to randomly generate it. But in order to minimize the collision probability, we ought to stick with the current length of 8 bytes.",
          "createdAt": "2021-01-26T17:33:09Z",
          "updatedAt": "2021-01-26T17:55:38Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Why this name change?",
              "createdAt": "2021-01-26T17:33:09Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            },
            {
              "originalPosition": 14,
              "body": "IMO it's a bit tidier to have `cipher_suites` immediately precede the `kem_id`.",
              "createdAt": "2021-01-26T17:37:01Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            },
            {
              "originalPosition": 163,
              "body": "Whether this sticks out depends on how the real `key_id` is chosen. If chosen randomly then we're golden. However the chance of two randomly chosen key ids colliding is high.",
              "createdAt": "2021-01-26T17:48:58Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            },
            {
              "originalPosition": 53,
              "body": "Why `key_id` instead of `config_id`? The new name sounds as if it should be possible to have a single key used by multiple configs, but what we actually want is a handle with which the server can resolve which config to use.",
              "createdAt": "2021-01-26T17:51:14Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc2NjEyOTgy",
          "commit": {
            "abbreviatedOid": "15d8adb"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-26T17:56:39Z",
          "updatedAt": "2021-01-26T17:56:40Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I don't have a strong feeling here. I think the only important bit is that the kem_id precedes the public key.",
              "createdAt": "2021-01-26T17:56:39Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc2NjEzMjcw",
          "commit": {
            "abbreviatedOid": "15d8adb"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-26T17:56:59Z",
          "updatedAt": "2021-01-26T17:56:59Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "It seems to capture the intent of the struct better.",
              "createdAt": "2021-01-26T17:56:59Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc2NjE0NTU2",
          "commit": {
            "abbreviatedOid": "15d8adb"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-26T17:58:24Z",
          "updatedAt": "2021-01-26T17:58:24Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Since the identifier corresponds primarily to the HPKE public key, and not the public name et al. (If we lifted the key_id *out* of the HpkeKeyConfig, I think config_id would be better.)",
              "createdAt": "2021-01-26T17:58:24Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc2Njg3NTk5",
          "commit": {
            "abbreviatedOid": "513617a"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I believe that `key_id` should be a U8-prefixed string, just like `config_id` was. The spec currently allows for implementations to send an empty `ClientECH.config_id`, e.g., in \"local discovery mode\" (https://tools.ietf.org/html/draft-ietf-tls-esni-09#section-7.1).",
          "createdAt": "2021-01-26T19:27:01Z",
          "updatedAt": "2021-01-26T22:47:16Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "SHOULD instead of MAY?",
              "createdAt": "2021-01-26T19:28:03Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            },
            {
              "originalPosition": 14,
              "body": "My thinking is that we should minimize changes to the ECHConfig structure, since the less changes we make the easier it will be to support multiple versions. Concretely, I would revert changes that re-order parameter unless there's a compelling reason to reorder them.",
              "createdAt": "2021-01-26T19:29:31Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            },
            {
              "originalPosition": 53,
              "body": "Perhaps another way to resolve this would be to change `key_id` to simply `id`. The `key_` prefix seems a bit redundant.",
              "createdAt": "2021-01-26T22:32:44Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            },
            {
              "originalPosition": 154,
              "body": "Like we did for config_id, we could avoid re-transmitting the key_id by changing its type to a U8-prefixed string. IIRC there were upsides to not re-transmitting config_id.",
              "createdAt": "2021-01-26T22:42:21Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc2OTk4MzQ2",
          "commit": {
            "abbreviatedOid": "513617a"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-27T05:38:49Z",
          "updatedAt": "2021-01-27T05:38:49Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Any change is a change and they are all equally not-free, so minimizing changes is not a goal I would worry about.  In terms of ordering, I prefer what @chris-wood proposed.",
              "createdAt": "2021-01-27T05:38:49Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3MzE2NzE5",
          "commit": {
            "abbreviatedOid": "513617a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-27T13:09:27Z",
          "updatedAt": "2021-01-27T13:09:28Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "We could do that, but then ClientECH would either have an inconsistently named field (key_id) or an ambiguously named field (id). I'd prefer to keep key_id, but in the interest of minimizing changes in this PR, I'll revert to config_id.",
              "createdAt": "2021-01-27T13:09:27Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3MzIzNDg5",
          "commit": {
            "abbreviatedOid": "2aa42e0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-27T13:17:26Z",
          "updatedAt": "2021-01-27T13:17:26Z",
          "comments": [
            {
              "originalPosition": 154,
              "body": "One upside is that the server doesn't have to check them for equality against HRR, but there's already a check for the cipher_suite field, so this seems like not a stretch.",
              "createdAt": "2021-01-27T13:17:26Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3MzI1Njc4",
          "commit": {
            "abbreviatedOid": "2aa42e0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-27T13:19:57Z",
          "updatedAt": "2021-01-27T13:19:57Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "That would align this with GREASE, which seems like a fine thing to do. (That is, in both GREASE and optional configs, the ID would be random.)",
              "createdAt": "2021-01-27T13:19:57Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3MzY5NDQz",
          "commit": {
            "abbreviatedOid": "766001f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-27T14:06:41Z",
          "updatedAt": "2021-01-27T14:06:42Z",
          "comments": [
            {
              "originalPosition": 154,
              "body": "I reverted this change, too. It's now length prefixed so the HRR case is empty. We can discuss the size of the ID in a separate issue.",
              "createdAt": "2021-01-27T14:06:42Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3MzcyMTg2",
          "commit": {
            "abbreviatedOid": "766001f"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM but I would split out the technical change from the refactor of the structures.",
          "createdAt": "2021-01-27T14:09:21Z",
          "updatedAt": "2021-01-27T14:10:48Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "So when is empty valid?",
              "createdAt": "2021-01-27T14:09:21Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            },
            {
              "originalPosition": 96,
              "body": "```suggestion\r\n: The ECHConfigContents.key_config.config_id for the chosen ECHConfig.\r\n```",
              "createdAt": "2021-01-27T14:10:27Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3NTQ0OTQ0",
          "commit": {
            "abbreviatedOid": "766001f"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-27T16:47:45Z",
          "updatedAt": "2021-01-27T16:47:46Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "Why change the wire format of the ECH extension? We might end up changing the type of `config_id` anyway, in which case the point is moot. However, for now, I think we should keep the extension parameters in the same order.",
              "createdAt": "2021-01-27T16:47:45Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3NTU2OTE3",
          "commit": {
            "abbreviatedOid": "3fa9d47"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-27T16:59:35Z",
          "updatedAt": "2021-01-27T16:59:35Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "Reverted!",
              "createdAt": "2021-01-27T16:59:35Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3NTU3NjAz",
          "commit": {
            "abbreviatedOid": "3fa9d47"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-27T17:00:14Z",
          "updatedAt": "2021-01-27T17:00:15Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "It's always valid, I think. The server will just have to do trial decryption.",
              "createdAt": "2021-01-27T17:00:14Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3ODgwMTY3",
          "commit": {
            "abbreviatedOid": "3fa9d47"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-28T00:06:53Z",
          "updatedAt": "2021-01-28T00:06:53Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "An empty identifier is just one possible value in the space.  It doesn't mean that other configurations aren't identified by non-empty identifiers.",
              "createdAt": "2021-01-28T00:06:53Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3ODgwOTEy",
          "commit": {
            "abbreviatedOid": "3fa9d47"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Happy to have the identifier discussion separately.  It is unfortunately not important or clear enough to lead to easy agreement.  I can live with any outcome.",
          "createdAt": "2021-01-28T00:08:40Z",
          "updatedAt": "2021-01-28T00:08:40Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3OTEwNTY2",
          "commit": {
            "abbreviatedOid": "3fa9d47"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-28T01:13:01Z",
          "updatedAt": "2021-01-28T01:13:01Z",
          "comments": [
            {
              "originalPosition": 189,
              "body": "I believe this change needs to be reverted as well. From {#client-hrr}:\r\n\r\n> The client then modifies the \"encrypted_client_hello\" extension in ClientHelloOuter as follows:\r\n> \r\n>   - **config_id is replaced with the empty string.**\r\n>   - cipher_suite is unchanged and contains the client's chosen HPKE cipher suite.\r\n>   - enc is replaced with the empty string.\r\n>   - payload is replaced with the value computed above.\r\n",
              "createdAt": "2021-01-28T01:13:01Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3OTEyNzQw",
          "commit": {
            "abbreviatedOid": "24aebee"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-28T01:18:17Z",
          "updatedAt": "2021-01-28T01:18:17Z",
          "comments": [
            {
              "originalPosition": 189,
              "body": "Fixed.",
              "createdAt": "2021-01-28T01:18:17Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3OTE2OTE1",
          "commit": {
            "abbreviatedOid": "6c67b9f"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "One little nit then -> LGTM.",
          "createdAt": "2021-01-28T01:29:20Z",
          "updatedAt": "2021-01-28T01:31:05Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "nit: missing semicolon `;`",
              "createdAt": "2021-01-28T01:29:20Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3OTE4NDA1",
          "commit": {
            "abbreviatedOid": "6c67b9f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-28T01:33:20Z",
          "updatedAt": "2021-01-28T01:33:20Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "```suggestion\r\n       opaque config_id<0..255>;\r\n```",
              "createdAt": "2021-01-28T01:33:20Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNzA1NTE5",
          "commit": {
            "abbreviatedOid": "2d2e514"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-15T19:04:33Z",
          "updatedAt": "2021-02-15T19:06:17Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "It's a little goofy to have the config_id apply to the whole thing here, but I suppose it's inlined.",
              "createdAt": "2021-02-15T19:04:33Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            },
            {
              "originalPosition": 146,
              "body": "What I'm saying here is that we have a way to indicate the identifier is optional, and that's to have it be 8 random bytes. So when would you use empty?",
              "createdAt": "2021-02-15T19:05:50Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            },
            {
              "originalPosition": 18,
              "body": "I think we at least need a comment here to explain that.",
              "createdAt": "2021-02-15T19:06:14Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNzA2Nzk5",
          "commit": {
            "abbreviatedOid": "2d2e514"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-15T19:07:47Z",
          "updatedAt": "2021-02-15T19:07:47Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Can you suggest text?",
              "createdAt": "2021-02-15T19:07:47Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNzA3MjQ0",
          "commit": {
            "abbreviatedOid": "2d2e514"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-15T19:08:52Z",
          "updatedAt": "2021-02-15T19:08:52Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "Whenever the application wants it, I suppose? We're just recommending that these be random when optional. As Martin says, they don't need to be. Can you propose text if you think something else needs to be said here?",
              "createdAt": "2021-02-15T19:08:52Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNzA3NTM4",
          "commit": {
            "abbreviatedOid": "2d2e514"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-15T19:09:44Z",
          "updatedAt": "2021-02-15T19:11:42Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "I think we should forbid the empty identifier.",
              "createdAt": "2021-02-15T19:09:44Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            },
            {
              "originalPosition": 30,
              "body": "```suggestion\r\nwith the HPKE public key. Note that this structure contains the `config_id` field, which applies to the\r\nentire ECHConfigContents. Sites MUST NOT publish two differet`ECHConfigContents` values with the same\r\n`HpkeKeyConfig` value.\r\n```",
              "createdAt": "2021-02-15T19:11:25Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNzA4Nzc4",
          "commit": {
            "abbreviatedOid": "2d2e514"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-15T19:13:00Z",
          "updatedAt": "2021-02-15T19:13:01Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "I'd like to not do anything here, especially given #379, wherein we move from a vector to a `uint`. Would that be OK?",
              "createdAt": "2021-02-15T19:13:01Z",
              "updatedAt": "2021-02-15T19:18:38Z"
            }
          ]
        }
      ]
    },
    {
      "number": 377,
      "id": "MDExOlB1bGxSZXF1ZXN0NTY2NDE0ODQx",
      "title": "Remove some more remnants of ESNIKeys",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/377",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The reference to \"retry keys\" comes from when the field was called\r\nretry_keys and the type ESNIKeys. We've since renamed them to\r\nretry_config and ECHConfig, so the prose should match.",
      "createdAt": "2021-02-02T23:55:31Z",
      "updatedAt": "2021-02-03T16:50:21Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "ee94206ba488d702a9acae30386875e14a5bb2a7",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "retry-config-naming",
      "headRefOid": "ad6acf8d783c9d3b39f650160196dc1b3bd5bce9",
      "closedAt": "2021-02-03T16:50:21Z",
      "mergedAt": "2021-02-03T16:50:21Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f77361979f03b3df295773accbdb4910e6967a40"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgxOTQ3NDI3",
          "commit": {
            "abbreviatedOid": "1df4a26"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-03T02:08:33Z",
          "updatedAt": "2021-02-03T02:08:33Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Nit: s/the both/both/",
              "createdAt": "2021-02-03T02:08:33Z",
              "updatedAt": "2021-02-03T15:41:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgyNTAzMTI4",
          "commit": {
            "abbreviatedOid": "1df4a26"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-03T15:41:07Z",
          "updatedAt": "2021-02-03T15:41:08Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Huh, that's new. I fixed it in https://github.com/davidben/draft-ietf-tls-esni/tree/retry-config-naming, but GitHub doesn't seem to have noticed. Hopefully it's just some weird slowness on their end and the PR will notice sooner or later?",
              "createdAt": "2021-02-03T15:41:07Z",
              "updatedAt": "2021-02-03T15:41:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgyNTAzNjk1",
          "commit": {
            "abbreviatedOid": "ad6acf8"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-03T15:41:38Z",
          "updatedAt": "2021-02-03T15:41:39Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Okay, now it's noticed. Done.",
              "createdAt": "2021-02-03T15:41:39Z",
              "updatedAt": "2021-02-03T15:41:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgyNTc2OTE4",
          "commit": {
            "abbreviatedOid": "ad6acf8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-03T16:50:15Z",
          "updatedAt": "2021-02-03T16:50:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 381,
      "id": "MDExOlB1bGxSZXF1ZXN0NTczNzUzNDM0",
      "title": "Truncate the config_id to a single byte.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/381",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #379.\r\n\r\ncc @davidben, @martinthomson, @cjpatton, @cbartle891, @ekr ",
      "createdAt": "2021-02-15T19:28:35Z",
      "updatedAt": "2021-04-19T15:52:12Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "caw/config_id-to-key_id",
      "baseRefOid": "ce8a04539acf0655a87ed57aa422c795aa8c6fd6",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/short-id",
      "headRefOid": "85db0c01e55e72c782dbfce9e5841c71bdb349b0",
      "closedAt": "2021-03-08T19:01:12Z",
      "mergedAt": "2021-03-08T19:01:12Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "cb7fbc6110fafca4094e50427a8e77c0137c104b"
      },
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM based on the discussion.",
          "createdAt": "2021-03-08T16:46:51Z",
          "updatedAt": "2021-03-08T16:46:51Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNzUxNDA3",
          "commit": {
            "abbreviatedOid": "3daa28a"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Looks good to me, though I think we should weaken \"config_id MUST be unique\"  to \"config_id SHOULD be unique\", since this seems impossible to enforce. (This comment pertains to the previous PR, unfortunately, but we could fix it here.)",
          "createdAt": "2021-02-15T21:04:28Z",
          "updatedAt": "2021-02-15T21:09:16Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "\"MUST NOT\" -> \"SHOULD NOT\"? This sounds like it could be hard to enforce.",
              "createdAt": "2021-02-15T21:04:29Z",
              "updatedAt": "2021-02-16T13:42:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNzY1OTY1",
          "commit": {
            "abbreviatedOid": "3daa28a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-15T21:37:58Z",
          "updatedAt": "2021-02-15T21:37:58Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Who are you thinking might enforce this? Clients? (I definitely don't feel strongly about the choice of word here.) ",
              "createdAt": "2021-02-15T21:37:58Z",
              "updatedAt": "2021-02-16T13:42:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNzY3MjQ2",
          "commit": {
            "abbreviatedOid": "3daa28a"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-15T21:40:33Z",
          "updatedAt": "2021-02-15T21:40:33Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNzg3OTUy",
          "commit": {
            "abbreviatedOid": "3daa28a"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-15T22:43:10Z",
          "updatedAt": "2021-02-15T22:44:45Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\nThis process is repeated if this config_id matches that of any valid ECHConfig, which\r\ncould include any ECHConfig that has been recently removed from active use.\r\n```\r\n\r\n... or something along those lines.  I suspect that operations will want to avoid collisions over slightly longer timescales.",
              "createdAt": "2021-02-15T22:43:10Z",
              "updatedAt": "2021-02-16T13:42:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkxNjIzNTM2",
          "commit": {
            "abbreviatedOid": "85db0c0"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-16T21:04:40Z",
          "updatedAt": "2021-02-16T21:04:40Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA2NDkxNzUz",
          "commit": {
            "abbreviatedOid": "85db0c0"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-08T16:47:16Z",
          "updatedAt": "2021-03-08T16:47:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 382,
      "id": "MDExOlB1bGxSZXF1ZXN0NTczODAyNzQ2",
      "title": "Clarify \"don't stick out\" considerations",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/382",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR aims to resolve the discussion in issue #354 by:\r\n\r\n1. clarifying goals/non-goals for \"don't stick out\"; and\r\n2. creating a TODO for a future experiment that assesses the deployability of the GREASE extension.\r\n\r\nDealing with PSK sticking out has been assigned to #384.",
      "createdAt": "2021-02-15T21:35:45Z",
      "updatedAt": "2021-04-16T19:56:50Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "95a3fb44cc7703ab33ef11a9781f51962f3d0e0b",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "dont-stick-out",
      "headRefOid": "630d8fffa82d3ac89a44708984b6af2473acc533",
      "closedAt": "2021-04-13T21:16:07Z",
      "mergedAt": "2021-04-13T21:16:07Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "d309b977ed5c91a5e7ae3aab969d11020bc3b97a"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Rebased on top of ECH-10 changes -- addressing @ekr's comments next.",
          "createdAt": "2021-03-18T18:30:19Z",
          "updatedAt": "2021-03-18T18:30:19Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ekr, this is ready for your second pass. I took your suggestion of substantially reducing the amount of text. It should be a bit more concise and to the point, if less precise.\r\n\r\n> In addition, I wouldn't frame GREASE as an experimental method. It's a permanent feature.\r\n\r\nI didn't mean to frame GREASE this way. Can you be more specific about how the text frames it this way?",
          "createdAt": "2021-03-18T19:44:34Z",
          "updatedAt": "2021-03-18T19:44:34Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNzY5MTQ0",
          "commit": {
            "abbreviatedOid": "fc1c47c"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-15T21:45:54Z",
          "updatedAt": "2021-02-15T21:45:54Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "Is this an open issue in the sense that the data from that experiment needs to be in this draft? If not, I'm not sure it should be mentioned here.\r\n\r\nEDIT: Never mind, I see that you mention the experiment later. This seems like material for a different draft? Like, about the ramifications of implementations? Or rationale for the design?",
              "createdAt": "2021-02-15T21:45:54Z",
              "updatedAt": "2021-03-18T19:40:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNzczMDc5",
          "commit": {
            "abbreviatedOid": "fc1c47c"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-15T21:56:46Z",
          "updatedAt": "2021-02-15T21:56:46Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkxNzA3NjQz",
          "commit": {
            "abbreviatedOid": "fc1c47c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I have only a couple of small nits, but overall this is really nice! Thanks for writing it up, and for marking next steps for the protocol deployment.",
          "createdAt": "2021-02-16T23:19:49Z",
          "updatedAt": "2021-02-16T23:25:24Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "This isn't clear to me. I'd just leave this as an open issue without a decision one way or the other.\r\n\r\n```suggestion\r\n   #<new issue ID>, this may be mitigated with a future change.]]\r\n```",
              "createdAt": "2021-02-16T23:19:49Z",
              "updatedAt": "2021-03-18T19:40:52Z"
            },
            {
              "originalPosition": 117,
              "body": "```suggestion\r\nwhether the attacker is passive or active (see {{goals}}).\r\n```\r\n\r\nI'd suggest dropping this unless we can point to some evidence. Maybe @davidben has one?",
              "createdAt": "2021-02-16T23:20:32Z",
              "updatedAt": "2021-03-18T19:40:52Z"
            },
            {
              "originalPosition": 93,
              "body": "I think the point is that we will first run an experiment -- before this document is published as an RFC -- and then update this text with the results. Perhaps this helps?\r\n\r\n```suggestion\r\nthe protocol and measuring its impact. [[TODO: Document results from preliminary experiment that\r\n```",
              "createdAt": "2021-02-16T23:23:00Z",
              "updatedAt": "2021-03-18T19:40:52Z"
            },
            {
              "originalPosition": 7,
              "body": "Let's revert this. We don't yet have consensus as to whether or not we want (or need) to mitigate this particular differentiator. (Please also file a separate issue focused specifically on this issue that we can use to track discussion!)",
              "createdAt": "2021-02-16T23:24:04Z",
              "updatedAt": "2021-03-18T19:40:52Z"
            },
            {
              "originalPosition": 7,
              "body": "(#354 seems too generic to be useful for converging on consensus here, I think.)",
              "createdAt": "2021-02-16T23:24:46Z",
              "updatedAt": "2021-03-18T19:40:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkyMzQzMTI4",
          "commit": {
            "abbreviatedOid": "fc1c47c"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-17T15:49:52Z",
          "updatedAt": "2021-02-17T15:49:52Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "Yup, that's what I mean!",
              "createdAt": "2021-02-17T15:49:52Z",
              "updatedAt": "2021-03-18T19:40:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkzNTg0ODM1",
          "commit": {
            "abbreviatedOid": "fc1c47c"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-18T19:44:38Z",
          "updatedAt": "2021-02-18T19:44:38Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "There are some amazing examples [here](https://mailarchive.ietf.org/arch/msg/tls/i9blmvG2BEPf1s1OJkenHknRw9c/):\r\n> We found that Firepower middleboxes in \"Decrypt - Resign\" mode\r\nterminate TLS connections, but do not send a compliant ClientHello:\r\nThey modify the original ClientHello to remove unknown ciphersuites,\r\nEMS, and NPN, but incorrectly forward most other fields from the\r\noriginal ClientHello, including unknown extensions (supported_versions\r\nand key_shares), and the client random. This breaks TLS 1.3 servers.\r\nAdditionally, these devices forward the server random rather than\r\ngenerating their own (which will break when deploying the TLS 1.3\r\nanti-downgrade feature), and forward unknown signature algorithms\r\n(which will break when deploying, e.g., Ed25519).\r\n",
              "createdAt": "2021-02-18T19:44:38Z",
              "updatedAt": "2021-03-18T19:40:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkzNTg2MTQ3",
          "commit": {
            "abbreviatedOid": "fc1c47c"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-18T19:46:12Z",
          "updatedAt": "2021-02-18T19:46:12Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Done. I also added a reference to #384.",
              "createdAt": "2021-02-18T19:46:12Z",
              "updatedAt": "2021-03-18T19:40:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkzNTkwNTMy",
          "commit": {
            "abbreviatedOid": "0b5bc28"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-18T19:52:00Z",
          "updatedAt": "2021-02-18T19:52:01Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "Can we just cite this email? That would be fine for me!",
              "createdAt": "2021-02-18T19:52:00Z",
              "updatedAt": "2021-03-18T19:40:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkzNTkwNTcx",
          "commit": {
            "abbreviatedOid": "0b5bc28"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-18T19:52:03Z",
          "updatedAt": "2021-02-18T19:52:03Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkzNTk3MDE1",
          "commit": {
            "abbreviatedOid": "30e22a2"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-18T20:00:23Z",
          "updatedAt": "2021-02-18T20:00:23Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "Cited references in Section D.4 of RFC 8446.",
              "createdAt": "2021-02-18T20:00:23Z",
              "updatedAt": "2021-03-18T19:40:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA1NTA4Mzcx",
          "commit": {
            "abbreviatedOid": "30e22a2"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Hi @cjpatton I think this needs to be trimmed down substantially. In particular, a lot of the sections about formally defining indifferentiability don't really belong here.\r\n\r\nIn addition, I wouldn't frame GREASE as an experimental method. It's a permanent feature.",
          "createdAt": "2021-03-05T18:50:06Z",
          "updatedAt": "2021-03-05T18:56:58Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "```suggestion\r\n({{real-ech}}) without protecting the client hello.\r\n```",
              "createdAt": "2021-03-05T18:50:06Z",
              "updatedAt": "2021-03-18T19:40:52Z"
            },
            {
              "originalPosition": 87,
              "body": "I'm not sure I think of this so much as a measurement thing but rather as an anti-ossification measure.",
              "createdAt": "2021-03-05T18:50:31Z",
              "updatedAt": "2021-03-18T19:40:52Z"
            },
            {
              "originalPosition": 113,
              "body": "I would remove everything between \"This strategy is...\" and here.",
              "createdAt": "2021-03-05T18:52:33Z",
              "updatedAt": "2021-03-18T19:40:52Z"
            },
            {
              "originalPosition": 92,
              "body": "```suggestion\r\nossification is to make the use of GREASE ECH widespread, thus disincentivizing filtering of the ECH extension by passive attackers.\r\n```",
              "createdAt": "2021-03-05T18:53:53Z",
              "updatedAt": "2021-03-18T19:40:52Z"
            },
            {
              "originalPosition": 123,
              "body": "I would also remove this paragraph.",
              "createdAt": "2021-03-05T18:54:27Z",
              "updatedAt": "2021-03-18T19:40:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE1NzgzNDA3",
          "commit": {
            "abbreviatedOid": "dbdcb68"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-18T19:19:04Z",
          "updatedAt": "2021-03-18T19:19:04Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "I think this suggestion makes the text less clear.",
              "createdAt": "2021-03-18T19:19:04Z",
              "updatedAt": "2021-03-18T19:40:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE1Nzk3OTI0",
          "commit": {
            "abbreviatedOid": "dbdcb68"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-18T19:29:04Z",
          "updatedAt": "2021-03-18T19:29:05Z",
          "comments": [
            {
              "originalPosition": 92,
              "body": "Changed as follows:\r\n> Thus, our strategy for mitigating network ossification is to deploy GREASE ECH widely enough to disincentivize    differential treatment of the real ECH protocol by the network.",
              "createdAt": "2021-03-18T19:29:04Z",
              "updatedAt": "2021-03-18T19:40:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE1ODA3MzI2",
          "commit": {
            "abbreviatedOid": "dbdcb68"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-18T19:40:55Z",
          "updatedAt": "2021-03-18T19:40:56Z",
          "comments": [
            {
              "originalPosition": 123,
              "body": "Done.",
              "createdAt": "2021-03-18T19:40:55Z",
              "updatedAt": "2021-03-18T19:40:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE1ODA3NDk1",
          "commit": {
            "abbreviatedOid": "dbdcb68"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-18T19:41:08Z",
          "updatedAt": "2021-03-18T19:41:09Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "Done.",
              "createdAt": "2021-03-18T19:41:08Z",
              "updatedAt": "2021-03-18T19:41:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE1ODA4NzI3",
          "commit": {
            "abbreviatedOid": "630d8ff"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-18T19:42:47Z",
          "updatedAt": "2021-03-18T19:42:47Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "The point I was trying to make about measurement is that we have no idea how deployable GREASE ECH is today.",
              "createdAt": "2021-03-18T19:42:47Z",
              "updatedAt": "2021-03-18T19:42:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI2NzIwNDU4",
          "commit": {
            "abbreviatedOid": "630d8ff"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2021-04-02T00:05:26Z",
          "updatedAt": "2021-04-02T00:05:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 383,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc0NTk2Nzcy",
      "title": "Clarify privacy risk pertaining to resumption.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/383",
      "state": "MERGED",
      "author": "cbartle891",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Resolves #380.\r\n\r\ncc @davidben ",
      "createdAt": "2021-02-17T02:21:32Z",
      "updatedAt": "2021-04-19T15:52:28Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "c1a3d71f20f6fa69da00fa5ee7fa1a11abc291de",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "cdb/privacy-leak-clarification",
      "headRefOid": "23bd6b03319b515b5b6835f56bb77c97181c8cda",
      "closedAt": "2021-02-17T20:20:55Z",
      "mergedAt": "2021-02-17T20:20:55Z",
      "mergedBy": "cbartle891",
      "mergeCommit": {
        "oid": "b7757a11639f4b6ea77d97477ee39c2398dcc9a5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkyNDgyODkx",
          "commit": {
            "abbreviatedOid": "23bd6b0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM -- thanks!",
          "createdAt": "2021-02-17T18:08:33Z",
          "updatedAt": "2021-02-17T18:08:33Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkyNTkyNzE4",
          "commit": {
            "abbreviatedOid": "23bd6b0"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2021-02-17T20:19:11Z",
          "updatedAt": "2021-02-17T20:19:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 385,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc2NTU4Mzc5",
      "title": "Add note about denial-of-service vulnerability",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/385",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "A naive implementation of EncodedClientHelloInner decoding would require\r\na quadratic amount of work, which clients might be able to  exploit to\r\nDoS the server. This adds an implementation note intended to guide\r\nservers to mitigate this problem.\r\n\r\nResolves #378.",
      "createdAt": "2021-02-19T16:05:44Z",
      "updatedAt": "2021-04-16T19:56:55Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "b7757a11639f4b6ea77d97477ee39c2398dcc9a5",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "decode-cho-risk",
      "headRefOid": "315fe49aaaa0047a70de8fe64b49c715da1a9e99",
      "closedAt": "2021-02-23T01:36:40Z",
      "mergedAt": "2021-02-23T01:36:40Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "1aa4a2e222c77d1f29cb273ad71e7fcfe890ac53"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "cc/ @davidben :)",
          "createdAt": "2021-02-19T16:06:03Z",
          "updatedAt": "2021-02-19T16:06:03Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@davidben let's do that change in a separate PR for now. ",
          "createdAt": "2021-02-23T01:36:36Z",
          "updatedAt": "2021-02-23T01:36:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk0NTA3OTg0",
          "commit": {
            "abbreviatedOid": "b0da5cd"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-19T19:41:25Z",
          "updatedAt": "2021-02-19T19:43:14Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Nit: O(N\\*M) and O(N\\*log(M)), since it's not exact? (And since O captures \"in the worst case\", you could probably even omit it then.)",
              "createdAt": "2021-02-19T19:41:25Z",
              "updatedAt": "2021-02-22T16:34:21Z"
            },
            {
              "originalPosition": 14,
              "body": "You want to represent the ClientHelloOuter's extensions this way, not the OuterExtensions, right? OuterExtensions is the structure stored in the outer_extensions extension. (Gosh, so many variations on \"outer\" and \"extensions\"!)",
              "createdAt": "2021-02-19T19:43:10Z",
              "updatedAt": "2021-02-22T16:34:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk0Nzc4Mjc5",
          "commit": {
            "abbreviatedOid": "b0da5cd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM pending nits and suggestions from @davidben.",
          "createdAt": "2021-02-20T19:17:18Z",
          "updatedAt": "2021-02-20T19:19:33Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nClientHelloOuter. The naive strategy would require O(N\\*M) comparisons in the worst\r\n```",
              "createdAt": "2021-02-20T19:17:18Z",
              "updatedAt": "2021-02-22T16:34:21Z"
            },
            {
              "originalPosition": 13,
              "body": "```suggestion\r\ncan be improved to O(N\\*log(M)) by sorting the OuterExtensions and using binary\r\n```",
              "createdAt": "2021-02-20T19:17:28Z",
              "updatedAt": "2021-02-22T16:34:21Z"
            },
            {
              "originalPosition": 11,
              "body": "```suggestion\r\nexploit this behavior in order to cause excessive work for the server.\r\nThis problem can be mitigated by representing OuterExtensions in a way\r\n```",
              "createdAt": "2021-02-20T19:18:07Z",
              "updatedAt": "2021-02-22T16:34:21Z"
            },
            {
              "originalPosition": 12,
              "body": "```suggestion\r\nthat allows it to be searched more quickly. For example, the worst case runtime\r\n```",
              "createdAt": "2021-02-20T19:18:15Z",
              "updatedAt": "2021-02-22T16:34:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk1NTM0OTY0",
          "commit": {
            "abbreviatedOid": "b0da5cd"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-22T16:28:01Z",
          "updatedAt": "2021-02-22T16:28:02Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Done.",
              "createdAt": "2021-02-22T16:28:02Z",
              "updatedAt": "2021-02-22T16:34:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk1NTM4MTQx",
          "commit": {
            "abbreviatedOid": "b0da5cd"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-22T16:30:52Z",
          "updatedAt": "2021-02-22T16:30:52Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I was thinking it would be better to pre-sort OuterExtensions, since presumably M << N.",
              "createdAt": "2021-02-22T16:30:52Z",
              "updatedAt": "2021-02-22T16:34:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk1NTM5OTc1",
          "commit": {
            "abbreviatedOid": "b0da5cd"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-22T16:32:32Z",
          "updatedAt": "2021-02-22T16:32:32Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Done, I also added \", possibly making it unavailable.\" (Worth mentioning since it's the goal of the attacker.)",
              "createdAt": "2021-02-22T16:32:32Z",
              "updatedAt": "2021-02-22T16:34:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk1NTQxMTU4",
          "commit": {
            "abbreviatedOid": "b0da5cd"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-22T16:33:42Z",
          "updatedAt": "2021-02-22T16:33:42Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "O(M log(M)) instead of O(N log(N)) seems better for sorting.",
              "createdAt": "2021-02-22T16:33:42Z",
              "updatedAt": "2021-02-22T16:34:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk1NzI2NTE3",
          "commit": {
            "abbreviatedOid": "315fe49"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM, though I guess we should either update it to resolve this other vector, or just make the PR not quite close the issue yet:\r\nhttps://github.com/tlswg/draft-ietf-tls-esni/issues/378#issuecomment-782763490\r\n\r\n(This other vector is even more fun because you can make a quadratically-*sized* ClientHello!)",
          "createdAt": "2021-02-22T19:53:05Z",
          "updatedAt": "2021-02-22T19:53:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 390,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc5Mzg0NjMw",
      "title": "Update HPKE (and ECH) versions.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/390",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #387, and also updates the ECH version. I didn't bump the extension codepoint for \"ech_is_inner,\" since that seems harmless. \r\n\r\ncc @davidben, @cjpatton ",
      "createdAt": "2021-02-24T15:20:40Z",
      "updatedAt": "2021-04-19T15:52:11Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1aa4a2e222c77d1f29cb273ad71e7fcfe890ac53",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/update-versions",
      "headRefOid": "8aa95378e039d33b09316725a28a2e04878d63e9",
      "closedAt": "2021-02-24T18:05:13Z",
      "mergedAt": "2021-02-24T18:05:13Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "fe714e011f8541d961b14d8090b0e1809056b36c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk3Njg3OTQ4",
          "commit": {
            "abbreviatedOid": "8aa9537"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-24T16:39:36Z",
          "updatedAt": "2021-02-24T16:39:36Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk3NzMzNDcx",
          "commit": {
            "abbreviatedOid": "8aa9537"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Works for me!",
          "createdAt": "2021-02-24T17:22:27Z",
          "updatedAt": "2021-02-24T17:22:27Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk3Nzc0MDc0",
          "commit": {
            "abbreviatedOid": "8aa9537"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-24T18:04:57Z",
          "updatedAt": "2021-02-24T18:04:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 391,
      "id": "MDExOlB1bGxSZXF1ZXN0NTgwOTYzNTYz",
      "title": "s/ECHConfigs/ECHConfigList, for clarity.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/391",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See [the source of confusion](https://github.com/MikeBishop/dns-alt-svc/issues/298).",
      "createdAt": "2021-02-26T16:06:00Z",
      "updatedAt": "2021-04-19T15:51:59Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "fe714e011f8541d961b14d8090b0e1809056b36c",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/s-to-list",
      "headRefOid": "3e2595417121a57545daf6151040b00340bac4cd",
      "closedAt": "2021-03-02T22:30:09Z",
      "mergedAt": "2021-03-02T22:30:09Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "d5113cc41f9f2c52e327ae2b9ab97dfbf04cfaf9"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I figure the precision might help reenforce the path from published structure to client behavior.\r\n\r\nI left this out because I figure there may be cases where there is no \"published\" ECHConfigList. (Maybe the config is baked in the app?)",
          "createdAt": "2021-02-26T16:26:54Z",
          "updatedAt": "2021-02-26T16:26:54Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah fair, that might be too precise. I think it still makes sense for that case to have the baked-in thing be an ECHConfigList than an ECHConfig, just for consistency. (I'm envisioning that ECHConfigList is the \"public API\" for client ECH and your TLS library might just that one byte string as input.)\r\n\r\nHow about s/published/server's/?",
          "createdAt": "2021-02-26T16:34:07Z",
          "updatedAt": "2021-02-26T16:34:07Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> How about s/published/server's/?\r\n\r\nThat'd work :)",
          "createdAt": "2021-02-26T16:45:13Z",
          "updatedAt": "2021-02-26T16:45:13Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@davidben done!",
          "createdAt": "2021-02-26T16:50:42Z",
          "updatedAt": "2021-02-26T16:50:42Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk5NzI1NzYy",
          "commit": {
            "abbreviatedOid": "ccf349e"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-26T16:14:07Z",
          "updatedAt": "2021-02-26T16:14:07Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Would it be possible to keep the \"set of candidate $X\" phrasing?\r\n\r\nThe phrase \"candidate ECHConfigList\" sounds to me like the whole ECHConfigList is a candidate, not that each element is a candidate. \r\n\r\nPerhaps\r\n\r\n> First, the server collects a set of candidate ECHConfig values.",
              "createdAt": "2021-02-26T16:14:07Z",
              "updatedAt": "2021-02-26T16:50:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk5NzI4ODc3",
          "commit": {
            "abbreviatedOid": "ccf349e"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-26T16:17:32Z",
          "updatedAt": "2021-02-26T16:17:32Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "I think this section should just be \"ECHConfigs\" or \"ECHConfig values\". The server doesn't actually need to serialize them or anything. (Edit: Ah, I see Dan and I crossed mid-air!)\r\n\r\nAlso now that we also have a better word, maybe {{real-ech}} should now be a bit more precise and say something like:\r\n\"To offer ECH, the client first chooses a suitable ECHConfig from the published ECHConfigList.\"",
              "createdAt": "2021-02-26T16:17:32Z",
              "updatedAt": "2021-02-26T16:50:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk5NzMwMTQz",
          "commit": {
            "abbreviatedOid": "ccf349e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-26T16:18:54Z",
          "updatedAt": "2021-02-26T16:18:55Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Sure, that works equally well for me!",
              "createdAt": "2021-02-26T16:18:55Z",
              "updatedAt": "2021-02-26T16:50:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk5NzMwNDMy",
          "commit": {
            "abbreviatedOid": "4652d8e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-26T16:19:14Z",
          "updatedAt": "2021-02-26T16:19:14Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "(See latest change)",
              "createdAt": "2021-02-26T16:19:14Z",
              "updatedAt": "2021-02-26T16:50:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk5NzM1MTg5",
          "commit": {
            "abbreviatedOid": "4652d8e"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks, Chris!",
          "createdAt": "2021-02-26T16:24:34Z",
          "updatedAt": "2021-02-26T16:24:34Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk5NzM1NDI4",
          "commit": {
            "abbreviatedOid": "4652d8e"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM with one comment that got lost in the mixup. Now that we also have a better word, maybe {{real-ech}} should now be a bit more precise and say something like:\r\n\r\n> To offer ECH, the client first chooses a suitable ECHConfig from the published ECHConfigList.\r\n\r\nI figure the precision might help reenforce the path from published structure to client behavior.",
          "createdAt": "2021-02-26T16:24:49Z",
          "updatedAt": "2021-02-26T16:24:49Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk5ODM2ODU3",
          "commit": {
            "abbreviatedOid": "3e25954"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-26T18:30:40Z",
          "updatedAt": "2021-02-26T18:30:40Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk5ODYxMDgx",
          "commit": {
            "abbreviatedOid": "3e25954"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2021-02-26T19:04:23Z",
          "updatedAt": "2021-02-26T19:04:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 392,
      "id": "MDExOlB1bGxSZXF1ZXN0NTgzMzk1MTQ0",
      "title": "Add -09 to -10 change log.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/392",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #388. We'll keep this updated moving forward.\r\n\r\ncc @martinthomson, @davidben, @cjpatton ",
      "createdAt": "2021-03-02T22:45:57Z",
      "updatedAt": "2021-04-19T15:51:59Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "d5113cc41f9f2c52e327ae2b9ab97dfbf04cfaf9",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/change-log",
      "headRefOid": "da6859a0ba7063def5bf77301a1f014cd0f05003",
      "closedAt": "2021-03-08T18:54:58Z",
      "mergedAt": "2021-03-08T18:54:58Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "db33d117910bc62026b9efc2eb6fe01254b87cba"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAyMzcwNDAw",
          "commit": {
            "abbreviatedOid": "da6859a"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-02T23:32:04Z",
          "updatedAt": "2021-03-02T23:32:04Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAyMzc2MzI4",
          "commit": {
            "abbreviatedOid": "da6859a"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-02T23:43:56Z",
          "updatedAt": "2021-03-02T23:43:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 393,
      "id": "MDExOlB1bGxSZXF1ZXN0NTg1ODA1MDkw",
      "title": "Define HelloRetryRequestInner/Outer messages",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/393",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-03-05T18:43:35Z",
      "updatedAt": "2021-03-05T18:43:42Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "d5113cc41f9f2c52e327ae2b9ab97dfbf04cfaf9",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "hrr-inner",
      "headRefOid": "bcb679661d6a96aeddc45391e43c133c3507b3a6",
      "closedAt": "2021-03-05T18:43:42Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 394,
      "id": "MDExOlB1bGxSZXF1ZXN0NTg3MDI0NTc2",
      "title": "Retarget #384",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/394",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "#384 accidentally targeted an older branch that was since merged into master. This just takes the same change and redirects it to the main branch.",
      "createdAt": "2021-03-08T19:03:33Z",
      "updatedAt": "2021-04-19T15:51:58Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "afbc388c8e49902ccc932b53c15a40b2cf3d3ac9",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/config_id-to-key_id",
      "headRefOid": "cb7fbc6110fafca4094e50427a8e77c0137c104b",
      "closedAt": "2021-03-08T19:04:07Z",
      "mergedAt": "2021-03-08T19:04:07Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "034403dc826ac5b90db5f531839cf98f62d7a7f3"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 407,
      "id": "MDExOlB1bGxSZXF1ZXN0NjAxMTY2NTk1",
      "title": "Define HelloRetryRequestInner/Outer messages",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/407",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The design is based on @davidben's sketch.\r\n\r\nCloses #374.\r\nCloses #373.\r\nCloses #358.\r\nCloses #333.",
      "createdAt": "2021-03-25T23:32:17Z",
      "updatedAt": "2021-06-17T21:17:36Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "95a3fb44cc7703ab33ef11a9781f51962f3d0e0b",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "hrr-inner",
      "headRefOid": "003745ffe9599ce2be8c9af2de322119ae25c4a4",
      "closedAt": "2021-06-11T21:43:54Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyNTQyMjE5",
          "commit": {
            "abbreviatedOid": "afd182f"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-26T21:22:11Z",
          "updatedAt": "2021-03-26T21:22:56Z",
          "comments": [
            {
              "originalPosition": 74,
              "body": "\r\n```suggestion\r\nAs described in {{server-hrr}}, if the server has accepted ECH but needs to send\r\nan HRR then it will be carried in an encrypted HRR value in an \"encrypted_client_hello\" extension\r\ninside an outer HRR.\r\nIf the server sends a HelloRetryRequest (HRR) in response to the ClientHello,\r\n```",
              "createdAt": "2021-03-26T21:22:11Z",
              "updatedAt": "2021-03-30T19:56:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyNTk5NDQy",
          "commit": {
            "abbreviatedOid": "bf2a4a1"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-27T00:28:07Z",
          "updatedAt": "2021-03-27T00:28:08Z",
          "comments": [
            {
              "originalPosition": 227,
              "body": "The usual way an HRR is constructed?",
              "createdAt": "2021-03-27T00:28:07Z",
              "updatedAt": "2021-03-30T19:56:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyNjAzMDU5",
          "commit": {
            "abbreviatedOid": "bf2a4a1"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-27T00:56:31Z",
          "updatedAt": "2021-03-27T00:56:32Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "s/sever/server/",
              "createdAt": "2021-03-27T00:56:31Z",
              "updatedAt": "2021-03-30T19:56:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIzNzY5MzMz",
          "commit": {
            "abbreviatedOid": "bf2a4a1"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-30T01:22:06Z",
          "updatedAt": "2021-03-30T01:22:06Z",
          "comments": [
            {
              "originalPosition": 235,
              "body": "(This is a note not just about this PR but the document in general.) I'm finding it confusing for all the client behavior discussed in one section and the server behavior discussed in another. I'm bouncing back and forth from one to the other to get the actual ordering of the series of events. Would it not be less confusing to put things in that order than to describe all the client behavior and then all the server behavior?",
              "createdAt": "2021-03-30T01:22:06Z",
              "updatedAt": "2021-03-30T19:56:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIzNzgxODY3",
          "commit": {
            "abbreviatedOid": "bf2a4a1"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-30T01:58:10Z",
          "updatedAt": "2021-03-30T01:58:10Z",
          "comments": [
            {
              "originalPosition": 127,
              "body": "> (i.e., the \"ech_outer_extensions\" extension is not used)\r\n\r\nWhy is this?",
              "createdAt": "2021-03-30T01:58:10Z",
              "updatedAt": "2021-03-30T19:56:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIzNzgzNDMy",
          "commit": {
            "abbreviatedOid": "bf2a4a1"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-30T02:02:39Z",
          "updatedAt": "2021-03-30T02:02:40Z",
          "comments": [
            {
              "originalPosition": 139,
              "body": "> if the client did not offer ECH in the first ClientHello, then it MUST NOT not offer ECH in the second.\r\n\r\nIs this no longer true? If not, why not? If it is still true, did this get moved somewhere else? ",
              "createdAt": "2021-03-30T02:02:40Z",
              "updatedAt": "2021-03-30T19:56:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI0NDg4ODY1",
          "commit": {
            "abbreviatedOid": "bf2a4a1"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-30T16:47:50Z",
          "updatedAt": "2021-03-30T16:47:50Z",
          "comments": [
            {
              "originalPosition": 227,
              "body": "Eh, perhaps s/usual way/as described in {{RFC8446}}/.",
              "createdAt": "2021-03-30T16:47:50Z",
              "updatedAt": "2021-03-30T19:56:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI0NDkwNjY4",
          "commit": {
            "abbreviatedOid": "bf2a4a1"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-30T16:49:42Z",
          "updatedAt": "2021-03-30T16:49:42Z",
          "comments": [
            {
              "originalPosition": 227,
              "body": "Even that is confusing because RFC8446 doesn't define \"HelloRetryRequestInner.\" I would say something like \"it constructs a HelloRetryRequestInner message the same way a HelloRetryRequest is constructed per {{RFC8446}}.\"",
              "createdAt": "2021-03-30T16:49:42Z",
              "updatedAt": "2021-03-30T19:56:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI0NDkzODg2",
          "commit": {
            "abbreviatedOid": "bf2a4a1"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-30T16:53:13Z",
          "updatedAt": "2021-03-30T16:53:14Z",
          "comments": [
            {
              "originalPosition": 235,
              "body": "Hmmm, that's an interesting idea. I wonder which is easier from the perspective of someone who is implementing this for the first time. My assumption has been that it's better to separate client behavior and server behavior into two section so that the implementer needs only to refer to one section when implementing the client (resp. server) bits. But given how complex ECH is, perhaps a chronological description is better. I think this sort of editorial re-work is worth filing an issue for discussion.",
              "createdAt": "2021-03-30T16:53:14Z",
              "updatedAt": "2021-03-30T19:56:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI0NDk3NjI0",
          "commit": {
            "abbreviatedOid": "bf2a4a1"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-30T16:57:08Z",
          "updatedAt": "2021-03-30T16:57:08Z",
          "comments": [
            {
              "originalPosition": 127,
              "body": "The idea here is that there's no need to incorporate outer extensions because since the inner handshake was taken. However, it occurs to me that this assumption might not be correct, depending on how the \"TODO\" above is resolved. I wonder, are there any extensions that MUST appear in CHOuter (according to the HRR rules prescribed by 8446), but which one would want to incorporate here? \"supported_versions\" is the only extension I know of that MUST appear in the CHOuter, but there's no reason to incorporate it.",
              "createdAt": "2021-03-30T16:57:08Z",
              "updatedAt": "2021-03-30T19:56:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI0NDk5NzE3",
          "commit": {
            "abbreviatedOid": "bf2a4a1"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-30T16:59:15Z",
          "updatedAt": "2021-03-30T16:59:15Z",
          "comments": [
            {
              "originalPosition": 139,
              "body": "> If the client offered ECH in the first ClientHello, then it MUST offer ECH in\r\nthe second. Likewise, if the client did not offer ECH in the first ClientHello,\r\nthen it MUST NOT not offer ECH in the second.\r\n\r\nHmm, I think the first part of this paragraph is implied by the new rules. However, the second is not. I think I'll just revert this change. Good catch!",
              "createdAt": "2021-03-30T16:59:15Z",
              "updatedAt": "2021-03-30T19:56:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI0NTIwOTM1",
          "commit": {
            "abbreviatedOid": "bf2a4a1"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-30T17:22:27Z",
          "updatedAt": "2021-03-30T17:22:27Z",
          "comments": [
            {
              "originalPosition": 287,
              "body": "If I'm not mistaken, this paragraph refers to the case where the first ClientHello didn't include the \"encrypted_client_hello\" extension, but the second ClientHello(Outer) did. In that case, because \"if the client did not offer ECH in the first ClientHello, then it MUST NOT not offer ECH in the second,\" the client-facing server shouldn't proceed with the connection, but rather terminate it, no?",
              "createdAt": "2021-03-30T17:22:27Z",
              "updatedAt": "2021-03-30T19:56:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI0NTIyMjE0",
          "commit": {
            "abbreviatedOid": "1699314"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-30T17:23:51Z",
          "updatedAt": "2021-03-30T17:23:51Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI0NTgxMDg4",
          "commit": {
            "abbreviatedOid": "1699314"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-30T18:30:13Z",
          "updatedAt": "2021-03-30T18:30:14Z",
          "comments": [
            {
              "originalPosition": 287,
              "body": "Actually, this paragraph is just supposed to say what the client-facing server does if it is completing the handshake and needs to send an HRR. I'm not so sure this paragraph is actually needed any more. I would favor deleting it, since there's not really any context for it anymore.",
              "createdAt": "2021-03-30T18:30:14Z",
              "updatedAt": "2021-03-30T19:56:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI0NTkxNzAy",
          "commit": {
            "abbreviatedOid": "1699314"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-30T18:42:42Z",
          "updatedAt": "2021-03-30T18:42:42Z",
          "comments": [
            {
              "originalPosition": 287,
              "body": "Deleting sounds good to me.",
              "createdAt": "2021-03-30T18:42:42Z",
              "updatedAt": "2021-03-30T19:56:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI0NjUxMjAx",
          "commit": {
            "abbreviatedOid": "003745f"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-30T19:57:10Z",
          "updatedAt": "2021-03-30T19:57:10Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI0NjUyMDYx",
          "commit": {
            "abbreviatedOid": "003745f"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-30T19:58:14Z",
          "updatedAt": "2021-03-30T19:58:14Z",
          "comments": [
            {
              "originalPosition": 287,
              "body": "Done.",
              "createdAt": "2021-03-30T19:58:14Z",
              "updatedAt": "2021-03-30T19:58:14Z"
            }
          ]
        }
      ]
    },
    {
      "number": 409,
      "id": "MDExOlB1bGxSZXF1ZXN0NjAzODMwMDQ1",
      "title": "Compress ECHConfigContents.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/409",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #403.\r\n\r\ncc @martinthomson ",
      "createdAt": "2021-03-30T14:00:54Z",
      "updatedAt": "2021-04-19T15:51:58Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "95a3fb44cc7703ab33ef11a9781f51962f3d0e0b",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/compress-ech-config",
      "headRefOid": "888b9fe8057d11ae36741a6919d59d54058ec396",
      "closedAt": "2021-04-12T20:23:47Z",
      "mergedAt": "2021-04-12T20:23:47Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "8aaf750d4e78a9d79e8216ac61da83ef712df916"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI0MzI3MDMw",
          "commit": {
            "abbreviatedOid": "888b9fe"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-30T14:23:32Z",
          "updatedAt": "2021-03-30T14:23:46Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "(2^16-1 in `public_name` is probably my fault. I bet I got it from HostName in RFC6066.)",
              "createdAt": "2021-03-30T14:23:32Z",
              "updatedAt": "2021-03-30T14:23:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI0MzM5NjU0",
          "commit": {
            "abbreviatedOid": "888b9fe"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-30T14:33:20Z",
          "updatedAt": "2021-03-30T14:33:20Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "No one's fault :-)",
              "createdAt": "2021-03-30T14:33:20Z",
              "updatedAt": "2021-03-30T14:33:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI0NjA2MDg5",
          "commit": {
            "abbreviatedOid": "888b9fe"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-30T18:59:52Z",
          "updatedAt": "2021-03-30T18:59:52Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI1ODUyODUz",
          "commit": {
            "abbreviatedOid": "888b9fe"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-01T02:22:55Z",
          "updatedAt": "2021-04-01T02:22:55Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI1ODY5OTQz",
          "commit": {
            "abbreviatedOid": "888b9fe"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Easy.  Thanks.\r\n\r\nGood to see at least some of the problems of RFC 6066 aren't going to continue here.",
          "createdAt": "2021-04-01T03:16:56Z",
          "updatedAt": "2021-04-01T03:16:56Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI2NzIyODA1",
          "commit": {
            "abbreviatedOid": "888b9fe"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2021-04-02T00:14:18Z",
          "updatedAt": "2021-04-02T00:14:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 410,
      "id": "MDExOlB1bGxSZXF1ZXN0NjAzOTA5NjI1",
      "title": "Authenticate ClientECH extension position in ClientHelloOuterAAD.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/410",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #402.",
      "createdAt": "2021-03-30T14:57:10Z",
      "updatedAt": "2021-04-19T15:51:19Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "95a3fb44cc7703ab33ef11a9781f51962f3d0e0b",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/outer-aad-placeholder",
      "headRefOid": "3859b4adf170f9dcff06d0369f80f9e9b38ec115",
      "closedAt": "2021-04-12T20:23:27Z",
      "mergedAt": "2021-04-12T20:23:27Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "45b820869d9d9684cf5ad56e4f861cc672eef0f2"
      },
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Having looked at this, I have a preference for a construction where the outer ClientHello has a placeholder with empty extension data, rather than a placeholder that has an empty payload field.\r\n\r\nZeroing out the payload field is not easier in our implementation.  It is somewhat more difficult to implement.\r\n\r\nThis is a preference only; anything can be implemented.  But this version is preferable.",
          "createdAt": "2021-04-01T03:15:52Z",
          "updatedAt": "2021-04-01T03:22:00Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI0NDE2ODE1",
          "commit": {
            "abbreviatedOid": "3859b4a"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-30T15:37:55Z",
          "updatedAt": "2021-03-30T15:37:56Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "If we're preserving the location of the \"encrypted_client_hello\" extension anyway, do we still need the `cipher_suite`, `config_id`, and `enc` separated out like this? Seems we can drop all of those, make ClientHelloOuterAAD the reserialized ClientHello, and say:\r\n\r\n> [...] serializing ClientHelloOuter with the \"payload\" field of the \"encrypted_client_hello\" extension set to the empty string.",
              "createdAt": "2021-03-30T15:37:56Z",
              "updatedAt": "2021-03-30T15:37:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI0NDUyNTIz",
          "commit": {
            "abbreviatedOid": "3859b4a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-30T16:10:50Z",
          "updatedAt": "2021-03-30T16:10:51Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Hmm, that's what this text already says (\"extension_data\" is the payload of the extension).",
              "createdAt": "2021-03-30T16:10:50Z",
              "updatedAt": "2021-03-30T16:10:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI0NDYwMTA1",
          "commit": {
            "abbreviatedOid": "3859b4a"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-30T16:18:25Z",
          "updatedAt": "2021-03-30T16:18:26Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Sorry, this was probably unclear. GitHub is terrible and doesn't let you add comments more than two lines away from the diff. :-/ ClientHelloOuterAAD is defined as:\r\n\r\n~~~\r\n   struct {\r\n      HpkeSymmetricCipherSuite cipher_suite;\r\n      uint8 config_id;\r\n      opaque enc<1..2^16-1>;\r\n      opaque outer_hello<1..2^24-1>;\r\n   } ClientHelloOuterAAD;\r\n~~~\r\n\r\nThe encrypted_client_hello extension normally contains a:\r\n\r\n~~~\r\n    struct {\r\n       HpkeSymmetricCipherSuite cipher_suite;\r\n       uint8 config_id;\r\n       opaque enc<1..2^16-1>;\r\n       opaque payload<1..2^16-1>;\r\n    } ClientECH;\r\n~~~\r\n\r\nI'm saying that, rather than replace encrypted_client_hello with the empty string, and lift all but one of its fields to the outside, we may as well say ClientHelloOuterAAD is just the outer_hello field, and that encrypted_client_hello is a *non-empty* extension, containing a ClientECH whose payload field is empty.",
              "createdAt": "2021-03-30T16:18:25Z",
              "updatedAt": "2021-03-30T16:18:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI0NDYxMzUx",
          "commit": {
            "abbreviatedOid": "3859b4a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-30T16:19:43Z",
          "updatedAt": "2021-03-30T16:19:44Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I had that change first, but it seems unnecessarily complicated. Why not just zero out the extension entirely? All we care about is the position.",
              "createdAt": "2021-03-30T16:19:43Z",
              "updatedAt": "2021-03-30T16:19:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI0NjE4NjE3",
          "commit": {
            "abbreviatedOid": "3859b4a"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-30T19:15:06Z",
          "updatedAt": "2021-03-30T19:15:06Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI0NjM1MTA2",
          "commit": {
            "abbreviatedOid": "3859b4a"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-30T19:36:16Z",
          "updatedAt": "2021-03-30T19:36:17Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Heh, I figured zeroing out the field was simpler. Then we don't have to worry copying out the correct `enc` field (in the second ClientHelloOuterAAD, is it the empty string or the old value?), and ClientHello serializers don't need to support two different kinds of encrypted_client_hello payloads (empty vs ClientECH).",
              "createdAt": "2021-03-30T19:36:16Z",
              "updatedAt": "2021-03-30T19:36:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI0NjQ1Mzcw",
          "commit": {
            "abbreviatedOid": "3859b4a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-30T19:49:43Z",
          "updatedAt": "2021-03-30T19:49:43Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I totally do not feel strongly here. They are mostly equivalent in my view, so whatever folks think is best works for me!",
              "createdAt": "2021-03-30T19:49:43Z",
              "updatedAt": "2021-03-30T19:49:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI1ODUyNjMy",
          "commit": {
            "abbreviatedOid": "3859b4a"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-01T02:22:13Z",
          "updatedAt": "2021-04-01T02:22:13Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI2NzIyNTg2",
          "commit": {
            "abbreviatedOid": "3859b4a"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-02T00:13:36Z",
          "updatedAt": "2021-04-02T00:13:36Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I think I'm in favor of this PR as-is but I don't feel strongly.",
              "createdAt": "2021-04-02T00:13:36Z",
              "updatedAt": "2021-04-02T00:13:36Z"
            }
          ]
        }
      ]
    },
    {
      "number": 411,
      "id": "MDExOlB1bGxSZXF1ZXN0NjA0MTA0OTc1",
      "title": "Validate the contents of ClientHelloInner.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/411",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #406.",
      "createdAt": "2021-03-30T17:09:43Z",
      "updatedAt": "2021-04-19T15:51:17Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "95a3fb44cc7703ab33ef11a9781f51962f3d0e0b",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/validate-ch-inner",
      "headRefOid": "7f9be69c301ca6b61579225081f1d97b07d0f8a3",
      "closedAt": "2021-04-12T20:21:28Z",
      "mergedAt": "2021-04-12T20:21:28Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "e3c5d038f78be784e85ccaa47963a4f397d230ea"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI0NjAzNDk0",
          "commit": {
            "abbreviatedOid": "6f55601"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-30T18:56:43Z",
          "updatedAt": "2021-03-30T18:56:43Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI0NzgxOTk0",
          "commit": {
            "abbreviatedOid": "6f55601"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-30T23:31:10Z",
          "updatedAt": "2021-03-30T23:31:10Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI0ODAzMTk5",
          "commit": {
            "abbreviatedOid": "6f55601"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-31T00:28:44Z",
          "updatedAt": "2021-03-31T00:28:45Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "This is a [wall of text](https://en.uncyclopedia.co/wiki/Wall_of_Text) now.\r\n\r\nIt might be time to break this down a little more.  Pause for a breath occasionally.",
              "createdAt": "2021-03-31T00:28:45Z",
              "updatedAt": "2021-03-31T20:27:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI1NjkwMjM3",
          "commit": {
            "abbreviatedOid": "7f9be69"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-31T20:28:01Z",
          "updatedAt": "2021-03-31T20:28:01Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "\ud83d\udc4d ",
              "createdAt": "2021-03-31T20:28:01Z",
              "updatedAt": "2021-03-31T20:28:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI1ODUyMzU3",
          "commit": {
            "abbreviatedOid": "7f9be69"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-01T02:21:18Z",
          "updatedAt": "2021-04-01T02:21:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 413,
      "id": "MDExOlB1bGxSZXF1ZXN0NjA0MjYwMTI3",
      "title": "Add MUST for clients to validate ECHConfig.contents.public_name.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/413",
      "state": "MERGED",
      "author": "dmcardle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "[Edit: deleted \"Fixes\" line for #405]",
      "createdAt": "2021-03-30T18:57:08Z",
      "updatedAt": "2021-04-20T16:24:48Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "95a3fb44cc7703ab33ef11a9781f51962f3d0e0b",
      "headRepository": "dmcardle/draft-ietf-tls-esni",
      "headRefName": "dan-public-name-edge-cases",
      "headRefOid": "1bfd934f46d0da48d1f074b7e1fcd05879c5deeb",
      "closedAt": "2021-04-19T14:03:06Z",
      "mergedAt": "2021-04-19T14:03:06Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ae554bbd76877809cc458cc19bac3d149cdc0706"
      },
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "From #405, we also talked about IP addresses and such. Do we still want to do that?\r\n\r\nWhether the client validation is SHOULD or MUST (TBH I kinda prefer MUST, given the implications on private services... if it's a SHOULD, we should talk about why so implementations can make an informed decision), we do also need to say what values are valid for the server.",
          "createdAt": "2021-03-30T19:32:40Z",
          "updatedAt": "2021-03-30T19:32:40Z"
        },
        {
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK, switched to a MUST.  Added IP addresses as well.\r\n\r\nI'm calling out to [RFC3986](https://tools.ietf.org/html/rfc3986) for IPv4/IPv6 parsing. I'd like to avoid any ambiguities that might creep in if I were allowed to define the grammar, like allowing octal numbers in an IPv4 address, e.g. `192.168.0.042` != `192.168.0.42`.\r\n\r\nFor hostname parsing, I'm borrowing from [RFC5890](https://tools.ietf.org/html/rfc5890) so we can parse IDNs.",
          "createdAt": "2021-03-31T17:06:39Z",
          "updatedAt": "2021-03-31T17:06:39Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": ">  Added IP addresses as well.\r\n\r\nI think that is a mistake.",
          "createdAt": "2021-03-31T17:09:24Z",
          "updatedAt": "2021-03-31T17:09:24Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "> > Added IP addresses as well.\r\n> \r\n> I think that is a mistake.\r\n\r\nWhy is that?",
          "createdAt": "2021-03-31T17:16:05Z",
          "updatedAt": "2021-03-31T17:16:05Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": "I think IP addresses are a mistake because they can introduce parsing ambiguities (as pointed out above), and sometimes those cause problems (https://securityledger.com/2021/03/critical-flaws-found-in-widely-used-netmask-open-source-library/). Also, SNI is really limited to hostname (as @davidben has pointed out before, referencing AGL's post), and having the two mismatch in their capabilities bothers me.\r\n",
          "createdAt": "2021-03-31T17:19:47Z",
          "updatedAt": "2021-03-31T17:19:47Z"
        },
        {
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed that the capability mismatch between SNI and ECHConfig.public_name is odd. However, there is already a capability mismatch between ECHConfig.public_name and names allowable on server certificates. At least in theory, the server's certificate might not have a hostname.\r\n\r\nThat being said, I don't have a strong opinion either way. If we *do* decide to disallow IP addresses, I think we'd still want the client to look for them so it can reject those ECHConfigs that use IP addresses. This is about stopping wacky values from bubbling up to the application.",
          "createdAt": "2021-03-31T17:57:23Z",
          "updatedAt": "2021-03-31T17:57:23Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": ">  I think we'd still want the client to look for them so it can reject those ECHConfigs that use IP addresses\r\n\r\nThe client sending the ECH or the server receiving it?\r\n\r\nCurrent TLS stacks don't seem to check, on either side.  (At least OpenSSL and its major forks)\r\n",
          "createdAt": "2021-03-31T18:17:13Z",
          "updatedAt": "2021-03-31T18:17:13Z"
        },
        {
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I was referring to the client, but yeah, scratch that idea. If public_name can only be a hostname, the client should only validate that it looks like a hostname.",
          "createdAt": "2021-03-31T18:21:08Z",
          "updatedAt": "2021-03-31T18:21:08Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think the capability mismatch between SNI and ECHConfig.public_name is a fatal. We can move ECHConfig.public_name up an abstraction level. I think we should do this whether we allow IPs or not.\r\n\r\n* The public name isn't \"put this in ClientHelloOuter.server_name\" but \"the name you are trying to connect to in the outer handshake\". In particular, this encompasses both ClientHelloOuter.server_name *and* certificate verification.\r\n* To fill in ClientHelloOuter.server_name, you use the rules in RFC6066: server_name is the name you are trying to connect to, provided it's a DNS name.\r\n\r\nUnder this model, it is perfectly coherent for \"the name you are trying to connect to\" to be an IP address, if we want to do that. *If* we wish to do that then, yeah, we'll need to spell out the syntax here. That syntax clearly *does* already exist (URLs, etc.), but not in TLS. I don't particular care whether we do it, though.\r\n\r\nHow about this:\r\n1. Right now, IP addresses are implicitly not okay by way of CHOuter.server_name = ECHConfig.public_name. So let's not introduce them in this PR and merely iron out the DNS name validation. This PR adds to, but does *not* close #405.\r\n2. We then rework the text to redefine public_name as above. This is a prerequisite to allowing IPs, but I think it's worth doing either way.\r\n3. We decide the IP question (interim?) and resolve #405 with the result.\r\n\r\n(Sorry, I think some of this confusion is my fault. I filed two related, but separate, discussion points in #405, which was confusing. My comment in https://github.com/tlswg/draft-ietf-tls-esni/pull/413#issuecomment-810523171 was most in reaction to \"Fixes #405\"; that we shouldn't close it out without resolving both points.)",
          "createdAt": "2021-03-31T19:50:06Z",
          "updatedAt": "2021-03-31T19:50:27Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 31/03/2021 20:50, David Benjamin wrote:\n> 3. We decide the IP question (interim?) and resolve #405 with the result.\n\nI think I'd mostly be against supporting IP addresses in\nECHConfig.public_name. I suspect including an IP address\nin outer.sni would break some things. The comment below\nis from OpenSSL's ssl/statem/extensions_srvr.c:\n\n     /*\n      * Although the intent was for server_name to be extensible, RFC 4366\n      * was not clear about it; and so OpenSSL among other implementations,\n      * always and only allows a 'host_name' name types.\n      * RFC 6066 corrected the mistake but adding new name types\n      * is nevertheless no longer feasible, so act as if no other\n      * SNI types can exist, to simplify parsing.\n      *\n      * Also note that the RFC permits only one SNI value per type,\n      * i.e., we can only have a single hostname.\n      */\n\nSeparately, we could land ourselves with yet more confusion\nrelated to the address to which one ought send a ClientHello,\n(the address in the ECHConfig or in the svbb.ipv?hint or the\nA/AAAA of one of the names involved, and which to prefer if\nsome things have DNSSEC etc etc.).\n\n\nCheers,\nS.\n",
          "createdAt": "2021-03-31T20:06:06Z",
          "updatedAt": "2021-03-31T20:06:06Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "@sftcd Right, I think it's unambiguous, whatever we do with IP addresses, they won't go in ClientHelloOuter.server_name. Any use of this, if we want it, would be for public name verification, not the server_name value. See my comment above with how to think about public_name.",
          "createdAt": "2021-03-31T20:12:17Z",
          "updatedAt": "2021-03-31T20:12:33Z"
        },
        {
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "SGTM, folks. Just dropped the parts about IP addresses.",
          "createdAt": "2021-03-31T20:28:49Z",
          "updatedAt": "2021-03-31T20:28:49Z"
        },
        {
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks like I was a little overzealous removing the IP address text.\r\n\r\nWe still need to check that public_name is not an IPv4 address because dotted-decimal IPv4 addresses would slip through the cracks of hostname validation. This is bad because a malicious/misconfigured DNS would cause the ECH client to break [RFC6066](https://tools.ietf.org/html/rfc6066#section-3)'s rule on the contents of \"server_name\":\r\n\r\n> Literal IPv4 and IPv6 addresses are not permitted in \"HostName\".\r\n\r\n(Re-added this IPv4 check in the last commit.)",
          "createdAt": "2021-04-01T14:17:12Z",
          "updatedAt": "2021-04-01T14:17:12Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": "I would rather make \"validate the host name\" be a SHOULD and remove all these requirements.",
          "createdAt": "2021-04-01T14:21:29Z",
          "updatedAt": "2021-04-01T14:21:29Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "ECH implementations not validating that string risks surprising behavior for a lot of applications, and potentially more attack surface to private services than before. Have you looked at the discussion in issue #405, in particular:\r\n\r\n> Current TLS stacks don't seem to check, on either side. (At least OpenSSL and its major forks)\r\n\r\nSadly, the thing that makes that work (logic earlier in the application) doesn't apply here. See https://github.com/tlswg/draft-ietf-tls-esni/issues/405#issuecomment-810496976",
          "createdAt": "2021-04-01T14:57:44Z",
          "updatedAt": "2021-04-01T14:58:11Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": "> ECH implementations not validating that string risks surprising behavior for a lot of applications, and potentially more attack surface to private services than before.\r\n\r\nCan you explain your concerns in more detail?\r\n\r\nI think the application should be responsible for validation.",
          "createdAt": "2021-04-01T15:20:03Z",
          "updatedAt": "2021-04-01T15:20:03Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think the application should be responsible for validation.\r\n\r\nThe application should never see the value of ECHConfig.public_name, right?",
          "createdAt": "2021-04-01T15:21:38Z",
          "updatedAt": "2021-04-01T15:21:38Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> Can you explain your concerns in more detail?\r\n\r\nSee #405, specifically https://github.com/tlswg/draft-ietf-tls-esni/issues/405#issue-841232184 and https://github.com/tlswg/draft-ietf-tls-esni/issues/405#issuecomment-810430589/\r\n\r\n>> I think the application should be responsible for validation.\r\n>\r\n> The application should never see the value of ECHConfig.public_name, right?\r\n\r\nWell, there are several things going on here:\r\n\r\nFirst, different systems may differently divide the \"TLS\" part and the \"application\" part. The spec mostly captures behavior of the overall client system, because that's all we can usefully talk about. (For example, ECH specifies a retry flow that involves making a new connection. At the level of many TLS libraries, including OpenSSL + derivatives, the caller makes connections. So instead the TLS library can expose APIs and document the caller's responsibilities as part of enabling ECH. Other interfaces may be create their own connections and handle this internally.) So whether it's the application or TLS, at the implementation level, isn't a hard deciding factor.\r\n\r\nSecond, with that said, yes, I expect that the majority of TLS <-> application interfaces will treat the ECHConfigList as an opaque blob. That is a good division of responsibilities because the TLS half already needs to process individual ECHConfigs in the ECHConfigList and select one based on its internal capabilities. Having to thread through application-specific DNS validation seems like it'd be complex. (But this is just my view as an implementor. The spec merely describes the overall behavior of the client system. How you choose to layer it is an implementation decision.)\r\n\r\nFinally, there's the question of whether TLS as a spec should have opinions here or if it should punt to some upper layer spec profile, as we did with 0-RTT. I don't think that's warranted here. RFC6066 already decided what can go in server_name, so TLS already is plenty opinionated on the shape of strings meant to be DNS names.\r\n\r\nThus, IMO, the simplest and most practical story is to have TLS handle this, rather than thread it up through all the layers.",
          "createdAt": "2021-04-01T15:46:53Z",
          "updatedAt": "2021-04-01T15:46:53Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": "I am willing to accept that I am in the rough here.",
          "createdAt": "2021-04-01T16:10:28Z",
          "updatedAt": "2021-04-01T16:10:28Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As noted in https://github.com/tlswg/draft-ietf-tls-esni/issues/405#issuecomment-812088744, I don't think we should be putting IP addresses in `public_name`.",
          "createdAt": "2021-04-01T18:28:31Z",
          "updatedAt": "2021-04-01T18:28:31Z"
        },
        {
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In the interest of dealing with one problem at a time, this PR no longer attempts to spell out how to recognize IP addresses. \r\n\r\nRoughly:\r\n\r\n* The client MUST validate `public_name` as a LDH hostname.\r\n* The client SHOULD exclude IP address literals, which may come in many strange forms, or else it may send a non-compliant \"server_name\" extension.\r\n\r\nIf we care to make excluding IP addresses a MUST, let's work out the details in another PR. Same goes for if we want to explicitly support IP address literals \u2014\u00a0we still need to validate them to protect server applications from receiving IP addresses in non-standard notations, e.g. octal.",
          "createdAt": "2021-04-02T18:53:11Z",
          "updatedAt": "2021-04-02T18:53:11Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I think there are a couple things going on here:\r\n\r\n1. ECHConfig.public_name, as currently written, is described as what goes in CHOuter.server_name. That wasn't right and we should have made it outer reference identity. I believe @chris-wood is going to do a separate PR after this goes through.\r\n\r\n2. SNI or reference identity, we need to define what the type of the thing that goes in ECHConfig.public_name and what validation the client does. In particular, without validation, it gives the network more control over what goes into CHOuter.server_name than would otherwise be the case. Normally, in a typical HTTPS client, TLS can just assume the hostname has passed whatever checks earlier in the stack (URL parsing, DNS lookup, etc.) and so checks in TLS are not load-bearing. The public name breaks this because the TLS layer is fabricating a hostname on its own. So we should have TLS validate it before running too far with it.\r\n\r\nThis PR addresses (2).",
          "createdAt": "2021-04-12T19:41:18Z",
          "updatedAt": "2021-04-12T19:41:18Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Following up on @davidben's comment, I was indeed planning on clarifying that ECHConfig.public_name is a reference identity, and planned on renaming this to something other than `public_name` to match. Basically: `ECHConfig.public_identity` may be either a name or IP address, validated according to the rules in this PR, and clients will use that identity when constructing the ClientHello per the normal rules. (If it's a name, put it in \"server_name,\" else don't put it in that name.)\r\n\r\nI think we can probably land this PR as-is. Is everyone else OK with this plan?",
          "createdAt": "2021-04-12T20:55:49Z",
          "updatedAt": "2021-04-12T20:55:49Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 12/04/2021 21:56, Christopher Wood wrote:\n> Following up on @davidben's comment, I was indeed planning on\n> clarifying that ECHConfig.public_name is a reference identity, and\n> planned on renaming this to something other than `public_name` to\n> match. Basically: `ECHConfig.public_identity` \n\nIt's a nit, but I don't think I've ever seen a use of the\nterm \"identity\" that didn't eventually cause confusion. I\nthink public_name was better TBH.\n\n> may be either a name or\n> IP address, \n\nSorry if I missed the discussion but:\n\n- Are one or more IPv4/IPv6 addresses allowed and if so with\n   what syntax?\n- If only 1 is allowed, why? (Syntax still needs a\n   reference.)\n- I don't know how an IP address here ought be handled if it\n   differs from those in the SVCB address hints fields. (Not\n   to mention the origin's A/AAAA records.)\n- Lastly, I forget why we even want an IP address there at\n   all.\n\n\nThanks,\nS.\n\n\n> validated according to the rules in this PR, and clients\n> will use that identity when constructing the ClientHello per the\n> normal rules. (If it's a name, put it in \"server_name,\" else don't\n> put it in that name.)\n> \n> I think we can probably land this PR as-is. Is everyone else OK with\n> this plan?\n> \n",
          "createdAt": "2021-04-12T21:21:48Z",
          "updatedAt": "2021-04-12T21:21:48Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I assumed there's at most one identity in this field, be it a name or address, but @dmcardle can clarify. Also, I think the identity here only pertains to how the client-facing server is authenticated. If a server uses an IP-address certificate for the rejection path then it might specify the single IP address of that certificate. (Clients don't use SVCB hints for this, so they're orthogonal.)",
          "createdAt": "2021-04-12T21:32:40Z",
          "updatedAt": "2021-04-12T21:32:40Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 12/04/2021 22:32, Christopher Wood wrote:\n> I assumed there's at most one identity in this field, be it a name or\n> address, but @dmcardle can clarify. Also, I think the identity here\n> only pertains to how the client-facing server is authenticated. If a\n> server uses an IP-address certificate for the rejection path then it\n> might specify the single IP address of that certificate. \n\nThere can be many SANs even if those are IP addresses. So\nI think you mean that you want exactly one IP address here\nand if one is here that MUST match one SAN iPaddress from\nthe cert?\n\nPersonally I don't think that's useful enough to support\nbut maybe I missed why it was really good.\n\n> (Clients\n> don't use SVCB hints for this, so they're orthogonal.)\n\nTBH, I doubt implementers will notice that orthogonality.\nAnd those deploying even less would be my guess. If one\nis allowed put a single IP address in an ECHConfig and\nothers in SVCB hints then someone needs to say what to do\nwhen those aren't the same.\n\nS.\n\n\n",
          "createdAt": "2021-04-12T21:41:51Z",
          "updatedAt": "2021-04-12T21:41:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> There can be many SANs even if those are IP addresses\r\n\r\nTrue, but I'm just commenting on parity with what's there right now. (ECHConfig.public_name is just one name.) We may change that later if people want it? I don't see a reason to, though.\r\n\r\n> So I think you mean that you want exactly one IP address here and if one is here that MUST match one SAN iPaddress from the cert?\r\n\r\nYeah, that's what I'm thinking. \r\n\r\n> If one is allowed put a single IP address in an ECHConfig and others in SVCB hints then someone needs to say what to do when those aren't the same.\r\n\r\nHmm, yeah, we may be able to clarify this, but given that we don't discuss anything about the SVCB record (beyond the config) currently, it may not be needed.",
          "createdAt": "2021-04-12T21:52:00Z",
          "updatedAt": "2021-04-12T21:52:00Z"
        },
        {
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Currently, this PR explicitly states that the client SHOULD ignore the ECHConfig if its `public_name` contains an IP address. Unfortunately, what constitutes a textual representation of an IPv4 address is pretty underspecified, so I didn't manage to come up with a foolproof validation algorithm, otherwise I would make it a MUST.\r\n\r\nIf we want to allow IP addresses, let's figure it out in another PR.",
          "createdAt": "2021-04-12T21:58:00Z",
          "updatedAt": "2021-04-12T21:58:00Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So I don't think that we need to worry about IPv6 here.  That will never match LDH.\r\n\r\nThe IPv4 thing is unfortunate.  I *think* that the risk is that the public name is passed to a certificate validation library that subsequently treats the name as an IP address (matching against an ipAddress SAN rather than dNSName SAN) when doing fallback process.  If there is any potential for confusion about this string (or look-alikes if we consider the octal mess) then it might happen that there is variation in what certificates are considered OK.\r\n\r\nThat leads to a reliance on the certification authorities being careful about issuance for names that look like IP addresses.  We don't want that.\r\n\r\nEither way, I don't like \"SHOULD\" here.  It retains the potential confusion.  If one client component is sloppy and doesn't bother other components are then forced to contend with that choice.\r\n\r\nI think that I've come around to @bemasc's viewpoint on this.  It's reasonable to require a domain name for fallback in all cases, even where a server is identified by IP address alone.\r\n\r\nI think that means prohibiting IPv4 addresses, just to avoid the potential confusion.  That is, if the name contains exactly 4 labels that are only digits, then the record is invalid.  IPv6 addresses will look after themselves as they aren't valid LDH A-labels.\r\n\r\nNote: I don't know if there are rules that might allow 172.0.2.2045 to be registered, which is clearly not an IP address.  I believe that the main protection we have against valid DNS names appearing to be IPv4 addresses is the gTLD registration rules (from https://newgtlds.icann.org/en/applicants/agb Section 2.2.1.3.1 clause 1.2.1 this is currently assured as only a-z is permitted from the ASCII range).",
          "createdAt": "2021-04-18T23:56:29Z",
          "updatedAt": "2021-04-18T23:56:29Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> The IPv4 thing is unfortunate. I think that the risk is that the public name is passed to a certificate validation library that subsequently treats the name as an IP address (matching against an ipAddress SAN rather than dNSName SAN) when doing fallback process. If there is any potential for confusion about this string (or look-alikes if we consider the octal mess) then it might happen that there is variation in what certificates are considered OK.\r\n\r\n@martinthomson can you drill into this? I must be misunderstanding you (and maybe the problem), but are you suggesting that strings which _look_ like IP addresses might be parsed incorrectly by the thing validating certificates against such look-alike addresses?\r\n\r\n> That leads to a reliance on the certification authorities being careful about issuance for names that look like IP addresses. We don't want that.\r\n\r\nThey also have to be careful about names that aren't actually domain names (\"DROP TABLES\" or whatever). How is this a substantially new requirement?\r\n\r\nProhibiting IP addresses here seems overly restrictive. Given that it doesn't seem challenging to support, and does not, to my knowledge, introduce any new requirements for CAs or certificate validation APIs, I'd like to hear more reasons why we ought to definitely rule them out. And as @dmcardle says, we should hash this out in a separate issue and PR. In the interest of making forward progress, I'm going to merge this PR as-is, and we can discuss more in #424.",
          "createdAt": "2021-04-19T13:59:07Z",
          "updatedAt": "2021-04-19T14:01:22Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @martinthomson can you drill into this? I must be misunderstanding you (and maybe the problem), but are you suggesting that strings which look like IP addresses might be parsed incorrectly by the thing validating certificates against such look-alike addresses?\r\n\r\nIn most cases, I don't anticipate problems: there will be one certificate validator used during fallback and that will make a single determination.  IP address lookalikes in that case probably won't be a problem.  However, in cases where there are multiple components involved, there might be IP address lookalikes that pass one validator but not another.  That might be used to attack clients.",
          "createdAt": "2021-04-20T00:11:18Z",
          "updatedAt": "2021-04-20T00:11:18Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Given how [complicated](https://url.spec.whatwg.org/#concept-ipv4-parser) IPv4 literals can get in some applications, I suspect the TLS library classifying and rejecting IPv4 literals in a way that ensures the calling application always interprets it as a DNS name is hopeless.\r\n\r\nI'm now inclined to say we should:\r\n1.  Do #426 and say public_name is exclusively DNS. If anyone adds IP in the future, the expectation will be a separate extension and thus not require any parsing to pick semantics.\r\n2. The exclusively-DNS public_name field is validated according to DNS rules and leave it at that. That at least avoids _completely_ unbounded DNS control on the ClientHello.\r\n3. Concede that we can't reliably exclude IPv4 literals at this layer. Call this out and say that clients MUST NOT validate the string as IP addresses. If your verifier has separate APIs for configuring DNS vs IP names for subjectAltName, feel free to pass the string as a DNS input and move on. If your verifier's API takes a more URL-like hostname, you should use whatever logic you used to distinguish DNS vs. IP and fail the verification if you think the string is an IP. (Effectively that verifier believes \"DNS:1.2.3.4\" is never valid because it has no way to spell it.)\r\n\r\nThis does mean the DNS can cause ClientHelloOuter to violate the RFC6066 prohibition on IPv4 literals, but since RFC6066 failed to specify what syntax it was prohibiting, the meaning of that rule is somewhat unclear.",
          "createdAt": "2021-04-20T16:23:06Z",
          "updatedAt": "2021-04-20T16:24:48Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI1NjkyMDQx",
          "commit": {
            "abbreviatedOid": "db4dded"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This seems like it would prohibit _service.name. @huitema, @DavidSchinazi: would this be a problem for the DNS-SD case?",
          "createdAt": "2021-03-31T20:30:23Z",
          "updatedAt": "2021-03-31T20:45:45Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nstructure with a `public_name` that fails validation. To validate, the\r\n```",
              "createdAt": "2021-03-31T20:30:23Z",
              "updatedAt": "2021-04-05T14:56:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI3NDgwOTEy",
          "commit": {
            "abbreviatedOid": "2267782"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-03T19:23:03Z",
          "updatedAt": "2021-04-03T19:25:25Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Perhaps rephrasing this slightly as:\r\n\r\n> This value MUST NOT begin or end with an ASCII dot and MUST be parsable as a dot-separated sequence of LDH labels, as defined in {{RFC5980}}, Section 2.3.1. Clients MUST ignore any ECHConfig structure whose public_name does not meet this criteria.\r\n\r\nThis way we capture both sender and receiver rules.",
              "createdAt": "2021-04-03T19:23:03Z",
              "updatedAt": "2021-04-05T14:56:50Z"
            },
            {
              "originalPosition": 14,
              "body": "Man, this IP address thing is a mess. The SHOULD makes me sad, but I don't have a clear alternate suggestion. I can see not wanting to tie to the slightly odd \"first-match-wins\" parse from URLs. (And then there's the mess that is URL parsing...) Although, amusingly, RFC6066 section 3 clearly assumes that we have somehow defined this in a TLS-compatible way, but it forgot to cite anything. :-(\r\n\r\nI dunno, I'll defer to others on the exact wording here. @martinthomson, what do you think?\r\n\r\nEither way, I'm on board with dealing with one problem at a time in this PR.",
              "createdAt": "2021-04-03T19:23:34Z",
              "updatedAt": "2021-04-05T14:56:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI3OTAxNTcx",
          "commit": {
            "abbreviatedOid": "1ddccd3"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-05T14:52:27Z",
          "updatedAt": "2021-04-05T14:52:27Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "That's better, thanks.",
              "createdAt": "2021-04-05T14:52:27Z",
              "updatedAt": "2021-04-05T14:56:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI2NTc2MTU4",
          "commit": {
            "abbreviatedOid": "ed80728"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "High-level, I think that we need to agree on what this value is *for* first.\r\n\r\nEditorially, I think that this text needs more space to move.  Trying to cram all this stuff into a single paragraph isn't doing us any favours.  Make a new section for this.  It's certainly important enough to do properly.\r\n\r\nMy sense is that the right answer to the underlying issues is that this is a reference identity rather than something we put in server_name in ClientHelloOuter.\r\n\r\nIn that case, the fallback is achieved by establishing a connection and validating that the entity providing the updated configuration is able to answer for this reference identity.  You then construct ClientHelloOuter in such a way as to ensure that you are able to successfully connect to that reference identity if ClientHelloInner cannot be accepted.\r\n\r\nIf this is just a name, then this is over-specified.  If the goal is to describe what goes in ClientHelloOuter server_name, none of the validation is necessary.  If the server wants you to put junk in the field, then I don't see how that junk would be any more identifying than an identifying DNS name.  You really only need special IP address rules if you intend for this to be a reference identity.",
          "createdAt": "2021-04-01T19:18:11Z",
          "updatedAt": "2021-04-06T02:18:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 414,
      "id": "MDExOlB1bGxSZXF1ZXN0NjA0Mjk4OTAx",
      "title": "Allow clients to send a dummy PSK in ClientHelloOuter",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/414",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #384.\r\nThis may also be useful for #408.\r\n\r\n@davidben, do let me know if this PR overloads the term \"GREASE\" in a way that you find to be inaccurate or not in the GREASE spirit :) I'm perfectly happy to call it something else.",
      "createdAt": "2021-03-30T19:24:22Z",
      "updatedAt": "2021-04-16T19:55:20Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "95a3fb44cc7703ab33ef11a9781f51962f3d0e0b",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "dummy-psk",
      "headRefOid": "bc98c900de208b4d37bc2b0251062ce74f56c2c9",
      "closedAt": "2021-04-12T20:22:30Z",
      "mergedAt": "2021-04-12T20:22:30Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ea85bf171a5a675c7d752fc17da46d42370c9f2d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI0NzM4NzEx",
          "commit": {
            "abbreviatedOid": "9a642b8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM modulo a couple suggestions!",
          "createdAt": "2021-03-30T21:59:40Z",
          "updatedAt": "2021-03-30T22:07:46Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\n   SHOULD also include a GREASE \"pre_shared_key\" extension in ClientHelloOuter,\r\n```\r\n(to match the section title below)",
              "createdAt": "2021-03-30T21:59:40Z",
              "updatedAt": "2021-04-01T17:12:09Z"
            },
            {
              "originalPosition": 23,
              "body": "```suggestion\r\nthe ClientHelloOuter. However, the client can send a \"pre_shared_key\" extension in the\r\nClientHelloInner. In this case, when resuming a session with the client, the backend \r\nserver sends a \"pre_shared_key\" extension in its ServerHello. This would\r\n```",
              "createdAt": "2021-03-30T22:04:14Z",
              "updatedAt": "2021-04-01T17:12:09Z"
            },
            {
              "originalPosition": 26,
              "body": "```suggestion\r\n{{RFC8446}}. Sending a GREASE \"pre_shared_key\" extension in the ClientHelloOuter\r\n```",
              "createdAt": "2021-03-30T22:04:29Z",
              "updatedAt": "2021-04-01T17:12:09Z"
            },
            {
              "originalPosition": 23,
              "body": "(proposed simplification to focus on only extension solicitation violation, rather than on cover traffic, which is the main motivation for this change.)",
              "createdAt": "2021-03-30T22:06:23Z",
              "updatedAt": "2021-04-01T17:12:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI1Njg1NjAy",
          "commit": {
            "abbreviatedOid": "9a642b8"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-31T20:22:00Z",
          "updatedAt": "2021-03-31T20:29:43Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "s/unsinged/unsigned/",
              "createdAt": "2021-03-31T20:22:00Z",
              "updatedAt": "2021-04-01T17:12:09Z"
            },
            {
              "originalPosition": 34,
              "body": "Suppose the client does this, and then the server sends a ServerHello that claims to handshake with this PSK against ClientHelloOuter. What happens?\r\n\r\n(This probably should be an error, i.e. the client should act as if it didn't offer PSKs. But it's ambiguous enough that we should write it down.)",
              "createdAt": "2021-03-31T20:23:43Z",
              "updatedAt": "2021-04-01T17:12:09Z"
            },
            {
              "originalPosition": 30,
              "body": "As @kaduk pointed out to me recently, TLS 1.3 actually forbids sending pre_shared_keys without psk_key_exchange_modes and even mandates the server enforce this. If we're going to start patching in individual fields, we probably need to say that too.\r\nhttps://tools.ietf.org/html/rfc8446#section-4.2.9",
              "createdAt": "2021-03-31T20:25:48Z",
              "updatedAt": "2021-04-01T17:12:09Z"
            },
            {
              "originalPosition": 23,
              "body": "+1. #408 would be another example of a non-cover-traffic motivation which is actually about the real server and not network observers. Worrying about cover traffic suggests needing a threat model and such. The threat model for this is especially weird because the cover traffic can be distinguished with an active client probe:\r\n\r\n1. Observe a ClientHello with (possibly GREASE) ECH and (possibly GREASE) PSK.\r\n2. Call the client's bluff and construct a ServerHello that attempts to resume the PSK.\r\n3. See if the client rejects the message.",
              "createdAt": "2021-03-31T20:29:37Z",
              "updatedAt": "2021-04-01T17:12:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI1Njk2Mjk4",
          "commit": {
            "abbreviatedOid": "9a642b8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-31T20:35:50Z",
          "updatedAt": "2021-03-31T20:35:51Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "\ud83e\udd26 sigh, yeah. ",
              "createdAt": "2021-03-31T20:35:50Z",
              "updatedAt": "2021-04-01T17:12:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI1Njk2NDMw",
          "commit": {
            "abbreviatedOid": "9a642b8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-31T20:36:00Z",
          "updatedAt": "2021-03-31T20:36:01Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "```suggestion\r\nwith the same length. It also generates a random, 32-bit, unsigned integer to\r\n```",
              "createdAt": "2021-03-31T20:36:00Z",
              "updatedAt": "2021-04-01T17:12:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI1Njk3Nzg1",
          "commit": {
            "abbreviatedOid": "9a642b8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-31T20:37:52Z",
          "updatedAt": "2021-03-31T20:37:52Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Good point -- I think noting this as an error and failing the handshake seems good enough. ",
              "createdAt": "2021-03-31T20:37:52Z",
              "updatedAt": "2021-04-01T17:12:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI1NzM4MDAw",
          "commit": {
            "abbreviatedOid": "9a642b8"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-31T21:34:38Z",
          "updatedAt": "2021-03-31T21:34:38Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Done.",
              "createdAt": "2021-03-31T21:34:38Z",
              "updatedAt": "2021-04-01T17:12:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI1NzQwMTk4",
          "commit": {
            "abbreviatedOid": "9a642b8"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-31T21:38:13Z",
          "updatedAt": "2021-03-31T21:38:13Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Added this line below:\r\n\r\n> If the server replies with a \"pre_shared_key\" extension in its SeverHello, then\r\n> the client MUST abort the handshake with a \"handshake_failure\" alert.",
              "createdAt": "2021-03-31T21:38:13Z",
              "updatedAt": "2021-04-01T17:12:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI1NzQwNzA1",
          "commit": {
            "abbreviatedOid": "9a642b8"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-31T21:39:06Z",
          "updatedAt": "2021-03-31T21:39:06Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Sure, if you like that kind of thing. I prefer my integers to be unsinged.",
              "createdAt": "2021-03-31T21:39:06Z",
              "updatedAt": "2021-04-01T17:12:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI1NzQxNDg5",
          "commit": {
            "abbreviatedOid": "9a642b8"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-31T21:40:25Z",
          "updatedAt": "2021-03-31T21:40:25Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Yeah, I noticed that too. I guess I sort of thought this would be implied, but being explicit about it seems like a good idea. ",
              "createdAt": "2021-03-31T21:40:25Z",
              "updatedAt": "2021-04-01T17:12:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI1NzQ0MDI3",
          "commit": {
            "abbreviatedOid": "9a642b8"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-31T21:44:39Z",
          "updatedAt": "2021-03-31T21:44:39Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "The client now MUST copy \"psk_key_exchange_modes\" from CHInner into CHOuter.",
              "createdAt": "2021-03-31T21:44:39Z",
              "updatedAt": "2021-04-01T17:12:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI1NzUwNjE2",
          "commit": {
            "abbreviatedOid": "7fa0355"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-31T21:55:46Z",
          "updatedAt": "2021-03-31T21:55:47Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Minor nitpick: Probably \"unsupported_extension\" or \"illegal_parameter\". \"handshake_failure\" is specifically if everyone followed the protocol correctly, just you were unable to pick a common set of parameter. Whereas the other alerts are variations of \"you sent something invalid\".",
              "createdAt": "2021-03-31T21:55:47Z",
              "updatedAt": "2021-04-01T17:12:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI1Nzc2OTk0",
          "commit": {
            "abbreviatedOid": "7fa0355"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-31T22:46:37Z",
          "updatedAt": "2021-03-31T22:46:38Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "I'll go with \"illegal_parameter\" :)",
              "createdAt": "2021-03-31T22:46:38Z",
              "updatedAt": "2021-04-01T17:12:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI2MzkxMTQ3",
          "commit": {
            "abbreviatedOid": "1c8519d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-01T15:29:10Z",
          "updatedAt": "2021-04-01T15:29:21Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\n   {{flow-clienthello-malleability}}.) When the client includes a GREASE \"pre_shared_key\" extension, \r\n   it MUST also copy the \"psk_key_exchange_modes\" from the ClientHelloInner into the ClientHelloOuter.\r\n```",
              "createdAt": "2021-04-01T15:29:11Z",
              "updatedAt": "2021-04-01T17:12:09Z"
            }
          ]
        }
      ]
    },
    {
      "number": 415,
      "id": "MDExOlB1bGxSZXF1ZXN0NjA2MzQzMjAy",
      "title": "Mirror early_data in ClientHelloOuter when applicable.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/415",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This should probably land after #414.\r\n\r\nCloses #408.\r\n\r\ncc @davidben",
      "createdAt": "2021-03-31T20:55:10Z",
      "updatedAt": "2021-04-19T15:51:16Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "5a3783895a85b13abeba3e98e9abe2a3890a0ac2",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/mirror-early-data",
      "headRefOid": "97ae7aa8a4ceb2a779d84112a228113dbfd95920",
      "closedAt": "2021-04-19T13:47:49Z",
      "mergedAt": "2021-04-19T13:47:49Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "6a33a39feaf1cc0b404bb5b59b26ee25b3e7f69c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI1NzIxNTg3",
          "commit": {
            "abbreviatedOid": "b93c90e"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-31T21:10:13Z",
          "updatedAt": "2021-03-31T21:10:13Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI1NzM1Nzc3",
          "commit": {
            "abbreviatedOid": "b93c90e"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-31T21:30:58Z",
          "updatedAt": "2021-03-31T21:30:58Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI2NzE2MjAy",
          "commit": {
            "abbreviatedOid": "b93c90e"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-04-01T23:49:56Z",
          "updatedAt": "2021-04-01T23:50:01Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "This also requires pre_shared_key per s 4.2.10, so this contradicts the previous reqt.",
              "createdAt": "2021-04-01T23:49:57Z",
              "updatedAt": "2021-04-19T13:46:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI2NzE2NjA1",
          "commit": {
            "abbreviatedOid": "b93c90e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-01T23:51:25Z",
          "updatedAt": "2021-04-01T23:51:25Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "This is based on #414, which clarifies that the PSK must also be present. This won't land until that does.",
              "createdAt": "2021-04-01T23:51:25Z",
              "updatedAt": "2021-04-19T13:46:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM0NTc1NDE4",
          "commit": {
            "abbreviatedOid": "c2160ce"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-13T13:16:48Z",
          "updatedAt": "2021-04-13T13:16:48Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n   SHOULD also include a GREASE \"pre_shared_key\" extension in ClientHelloOuter,\r\n```",
              "createdAt": "2021-04-13T13:16:48Z",
              "updatedAt": "2021-04-19T13:46:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM0NTc3MDg5",
          "commit": {
            "abbreviatedOid": "15259b6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-13T13:18:20Z",
          "updatedAt": "2021-04-13T13:18:21Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "@ekr this should now be resolved give that #414 landed. Can you please take another look?",
              "createdAt": "2021-04-13T13:18:20Z",
              "updatedAt": "2021-04-19T13:46:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM0OTUzOTY3",
          "commit": {
            "abbreviatedOid": "15259b6"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-13T19:31:19Z",
          "updatedAt": "2021-04-13T19:31:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 416,
      "id": "MDExOlB1bGxSZXF1ZXN0NjA5Mzc4MDkw",
      "title": "Don't make a new handshake",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/416",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The idea that it might be OK to make a new handshake based on\r\nunauthenticated messages is inherently insecure.",
      "createdAt": "2021-04-06T01:03:11Z",
      "updatedAt": "2021-06-11T22:34:27Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "95a3fb44cc7703ab33ef11a9781f51962f3d0e0b",
      "headRepository": "martinthomson/draft-ietf-tls-esni",
      "headRefName": "noooo-restart",
      "headRefOid": "24eacecb5f97a46c526dac29b412716f4ee3d0b4",
      "closedAt": "2021-06-11T22:34:27Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This won't be needed if you take #417.  I just provided it because it is separable.",
          "createdAt": "2021-04-06T02:09:06Z",
          "updatedAt": "2021-04-06T02:09:06Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This is overcome by #423. Closing.",
          "createdAt": "2021-06-11T22:34:27Z",
          "updatedAt": "2021-06-11T22:34:27Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 417,
      "id": "MDExOlB1bGxSZXF1ZXN0NjA5Mzg5NjYy",
      "title": "HRR applies to both",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/417",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The current document is *so* close to getting this right.  I think that\r\nthis is correct and sufficient.\r\n\r\nCloses #233.\r\nCloses #373 by doing nothing.\r\nIssue #358 can be fixed in TLS 1.3 proper.\r\nIssue #333 can be addressed separately.",
      "createdAt": "2021-04-06T01:45:32Z",
      "updatedAt": "2021-06-11T22:26:25Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "95a3fb44cc7703ab33ef11a9781f51962f3d0e0b",
      "headRepository": "martinthomson/draft-ietf-tls-esni",
      "headRefName": "hrr-both",
      "headRefOid": "061cd2a70bf1562a6ec473a010563727a5ba0cee",
      "closedAt": "2021-06-11T22:26:25Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On the whole I think this is an improvement over the current language. However, it doesn't seem to solve what I think of as our fundamental problem: any future extension to TLS 1.3 that is HRR-sensitive most not only consider how it changes the core protocol, but also how it interacts with ECH. Insofar as possible, we should design ECH in a way that mitigates friction when composing it with other protocol changes. Otherwise, I worry this could become the source of future bugs or vulnerabilities in TLS stacks.\r\n\r\nThat said, it may be the prevailing view that these sorts of composition issues are inherent to protocol design, and hence not worth spending too much time/energy trying to mitigate. I'd like to think these issues aren't inevitable. Admittedly, however, I lack the chops of others following this issue and may be incredibly naive :)",
          "createdAt": "2021-04-13T19:30:02Z",
          "updatedAt": "2021-04-13T19:30:02Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as a solution to HRR since #423 was merged. (If we want to add text that suggests how clients construct CH1Inner/CH1Outer, that would be fine, but let's do it in a different PR!)",
          "createdAt": "2021-06-11T22:26:25Z",
          "updatedAt": "2021-06-11T22:26:25Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM1MDgyMzM4",
          "commit": {
            "abbreviatedOid": "061cd2a"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-13T22:43:39Z",
          "updatedAt": "2021-04-13T22:43:39Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "This criteria still doesn't look right. It seems to make the same mistake as text elsewhere in the document. ClientHello.cipher_suites cannot change in response to HelloRetryRequest, so it does not match the stated criteria. But in order for HRR to successfully apply to both, it must match. The PR also says 'which groups are\r\nincluded in the \"key_share\" extension', which is not supported by the proposed sentence. The proposed sentence would capture the entire key_share extension.\r\n\r\nFor me, I think the big question on matching vs. making a mismatch work (I now think we can do something much simpler than the HRRInner/HRROuter design, especially since we're discarding #333) is getting this criteria down. Whether we can write down clear and complete criteria that captures current and future[*] extensions and convince ourselves it'll work going forward. I don't think this PR is yet a successful existence proof.\r\n\r\n[*] We don't have many of these, but RFC8492 is at least one data point.",
              "createdAt": "2021-04-13T22:43:39Z",
              "updatedAt": "2021-04-13T22:43:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM4MzkyMDc0",
          "commit": {
            "abbreviatedOid": "061cd2a"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-19T00:13:45Z",
          "updatedAt": "2021-04-19T00:13:46Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "It seems like you are fixating on being able to find a perfect solution (as @cjpatton is).  I'm suggesting that we give up on that.  We have the means to work out what the right answer is for any new extension.  And the default answer (it can't change) means that we won't often need to contend with that problem.  It's only when new key exchange methods arise that this becomes an issue.  Which is why RFC 8492 is potentially interesting, except that it really isn't[*].\r\n\r\n[*] RFC 8492 is badly specified; it doesn't say that ClientHello needs to include password_salt in [Section 4.5.2.2](https://datatracker.ietf.org/doc/html/rfc8492#section-4.5.2.2).  But it seems fairly clear in its intent.  The extension exists to communicate a salt, which leads to a revision to the value of the key_share value.  This doesn't really change the calculus, except that key_share handling gets more complicated.  None of that is visible at the level at which this text operates though.\r\n\r\nI think that I know where your objection comes from, but it's a fine point regarding wording rather than a point about its intent.  I can maybe see the shortcomings of the text, but I want to work through the fundamental point before I try to finagle the text.",
              "createdAt": "2021-04-19T00:13:45Z",
              "updatedAt": "2021-04-19T00:13:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM5MDAyMjcx",
          "commit": {
            "abbreviatedOid": "061cd2a"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-19T15:24:03Z",
          "updatedAt": "2021-04-19T15:24:04Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "You're right that this is mostly a comment on the text. I think you and I are on the same page on the PR's intent (arrange for an identical set of acceptable HRRs between CHInner and CHOuter). But I think the text doesn't accomplish the intent. I'm using the complexity and accuracy of the text somewhat as a proxy for how future-proof it is, though there's also the more immediate concern that the paragraph is self-contradictory. :-)\r\n\r\nWhen you say figure out the right answer for any new extension, do you mean that each new extension where this matters should have some text relating to ECH? I think that's fine if we provide enough guidance (even if non-normative) that new extensions know what they need to do. (Do we need to update 8446 for this?) I don't think the general guidance in the PR works:\r\n\r\n> To ensure that a HelloRetryRequest is successful, clients needs to ensure that any values that might change in response to HelloRetryRequest are consistent in the two messages. \r\n\r\n> By consistent, this means that values in ClientHelloInner are identical to those in ClientHelloOuter, but with any values that only apply to TLS 1.2 or lower removed.\r\n\r\n>  Only extensions that change in response to HelloRetryRequest need to have any consideration for consistency between ClientHelloOuter and ClientHelloInner.\r\n\r\nThis general guidance isn't consistent with the goal of having an identical acceptable-HRR-set between the two. Suppose we added a parallel version of supported_groups + key_share tomorrow. By this guidance, supported_groups2 does not need to think about ECH, while key_share2 needs to be identical. But this is wrong on both counts. supported_groups2 *does* need to think about ECH, and only a subset of the information in key_share2 needs to match. (The latter isn't fatal. We could conservatively say key_share2 need to completely match, but I'll note that's not the strategy taken by this PR.)\r\n\r\nI believe the actual general rule is if the extension impacts what HRR messages are acceptable.",
              "createdAt": "2021-04-19T15:24:03Z",
              "updatedAt": "2021-04-19T15:24:04Z"
            }
          ]
        }
      ]
    },
    {
      "number": 418,
      "id": "MDExOlB1bGxSZXF1ZXN0NjA5MzkyMTQy",
      "title": "Split-mode HRR is just hard ",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/418",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "...but don't give both servers a cookie.\r\n\r\nThat is, if a client-facing server forwards the ClientHello, it can't do\r\nso statelessly without coordinating with the backend.  This is a\r\nconsequence of moving to a single HelloRetryRequest, but it's a minor\r\none.  In most cases, there will be state established anyway just to get\r\nthe connection forwarded.  DTLS might not work that way, but it's still\r\nlikely reasonable to assume state.\r\n\r\nCloses #333.\r\nNo longer builds on #417.",
      "createdAt": "2021-04-06T01:54:53Z",
      "updatedAt": "2021-04-22T02:12:59Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3562943c804fd173a513037d578a71dfd4ee967b",
      "headRepository": "martinthomson/draft-ietf-tls-esni",
      "headRefName": "split-hrr",
      "headRefOid": "a19979e91040bdab9d2a1fda8b07b0961e6f3cb5",
      "closedAt": "2021-04-22T02:12:59Z",
      "mergedAt": "2021-04-22T02:12:59Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "d36bc1e980018ef695aa81c1b24ba15050fbaf45"
      },
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I guess the dust is still settling on the rest of the HRR mess, but a6b6b67ca710d023962b8b950a2d26f2806d7aac LGTM.",
          "createdAt": "2021-04-21T17:55:42Z",
          "updatedAt": "2021-04-21T17:55:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 -- @martinthomson, can we cherry-pick a6b6b67 into a separate PR?",
          "createdAt": "2021-04-21T23:47:31Z",
          "updatedAt": "2021-04-21T23:47:31Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would be happy for you to take that and merge it.",
          "createdAt": "2021-04-21T23:54:21Z",
          "updatedAt": "2021-04-21T23:54:21Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Or, I will just rebase -i here.",
          "createdAt": "2021-04-22T00:22:34Z",
          "updatedAt": "2021-04-22T00:22:34Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQxNzIyMzU1",
          "commit": {
            "abbreviatedOid": "a19979e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-22T02:12:55Z",
          "updatedAt": "2021-04-22T02:12:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 419,
      "id": "MDExOlB1bGxSZXF1ZXN0NjA5Mzk1MjQ3",
      "title": "Grease and HRR leak",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/419",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "But that is just how it is.  We get to choose between that leakage and a\r\nknown large amount of bustage.\r\n\r\nCloses #358.",
      "createdAt": "2021-04-06T02:05:45Z",
      "updatedAt": "2021-08-02T16:15:20Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "5082ba6fa57954e1a5c5a64993894d5ada5758bb",
      "headRepository": "martinthomson/draft-ietf-tls-esni",
      "headRefName": "grease-sticks-out",
      "headRefOid": "04bb8ba1972e08eed0e23af2be7c3e9b0a1de0ca",
      "closedAt": "2021-08-02T16:15:20Z",
      "mergedAt": "2021-08-02T16:15:19Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "b02467727c3213e58e3262c95c6b1eb189c14673"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This solution admits a straightforward, active distinguisher: just intercept CH1, respond with a fake HRR, and look at CH2. It's true that we \"give up\" on making HRR not stick out in #407. However, one of the design goals there is to prevent active attacks that trigger the HRR code path when it otherwise would not have happened. What we give up on is ensuring \"don't stick out\" when HRR is inevitable for the given client and server.",
          "createdAt": "2021-04-13T19:00:35Z",
          "updatedAt": "2021-04-13T19:02:06Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "> This solution admits a straightforward, active distinguisher: just intercept CH1, respond with a fake HRR, and look at CH2. It's true that we \"give up\" on making HRR not stick out in #407. However, one of the design goals there is to prevent active attacks that trigger the HRR code path when it otherwise would not have happened. What we give up on is ensuring \"don't stick out\" when HRR is inevitable for the given client and server.\r\n\r\nAh, are you saying that this conflicts with #407 (and thus would have to be removed if #407 is merged)?",
          "createdAt": "2021-04-13T19:15:55Z",
          "updatedAt": "2021-04-13T19:15:55Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe #407 resolves the same \"OPEN ISSUE\", yes.",
          "createdAt": "2021-04-13T19:54:50Z",
          "updatedAt": "2021-04-13T19:54:50Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM0OTI3ODE1",
          "commit": {
            "abbreviatedOid": "2b3ea14"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-13T18:57:36Z",
          "updatedAt": "2021-04-13T18:57:36Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA5ODE1OTY2",
          "commit": {
            "abbreviatedOid": "2b3ea14"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-19T17:40:00Z",
          "updatedAt": "2021-07-19T17:40:00Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA5ODg3MDM1",
          "commit": {
            "abbreviatedOid": "2b3ea14"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-19T19:07:36Z",
          "updatedAt": "2021-07-19T19:07:36Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\nHelloRetryRequest. \r\n```",
              "createdAt": "2021-07-19T19:07:36Z",
              "updatedAt": "2021-07-19T19:07:36Z"
            }
          ]
        }
      ]
    },
    {
      "number": 420,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE1MjYwNDM4",
      "title": "Relax computation of the acceptance signal.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/420",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We previously derived the acceptance signal from the handshake secret.\r\nThis meant that clients which used the wrong ECHConfig might need to\r\nprocess ServerHello extensions twice before computing the signal, which\r\ncan be problematic for some libraries. Given that the signal's secrecy\r\nis entirely dependent on ClientHelloInner.random, we can relax the signal\r\ncomputation and base it on the transcript alone, which includes\r\nClientHelloInner.random, rather than a secret derived from that transcript.\r\n\r\nCloses #399.\r\n\r\ncc @davidben, @cjpatton, @sftcd ",
      "createdAt": "2021-04-14T13:51:35Z",
      "updatedAt": "2021-04-19T15:51:17Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "d309b977ed5c91a5e7ae3aab969d11020bc3b97a",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/relax-accept-signal",
      "headRefOid": "805c13f6ab3d8ce5b9194b1e5f29681347556b94",
      "closedAt": "2021-04-19T13:45:43Z",
      "mergedAt": "2021-04-19T13:45:43Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "5a3783895a85b13abeba3e98e9abe2a3890a0ac2"
      },
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 14/04/2021 21:11, David Benjamin wrote:\n> @davidben approved this pull request.\n\nYep, good change. Thanks,\nS.\n\n> \n> \n> \n> \n> \n",
          "createdAt": "2021-04-14T20:35:30Z",
          "updatedAt": "2021-04-14T20:35:30Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM2MDM4MzA2",
          "commit": {
            "abbreviatedOid": "2859bab"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-14T20:11:06Z",
          "updatedAt": "2021-04-14T20:11:06Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM3MTI4MDA2",
          "commit": {
            "abbreviatedOid": "2859bab"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-15T21:05:11Z",
          "updatedAt": "2021-04-15T21:05:11Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM4MDk1Mzg5",
          "commit": {
            "abbreviatedOid": "2859bab"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-16T21:28:13Z",
          "updatedAt": "2021-04-16T21:28:13Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM4MzkyNTQz",
          "commit": {
            "abbreviatedOid": "2859bab"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Seems fine to me.",
          "createdAt": "2021-04-19T00:17:15Z",
          "updatedAt": "2021-04-19T00:18:21Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Not a problem with this PR, but...\r\n\r\nI honestly don't understand this construction.  ServerHelloECHConf isn't part of the sequence listed in [Section 4.4.1 of RFC 8446](https://tools.ietf.org/html/rfc8446#section-4.4.1).  Maybe I can infer that it replaces ServerHello, but you need to *say* that.  And ClientHelloInner isn't listed there either.\r\n\r\nI think that you need to be more careful about this part of the specification.",
              "createdAt": "2021-04-19T00:17:15Z",
              "updatedAt": "2021-04-19T13:45:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM4ODg2MjUw",
          "commit": {
            "abbreviatedOid": "2859bab"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-19T13:45:12Z",
          "updatedAt": "2021-04-19T13:45:12Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Yeah, that's the idea. I updated the text to make this explicit. ",
              "createdAt": "2021-04-19T13:45:12Z",
              "updatedAt": "2021-04-19T13:45:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 421,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE2Mzc4MTY5",
      "title": "Wrap some lines so that the build succeeds",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/421",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-04-15T21:40:31Z",
      "updatedAt": "2021-04-16T19:55:18Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "d309b977ed5c91a5e7ae3aab969d11020bc3b97a",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "build-fix",
      "headRefOid": "6045fbeaedc0c16cbf8b46ba6e3e4013f7761559",
      "closedAt": "2021-04-15T21:42:50Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 422,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE2NDAxNjgz",
      "title": "Use ECH payload to distinguish CHI from CHO",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/422",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently we distinguish between CHI and CHO by sending \"ech_is_inner\"\r\nin CHI and \"encrypted_client_hello\" in CHO. A future change will signal\r\nECH acceptance in HRR using the \"encrypted_client_hello\" codepoint. This\r\nwould violate 8446's rule that disallows unsolicited extensions. In\r\npreparation for this change, this commit removes the \"ech_is_inner\"\r\nextension and adds a byte to the payload of \"encrypted_client_hello\"\r\nthat signals to the server whether the message is CHI or CHO.",
      "createdAt": "2021-04-15T22:37:44Z",
      "updatedAt": "2021-06-17T21:17:41Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f08b6cf4ab8378723f7b4ab36a1d68e29b1227a0",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "hrr-inner-2",
      "headRefOid": "b7fea2cc55688ed7aad2a3a3cfc69869b26c5c66",
      "closedAt": "2021-06-11T22:21:02Z",
      "mergedAt": "2021-06-11T22:21:02Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "b7fea2cc55688ed7aad2a3a3cfc69869b26c5c66"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Rebased and squashed.",
          "createdAt": "2021-06-07T17:35:13Z",
          "updatedAt": "2021-06-07T17:35:13Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Rebased.",
          "createdAt": "2021-06-11T21:56:00Z",
          "updatedAt": "2021-06-11T21:56:00Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM3Nzg0OTk2",
          "commit": {
            "abbreviatedOid": "9f32694"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-16T14:52:41Z",
          "updatedAt": "2021-04-16T14:52:41Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Why do we need a type byte? Don't the contents of the extension distinguish inner vs outer? (That is, if it's empty, the extension is of type is-outer, else it's is-inner.) The type byte seems redundant.",
              "createdAt": "2021-04-16T14:52:41Z",
              "updatedAt": "2021-04-16T19:53:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM3ODA5Mzg2",
          "commit": {
            "abbreviatedOid": "9f32694"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-16T15:16:58Z",
          "updatedAt": "2021-04-16T15:16:58Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "It avoids an ambiguity between ClientHelloInner with ClientHelloOuterAAD.outer_hello, both of which would contain an empty ECH extension. Plus, using an enum here seemed more idiomatic for TLS. It seems like it's easier to write down the protocol logic.",
              "createdAt": "2021-04-16T15:16:58Z",
              "updatedAt": "2021-04-19T15:09:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM3ODE0MjM1",
          "commit": {
            "abbreviatedOid": "9f32694"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-16T15:22:03Z",
          "updatedAt": "2021-04-16T15:22:04Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "```suggestion\r\n`is-inner` variant. The inner extension has an empty payload. The outer\r\n```",
              "createdAt": "2021-04-16T15:22:03Z",
              "updatedAt": "2021-04-16T19:53:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM3ODE2Njc1",
          "commit": {
            "abbreviatedOid": "9f32694"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-16T15:24:31Z",
          "updatedAt": "2021-04-16T15:24:32Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Hmm... why is avoiding that ambiguity important? ",
              "createdAt": "2021-04-16T15:24:32Z",
              "updatedAt": "2021-04-19T15:09:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM3ODIwMzIy",
          "commit": {
            "abbreviatedOid": "9f32694"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-16T15:28:16Z",
          "updatedAt": "2021-04-16T15:28:16Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "It might not be. If you prefer to save a byte here, we can do away with the type. I just think the protocol is cleaner and the spec is easier to understand with the type.",
              "createdAt": "2021-04-16T15:28:16Z",
              "updatedAt": "2021-04-19T15:09:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM3ODQ3NjY2",
          "commit": {
            "abbreviatedOid": "9f32694"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-16T15:46:23Z",
          "updatedAt": "2021-04-16T15:46:24Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Yeah, that's makes sense. I just wanted to make sure I wasn't missing something else. If folks think it's more clear, I'm fine with keeping it. ",
              "createdAt": "2021-04-16T15:46:23Z",
              "updatedAt": "2021-04-19T15:09:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM3ODUyNzk0",
          "commit": {
            "abbreviatedOid": "9f32694"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-16T15:51:59Z",
          "updatedAt": "2021-04-16T15:56:09Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "```suggestion\r\n1. It MUST include the \"encrypted_client_hello\" extension of type `is-inner` as described in\r\n```",
              "createdAt": "2021-04-16T15:51:59Z",
              "updatedAt": "2021-04-16T19:53:31Z"
            },
            {
              "originalPosition": 114,
              "body": "```suggestion\r\n* If `ClientECH.type` is `outer`, then the server acts as a client-facing\r\n```",
              "createdAt": "2021-04-16T15:53:03Z",
              "updatedAt": "2021-04-16T19:53:32Z"
            },
            {
              "originalPosition": 21,
              "body": "```suggestion\r\n    enum { outer(0), inner(1) } ClientECHType;\r\n```",
              "createdAt": "2021-04-16T15:53:14Z",
              "updatedAt": "2021-04-16T19:53:32Z"
            },
            {
              "originalPosition": 121,
              "body": "```suggestion\r\n* If `ClientECH.type` is `inner`, then the server acts as a backend server and\r\n```",
              "createdAt": "2021-04-16T15:53:29Z",
              "updatedAt": "2021-04-16T19:53:32Z"
            },
            {
              "originalPosition": 158,
              "body": "```suggestion\r\nmessage includes a well-formed \"encrypted_client_hello\" extension of type `inner` and that it\r\n```",
              "createdAt": "2021-04-16T15:54:02Z",
              "updatedAt": "2021-04-16T19:53:32Z"
            },
            {
              "originalPosition": 185,
              "body": "```suggestion\r\n`ClientECH.type` is `inner`. If this is not the case, the backend server MUST\r\n```",
              "createdAt": "2021-04-16T15:54:23Z",
              "updatedAt": "2021-04-16T19:53:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM5MjY1MDI0",
          "commit": {
            "abbreviatedOid": "bd09b09"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-19T20:09:52Z",
          "updatedAt": "2021-04-19T20:16:59Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "I'm not sure if there is a way to say `select (empty)` in the TLS presentation syntax. Though I suspect the ambiguity doesn't matter. (If it did, we could go back to the idea of just clearing `payload` rather than replacing with an empty extension.)\r\n\r\n*shrug* Whatever works. I don't think it's worth worrying about too much.",
              "createdAt": "2021-04-19T20:09:52Z",
              "updatedAt": "2021-04-19T20:16:59Z"
            },
            {
              "originalPosition": 173,
              "body": "of type inner",
              "createdAt": "2021-04-19T20:14:38Z",
              "updatedAt": "2021-04-19T20:16:59Z"
            },
            {
              "originalPosition": 188,
              "body": "I think we can delete this paragraph:\r\n\r\nThe old text wasn't talking about inner vs outer but about the payload of the extension. But that's part of the syntax of the extension so it'd be decode_error and also already captured in the extension's syntax.\r\n\r\nThe new text seems to be talking about inner vs outer, but we've already captured that in the precondition for this section. You only go into the backend server section if it's already an inner variant.\r\n\r\nThus, I think we can trim this. :-)",
              "createdAt": "2021-04-19T20:16:43Z",
              "updatedAt": "2021-04-19T20:16:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjYwMDgyNTI0",
          "commit": {
            "abbreviatedOid": "bd09b09"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-14T18:08:48Z",
          "updatedAt": "2021-05-14T18:08:48Z",
          "comments": [
            {
              "originalPosition": 188,
              "body": "Good call :)",
              "createdAt": "2021-05-14T18:08:48Z",
              "updatedAt": "2021-05-14T18:08:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY0OTY1NDU1",
          "commit": {
            "abbreviatedOid": "83ac6eb"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-20T22:52:21Z",
          "updatedAt": "2021-05-20T22:52:21Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "(This comment should be a few stanzas down, but GitHub is silly.)\r\n\r\nSomething I realized working through an implementation. I think we also need to adjust this line below:\r\n\r\n>  When the client offers the \"encrypted_client_hello\" extension, the server MAY include an \"encrypted_client_hello\" extension in its EncryptedExtensions message with the following payload:\r\n\r\nIf we handshake a ClientHelloInner, the server is not supposed to send retry configs. The encrypted_client_hello / ech_is_inner version captured this implicitly with the unsolicited extensions rule: the inner ClientHello doesn't have encrypted_client_hello, only ech_is_inner.\r\n\r\nIn this form, we instead make HRR happier, but I think we need to here, or elsewhere, say the server can only send this when the client offers encrypted_client_hello with type outer. Sending this with type inner should be an unsupported_extension alert.",
              "createdAt": "2021-05-20T22:52:21Z",
              "updatedAt": "2021-05-20T22:52:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY1NjI1NTIw",
          "commit": {
            "abbreviatedOid": "a8a7c0a"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-21T15:59:08Z",
          "updatedAt": "2021-05-21T15:59:08Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Done.",
              "createdAt": "2021-05-21T15:59:08Z",
              "updatedAt": "2021-05-21T15:59:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc2MzMyMTYx",
          "commit": {
            "abbreviatedOid": "a8a7c0a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-04T14:14:38Z",
          "updatedAt": "2021-06-04T14:14:38Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc2NzM5MDM3",
          "commit": {
            "abbreviatedOid": "a8a7c0a"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-05T01:44:14Z",
          "updatedAt": "2021-06-05T01:44:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 423,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE2NDMzOTI0",
      "title": "Confirm ECH acceptance after HRR",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/423",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Based on #422 (review that first!).\r\n\r\nIf an HRR is sent in response to CH, the client doesn't know whether ECH\r\nwas accepted. As a result, it doesn't know whether it's CHI or CHO that\r\nneeds to be updated. The spec attempts to address this ambiguity by\r\nrequiring that all HRR-sensitive parameters are the same in CHI and CHO.\r\nThis criterion is currently underspecified, and it's not clear how to\r\nmake sure that future extensions don't violate it. (See issue #374.)\r\n\r\nThis change solves this ambiguity by adding an explicit signal of ECH\r\nacceptance to HRR. This violates \"don't stick out\" whenever an HRR is\r\ninevitable for a particular client and server configuration. However,\r\nthis change is designed to prevent an active attacker from\r\ndistinguishing real ECH from GREASE ECH by triggering HRR.\r\n\r\nCloses #374 by providing an alternative to PR #407.\r\nCloses #373.\r\nCloses #358.\r\n\r\n",
      "createdAt": "2021-04-15T23:51:53Z",
      "updatedAt": "2021-06-17T21:17:39Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f08b6cf4ab8378723f7b4ab36a1d68e29b1227a0",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "hrr-inner-2-main",
      "headRefOid": "f543f207fdfd686cb004d47beb85e89b61c24388",
      "closedAt": "2021-06-11T22:21:00Z",
      "mergedAt": "2021-06-11T22:21:00Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "9f9f26ddcefc771f3e2b77aa75a824f76f3cf981"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Rebased.",
          "createdAt": "2021-06-07T17:52:37Z",
          "updatedAt": "2021-06-07T17:52:37Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Squashed and rebased.",
          "createdAt": "2021-06-11T22:19:44Z",
          "updatedAt": "2021-06-11T22:19:44Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM3ODU4NDI3",
          "commit": {
            "abbreviatedOid": "0a555c9"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-16T15:57:59Z",
          "updatedAt": "2021-04-16T16:04:58Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "```suggestion\r\n{{backend-server}}. If found, the client presumes acceptance and handles the HelloRetryRequest\r\nusing ClientHelloInner. Otherwise, it\r\n```",
              "createdAt": "2021-04-16T15:57:59Z",
              "updatedAt": "2021-05-11T15:11:09Z"
            },
            {
              "originalPosition": 161,
              "body": "```suggestion\r\npresumes rejection and handles the HelloRetryRequest using ClientHelloOuter.\r\n```",
              "createdAt": "2021-04-16T15:58:27Z",
              "updatedAt": "2021-05-11T15:11:09Z"
            },
            {
              "originalPosition": 193,
              "body": "Do we want to note this as a possible distinguisher here (or in the security considerations)?",
              "createdAt": "2021-04-16T16:00:41Z",
              "updatedAt": "2021-05-11T15:11:09Z"
            },
            {
              "originalPosition": 318,
              "body": "What does \"overriding\" mean here?",
              "createdAt": "2021-04-16T16:03:23Z",
              "updatedAt": "2021-05-11T15:11:09Z"
            },
            {
              "originalPosition": 160,
              "body": "Maybe not needed, but should we clarify that the extension _is not_ sent if ECH was rejected? (That currently seems to be how this works, and I think that's fine, since the fact that the client's extension value doesn't change in the second CH on rejection is a clear distinguisher.)",
              "createdAt": "2021-04-16T16:04:46Z",
              "updatedAt": "2021-05-11T15:11:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM4MDQ3MTc5",
          "commit": {
            "abbreviatedOid": "0a555c9"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-16T20:02:03Z",
          "updatedAt": "2021-04-16T20:02:03Z",
          "comments": [
            {
              "originalPosition": 318,
              "body": "I mean that it replaces the payload with the derived value. I changed \"overriding\" to \"replacing\".",
              "createdAt": "2021-04-16T20:02:03Z",
              "updatedAt": "2021-05-11T15:11:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM4MDQ4OTMy",
          "commit": {
            "abbreviatedOid": "0a555c9"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-16T20:04:50Z",
          "updatedAt": "2021-04-16T20:04:50Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "Yeah, I think it's worth noting. Done.",
              "createdAt": "2021-04-16T20:04:50Z",
              "updatedAt": "2021-05-11T15:11:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM4MDk3Nzk4",
          "commit": {
            "abbreviatedOid": "acc2370"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-16T21:33:27Z",
          "updatedAt": "2021-04-16T21:33:27Z",
          "comments": [
            {
              "originalPosition": 318,
              "body": "We might want to make it clear, in the definition of this extension, that it can exist in HelloRetryRequest, and in that case, carries `uint8 accept_signal[8]`. It just seems strange to say \"we know the extension is defined with this structure, but in this exceptional case we just ignore that syntax and throw some bytes in the payload.\"",
              "createdAt": "2021-04-16T21:33:27Z",
              "updatedAt": "2021-05-11T15:11:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM4NDA3MzA0",
          "commit": {
            "abbreviatedOid": "acc2370"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I can live with this change.  I still think that the concerns about HRR applicability are overblown, but this is workable.",
          "createdAt": "2021-04-19T01:38:54Z",
          "updatedAt": "2021-04-19T01:39:07Z",
          "comments": [
            {
              "originalPosition": 328,
              "body": "Please, work on improving the definition of `Transcript-Hash()`.  As I commented in the other PR, this definition is too loose.",
              "createdAt": "2021-04-19T01:38:55Z",
              "updatedAt": "2021-05-11T15:11:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU1OTg4MjU3",
          "commit": {
            "abbreviatedOid": "acc2370"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-10T18:58:17Z",
          "updatedAt": "2021-05-10T18:58:18Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "Just to make sure I'm reading this right: the intent of this text is that you'd leave all other extensions of ClientHelloOuter unchanged, independent of what was in HelloRetryRequest?\r\n\r\nNot an objection. Just trying to understand what this is saying.\r\n\r\nThough, as I write this, this does do something kinda interesting. Suppose your first ClientHello was:\r\n\r\n```\r\nClientHelloOuter{\r\n  alpn{h2},\r\n  key_share{x25519{aaa}}\r\n  supported_groups{x25519, secp256r1}\r\n  server_name{\"public.example\"}\r\n  encrypted_client_hello{\r\n    EncodedClientHelloInner{\r\n      outer_extensions{alpn, key_share, supported_groups}\r\n      server_name{\"example.com\"}\r\n      encrypted_client_hello{}\r\n    }\r\n    # Expands to:\r\n    # ClientHelloInner{\r\n    #  alpn{h2},\r\n    #  key_share{x25519{aaa}}\r\n    #  supported_groups{x25519, secp256r1}\r\n    #  server_name{\"example.com\"}\r\n    #  encrypted_client_hello{}\r\n    # }\r\n  }\r\n}\r\n```\r\n\r\nNow you get a HelloRetryRequest:\r\n\r\n```\r\nHelloRetryRequest{\r\n  key_share{secp256r1}\r\n  encrypted_client_hello{...}\r\n}\r\n```\r\n\r\nThis is an ECH-accept HRR, so the new ClientHelloInner is:\r\n\r\n```\r\nClientHelloInner{\r\n  alpn{h2},\r\n  key_share{secp256r1{bbb}}\r\n  supported_groups{x25519, secp256r1}\r\n  server_name{\"example.com\"}\r\n  encrypted_client_hello{}\r\n}\r\n```\r\n\r\nBut if our rules say you don't change ClientHelloOuter, the key_share extension no longer matches. You can only compress alpn and supported_groups. But those extensions are no longer contiguous, and a sufficiently strict reading of RFC8446 4.1.2 probably forbids reordering the extensions.\r\n\r\nSome ideas on ways out of this:\r\n\r\n* Don't compress the second ClientHelloInner at all. But this means wasting bytes because we're obligated to resend a bunch of stuff now known to be useless.\r\n* Allow the second ClientHelloOuter to arbitrarily change if the client feels like it. Then the client can arrange to compress the same way as it previously did (probably reusing the same code as above). But this means the rules on what the client does are weird and open-ended.\r\n* Don't compress the second ClientHelloInner at all *and* drop all extensions from the ClientHelloOuter because it's totally irrelevant at this point. This avoids wasting bytes and is well-defined, but it means yet another ad-hoc ClientHello serializer, albeit a pretty straightforward one.\r\n* Relax RFC8446 4.1.2 rules. You compress the ones that didn't change and reorder as needed. Wastes less bytes but still some bytes. Also it means the client's compression logic gets even more interesting cases.",
              "createdAt": "2021-05-10T18:58:18Z",
              "updatedAt": "2021-05-11T15:11:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU2MTY4OTkz",
          "commit": {
            "abbreviatedOid": "acc2370"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-10T23:48:50Z",
          "updatedAt": "2021-05-10T23:48:50Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "Or you could change both.  That isn't this PR, but it is straightforward.\r\n\r\nSo many words spilled on a feature that only really changes one field (key_share)...",
              "createdAt": "2021-05-10T23:48:50Z",
              "updatedAt": "2021-05-11T15:11:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU2Nzk2Mjkw",
          "commit": {
            "abbreviatedOid": "acc2370"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-11T14:37:16Z",
          "updatedAt": "2021-05-11T14:37:17Z",
          "comments": [
            {
              "originalPosition": 318,
              "body": "I'm not understanding the recommendation. Do you mean we should say in {{encrypted-client-hello}} that the server's response may appear in HRR and define the structure?",
              "createdAt": "2021-05-11T14:37:16Z",
              "updatedAt": "2021-05-11T15:11:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU2ODAwNjQy",
          "commit": {
            "abbreviatedOid": "acc2370"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-11T14:40:46Z",
          "updatedAt": "2021-05-11T14:40:46Z",
          "comments": [
            {
              "originalPosition": 328,
              "body": "I'm sorry, Martin, I'm afraid I've lost the context here. Can you point me to your original comment, or recall the change that's needed?",
              "createdAt": "2021-05-11T14:40:46Z",
              "updatedAt": "2021-05-11T15:11:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU2ODE5NjY4",
          "commit": {
            "abbreviatedOid": "acc2370"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-11T14:52:56Z",
          "updatedAt": "2021-05-11T14:52:56Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "> Just to make sure I'm reading this right: the intent of this text is that you'd leave all other extensions of ClientHelloOuter unchanged, independent of what was in HelloRetryRequest?\r\n\r\nThe intention was that you would change the ClientHelloOuter as needed for the inner handshake. For example, if you need to change CHI.key_share, but you referenced this from CHO, you would update CHO.key_share.\r\n\r\n>     * Don't compress the second ClientHelloInner at all. But this means wasting bytes because we're obligated to resend a bunch of stuff now known to be useless.\r\n\r\n:-1: :)\r\n \r\n>     * Allow the second ClientHelloOuter to arbitrarily change if the client feels like it. Then the client can arrange to compress the same way as it previously did (probably reusing the same code as above). But this means the rules on what the client does are weird and open-ended.\r\n\r\n:+1: This is what I intended. Are you suggesting that the algorithm for updating CHI and CHO is ambiguous?\r\n\r\n>     * Don't compress the second ClientHelloInner at all _and_ drop all extensions from the ClientHelloOuter because it's totally irrelevant at this point. This avoids wasting bytes and is well-defined, but it means yet another ad-hoc ClientHello serializer, albeit a pretty straightforward one.\r\n\r\nI'd be OK with this.\r\n\r\n>     * Relax RFC8446 4.1.2 rules. You compress the ones that didn't change and reorder as needed. Wastes less bytes but still some bytes. Also it means the client's compression logic gets even more interesting cases.\r\n\r\nWhich rules would we need to relax?",
              "createdAt": "2021-05-11T14:52:56Z",
              "updatedAt": "2021-05-11T15:11:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU3MTkzNzM0",
          "commit": {
            "abbreviatedOid": "fe810b0"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-11T20:15:49Z",
          "updatedAt": "2021-05-11T20:15:50Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "(Taking the second option. I'll make the text more clear.)",
              "createdAt": "2021-05-11T20:15:49Z",
              "updatedAt": "2021-05-11T20:15:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU3MTk2NTA0",
          "commit": {
            "abbreviatedOid": "fe810b0"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-11T20:19:26Z",
          "updatedAt": "2021-05-11T20:19:26Z",
          "comments": [
            {
              "originalPosition": 328,
              "body": "(The `Msg1...MsgN` syntax doesn't mean what I think it means. Per @martinthomson's comment, say how we change Section 4.4.1 of 8446. Need to fix this in the SH.random signal as well.)",
              "createdAt": "2021-05-11T20:19:26Z",
              "updatedAt": "2021-05-11T20:23:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc2MzM4NjQ2",
          "commit": {
            "abbreviatedOid": "c4f84a7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I'm OK with this change, with one exception: I think we should grease the rejection path so that there's no obvious distinguisher as to whether ECH was accepted or rejected in the presence of HRR.",
          "createdAt": "2021-06-04T14:20:09Z",
          "updatedAt": "2021-06-04T14:31:56Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "```suggestion\r\nhandles the HelloRetryRequest using ClientHelloOuter. \r\n```\r\n\r\nI thought the intent was to grease this in the case of rejection to ensure the extension is always present -- am I misremembering? @davidben, do you remember? (This would require us to add new text to the client-facing server section on what to do when it rejects but sends HRR, which we currently don't have.) ",
              "createdAt": "2021-06-04T14:20:09Z",
              "updatedAt": "2021-06-04T14:31:56Z"
            },
            {
              "originalPosition": 315,
              "body": "This seems like a more verbose description of the hash than what was there previously. Why the change?",
              "createdAt": "2021-06-04T14:23:01Z",
              "updatedAt": "2021-06-04T14:31:56Z"
            },
            {
              "originalPosition": 359,
              "body": "```suggestion\r\nbytes. It then computes the transcript has for the first ClientHelloInner, denoted ClientHelloInner1, up to and\r\n```\r\n\r\n(`ClientHelloInner1` isn't defined anywhere)",
              "createdAt": "2021-06-04T14:28:50Z",
              "updatedAt": "2021-06-04T14:31:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc2MzU1Mzc0",
          "commit": {
            "abbreviatedOid": "c4f84a7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-04T14:36:07Z",
          "updatedAt": "2021-06-04T14:36:07Z",
          "comments": [
            {
              "originalPosition": 328,
              "body": "What did you think it meant? The syntax seems pretty clear (to me) -- it's a sequence of messages. Is the problem that the sequence of messages is not clear? Should we just be explicit and list all messages, rather than just assume the reader can figure it out? That is, instead of:\r\n\r\n`ClientHelloInner...ServerHelloECHConf`\r\n\r\nsay\r\n\r\n`ClientHelloInner || ServerHelloECHConf`\r\n\r\nin the happy path, and, e.g., \r\n\r\n`ClientHelloInner1 || HelloRetryRequest || ClientHelloInner2 || ServerHelloECHConf`\r\n\r\nin the HRR+ECH-accept path, or whatever?\r\n",
              "createdAt": "2021-06-04T14:36:07Z",
              "updatedAt": "2021-06-11T22:01:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc2NzEzOTU5",
          "commit": {
            "abbreviatedOid": "c4f84a7"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-04T23:03:38Z",
          "updatedAt": "2021-06-04T23:03:39Z",
          "comments": [
            {
              "originalPosition": 322,
              "body": "Why is `HKDF-Extract(0, ClientHelloInner.random)` now necessary?",
              "createdAt": "2021-06-04T23:03:38Z",
              "updatedAt": "2021-06-04T23:03:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc2NzE0NjE4",
          "commit": {
            "abbreviatedOid": "c4f84a7"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-04T23:06:05Z",
          "updatedAt": "2021-06-04T23:06:05Z",
          "comments": [
            {
              "originalPosition": 315,
              "body": "Seems like it was to clarify what exactly the transcript hash should consist of (i.e. the zeroes) or else it becomes a recursive definition.",
              "createdAt": "2021-06-04T23:06:05Z",
              "updatedAt": "2021-06-04T23:06:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc2NzI1MDcz",
          "commit": {
            "abbreviatedOid": "c4f84a7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-04T23:49:53Z",
          "updatedAt": "2021-06-04T23:49:53Z",
          "comments": [
            {
              "originalPosition": 322,
              "body": "It shouldn't be -- we can probably drop it.",
              "createdAt": "2021-06-04T23:49:53Z",
              "updatedAt": "2021-06-04T23:49:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc2NzI1NDcx",
          "commit": {
            "abbreviatedOid": "c4f84a7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-04T23:51:54Z",
          "updatedAt": "2021-06-04T23:51:55Z",
          "comments": [
            {
              "originalPosition": 315,
              "body": "I don't see any difference in the text \ud83e\udd37",
              "createdAt": "2021-06-04T23:51:54Z",
              "updatedAt": "2021-06-04T23:51:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc2NzM5MDQ4",
          "commit": {
            "abbreviatedOid": "c4f84a7"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-05T01:44:22Z",
          "updatedAt": "2021-06-05T01:44:22Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc2NzM5MTM5",
          "commit": {
            "abbreviatedOid": "c4f84a7"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-05T01:45:39Z",
          "updatedAt": "2021-06-05T01:45:40Z",
          "comments": [
            {
              "originalPosition": 366,
              "body": "If you drop `HKDF-Extract(0, ClientHelloInner.random)` above, presumably you should drop `HKDF-Extract(0, ClientHelloInner1.random)` too.",
              "createdAt": "2021-06-05T01:45:39Z",
              "updatedAt": "2021-06-05T01:45:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3NTY1ODkx",
          "commit": {
            "abbreviatedOid": "c4f84a7"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "@chris-wood, IIRC we didn't make a call about whether to grease the HRR acceptance signal. I suggest we leave it out of this PR and re-consider it later.",
          "createdAt": "2021-06-07T15:27:03Z",
          "updatedAt": "2021-06-07T15:35:03Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "I don't recall making a decision about this. I'd like to suggest we leave this change out of the current PR and leave an OPEN ISSUE for deciding whether to grease the HRR acceptance signal.",
              "createdAt": "2021-06-07T15:27:04Z",
              "updatedAt": "2021-06-07T15:35:03Z"
            },
            {
              "originalPosition": 322,
              "body": "Using `0` as the PRK isn't safe, since this value is supposed to be pseudorandom (see https://datatracker.ietf.org/doc/html/rfc5869). Assuming `ClientHelloInner.random` has entropy,  `HKDF-Extract(0, ClientHelloInner.random)` is pseudorandom. We might be able to get away with using `ClientHelloInner.random` as the PRK directly, if the client generates this value securely. Note that this is change matches what we had in draft-ietf-tls-esni-08.",
              "createdAt": "2021-06-07T15:31:52Z",
              "updatedAt": "2021-06-07T15:35:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3NjUxODc1",
          "commit": {
            "abbreviatedOid": "2de9a8b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T16:41:13Z",
          "updatedAt": "2021-06-07T16:41:14Z",
          "comments": [
            {
              "originalPosition": 322,
              "body": "HKDF is a dual-PRF, so the result is the same. We don't need to do this. ",
              "createdAt": "2021-06-07T16:41:14Z",
              "updatedAt": "2021-06-07T16:41:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3NjUzMzgx",
          "commit": {
            "abbreviatedOid": "2de9a8b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T16:42:49Z",
          "updatedAt": "2021-06-07T16:42:49Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "That works for me, then. Let's prep that PR to build on top of this, and flag this as an open issue.",
              "createdAt": "2021-06-07T16:42:49Z",
              "updatedAt": "2021-06-07T16:43:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3NjcyODc2",
          "commit": {
            "abbreviatedOid": "dd1f9f6"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T17:04:02Z",
          "updatedAt": "2021-06-07T17:04:03Z",
          "comments": [
            {
              "originalPosition": 322,
              "body": "I don't think that's true. In any case, the change is orthogonal, so I'll move it to a separate PR.",
              "createdAt": "2021-06-07T17:04:03Z",
              "updatedAt": "2021-06-07T17:04:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3NzI2MTU0",
          "commit": {
            "abbreviatedOid": "eceb7eb"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T17:59:18Z",
          "updatedAt": "2021-06-07T17:59:19Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "Done.",
              "createdAt": "2021-06-07T17:59:18Z",
              "updatedAt": "2021-06-07T17:59:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMjQ4NDE0",
          "commit": {
            "abbreviatedOid": "f543f20"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-11T22:20:37Z",
          "updatedAt": "2021-06-11T22:20:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 425,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE4MTI5ODk2",
      "title": "Relax public_name to public_identity and describe how clients construct CHOuter based on it.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/425",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "(This change assumes the answers to (1) and (2) from #424 are both \"yes.\")\r\n\r\nPreviously, public_name was assumed to be a DNS name. #413 added validation criteria for this value. This change relaxes public_name to be a reference identity for the client-facing server. As a result, clients use this identity when constructing CHOuter and authenticating the client-facing server. This identity may be either a DNS name or an IP address, depending on the particular client-facing server deployment.\r\n\r\nI'm totally open to bike shedding the validation criteria, but would really like to hear high-level opinions on this change before doing so.\r\n\r\ncc @bemasc, @davidben, @sftcd, @martinthomson, @dmcardle \r\n\r\nCloses #424, #405, #396",
      "createdAt": "2021-04-19T16:00:44Z",
      "updatedAt": "2021-06-08T17:04:32Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3562943c804fd173a513037d578a71dfd4ee967b",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/public-identity",
      "headRefOid": "2491e9a1f2d9ba52a6aca68ade485f313cc5599e",
      "closedAt": "2021-06-08T17:04:32Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As I mentioned in #424, I think RFC 8738's [approach](https://tools.ietf.org/html/rfc8738#section-6) is worth considering:\r\n\r\n> As [RFC6066] does not permit IP\r\n>    addresses to be used in the Server Name Indication (SNI) extension\r\n>    HostName field, the server MUST instead use the IN-ADDR.ARPA\r\n>    [RFC1034] or IP6.ARPA [RFC3596] reverse mapping of the IP address as\r\n>    the HostName field value instead of the IP address string\r\n>    representation itself.  For example, if the IP address being\r\n>    validated is 2001:db8::1, the SNI HostName field should contain \"1.0.\r\n>    0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6.arpa\"\r\n\r\nWe would leave the SNI empty for the IP case, but use this as the encoding of IP addresses in `public_name`.  This encoding is not very efficient, but it's nicely unambiguous and widely implemented.\r\n\r\nIf we decide to stick with this ambiguous encoding, I would suggest relying on the URI `host` syntax from [RFC 3986](https://tools.ietf.org/html/rfc3986#section-3.2.2), rather than cloning it as this text does.",
          "createdAt": "2021-04-19T17:50:44Z",
          "updatedAt": "2021-04-19T17:50:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "(Noting here that we're bike shedding on encoding, and not on whether or not the identity can be an IP address.)\r\n\r\n> We would leave the SNI empty for the IP case, but use this as the encoding of IP addresses in public_name. This encoding is not very efficient, but it's nicely unambiguous and widely implemented.\r\n\r\nIf folks think this is adequate and easy to implement, I'm fine with it. (I don't know how widely implemented this is.)\r\n\r\n> If we decide to stick with this ambiguous encoding, I would suggest relying on the URI host syntax from RFC 3986, rather than cloning it as this text does.\r\n\r\nI do not feel strongly, but, any particular reason why you'd lean on RFC 3986?",
          "createdAt": "2021-04-19T18:04:34Z",
          "updatedAt": "2021-04-19T18:04:34Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM5MDQ4Mzk2",
          "commit": {
            "abbreviatedOid": "bafa71e"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-19T16:05:28Z",
          "updatedAt": "2021-04-19T16:05:29Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "s/updat/update",
              "createdAt": "2021-04-19T16:05:28Z",
              "updatedAt": "2021-04-19T16:25:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM5MDYwNjY1",
          "commit": {
            "abbreviatedOid": "bafa71e"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-19T16:15:50Z",
          "updatedAt": "2021-04-19T16:15:50Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "A name like `0x42.0x42.0x42.0x42` would pass the DNS name validation, yet still be treated as an IP address by application code. I think it's worth acknowledging this possibility, so that clients cannot be induced into sending noncompliant server_name extensions to unsuspecting servers.",
              "createdAt": "2021-04-19T16:15:50Z",
              "updatedAt": "2021-04-19T16:25:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM5MDYyMzk2",
          "commit": {
            "abbreviatedOid": "bafa71e"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-19T16:17:35Z",
          "updatedAt": "2021-04-19T16:17:36Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Subject Alternative Name actually leans on GeneralName, which is a pretty big sledgehammer, as discussed in #405.",
              "createdAt": "2021-04-19T16:17:36Z",
              "updatedAt": "2021-04-19T16:25:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM5MDY2OTE3",
          "commit": {
            "abbreviatedOid": "bafa71e"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-19T16:22:07Z",
          "updatedAt": "2021-04-19T16:22:07Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Even if we only use `iPAddress` here, it will require some carveouts.  For starters, it actually defines a subnet, rather than a single address.\r\n\r\nI think we're better off inferring DNS-or-address from the textual representation in `public_identity`.",
              "createdAt": "2021-04-19T16:22:07Z",
              "updatedAt": "2021-04-19T16:25:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM5MDcwMDUx",
          "commit": {
            "abbreviatedOid": "bafa71e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-19T16:25:12Z",
          "updatedAt": "2021-04-19T16:25:16Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "```suggestion\r\n: The identity of the client-facing server, i.e., the entity trusted to update\r\n```",
              "createdAt": "2021-04-19T16:25:12Z",
              "updatedAt": "2021-04-19T16:25:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM5MDcyODM2",
          "commit": {
            "abbreviatedOid": "2491e9a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-19T16:28:01Z",
          "updatedAt": "2021-04-19T16:28:01Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "> yet still be treated as an IP address by application code.\r\n\r\nIt would? \ud83e\udd14 ",
              "createdAt": "2021-04-19T16:28:01Z",
              "updatedAt": "2021-04-19T16:28:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM5MDczMDUy",
          "commit": {
            "abbreviatedOid": "2491e9a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-19T16:28:15Z",
          "updatedAt": "2021-04-19T16:28:16Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "I'm not leaning on GeneralName, but specifically on what's allowed for iPAddress, since that's what's relevant for certificate verification. I think the text here adequately covers that case. I'm happy to take concrete suggestions to make this more clear if people have them. ",
              "createdAt": "2021-04-19T16:28:16Z",
              "updatedAt": "2021-04-19T16:28:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM5MTY4MzI3",
          "commit": {
            "abbreviatedOid": "2491e9a"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-19T18:17:52Z",
          "updatedAt": "2021-04-19T18:17:52Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "Haha yes, this is an odd anti-feature, but I can verify it exists in Chrome and Safari. Visit http://0xac.0xd9.0xa.0xe, which is translated to google.com's IPv4 address: 172.217.10.14.",
              "createdAt": "2021-04-19T18:17:52Z",
              "updatedAt": "2021-04-19T18:17:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM5MTY5Nzky",
          "commit": {
            "abbreviatedOid": "2491e9a"
          },
          "author": "dmcardle",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-19T18:19:44Z",
          "updatedAt": "2021-04-19T18:19:44Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "(To clarify, I just think it's plausible that application code could get confused by something like this. The above example shows lax client-side interpretation, not any server-side confusion.)",
              "createdAt": "2021-04-19T18:19:44Z",
              "updatedAt": "2021-04-19T18:19:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM5MTczMDI2",
          "commit": {
            "abbreviatedOid": "2491e9a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-19T18:23:53Z",
          "updatedAt": "2021-04-19T18:23:54Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "Wow, interesting. Thanks for clarifying!",
              "createdAt": "2021-04-19T18:23:54Z",
              "updatedAt": "2021-04-19T18:23:54Z"
            }
          ]
        }
      ]
    },
    {
      "number": 426,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE4NTMzMjIx",
      "title": "Move public_name to a mandatory extension.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/426",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "And in doing so, allow for future extensions to permit IP-based identities with a separate extension.\r\n\r\nAlternate to #425.\r\n\r\n",
      "createdAt": "2021-04-19T21:10:28Z",
      "updatedAt": "2021-06-08T17:04:21Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "3562943c804fd173a513037d578a71dfd4ee967b",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/punt-ips",
      "headRefOid": "79bb7fa90e98cdf5247f9500ca8eb7ef10d7032b",
      "closedAt": "2021-06-08T17:04:21Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM5MzQ1NDcy",
          "commit": {
            "abbreviatedOid": "596ee81"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-19T22:05:27Z",
          "updatedAt": "2021-04-19T22:11:44Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Perhaps: \"ECHConfig MUST contain this extension, and clients MUST ignore ECHConfigs missing the extension.\"",
              "createdAt": "2021-04-19T22:05:27Z",
              "updatedAt": "2021-04-20T14:43:35Z"
            },
            {
              "originalPosition": 110,
              "body": "s/reference/public/?",
              "createdAt": "2021-04-19T22:06:10Z",
              "updatedAt": "2021-04-20T14:43:35Z"
            },
            {
              "originalPosition": 249,
              "body": "(Just starting a discussion. I don't feel strongly either way, so whatever you think is best.)\r\n\r\nIt's interesting that we have a \"Mandatory\" column when it's purely a function of the value. On the one hand, it avoids readers needing to look at the constant. On the other hand, it might give the impression you can arbitrarily assign that column and you can't.\r\n\r\nMaybe if the registry had a note at the top explaining how the mandatory bit works?\r\n\r\nWDYT?",
              "createdAt": "2021-04-19T22:10:08Z",
              "updatedAt": "2021-04-20T14:43:35Z"
            },
            {
              "originalPosition": 245,
              "body": "s/254/127/? Otherwise all Private Use extensions are also Mandatory.",
              "createdAt": "2021-04-19T22:11:29Z",
              "updatedAt": "2021-04-20T14:43:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQwMDQwMTcx",
          "commit": {
            "abbreviatedOid": "596ee81"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-20T14:39:34Z",
          "updatedAt": "2021-04-20T14:39:35Z",
          "comments": [
            {
              "originalPosition": 249,
              "body": "That's a good point -- I tried to add some text which clarifies that the value has implications on users.",
              "createdAt": "2021-04-20T14:39:34Z",
              "updatedAt": "2021-04-20T14:43:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQwMDQ2MjE2",
          "commit": {
            "abbreviatedOid": "79bb7fa"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-20T14:44:22Z",
          "updatedAt": "2021-04-20T14:44:22Z",
          "comments": [
            {
              "originalPosition": 245,
              "body": "I did a slight variation on that -- thanks!",
              "createdAt": "2021-04-20T14:44:22Z",
              "updatedAt": "2021-04-20T14:44:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 428,
      "id": "MDExOlB1bGxSZXF1ZXN0NjIxMTQ3ODk1",
      "title": "Aligning API with draft-irtf-cfrg-hpke-08",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/428",
      "state": "MERGED",
      "author": "hannestschofenig",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-04-22T14:25:37Z",
      "updatedAt": "2021-04-22T15:42:40Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "d36bc1e980018ef695aa81c1b24ba15050fbaf45",
      "headRepository": "hannestschofenig/draft-ietf-tls-esni",
      "headRefName": "patch-1",
      "headRefOid": "0b777b5afee9d5290c1beb81e9b89ab93c618f56",
      "closedAt": "2021-04-22T15:42:40Z",
      "mergedAt": "2021-04-22T15:42:40Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "48c8b1117515a49852286f8e7ef46737472efd95"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQyMzQxNjAz",
          "commit": {
            "abbreviatedOid": "0b777b5"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-22T15:23:51Z",
          "updatedAt": "2021-04-22T15:23:51Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQyMzYyNzAx",
          "commit": {
            "abbreviatedOid": "0b777b5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-22T15:42:36Z",
          "updatedAt": "2021-04-22T15:42:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 432,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQ0MTYzNzQw",
      "title": "Fix HPKE typo.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/432",
      "state": "MERGED",
      "author": "sayrer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-05-13T18:30:49Z",
      "updatedAt": "2021-05-13T20:46:30Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "48c8b1117515a49852286f8e7ef46737472efd95",
      "headRepository": "sayrer/draft-ietf-tls-esni",
      "headRefName": "fix_hpke_typo",
      "headRefOid": "a72fce3eb6094a594ef73b7ae289c886dce7a642",
      "closedAt": "2021-05-13T20:32:12Z",
      "mergedAt": "2021-05-13T20:32:12Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "9e93dd483fb86ff65fb8f27b6f768ef6898e774a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU5MTg2ODky",
          "commit": {
            "abbreviatedOid": "a72fce3"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-13T18:34:09Z",
          "updatedAt": "2021-05-13T18:34:09Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU5Mjc3NzYz",
          "commit": {
            "abbreviatedOid": "a72fce3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-13T20:31:42Z",
          "updatedAt": "2021-05-13T20:31:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 435,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQ0ODkzMDk3",
      "title": "build fix: Wrap paragraphs at 80 characters",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/435",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-05-14T18:14:39Z",
      "updatedAt": "2021-06-11T17:35:26Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9e93dd483fb86ff65fb8f27b6f768ef6898e774a",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "build-fix",
      "headRefOid": "ffae91d934c332a991798317c37ca3dd773a48dc",
      "closedAt": "2021-05-14T18:15:16Z",
      "mergedAt": "2021-05-14T18:15:16Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "acd446bb01a92d1cfb03041c144975d5e3c3931b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjYwMDg3MDIx",
          "commit": {
            "abbreviatedOid": "ffae91d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-14T18:15:13Z",
          "updatedAt": "2021-05-14T18:15:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 436,
      "id": "MDExOlB1bGxSZXF1ZXN0NjU0MTY5OTA0",
      "title": "Prohibit IP addresses in ECHConfig.public_name.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/436",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is yet another option to deal with public_name encoding, reference identity, and ClientHelloOuter construction issues. \r\n\r\nCloses #396, #405, #424\r\n\r\ncc @martinthomson, @davidben, @cjpatton, @sftcd ",
      "createdAt": "2021-05-26T19:42:47Z",
      "updatedAt": "2021-06-11T22:25:06Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "db00bed8234460217bf49cc4a0a592b3dbaec1f5",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/prohibit-ips",
      "headRefOid": "536afde3bd4d52cfbe3b5cd6c8f667f992244277",
      "closedAt": "2021-06-11T22:25:06Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\nHiya,\n\nOn 26/05/2021 20:48, Christopher Wood wrote:\n> Sadly, no :( The format admits IP addresses, but the following\n> sentence says they should be ignored in those cases.\nI forget why we wanted to even consider all this TBH:-)\n\nI'm not sure if I'd want to write code to enforce those\nrules on the client or not TBH.\n\nOne nit: FQDNs can (and implicitly do) end in a dot. I\nbet the current text would annoy some DNS personages and\nmight even break something e.g. if the string were copied\nfrom (some library that reads in) a zone file where that\ntrailing dot is significant when present, but often\nabsent. (I dunno if a library that'd make that bug likely\nexists but I can easily imagine the code that'd cause a\ndot at the end of a public_name.)\n\nCheers,\nS.\n",
          "createdAt": "2021-05-26T20:23:04Z",
          "updatedAt": "2021-05-26T20:23:04Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I forget why we wanted to even consider all this TBH:-)\r\n\r\nDo you mean consider dropping IP address support? The rationale was that encoding rules for addresses here is overly complicated, and most folks should be able to get a certificate with a name.\r\n\r\n> I'm not sure if I'd want to write code to enforce those rules on the client or not TBH.\r\n\r\nBy rules, do you mean \"ignore if IP address\"?\r\n\r\nRegarding the FQDN trailing dot, yeah, I figure we'd just assume that's implicit. We could also change the text to say the trailing dot is allowed. I don't feel strongly about that. I'm just trying to find a path forward.",
          "createdAt": "2021-05-26T20:28:17Z",
          "updatedAt": "2021-05-26T20:28:17Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 26/05/2021 21:28, Christopher Wood wrote:\n>> I forget why we wanted to even consider all this TBH:-)\n> \n> Do you mean consider dropping IP address support? \n\nI just meant I literally forget why we need any IP address\nsupport at all within ECHConfigs.\n\n> The rationale was\n> that encoding rules for addresses here is overly complicated, and\n> most folks should be able to get a certificate with a name.\n\nYep.\n\n> \n>> I'm not sure if I'd want to write code to enforce those rules on\n>> the client or not TBH.\n> \n> By rules, do you mean \"ignore if IP address\"?\n\nSo it might be ok to delve into the public_name and do such\nchecks whilst encoding or decoding an ECHConfig but I'd not\nwanna include that code into the OpenSSL extension handling.\n\n> Regarding the FQDN trailing dot, yeah, I figure we'd just assume\n> that's implicit. We could also change the text to say the trailing\n> dot is allowed. I don't feel strongly about that. I'm just trying to\n> find a path forward.\n\nSure, it was a nit, but one that might be worth handling. (I\ndidn't check the whatwg thing though, so maybe that handles\nit too.)\n\nCheers,\nS.\n\n\n> \n",
          "createdAt": "2021-05-27T01:09:16Z",
          "updatedAt": "2021-05-27T01:09:16Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> So it might be ok to delve into the public_name and do such checks whilst encoding or decoding an ECHConfig but I'd not wanna include that code into the OpenSSL extension handling.\r\n\r\nWould this be part of the extension handling? I imagine it would be underneath some API where you pass ECHConfig from elsewhere (DNS) to the TLS stack. \r\n\r\nIn any case, isn't some sort of processing required for ECHConfig? If it's not a DNS name, what would you do? I would expect OpenSSL, like any major stack, to implement the ECH rejection path using public_name, absent an application-specific knob to disable that. Am I misunderstanding you?",
          "createdAt": "2021-05-27T01:22:54Z",
          "updatedAt": "2021-05-27T01:22:54Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 27/05/2021 02:23, Christopher Wood wrote:\n>> So it might be ok to delve into the public_name and do such checks\n>> whilst encoding or decoding an ECHConfig but I'd not wanna include\n>> that code into the OpenSSL extension handling.\n> \n> Would this be part of the extension handling? I imagine it would be\n> underneath some API where you pass ECHConfig from elsewhere (DNS) to\n> the TLS stack.\n\nRight, that's what I was trying to say:-)\n\n> \n> In any case, isn't some sort of processing required for ECHConfig? If\n> it's not a DNS name, what would you do? I would expect OpenSSL, like\n> any major stack, to implement the ECH rejection path using\n> public_name, absent an application-specific knob to disable that. Am\n> I misunderstanding you?\n\nI'd need to look at the code but from memory the library\ndefaults to just providing a function to let the application\nsay to enforce the check (e.g. to dive into the SANs and see\nif a string-form name matches some SAN). I've not stumbled\nover any detailed/strict DNS name syntax checks that I recall\ne.g. checking for <=63 octet label names or whatever else is\nneeded, though there may be such code already in order to\nsupport DANE. Would have to look and see TBH - but adding\nDNS name syntax checks that are only for ECH public_name\nwouldn't be so attractive if it didn't do the same as was\nalready done elsewhere in the library or by a bunch of\napplications using the library (that latter being v. hard to\nknow of course).\n\nCheers,\nS.\n\n\n> \n",
          "createdAt": "2021-05-27T14:52:08Z",
          "updatedAt": "2021-05-27T14:52:08Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> (For the record, 0x1.0x2.0x3.0x4 is a domain name always; the x makes it so. IP addresses are always digits. The real trick is in realizing that 127.1 and 2130706433 and 017700000001 are all localhost.)\r\n\r\nIs it? The WHATWG parser seems to happily accept hex digits. Empirically, Chrome, Firefox, and Safari interpret http://0x7f000001:8080/ as http://127.0.0.1:8080. I'm not seeing anything in WHATWG that says IPv4 literals are always digits. RFC3986 does, but RFC3986 is much more restrictive than what the web uses.\r\nhttps://url.spec.whatwg.org/#ipv4-number-parser",
          "createdAt": "2021-05-31T04:46:46Z",
          "updatedAt": "2021-05-31T04:47:30Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, I misread that.  I just went ahead and implemented this in rust, just to see what the algorithm might need to look like.  It's a gigantic mess.  Another lesson in how software engineering practices of the 1980s should be left there.\r\n\r\nBut you can all see how it worked out: https://github.com/martinthomson/url-ipv4",
          "createdAt": "2021-05-31T05:32:55Z",
          "updatedAt": "2021-05-31T05:32:55Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, that gigantic mess, combined with ambiguity as to IP syntaxes (we have at least two so far), is why I was inclined to go the Somebody Else's Problem route. :-) But I can also live with a well-defined IP literal syntax to reject. Though, in order to be useful for browsers, that syntax must be the messy WHATWG one or a superset.\r\n\r\nIt's a lot more complexity for ECH (lots of people now need to reimplement the WHATWG parser), but I agree it does avoid reasoning about `DNSName` -> `DNSOrIP` type transitions downstream... provided your `DNSOrIP` type is compatible with the WHATWG parser. `DNSOrIP<WHATWG>` and `DNSOrIP<RFC3986>` are fine. If your random protocol's `DNSOrIP<BrandNewVariant>` is even more permissive than WHATWG's IP parser, you're out of luck and need the SEP provisions.\r\n\r\nI don't think the SEP provisions are _quite_ that dire. Anyone transiting a `DNSOrIP` through their X.509 code has to be aware of the syntax *somewhere* because X.509 uses different name types for DNS vs. IP. Whatever you use to resolve that is the right parser to use when going from ECH's `DNSName` to your `DNSOrIP` type. And, hopefully, at that transition, the IP parser is readily available so we don't have duplicate code. Another thing to keep in mind is the public name doesn't need to interact with the *entire* system, just the TLS to certificate verification path. ClientHelloOuter handshakes are discarded.\r\n\r\nThat said, realistically, everyone just passes things around as strings, and you're right that this is something people need to remember to do. I dunno, it's a mess. I guess we pick whichever evil folks generally think is lesser.",
          "createdAt": "2021-06-01T18:35:19Z",
          "updatedAt": "2021-06-01T18:35:19Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, the thing that concerns me is that one common system architecture, one that we use at least, has logic that makes three independent decisions.  That is, the `DNSOrIP` call is made for name resolution, TLS ECH, and certificate validation.  That's nasty duplication, so it's gross, but they could - at least in theory - share an implementation.  As you say, if one of those is more permissible than another in the wrong direction, we get bad outcomes.  To be clear, a lot else has to fail before this becomes a genuinely exploitable problem, but I don't want us to be making security holes.\r\n\r\nI put up a patch for NSS that does this validation in case anyone wants to cheat. I probably should have been doing other work, but it's done now.  The LDH validation was easier, but still non-trivial.",
          "createdAt": "2021-06-01T23:20:15Z",
          "updatedAt": "2021-06-01T23:20:15Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I just did some investigation and it looks like Firefox has some interesting quirks that diverge slightly from this text:\r\n\r\n1. Certificate validation accepts underscores ('_') in names.  This includes the character at the start of the name, which is worrying enough for me to open a bug, but probably fine.  The question here is whether or not we need to include underscores also.\r\n\r\n2. The code detects the type of reference identity in a strict order: DNS, IPv6, IPv4.  That means that the DNS name recognition code is responsible for rejecting IPv4 addresses.  It does that by assuming that the input has been somehow normalized and rejecting any name for which the last label is only digits.  This means that it won't recognize `1.1.1.0x1` as invalid.  As we have normalization at other points in the system this is not exploitable, but I will be opening a bug on that.\r\n\r\n3. It also rejects `1.1.1.256` as a name.  As this is not a valid IP address according to the parser we are referencing, this PR would treat that as a domain name.  I think that is safe in the sense that @davidben notes.  If the certificate validation is more strict than the spec, the only risk is to interoperability.  (And in this case, ICANN would need to open up a `.256` gTLD, which is against their rules in addition to not working.)\r\n\r\n4. (Edited to add) It also allows a dot at the end of a name, but I think we're on firm footing here if we reject that (as the PR does).\r\n\r\n@chris-wood convinced me that we might not need to be perfect in all places `DNSOrIP` is implemented, as the certificate validation is the only security-critical one.  That's true when it comes to the main things we care about (server authentication).  It's also true provided that the secondary security properties (whether a name is exposed via SNI) are not interlinked.  I don't think we have any inter-dependency like that here.  @chris-wood did manage to identify a hypothetical scenario where disagreement does lead to failures, but it's not ECH-related.",
          "createdAt": "2021-06-02T01:12:40Z",
          "updatedAt": "2021-06-02T02:11:07Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Given that the primary risk in disagreement between DNS or IP here seems to be interopability, and not security, perhaps we can downgrade the \"MUST ignore\" to a \"SHOULD ignore\" and clarify the risk? Failing early and consistently is certainly better, but the (possibly new) parsing requirement this imposes on the stack may not be worth the complexity. @davidben, @martinthomson: what do you think?",
          "createdAt": "2021-06-02T12:50:49Z",
          "updatedAt": "2021-06-02T12:50:49Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": "I know that the parsing in OpenSSL is naive, doesn't easily handle fallbacks/alternatives.  Further, it just calls the local platform code, which means there could be inconsistencies.",
          "createdAt": "2021-06-02T13:23:25Z",
          "updatedAt": "2021-06-02T13:23:25Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Re SHOULD, if we do that, I think we should have some (probably less verbose) version of https://github.com/tlswg/draft-ietf-tls-esni/pull/436#discussion_r640744959 as guidance.\r\n\r\nWhatever we do, we should say \"ECH believes this is a DNS name, so please verify accordingly\" because we need to define semantics for things we expose out of TLS. The IP address thing is how to square \"DNS name\" with all systems built around \"DNS or IP\" serializations. We can either:\r\n\r\n* Say \"ECH _promises_ not to give you something that looks like an IP\" and define how to do that. But \"DNS or IP\" systems do not use consistent or simple syntaxes, so this is tricky. (But probably doable since the WHATWG syntax is likely a superset of every other one.)\r\n* Or we can say \"you might get something that looks like an IP, deal with it\" with rough guidance on how to deal with it. But this is punting up a layer which may or may not forget and misbehave. (How much do we care?)\r\n\r\nI'm not sure there's a way out of picking one. Anything short of a MUST that covers the \"DNS or IP\" syntaxes we care about puts us in the second bucket.",
          "createdAt": "2021-06-02T14:01:24Z",
          "updatedAt": "2021-06-02T14:12:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Re SHOULD, if we do that, I think we should have some (probably less verbose) version of [#436 (comment)](https://github.com/tlswg/draft-ietf-tls-esni/pull/436#discussion_r640744959) as guidance.\r\n\r\nIndeed \u2014 this is what I mean by clarifying the risk. I\u2019d also keep the pointer to the WHATWG parser in case someone wants to enforce that and otherwise doesn\u2019t have a parser to rely upon. \r\n\r\n> \r\n> Whatever we do, we should say \"ECH believes this is a DNS name, so please verify accordingly\" because we need to define semantics for things we expose out of TLS. The IP address thing is how to square \"DNS name\" with all systems built around \"DNS or IP\" serializations. We can either:\r\n> \r\n> * Say \"ECH _promises_ not to give you something that looks like an IP\" and define how to do that. But \"DNS or IP\" systems do not use consistent or simple syntaxes, so this is tricky. (But probably doable since the WHATWG syntax is likely a superset of every other one.)\r\n> * Or we can say \"you might get something that looks like an IP, deal with it\" with rough guidance on how to deal with it. But this is punting up a layer which may or may not forget and misbehave. (How much do we care?)\r\n\r\nThe sheer number of inconsistencies makes me lean towards the latter, with an _example_ of how to deal with the inconsistency. (That is, guidance for how to deal with it in ECH, and guidance for how to deal with it outside of ECH.)\r\n\r\n> I'm not sure there's a way out of picking one. Anything short of a MUST that covers the \"DNS or IP\" syntaxes we care about puts us in the second bucket.\r\n\r\nYeah, I\u2019m not suggesting we do nothing. I\u2019m just proposing we relax the MUST for stacks that might otherwise fall back on a check elsewhere. This seems to balance things nicely. \r\n\r\n",
          "createdAt": "2021-06-02T14:54:29Z",
          "updatedAt": "2021-06-02T14:54:29Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, sure. Works for me, though I was already okay with the Somebody Else's Problem version. :-) (Would we even need a SHOULD at that point, or should we just leave IP parsing out of ECH's hands entirely? We'd be always punting it, but consistently so.)\r\n\r\n@martinthomson, WDYT? I wasn't sure whether to read your most recent comment as changing your mind here or still preferring ECH apply an IP parser.",
          "createdAt": "2021-06-02T21:41:59Z",
          "updatedAt": "2021-06-02T21:41:59Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Would we even need a SHOULD at that point, or should we just leave IP parsing out of ECH's hands entirely? We'd be always punting it, but consistently so.\r\n\r\nI learn towards keeping it for now and removing it later if, after we all implement the thing, consider it unnecessary. There seem to be enough strange edge cases with how applications might use the `DNSOrIp` value in verifying client-facing servers, and removing sharp edges seems useful. That said, if all of the major stacks hate this, then certainly that says a lot too. :-)",
          "createdAt": "2021-06-02T22:16:22Z",
          "updatedAt": "2021-06-02T22:16:22Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that we should just change MUST to SHOULD and add some verbiage about the risks. It strikes me that we're trying to close the barn doors after the horses are out. The fact is that most systems already have some sort of DNS and IP parser, some of which are probably not consistent with each other, and to now say \"you have to be consistent and here are the rules you must abide by\" just isn't realistic.\r\n\r\nWe had a case recently where Safari wasn't allowing SNIs with an underscore--because we were following the spec--but when someone complained (https://twitter.com/ifette/status/1375559666340618242?s=20), we discovered that Chrome and Firefox were allowing underscores and changed our policy to reflect this, even though it went against the spec. If we can't all follow the official DNS parsing rules now, without ECH, what makes you think we would all follow the official DNS and IP parsing rules later?\r\n\r\nIf we just say \"use the parsers you already have\" (and point to the WHATWG parser for those who don't already have one as @chris-wood suggested), at least we'll be gaining consistency within a system.",
          "createdAt": "2021-06-02T22:50:19Z",
          "updatedAt": "2021-06-02T22:51:33Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Given that I've already written the code, there is a bit of sunk-cost that influences my thinking now...  \r\n\r\nThat said, I am thinking that the worst that can happen here if someone gets this wrong.  We get either:\r\n\r\n* an ECH configuration is ignored because we falsely believe that it is an IP address\r\n* a bad ECH configuration with an IP address is used because we falsely believe that it is a DNS name\r\n\r\nFor the former, if this happens, then we might not use ECH when we could.  That's not great, but we might get bug reports and can fix the parser (or people can use better names).\r\n\r\nFor the latter, we will put an IP in SNI and maybe the IP will make it as far as certificate validation.  If the server has a valid IP certificate for that address, then maybe it just works.  Maybe the server chokes on the SNI.  Maybe the client code chokes on the bizarre IP address and fails (this is what moz::pkix would do, it is picky about the format of addresses as it assumes that the caller normalizes them).  If the server doesn't have a valid certificate, then the connection fails.\r\n\r\nIn this latter case, it seems like failure to validate the ECH config correctly more often leads to connection failures.  That suggests that the SHOULD is worthwhile, because we don't want some clients connecting and others failing to connect.\r\n\r\nCarrick is right to point to our collective differences, but I see that as unhealthy rather than inevitable.  We should fix the underscore thing by updating specifications to match reality (Anne van Kesteren is right about this...again), but I know the IETF well enough to be wary of proposing that, even if it would be the right thing to do.  I do think that the suggestion to reuse existing parsers is sensible.\r\n\r\nSo I'm down for making this change with a \"SHOULD\" in place of the \"MUST\".",
          "createdAt": "2021-06-02T22:57:38Z",
          "updatedAt": "2021-06-02T22:57:38Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I downgraded to a SHOULD and made an attempt at clarifying risk without being overly verbose. @davidben, @martinthomson, please have a look! @sftcd, would this current framing work for your implementation? (It seems like it would, especially if the amount of parsing is to be minimized.)",
          "createdAt": "2021-06-03T21:32:48Z",
          "updatedAt": "2021-06-03T21:36:07Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": "> I worry we'll end up with a random mix of some TLS libraries doing a lot of work to reimplement the WHATWG algorithm (hopefully correctly!) and other libraries ignoring the text, depending on what they read between the lines of the SHOULD.\r\n\r\nI share this concern.  See my comment above about OpenSSL.",
          "createdAt": "2021-06-04T22:49:31Z",
          "updatedAt": "2021-06-04T22:49:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> we'll end up with a random mix of some TLS libraries doing a lot of work to reimplement the WHATWG algorithm (hopefully correctly!) and other libraries ignoring the text, depending on what they read between the lines of the SHOULD.\r\n\r\n@davidben, @richsalz: it's true, but this seems inevitable. (We could omit the reference entirely, and I could imagine stacks trying to implement a parser and verifier to abide by the SHOULD.) What's the downside of different libraries choosing to handle this SHOULD differently?",
          "createdAt": "2021-06-07T13:44:31Z",
          "updatedAt": "2021-06-07T13:44:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Paging @sftcd, @bemasc, and @cbartle891 for reviews!",
          "createdAt": "2021-06-07T13:48:54Z",
          "updatedAt": "2021-06-07T13:48:54Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": ">> we'll end up with a random mix of some TLS libraries doing a lot of work to reimplement the WHATWG algorithm (hopefully correctly!) and other libraries ignoring the text, depending on what they read between the lines of the SHOULD.\r\n>\r\n> @davidben, @richsalz: it's true, but this seems inevitable. (We could omit the reference entirely, and I could imagine stacks trying to implement a parser and verifier to abide by the SHOULD.) What's the downside of different libraries choosing to handle this SHOULD differently?\r\n\r\nI don't think this is inevitable. While https://github.com/tlswg/draft-ietf-tls-esni/pull/436#discussion_r640744959 (i.e. no requirement or recommendation here at all) punts the problem to the application, it punts the problem consistently. The application can then use the parser they already have. Especially since we seem to agree it won't cause security problems, it seems we should just stick with TLS not having an opinion, with non-normative text to point out this means DNS name.\r\n\r\nThe downside of libraries choosing to handle the SHOULD differently is that the ecosystem behaves differently. We'd have to consider both kinds of stacks when reasoning about the protocol. It's also less clear for any given implementor what the right behavior would be. We seem to essentially be saying \"you can reimplement the WHATWG protocol, which is just code, or you do less work and skip it, so do you want more code or less code?\".\r\n\r\n(I'll go put together some text for the \"consistently punt it\" option, so there's something concrete here.)",
          "createdAt": "2021-06-07T14:36:12Z",
          "updatedAt": "2021-06-07T14:36:12Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> (I'll go put together some text for the \"consistently punt it\" option, so there's something concrete here.)\r\n\r\nI understand that the text can consistently punt the problem elsewhere, unlike what this PR does, but that doesn't mean implementations will consistently punt it. \r\n\r\nIn any case, if you could target your change against this PR to minimize deltas, that would be great. ",
          "createdAt": "2021-06-07T14:39:15Z",
          "updatedAt": "2021-06-07T14:39:15Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": ">  it seems we should just stick with TLS not having an opinion, with non-normative text to point out this means DNS name.\r\n\r\nWorks for me.\r\n",
          "createdAt": "2021-06-07T15:31:29Z",
          "updatedAt": "2021-06-07T15:31:29Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> (I'll go put together some text for the \"consistently punt it\" option, so there's something concrete here.)\r\n\r\nhttps://github.com/tlswg/draft-ietf-tls-esni/pull/447\r\n\r\n> In any case, if you could target your change against this PR to minimize deltas, that would be great.\r\n\r\nDone. I've also left comments on this PR for the incidental stuff I noticed while putting that together.",
          "createdAt": "2021-06-07T15:38:22Z",
          "updatedAt": "2021-06-07T15:38:22Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 07/06/2021 14:49, Christopher Wood wrote:\n> Paging @sftcd, @bemasc, and @cbartle891 for reviews!\n> \n\nAssuming I figured out the actual latest text, that\nseems fine to me, except that DNS names can end with\nan explicit dot, (which is always implicitly there)\nas I think I pointed out  before. I don't know if TLS\nstacks handle that well or badly but we should probably\neither allow the trailing dot, or, if disallowing it\nis really better, just say that we know we're not quite\nperfectly correct, in DNS terms.\n\nCheers,\nS.\n",
          "createdAt": "2021-06-07T16:48:56Z",
          "updatedAt": "2021-06-07T16:48:56Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favor of #456.",
          "createdAt": "2021-06-11T22:25:06Z",
          "updatedAt": "2021-06-11T22:25:06Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5NDc1NTY0",
          "commit": {
            "abbreviatedOid": "04c8710"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-26T19:47:10Z",
          "updatedAt": "2021-05-26T19:47:30Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "```suggestion\r\nthat these criteria disallow IPv4 addresses in standard dotted-decimal or other\r\n```\r\n?",
              "createdAt": "2021-05-26T19:47:10Z",
              "updatedAt": "2021-05-26T19:47:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5NDc2Njk2",
          "commit": {
            "abbreviatedOid": "04c8710"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-26T19:48:36Z",
          "updatedAt": "2021-05-26T19:48:37Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Sadly, no :( The format admits IP addresses, but the following sentence says they should be ignored in those cases.",
              "createdAt": "2021-05-26T19:48:36Z",
              "updatedAt": "2021-05-26T19:48:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5NTkzNjgz",
          "commit": {
            "abbreviatedOid": "04c8710"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-05-26T22:22:20Z",
          "updatedAt": "2021-05-26T22:22:24Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "So this says \"work out if it is an IP address and don't allow it\".  That's too imprecise for me.\r\n\r\nThe [parsing algorithm for IP addresses in the whatWG URL spec](https://url.spec.whatwg.org/#concept-ipv4-parser) is very precise.  You could reference that and say that if that returns a value then the ECHConfig can be ignored.\r\n\r\nA MUST here without that level of precision is not good.  I can't test this.  Well, I can make something up, but that's not how this works.",
              "createdAt": "2021-05-26T22:22:20Z",
              "updatedAt": "2021-05-26T22:22:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5NTk1NDA3",
          "commit": {
            "abbreviatedOid": "04c8710"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-26T22:25:49Z",
          "updatedAt": "2021-05-26T22:25:50Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Thanks -- I don't think any of us (beyond you) knew that reference existed. We can certainly cite it to make this algorithm more precise. ",
              "createdAt": "2021-05-26T22:25:49Z",
              "updatedAt": "2021-05-26T22:25:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5NjAwNzIx",
          "commit": {
            "abbreviatedOid": "74d8cb5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-26T22:37:14Z",
          "updatedAt": "2021-05-26T22:37:15Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "@martinthomson I referenced it directly as a possible way to make this determination. I'm not sure we want to _require_ use of this specific algorithm (especially since that spec is a living document and may change). We could alternatively try to pull that algorithm into this document, but that seems... terrible.",
              "createdAt": "2021-05-26T22:37:14Z",
              "updatedAt": "2021-05-26T22:44:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjcwMzQ1ODgx",
          "commit": {
            "abbreviatedOid": "74d8cb5"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-27T15:39:43Z",
          "updatedAt": "2021-05-27T15:39:43Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "I agree with Martin that any MUST-level requirements should be precise. Though the WHATWG algorithm is... definitely hairy. :-/ I imagine most TLS libraries, including ours, will not have a version of it readily available, so we'd have to reimplement it.\r\n\r\nI currently lean towards not trying too hard to filter IPs and instead saying:\r\n\r\n* The public name is a DNS name. DNS names have such-and-such syntax. Anything outside that syntax is invalid. (We could, optionally, exclude the tighter [RFC3986 definition](https://datatracker.ietf.org/doc/html/rfc3986#section-3.2.2), but see note below.)\r\n* When your application evaluates whether a certificate is valid for a public name, you must interpret the public name as a DNS name. That means, you should match it against DNS entries in the SAN list.\r\n* Note, however, that the syntax for IPv4 literals in URLs are also valid DNS names. (Non-normative, so we could even cite a living WHATWG standard without worry.) If your application would otherwise interpret the public name as an IP literal, you should make sure you don't go down the IP address matching logic.\r\n* At the TLS level, we consider the embedding of IPv4 literals in strings an application-specific thing and assume different applications may do this subtly differently.\r\n\r\nThe consequence of this is:\r\n\r\n* If your application's certificate logic already separates DNS strings and IP strings, you can just send the string down the DNS string path and don't worry too hard.\r\n* If your application's certificate logic takes a string and expects to parse out DNS vs IP address out of one string for web stuff, you should detect this (hopefully now your application's IP parser is available)\r\n* Servers that live in an ecosystem where \"127.0.0.1\" is not a valid DNS name should not use \"127.0.0.1\" as a public name because it won't work.\r\n\r\nIn other words, the web-specific `MakeOriginFromDNSName(\"https\", \"127.0.0.1\", 443)` function should fail because `https://127.0.0.1` gives back an origin that's interpreted as an IP literal, not a DNS name. It's not possible to express \"127.0.0.1\", the DNS name in the web.\r\n\r\nThis is slightly disappointing because, practically, that WHATWG-IP-literals are invalid DNS names is really a universal constraint. But we seem to have made enough of a mess here that I don't think we can guarantee the application won't think it is an IPv4 literal. (RFC3986 has [another definition](https://datatracker.ietf.org/doc/html/rfc3986#section-3.2.2) of IPv4 literal, but if we used it, we'd still allow a bunch of strings that, on the web, is interpreted as an IPv4 literal. So applications would need to account for this `MakeOriginFromDNSName` error case regardless.)",
              "createdAt": "2021-05-27T15:39:43Z",
              "updatedAt": "2021-05-27T15:40:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjcwMzY3MDI2",
          "commit": {
            "abbreviatedOid": "74d8cb5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-27T15:58:09Z",
          "updatedAt": "2021-05-27T15:58:10Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "@davidben two quick comments:\r\n\r\n1. If we say \"anything outside that syntax is invalid,\" without giving a function to determine if it's invalid, then we're back at Martin's criticism, right?\r\n2. If the check is deferred to the application when validating the certificate, doesn't this run the risk of including an IP address in the outer SNI extension?",
              "createdAt": "2021-05-27T15:58:09Z",
              "updatedAt": "2021-05-27T16:01:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjcwMzg1NDE5",
          "commit": {
            "abbreviatedOid": "74d8cb5"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-27T16:15:37Z",
          "updatedAt": "2021-05-27T16:15:37Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "> If we say \"anything outside that syntax is invalid,\" without giving a function to determine if it's invalid, then we're back at Martin's criticism, right?\r\n\r\nSorry, when I say \"that syntax\", I mean just the syntax that DNS defines. The one that sadly allows IPv4 literals because IPv4 literals are ill-defined across all uses.\r\n\r\n> If the check is deferred to the application when validating the certificate, doesn't this run the risk of including an IP address in the outer SNI extension?\r\n\r\nIt does, but I think that's fine. I think the two risks here are that the DNS can induce the client to send some string in SNI to some server, and it technically violates RFC6066. The former doesn't haven't a clear threat model, more fuzzy \"well random private servers are often buggy\". I think it's reasonable to say we'll validate the DNS-level syntax and assume the server behaves equally well given \"a.b.c.d\" or \"0x1.0x2.0x3.0x4\". The latter is true, but RFC6066 doesn't actually define the syntax anyway. I'm not really sure how one is meant to interpret that prohibition apart beyond \"look deep into your heart and if this *feels* like an IP address, don't do it\". And under this interpretation, TLS truly,  deeply in its heart, wants a DNS name of \"0x1.0x2.0x3.0x4\". That the application will never accept any certificate for that *DNS* name is the application's problem. :-)\r\n\r\n(This is not a *great* interpretation. It's just barely self-consistent enough to say with a straight face, in hopes of getting out of this hole.)",
              "createdAt": "2021-05-27T16:15:37Z",
              "updatedAt": "2021-05-27T16:16:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjcwNDQxMzM0",
          "commit": {
            "abbreviatedOid": "74d8cb5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-27T17:14:01Z",
          "updatedAt": "2021-05-27T17:14:01Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Gotcha, thanks for clarifying! I'm fine with this as it avoids the parsing complexity altogether and moves it to other places in the stack -- \"not my problem\" =)",
              "createdAt": "2021-05-27T17:14:01Z",
              "updatedAt": "2021-05-27T17:14:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjcxODc2Nzky",
          "commit": {
            "abbreviatedOid": "74d8cb5"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "So I think that this is - unfortunately - the only sensible answer here.\r\n\r\nThe original sin here was the overloading of names and IP addresses in every interface that has ever accepted input from humans.  That's convenient, but the fact that an IPv4 address and domain name have overlapping syntax is a real problem.  However bad that is, that's the situation we have to deal with.\r\n\r\n(For the record, 0x1.0x2.0x3.0x4 is a domain name always; the x makes it so.  IP addresses are always digits.  The real trick is in realizing that 127.1 and 2130706433 and 017700000001 are all localhost.)\r\n\r\nAs much as @davidben's idea here is appealing (i.e., the [SEP](https://en.wikipedia.org/wiki/Somebody_else%27s_problem) cloaking field), that is a great way to get real security problems.  If you have an input that results in different parts of the system disagreeing about semantics, the time to next vulnerability (MTTV?) goes right down.  I know that we are in the business of expanding the attack surface, but that's a bit to easy.\r\n\r\nWe can't rely on \"usage\" context to protect us either.  Say protocol X says \"we don't accept IP addresses\" or protocol Y says \"we only accept strict decimal dotted quad\".  That doesn't work if someone forgets to validate inputs.  That a problem is someone else's fault doesn't absolve us.\r\n\r\nWe might be able to rely on ICANN.  Might.  They haven't enabled all-numeric TLDs.  Their current rules exclude the possibility.  If you trust in that, then looking for the last label being all digits might work, but I'm not going to advocate for trust like that.  I'll just write the code.\r\n\r\nI'll let you know how that goes.",
          "createdAt": "2021-05-30T23:49:17Z",
          "updatedAt": "2021-05-31T00:07:51Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "You will need to ask whatwg to make that anchor stable if you plan to reference it.  There's a whole process, but it all boils down to opening an issue on the relevant spec and asking nicely.",
              "createdAt": "2021-05-30T23:49:17Z",
              "updatedAt": "2021-05-31T00:07:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc1Nzg0NTUx",
          "commit": {
            "abbreviatedOid": "d978569"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-03T22:30:27Z",
          "updatedAt": "2021-06-03T22:33:41Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "```suggestion\r\nvalue when the input is an IPv4 address.) Failure to validate that a public_name\r\n```",
              "createdAt": "2021-06-03T22:30:27Z",
              "updatedAt": "2021-06-03T22:33:41Z"
            },
            {
              "originalPosition": 45,
              "body": "\"to the same name\" might be tricky - if there is a disagreement about whether the name is an IP or DNS name.\r\n\r\nHow about:\r\n\r\n```suggestion\r\nserver. However, it is not expected to induce security failures. Clients will\r\nfail closed if the client-facing server cannot produce a certificate bound\r\nto the a reference identity based on the public_name.\r\n```",
              "createdAt": "2021-06-03T22:31:54Z",
              "updatedAt": "2021-06-03T22:33:41Z"
            },
            {
              "originalPosition": 62,
              "body": "```suggestion\r\nspecifying otherwise.\r\n```",
              "createdAt": "2021-06-03T22:33:32Z",
              "updatedAt": "2021-06-03T22:33:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc1NzkxNzUx",
          "commit": {
            "abbreviatedOid": "b054fd8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-03T22:46:52Z",
          "updatedAt": "2021-06-03T22:46:52Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Much better!",
              "createdAt": "2021-06-03T22:46:52Z",
              "updatedAt": "2021-06-03T22:46:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc2NzAyODU2",
          "commit": {
            "abbreviatedOid": "76abb4f"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "*shrug* This works for me, although it still is unclear to me what we envision a TLS implementation doing here. I expect for most TLS implementations, \"use the parsers you already have\" isn't actionable because the parser you have is not available in the TLS library. It sounds like that's also true for @martinthomson, just there's a sunk cost thing where he's already implemented it. :-)\r\n\r\nI worry we'll end up with a random mix of some TLS libraries doing a lot of work to reimplement the WHATWG algorithm (hopefully correctly!) and other libraries ignoring the text, depending on what they read between the lines of the SHOULD.",
          "createdAt": "2021-06-04T22:27:42Z",
          "updatedAt": "2021-06-04T22:37:09Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "s/the a/the/",
              "createdAt": "2021-06-04T22:27:42Z",
              "updatedAt": "2021-06-04T22:36:50Z"
            },
            {
              "originalPosition": 62,
              "body": "No objection to the sentence, though I'm unsure what it's trying to do in the context of this PR.",
              "createdAt": "2021-06-04T22:28:20Z",
              "updatedAt": "2021-06-04T22:36:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc2NzA3ODky",
          "commit": {
            "abbreviatedOid": "76abb4f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-04T22:43:06Z",
          "updatedAt": "2021-06-04T22:43:06Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Flagged as an open issue for now.",
              "createdAt": "2021-06-04T22:43:06Z",
              "updatedAt": "2021-06-04T22:43:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc2NzA3OTQ1",
          "commit": {
            "abbreviatedOid": "76abb4f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-04T22:43:16Z",
          "updatedAt": "2021-06-04T22:43:17Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "```suggestion\r\nto the reference identity based on the public_name.\r\n```",
              "createdAt": "2021-06-04T22:43:16Z",
              "updatedAt": "2021-06-04T22:43:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc2NzA4MTc0",
          "commit": {
            "abbreviatedOid": "76abb4f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-04T22:43:59Z",
          "updatedAt": "2021-06-04T22:43:59Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "I threw this in to allow clients to omit the public name in CHO, for #396.",
              "createdAt": "2021-06-04T22:43:59Z",
              "updatedAt": "2021-06-04T22:44:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3NDU5MzMw",
          "commit": {
            "abbreviatedOid": "536afde"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-07T14:07:59Z",
          "updatedAt": "2021-06-07T14:09:09Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "This assertion requires a bunch of assumptions:\r\n* A server has published an IPv4 address in the public_name even though they're not supposed to, presumably because it's permitted by a future draft.\r\n* public_name is delivered \"securely\".\r\n* ICANN won't let anyone register a numeric TLD.\r\n* Clients don't parse IPv4 strings into 4 octets, and then try to interpret that as a domain name, resulting in a memory safety violation.\r\n\r\nI find these assumptions less than totally obvious, and that makes this text confusing.\r\n\r\nHere's some alternative explanatory text.\r\n```suggestion\r\nvalue when the input is an IPv4 address.) Ignoring any ECHConfig whose `public_name`\r\nis an IPv4 addresses allows the use of such addresses to be defined in a future\r\nupdate to ECH without breaking compatibility.\r\n```",
              "createdAt": "2021-06-07T14:07:59Z",
              "updatedAt": "2021-06-07T14:38:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3NDc4ODIz",
          "commit": {
            "abbreviatedOid": "536afde"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T14:23:54Z",
          "updatedAt": "2021-06-07T14:23:54Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "> Ignoring IPv4 addresses in `public_name` allows their use to be defined in a future update to ECH without breaking compatibility.\r\n\r\nI don't think this is true. If that's the goal, we'd need a MUST-level requirement. With a SHOULD, some TLS implementations will ignore it, while others will go ahead and use that ECHConfig and likely get confused.",
              "createdAt": "2021-06-07T14:23:54Z",
              "updatedAt": "2021-06-07T14:23:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3NDgzOTk5",
          "commit": {
            "abbreviatedOid": "536afde"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T14:27:58Z",
          "updatedAt": "2021-06-07T14:27:58Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "@bemasc clarifying question: by \"ignoring IPv4 addresses in `public_name`,\" do you mean \"ignore ECHConfigs that contain an IPv4 address,\" or \"allow ECHConfigs that contain an IPv4 address (by ignoring the fact that the config contains one)\"? (I'm parsing your suggestion as the latter, which seems counter to what this PR is trying to do.)",
              "createdAt": "2021-06-07T14:27:58Z",
              "updatedAt": "2021-06-07T14:27:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3NDk4ODI5",
          "commit": {
            "abbreviatedOid": "536afde"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T14:39:47Z",
          "updatedAt": "2021-06-07T14:39:47Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "@davidben Perhaps, but that's how I read the intention of the PR nonetheless.\r\n\r\n@chris-wood The former.  I updated my comment to clarify.",
              "createdAt": "2021-06-07T14:39:47Z",
              "updatedAt": "2021-06-07T14:39:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3NTI5MzU4",
          "commit": {
            "abbreviatedOid": "536afde"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T15:00:39Z",
          "updatedAt": "2021-06-07T15:00:39Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Couple minor nitpicks, just to make this less long-winded: I think we can drop \"non-empty\". It's already captured by both the struct definition and \"DNS name\". We can probably also replace \"standard dotted-decimal or other non-standard notations such as octal and hexadecimal\" with \"dotted-decimal or other notations\", since this PR ends up citing WHATWG later anyway. (Also it seems better not to get into the \"standard\" vs \"non-standard\" rabbithole regarding IETF vs WHATWG spellings.)",
              "createdAt": "2021-06-07T15:00:39Z",
              "updatedAt": "2021-06-07T15:00:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3NTY2Nzk4",
          "commit": {
            "abbreviatedOid": "536afde"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T15:27:54Z",
          "updatedAt": "2021-06-07T15:27:54Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Perhaps s/WhatWGURLAddressParser/WHATWG-IPV4/ to be slightly shorter? Also, while not explicitly stated, the example in https://datatracker.ietf.org/doc/html/rfc7322#section-4.8.6.6 implies we like SHOUTY-CASE-WITH-HYPHENS for these tags.",
              "createdAt": "2021-06-07T15:27:54Z",
              "updatedAt": "2021-06-07T15:27:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3NjQ5Mjg1",
          "commit": {
            "abbreviatedOid": "536afde"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T16:38:28Z",
          "updatedAt": "2021-06-07T16:38:29Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "\ud83d\udc4d The variant in your PR is cleaner, so we can just use that if we decide to land this.",
              "createdAt": "2021-06-07T16:38:29Z",
              "updatedAt": "2021-06-07T16:38:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3NjUwMDQx",
          "commit": {
            "abbreviatedOid": "536afde"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T16:39:19Z",
          "updatedAt": "2021-06-07T16:39:19Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "\ud83d\udc4d I'm fine with this, too :)",
              "createdAt": "2021-06-07T16:39:19Z",
              "updatedAt": "2021-06-07T16:39:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxMzU2MDI4",
          "commit": {
            "abbreviatedOid": "536afde"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T00:23:13Z",
          "updatedAt": "2021-06-11T00:23:14Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "If someone is allowed to change these rules, then how can they really be MUSTs?",
              "createdAt": "2021-06-11T00:23:13Z",
              "updatedAt": "2021-06-11T00:23:14Z"
            }
          ]
        }
      ]
    },
    {
      "number": 438,
      "id": "MDExOlB1bGxSZXF1ZXN0NjU3NTAwNzgy",
      "title": "Remove redundant length prefix from ClientHelloOuterAAD.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/438",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "ClientHello is already a defined structure. No need to wrap it in an opaque byte array. This avoids needing to fill in an extra length prefix in front.",
      "createdAt": "2021-05-29T16:55:47Z",
      "updatedAt": "2021-06-02T12:42:10Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "acd446bb01a92d1cfb03041c144975d5e3c3931b",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "simpler-aad",
      "headRefOid": "197b1d10bebbe9ffd9b772bb6f7397d688eb7d92",
      "closedAt": "2021-06-02T12:42:10Z",
      "mergedAt": "2021-06-02T12:42:10Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "5c7eba676d160f52f299d4750485b2524555fc2a"
      },
      "comments": [
        {
          "author": "eligrey",
          "authorAssociation": "NONE",
          "body": "Isn't the length prefix there in order to prevent ossification?",
          "createdAt": "2021-05-29T17:23:38Z",
          "updatedAt": "2021-05-29T17:23:38Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Could you elaborate? I don't see how this relates to ossification.\r\n\r\nNote AAD values aren't parsed or even sent over the wire. Rather, the requirement on them is injectivity.",
          "createdAt": "2021-05-29T17:39:33Z",
          "updatedAt": "2021-05-29T17:40:08Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "If the thinking is one might want to change what goes in the AAD later, the length prefix doesn't do anything. You'd need an actual distinguishing field like a type or version. We get that via labels and such when setting up the ECH context itself. By the time we've settled on speaking a particular ECH-like protocol, the AAD structure is fixed.",
          "createdAt": "2021-05-29T17:44:08Z",
          "updatedAt": "2021-05-29T17:44:08Z"
        },
        {
          "author": "eligrey",
          "authorAssociation": "NONE",
          "body": "Thanks for the clarification. I was confused about the specifics of how this prefix was used.",
          "createdAt": "2021-05-29T19:30:56Z",
          "updatedAt": "2021-05-29T19:31:09Z"
        },
        {
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "`Note this serialization uses the ClientHello structure from Section 4.1.2 of {{RFC8446}}, which does not include...`\r\n\r\nCan probably just say `This serialization...` instead of leading with `Note`, which is almost always unnecessary.",
          "createdAt": "2021-05-30T21:52:43Z",
          "updatedAt": "2021-05-30T21:52:43Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjczNjU3MDQw",
          "commit": {
            "abbreviatedOid": "a6701ef"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-01T22:59:33Z",
          "updatedAt": "2021-06-01T22:59:46Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "```suggestion\r\n`extension_data` list has zero length. This serialization uses the\r\nClientHello structure from Section 4.1.2 of {{RFC8446}}, which does not include\r\n```",
              "createdAt": "2021-06-01T22:59:34Z",
              "updatedAt": "2021-06-01T22:59:46Z"
            }
          ]
        }
      ]
    },
    {
      "number": 439,
      "id": "MDExOlB1bGxSZXF1ZXN0NjU3NTA2ODk2",
      "title": "Add some security considerations for cookie values.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/439",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "One of the motivations for encrypting HRR in #407 was the leaks from cookie values. If we don't go with such a construction (which seems likely) and instead do #417 or #422, cookies will be in the clear. That means it is instead on the backend servers to construct cookie values without leaking information. This PR provides security considerations to that effect.\r\n\r\nUnfortunately the requirements on backend servers within a Split Mode deployment are a bit onerous. I suspect, in practice, the answer is that Split Mode deployments cannot even use cookies on the backend server. Between HRRs being rare and stateless HRR being unnecessary over TCP or QUIC, that's hopefully fine. (Note this is different from #418, which was about the *client-facing* server being stateless. This applies if the *backend* server is stateless.)",
      "createdAt": "2021-05-29T17:37:46Z",
      "updatedAt": "2021-06-11T22:33:11Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "acd446bb01a92d1cfb03041c144975d5e3c3931b",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "unencrypted-cookies",
      "headRefOid": "2c1d108608f5dceaf7b4ce1f2c1e6f39c42b1efe",
      "closedAt": "2021-06-11T22:33:11Z",
      "mergedAt": "2021-06-11T22:33:11Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "1ca01023a5dacf897b0a5c3faf1fecd356bf4cdf"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc2NDkzNDMz",
          "commit": {
            "abbreviatedOid": "5c1db4f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "\ud83d\udc4d We can probably safely assume #422 will land and make the suggested edit.",
          "createdAt": "2021-06-04T16:54:49Z",
          "updatedAt": "2021-06-04T16:54:49Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc4NzcwMDIx",
          "commit": {
            "abbreviatedOid": "5c1db4f"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-08T16:57:00Z",
          "updatedAt": "2021-06-08T16:58:03Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\n{{Section 4.2.2 of RFC8446}} defines a cookie value that servers may send in\r\n```",
              "createdAt": "2021-06-08T16:57:01Z",
              "updatedAt": "2021-06-08T16:58:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc4NzczMzYx",
          "commit": {
            "abbreviatedOid": "47cd113"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-08T17:00:21Z",
          "updatedAt": "2021-06-08T17:00:21Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "This new feature makes me so happy. :-)",
              "createdAt": "2021-06-08T17:00:21Z",
              "updatedAt": "2021-06-08T17:00:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMjUyMzQy",
          "commit": {
            "abbreviatedOid": "47cd113"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-11T22:32:40Z",
          "updatedAt": "2021-06-11T22:32:54Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nHelloRetryRequest for clients to echo in the second ClientHello. While ECH\r\nencrypts the cookie in the second ClientHelloInner, the backend server's\r\nHelloRetryRequest is unencrypted.This means differences in cookies between\r\nbackend servers, such as lengths or cleartext components, may leak information\r\nabout the server identity.\r\n```",
              "createdAt": "2021-06-11T22:32:40Z",
              "updatedAt": "2021-06-11T22:32:54Z"
            },
            {
              "originalPosition": 27,
              "body": "```suggestion\r\n```",
              "createdAt": "2021-06-11T22:32:47Z",
              "updatedAt": "2021-06-11T22:32:54Z"
            }
          ]
        }
      ]
    },
    {
      "number": 442,
      "id": "MDExOlB1bGxSZXF1ZXN0NjYxMzk1MDc2",
      "title": "Preserve length prefixes in ClientHelloOuterAAD",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/442",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "After having written so many variations of ClientHelloOuterAAD construction (client and server, test and production), I think this may be simpler. A little bit less ClientHello rewriting. The cost is predicting the payload length on the client (same as PSK binders), but that prediction is just adding the tag length to len(EncodedClientHelloInner). The server, in particular, needs to parse and then re-encode an arbitrary incoming ClientHelloOuter with transforms.\r\n\r\nThoughts?",
      "createdAt": "2021-06-04T02:54:47Z",
      "updatedAt": "2021-06-08T17:04:03Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "10b35926e5773868e5e01682308b960ae51602eb",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "aad-zeros",
      "headRefOid": "ffeb69859403d1e0b09219887fce7a027ba428cd",
      "closedAt": "2021-06-08T17:04:03Z",
      "mergedAt": "2021-06-08T17:04:03Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "16825d47c06eaac4d80768f90f97e120b7e0b540"
      },
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> Did I miss the rationale for not including the HPKE parameters? I know that some of these are in HPKE and so they are redundant here, but they are encoded in the e_c_h extension, so maybe there is a different spelling of this that only drops/zeros-out the encrypted portion.\r\n\r\nThat's exactly what this PR does. `payload` is the encrypted portion. (The whole extension body is `extension_data` in RFC8446. Guessing that was the disconnect?)",
          "createdAt": "2021-06-04T03:30:48Z",
          "updatedAt": "2021-06-04T03:30:48Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, precise terminology is useful up until the point that you aren't intimately familiar with each and every term.  That would be OK, but as I said, it's not an improvement for us.",
          "createdAt": "2021-06-04T03:31:57Z",
          "updatedAt": "2021-06-04T03:31:57Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Hehe. I'm mostly hoping it'd tidy up the server side. When you decide to do ECH, you've already got to have parsed the ClientHello and found the ECH extension. Instead of going back, trimming out the ECH extension, preserving the surrounding extensions, and then updating the extensions length prefix, you can just take the offset of the payload field you just found, zero that and leave the rest alone.",
          "createdAt": "2021-06-04T03:40:31Z",
          "updatedAt": "2021-06-04T03:40:31Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, if it is a server-side improvement (we don't heavily optimize any of this stuff, so we don't care much), then I won't stand in the way.",
          "createdAt": "2021-06-04T03:49:27Z",
          "updatedAt": "2021-06-04T03:49:27Z"
        },
        {
          "author": "briansmith",
          "authorAssociation": "NONE",
          "body": "The benefit of this change, IIRC, is that you don't need to reserialize anything. But the new proposed text still talks about reserializing. It would be good to find a way to reword it so it doesn't imply that reserialization is needed.",
          "createdAt": "2021-06-04T18:09:46Z",
          "updatedAt": "2021-06-04T18:09:46Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "@briansmith Rephrased.",
          "createdAt": "2021-06-04T23:08:26Z",
          "updatedAt": "2021-06-04T23:08:26Z"
        },
        {
          "author": "briansmith",
          "authorAssociation": "NONE",
          "body": "@davidben LGTM! Thanks for making that change.",
          "createdAt": "2021-06-04T23:43:05Z",
          "updatedAt": "2021-06-04T23:43:05Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@davidben would you mind resolving conflicts here?",
          "createdAt": "2021-06-07T23:45:48Z",
          "updatedAt": "2021-06-07T23:45:48Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> would you mind resolving conflicts here?\r\n\r\nRebased.",
          "createdAt": "2021-06-07T23:56:06Z",
          "updatedAt": "2021-06-07T23:56:06Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks! Paging @cjpatton, @sftcd, and @cbartle891 for additional reviews.",
          "createdAt": "2021-06-07T23:57:34Z",
          "updatedAt": "2021-06-07T23:57:34Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "Apart from my question about clarification, makes sense to me.",
          "createdAt": "2021-06-08T02:43:36Z",
          "updatedAt": "2021-06-08T02:43:36Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 08/06/2021 00:57, Christopher Wood wrote:\n> Thanks! Paging @cjpatton, @sftcd, and @cbartle891 for additional reviews.\n> \n\nLGTM\n\nS.\n",
          "createdAt": "2021-06-08T09:47:08Z",
          "updatedAt": "2021-06-08T09:47:08Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'm kind of thrown off by the use of the word \"predict.\" It suggests to me that there's a chance that the prediction might be wrong. Should it not be \"compute\" instead? Or is there in fact a chance it might be wrong?\r\n\r\nGood idea. I went to make that more precise and, in the process, realized a whole lot of the client procedure was specified funny so e5ddeb9af5f4f142e436e399c1496faceaeb7e83 fixes that up. (Those issues apply to the existing text too, so if we end up not merging this PR, I'll write an equivalent PR with just those bits.)\r\n\r\n[edit: changed commit hash. old one had a typo.]\r\n[edit: so did the second one. bah, okay, going to stop force-pushing now...]",
          "createdAt": "2021-06-08T16:09:02Z",
          "updatedAt": "2021-06-08T16:12:31Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc1ODg4MjM3",
          "commit": {
            "abbreviatedOid": "9ae8358"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This wouldn't be easier for us to implement; we insert the extension.  Yes, with `memmove()`.  We use extension insertion in a few places (padding), so it's not that difficult.\r\n\r\nIt's doable, and not that much more work to do it this way.\r\n\r\nDid I miss the rationale for not including the HPKE parameters?  I know that some of these are in HPKE and so they are redundant here, but they are encoded in the e_c_h extension, so maybe there is a different spelling of this that only drops/zeros-out the encrypted portion.",
          "createdAt": "2021-06-04T03:25:55Z",
          "updatedAt": "2021-06-04T03:25:55Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc2MzU5Mjg4",
          "commit": {
            "abbreviatedOid": "9ae8358"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I've no strong preference here. This folds the same data into the AAD, just differently, so if it's easier to implement, \ud83d\udc4d ",
          "createdAt": "2021-06-04T14:39:59Z",
          "updatedAt": "2021-06-04T14:39:59Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc4MDMyNDIw",
          "commit": {
            "abbreviatedOid": "00e5b73"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-08T02:26:58Z",
          "updatedAt": "2021-06-08T02:26:59Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "I'm kind of thrown off by the use of the word \"predict.\" It suggests to me that there's a chance that the prediction might be wrong. Should it not be \"compute\" instead? Or is there in fact a chance it might be wrong?\r\n\r\nEdit: Additionally, should we not describe how to predict this length? How does one predict something based on the HPKE AEAD and EncodedClientHelloInner?",
              "createdAt": "2021-06-08T02:26:58Z",
              "updatedAt": "2021-06-08T02:31:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc4MDM4ODM4",
          "commit": {
            "abbreviatedOid": "00e5b73"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-08T02:43:47Z",
          "updatedAt": "2021-06-08T02:43:47Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc4NzQwNzc1",
          "commit": {
            "abbreviatedOid": "e5ddeb9"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-08T16:26:51Z",
          "updatedAt": "2021-06-08T16:34:13Z",
          "comments": [
            {
              "originalPosition": 123,
              "body": "```suggestion\r\nThe client serializes this structure to construct the ClientHelloOuterAAD. It then\r\n```",
              "createdAt": "2021-06-08T16:26:51Z",
              "updatedAt": "2021-06-08T16:34:13Z"
            },
            {
              "originalPosition": 127,
              "body": "Maybe we call this enc_payload (or final_payload or something) to distinguish between the payload extension value? The following sentence read a bit weird to me, where it refers to \"payload\" and \"this value.\" ",
              "createdAt": "2021-06-08T16:28:26Z",
              "updatedAt": "2021-06-08T16:34:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc4NzY2NDk5",
          "commit": {
            "abbreviatedOid": "e5ddeb9"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I'm happy with this.",
          "createdAt": "2021-06-08T16:53:09Z",
          "updatedAt": "2021-06-08T16:53:09Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc4Nzc1MzUy",
          "commit": {
            "abbreviatedOid": "ffeb698"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-08T17:02:30Z",
          "updatedAt": "2021-06-08T17:02:31Z",
          "comments": [
            {
              "originalPosition": 127,
              "body": "Done",
              "createdAt": "2021-06-08T17:02:31Z",
              "updatedAt": "2021-06-08T17:02:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc4Nzc1NTg3",
          "commit": {
            "abbreviatedOid": "ffeb698"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-08T17:02:46Z",
          "updatedAt": "2021-06-08T17:02:46Z",
          "comments": [
            {
              "originalPosition": 127,
              "body": "(Went with final_payload because enc_payload seemed potentially confusing with enc.)",
              "createdAt": "2021-06-08T17:02:46Z",
              "updatedAt": "2021-06-08T17:02:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc4Nzc2NDgy",
          "commit": {
            "abbreviatedOid": "ffeb698"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-08T17:03:45Z",
          "updatedAt": "2021-06-08T17:03:45Z",
          "comments": [
            {
              "originalPosition": 127,
              "body": "\ud83d\udc4d ",
              "createdAt": "2021-06-08T17:03:45Z",
              "updatedAt": "2021-06-08T17:03:45Z"
            }
          ]
        }
      ]
    },
    {
      "number": 443,
      "id": "MDExOlB1bGxSZXF1ZXN0NjYxNDEyODgx",
      "title": "Move ClientHello padding to the encoding.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/443",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #433. This PR does four things:\r\n\r\n1. Apply the EncodedClientHelloInner change suggested in #433.\r\n\r\n2. Adjust the recommended padding scheme to round the overall length to\r\n   a multiple of 32, now that this is fairly easy to compute.\r\n\r\n3. It fixes an mistake in the recommended padding scheme. The server\r\n   sets maximum_name_length to the longest *name*, but the client\r\n   computes padding based on the server_name *extension*. We're\r\n   miscounting 7 bytes of extension overhead and effectively are using\r\n   maximum_name_length - 7 instead of maximum_name_length.\r\n\r\n4. It defines what to do if you aren't sending SNI. While unlikely to\r\n   happen in practice (no way to get an ECHConfig), implementations will\r\n   need to handle this. The application may well call SetECHConfigList()\r\n   without SetServerName() and it's rude to crash. It's pretty obvious what\r\n   to do, so just define it.\r\n\r\n(If folks would rather the PR only do a subset of these, I can defer the more controversial bits to other PRs. They all touched the same text, so it was easier to just do them all.)",
      "createdAt": "2021-06-04T03:28:07Z",
      "updatedAt": "2021-06-28T13:47:02Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1ca01023a5dacf897b0a5c3faf1fecd356bf4cdf",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "encoded-padding",
      "headRefOid": "24b0cc3eeaf31fe68bdd57f593153f8e0c204d8a",
      "closedAt": "2021-06-28T13:47:02Z",
      "mergedAt": "2021-06-28T13:47:02Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "4bc468f47b56add741b26616ee62b2b57c0e4a11"
      },
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> This isn't how I had planned to implement this, but it seems preferable. Mostly because the padding calculation is clearer. I had planned to do much the same as this, but with a padding extension. This is less fuss.\r\n\r\nYeah, I'd actually already implemented the draft-10 construction, but I prefer this one. As you say, less fuss, especially if you want to do whole-message rounding. I also prefer rounding to a multiple of 32 at the end. If we decrease the range of possible values, it's easier to GREASE.",
          "createdAt": "2021-06-04T03:47:34Z",
          "updatedAt": "2021-06-04T03:47:34Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Oops. Pushed one more fixup to correct the server_name extension overhead. I missed the ServerNameList length prefix, so the correct overhead is 9, not 7. See 95b91f0d0465d5fcee3cd0d73c84dc293f4146b5 for derivation.",
          "createdAt": "2021-06-07T21:05:10Z",
          "updatedAt": "2021-06-07T21:05:10Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@davidben one last thing -- would you mind rebasing to resolve conflicts?",
          "createdAt": "2021-06-08T22:12:28Z",
          "updatedAt": "2021-06-08T22:12:28Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased.\r\n\r\n(Man, who is this jerk who keeps causing merge conflicts with my PRs? Let's see... oh, it's @davidben. That guy is the worst! :-D)",
          "createdAt": "2021-06-08T22:43:14Z",
          "updatedAt": "2021-06-08T22:43:14Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Given positive support here and on the list, I'm merging this to include in the next version of the draft.",
          "createdAt": "2021-06-28T13:46:58Z",
          "updatedAt": "2021-06-28T13:46:58Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc1ODkxMjE1",
          "commit": {
            "abbreviatedOid": "676de47"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This isn't how I had planned to implement this, but it seems preferable.  Mostly because the padding calculation is clearer.  I had planned to do much the same as this, but with a padding extension.  This is less fuss.\r\n\r\n...If only HPKE had padding.",
          "createdAt": "2021-06-04T03:35:24Z",
          "updatedAt": "2021-06-04T03:37:46Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "This would be easier if this wasn't length-prefixed.  Every padding scheme that ever used length has caused a lot of pain.  I realize that this isn't necessarily security-critical, but just extending with zeros should be easier to implement AND you don't have two extra bytes of overhead.",
              "createdAt": "2021-06-04T03:35:24Z",
              "updatedAt": "2021-06-04T03:37:46Z"
            },
            {
              "originalPosition": 70,
              "body": "```suggestion\r\n2. If the ClientHelloInner did not contain a \"server_name\" extension (e.g., if\r\n```",
              "createdAt": "2021-06-04T03:36:05Z",
              "updatedAt": "2021-06-04T03:37:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc1ODkyNDY5",
          "commit": {
            "abbreviatedOid": "676de47"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-04T03:39:34Z",
          "updatedAt": "2021-06-04T03:39:35Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Works for me. Since every TLS structure is self-delimiting, we can just append stuff. It shifts some work from presentation language to prose, but I agree that it's easier to implement.",
              "createdAt": "2021-06-04T03:39:35Z",
              "updatedAt": "2021-06-04T03:39:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc1ODk0MDQ1",
          "commit": {
            "abbreviatedOid": "308e703"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-04T03:45:00Z",
          "updatedAt": "2021-06-04T03:45:01Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Done. I kinda cheated a bit around the presentation language, but hopefully that's clear enough?",
              "createdAt": "2021-06-04T03:45:01Z",
              "updatedAt": "2021-06-04T03:45:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc1ODk1MDQy",
          "commit": {
            "abbreviatedOid": "308e703"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-04T03:48:04Z",
          "updatedAt": "2021-06-04T03:48:04Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "```suggestion\r\nNote this field uses the ClientHello structure, defined in {{Section 4.1.2\r\nof RFC8446}} which does not include the Handshake structure's four byte\r\n```",
              "createdAt": "2021-06-04T03:48:04Z",
              "updatedAt": "2021-06-04T03:48:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc2NDgyMDc4",
          "commit": {
            "abbreviatedOid": "308e703"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-04T16:40:24Z",
          "updatedAt": "2021-06-04T16:50:33Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "```suggestion\r\nClientHelloInner and sets the `legacy_session_id` field to an empty string.\r\n```",
              "createdAt": "2021-06-04T16:40:24Z",
              "updatedAt": "2021-06-04T16:50:33Z"
            },
            {
              "originalPosition": 21,
              "body": "```suggestion\r\nheader. The `padding` field MUST be all zeroes.\r\n```",
              "createdAt": "2021-06-04T16:45:43Z",
              "updatedAt": "2021-06-04T16:50:33Z"
            },
            {
              "originalPosition": 39,
              "body": "Should we require the server check that padding is all zeroes?",
              "createdAt": "2021-06-04T16:46:30Z",
              "updatedAt": "2021-06-04T16:50:33Z"
            },
            {
              "originalPosition": 82,
              "body": "```suggestion\r\nThis rounds the length of EncodedClientHelloInner up to a multiple of 32 bytes,\r\nreducing lengths of this structure across all clients.\r\n```",
              "createdAt": "2021-06-04T16:50:25Z",
              "updatedAt": "2021-06-04T16:50:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc2NDkwMzcx",
          "commit": {
            "abbreviatedOid": "308e703"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM pending one question about server-side checks for all-zero padding.",
          "createdAt": "2021-06-04T16:50:56Z",
          "updatedAt": "2021-06-04T16:50:56Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc2NTM0OTU5",
          "commit": {
            "abbreviatedOid": "308e703"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-04T17:50:20Z",
          "updatedAt": "2021-06-04T17:50:20Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "YOU CAN DO THAT?!?!!? Wow, I need to go update all my documents now.",
              "createdAt": "2021-06-04T17:50:20Z",
              "updatedAt": "2021-06-04T17:50:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc2NTM2Njgw",
          "commit": {
            "abbreviatedOid": "308e703"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-04T17:52:38Z",
          "updatedAt": "2021-06-04T17:52:38Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "Agreed on the first half. I worry \"reducing lengths\" reads like making the lengths smaller. I guess \"range of lengths\" also has a different meaning... I was thinking the range of a function. :-)\r\n\r\nHow about \"reducing the set of possible lengths across all clients\".",
              "createdAt": "2021-06-04T17:52:38Z",
              "updatedAt": "2021-06-04T17:52:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc2NTM4OTc2",
          "commit": {
            "abbreviatedOid": "19eeda9"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-04T17:55:44Z",
          "updatedAt": "2021-06-04T17:55:45Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "That works for me too \ud83d\udc4d ",
              "createdAt": "2021-06-04T17:55:45Z",
              "updatedAt": "2021-06-04T17:55:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc2NTU3OTM0",
          "commit": {
            "abbreviatedOid": "e567477"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-04T18:21:33Z",
          "updatedAt": "2021-06-04T18:21:33Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Done, though s/sets/setting/",
              "createdAt": "2021-06-04T18:21:33Z",
              "updatedAt": "2021-06-04T18:21:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc2NTU4MDUz",
          "commit": {
            "abbreviatedOid": "e567477"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-04T18:21:42Z",
          "updatedAt": "2021-06-04T18:21:42Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Sure. Done.",
              "createdAt": "2021-06-04T18:21:42Z",
              "updatedAt": "2021-06-04T18:21:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc2NTU4MTA4",
          "commit": {
            "abbreviatedOid": "e567477"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-04T18:21:47Z",
          "updatedAt": "2021-06-04T18:21:47Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "Done.",
              "createdAt": "2021-06-04T18:21:47Z",
              "updatedAt": "2021-06-04T18:21:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc4Nzc2MTMw",
          "commit": {
            "abbreviatedOid": "95b91f0"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Just some editorial comments.",
          "createdAt": "2021-06-08T17:03:21Z",
          "updatedAt": "2021-06-08T17:08:22Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "We ought to define N in this paragraph. Something like: Finally, the client sets the `padding` field to a length-N all-zero byte string, where N is computed as described in {{padding}}.`",
              "createdAt": "2021-06-08T17:03:21Z",
              "updatedAt": "2021-06-08T17:08:22Z"
            },
            {
              "originalPosition": 82,
              "body": "s/P/N/g",
              "createdAt": "2021-06-08T17:07:02Z",
              "updatedAt": "2021-06-08T17:08:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc4NzgzNjUz",
          "commit": {
            "abbreviatedOid": "95b91f0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-08T17:11:48Z",
          "updatedAt": "2021-06-08T17:11:49Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "```suggestion\r\n2. Let N = 31 - ((L - 1) % 32) and add N bytes of padding.\r\n```",
              "createdAt": "2021-06-08T17:11:48Z",
              "updatedAt": "2021-06-08T17:11:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc4Nzg1MzE5",
          "commit": {
            "abbreviatedOid": "95b91f0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-08T17:13:38Z",
          "updatedAt": "2021-06-08T17:13:39Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "```suggestion\r\nFinally, the client sets the `padding` field to a byte string of length N whose\r\ncontents are all zeros, where N is as computed as described in {{padding}}.\r\n```",
              "createdAt": "2021-06-08T17:13:39Z",
              "updatedAt": "2021-06-08T17:14:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc5MDI5NzU3",
          "commit": {
            "abbreviatedOid": "95b91f0"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-08T21:48:46Z",
          "updatedAt": "2021-06-08T21:49:20Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "Done.",
              "createdAt": "2021-06-08T21:48:46Z",
              "updatedAt": "2021-06-08T21:49:20Z"
            },
            {
              "originalPosition": 82,
              "body": "Done.",
              "createdAt": "2021-06-08T21:48:55Z",
              "updatedAt": "2021-06-08T21:49:20Z"
            },
            {
              "originalPosition": 33,
              "body": "Done, although tweaked slightly since {{padding}} is merely recommended, not required.",
              "createdAt": "2021-06-08T21:49:15Z",
              "updatedAt": "2021-06-08T21:49:20Z"
            },
            {
              "originalPosition": 33,
              "body": "Done, although tweaked slightly since {{padding}} is merely recommended, not required.",
              "createdAt": "2021-06-08T21:49:18Z",
              "updatedAt": "2021-06-08T21:49:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMjI0NzE0",
          "commit": {
            "abbreviatedOid": "15a269c"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T21:23:34Z",
          "updatedAt": "2021-06-11T21:23:34Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "nit: `uint8 zeros[length_of_padding];` aligns a little nicer with [8446](https://datatracker.ietf.org/doc/html/rfc8446#section-5.2).",
              "createdAt": "2021-06-11T21:23:34Z",
              "updatedAt": "2021-06-11T21:23:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzMTcyNjk1",
          "commit": {
            "abbreviatedOid": "4b3a48c"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T17:24:10Z",
          "updatedAt": "2021-06-14T17:24:11Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Done. It does make it no longer align with the requested variable name change in {{padding}}, but I agree with you aligning with 8446 makes sense.",
              "createdAt": "2021-06-14T17:24:10Z",
              "updatedAt": "2021-06-14T17:24:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg5OTg3OTY1",
          "commit": {
            "abbreviatedOid": "4b3a48c"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-22T20:56:15Z",
          "updatedAt": "2021-06-22T20:56:15Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg5OTkzMjA5",
          "commit": {
            "abbreviatedOid": "4b3a48c"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-22T21:02:35Z",
          "updatedAt": "2021-06-22T21:02:35Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "nit (here and below):\r\n```suggestion\r\nFinally, the client determines the number of padding bytes, length_of_padding, and sets the\r\n```",
              "createdAt": "2021-06-22T21:02:35Z",
              "updatedAt": "2021-06-22T21:02:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjkwODE2MzY3",
          "commit": {
            "abbreviatedOid": "4b3a48c"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-23T15:24:45Z",
          "updatedAt": "2021-06-23T15:24:45Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Well, N is referenced immediately afterwards and elsewhere we've used capital letters for random variables in prose. Note RFC8446 never utters length_of_padding in prose either. (Really what's going on here is that this is a questionably valid TLS message. The TLS message syntax is typically self-delimiting. But it's silly to add a length prefix here.)\r\n\r\nI'll rewrite this to not reference a variable name.",
              "createdAt": "2021-06-23T15:24:45Z",
              "updatedAt": "2021-06-23T15:24:45Z"
            }
          ]
        }
      ]
    },
    {
      "number": 444,
      "id": "MDExOlB1bGxSZXF1ZXN0NjYyMDE0NjM0",
      "title": "Allow empty enc in ClientECH.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/444",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The second ClientHello after HelloRetryRequest reuses the HPKE context\r\nand calls Seal/Open a second time. To avoid needing to unnecessarily\r\nretain the enc value, and discourage servers from mistakenly recreating\r\nthe HPKE context, we made it use the empty string but forgot to update\r\nthe syntax to match.",
      "createdAt": "2021-06-04T19:49:48Z",
      "updatedAt": "2021-06-04T20:44:52Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "0dd90ac55559bc0945acb8c78ac7ac114909543c",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "empty-enc",
      "headRefOid": "7575bb2339b5d51126609fe36e14245519d39de7",
      "closedAt": "2021-06-04T20:44:52Z",
      "mergedAt": "2021-06-04T20:44:52Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "69211578de6a173e9531baff2761176c4c7da1bc"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc2NjUxMTQ4",
          "commit": {
            "abbreviatedOid": "7575bb2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-04T20:44:40Z",
          "updatedAt": "2021-06-04T20:44:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 445,
      "id": "MDExOlB1bGxSZXF1ZXN0NjYyMjU4NjA1",
      "title": "Link to sections of references.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/445",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Apparently this works now!",
      "createdAt": "2021-06-05T01:44:56Z",
      "updatedAt": "2021-06-07T13:39:43Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "69211578de6a173e9531baff2761176c4c7da1bc",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "link-sections",
      "headRefOid": "0249e478908e091c082ed2d32d42d76a2b0a36b3",
      "closedAt": "2021-06-07T13:39:43Z",
      "mergedAt": "2021-06-07T13:39:43Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "db00bed8234460217bf49cc4a0a592b3dbaec1f5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc2NzM5MTE4",
          "commit": {
            "abbreviatedOid": "0249e47"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-05T01:45:21Z",
          "updatedAt": "2021-06-05T01:45:21Z",
          "comments": [
            {
              "originalPosition": 121,
              "body": "It didn't like the semicolon so I reworded this.",
              "createdAt": "2021-06-05T01:45:21Z",
              "updatedAt": "2021-06-05T01:45:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3NDI0NDE5",
          "commit": {
            "abbreviatedOid": "0249e47"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-07T13:39:38Z",
          "updatedAt": "2021-06-07T13:39:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 446,
      "id": "MDExOlB1bGxSZXF1ZXN0NjYzNjYzNDI2",
      "title": "Rephrase maximum_name_length description.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/446",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "While padding is \"described below\", it's pretty far away now. We also\r\nrecommend the padding scheme whether or not the value is non-zero. The\r\ntext about wildcard names also applies in both cases and seems to\r\ndescribe when the server name may exceed the max.\r\n\r\nThis rephases things a bit.",
      "createdAt": "2021-06-07T15:17:20Z",
      "updatedAt": "2021-06-07T23:45:26Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "db00bed8234460217bf49cc4a0a592b3dbaec1f5",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "max-name-length",
      "headRefOid": "f1d760ec9cdd4627cb68a48cd91d0f371c769d46",
      "closedAt": "2021-06-07T23:45:26Z",
      "mergedAt": "2021-06-07T23:45:26Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "10b35926e5773868e5e01682308b960ae51602eb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3NjI0OTM3",
          "commit": {
            "abbreviatedOid": "d2a3f93"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-07T16:15:51Z",
          "updatedAt": "2021-06-07T16:16:24Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "```suggestion\r\nconstrain server name lengths. Names may exceed this length if, e.g.,\r\n```",
              "createdAt": "2021-06-07T16:15:51Z",
              "updatedAt": "2021-06-07T16:16:24Z"
            }
          ]
        }
      ]
    },
    {
      "number": 447,
      "id": "MDExOlB1bGxSZXF1ZXN0NjYzNjgxNTI4",
      "title": " Leave IPv4 address parsing to the application",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/447",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This sits on top of #436 (per https://github.com/tlswg/draft-ietf-tls-esni/pull/436#issuecomment-855992106) and is an implementation of https://github.com/tlswg/draft-ietf-tls-esni/pull/436#discussion_r640744959.\r\n    \r\nThis is the \"somebody else's problem\" option, on the theory that IP parsers are typically outside the TLS stack, and, sadly, IPv4 address syntaxes are a bit inconsistent across applications.\r\n\r\nThis is papering over the fact that what DNS believes is a DNS name doesn't match reality. Almost everyone sticks IP literals and DNS names into one syntax, in slightly different variations. But we appear to have dug ourselves into that hole, so this PR attempts rationalize it by saying those applications accept a subset of the DNS syntax, and it's on the applications to manage their subsets.",
      "createdAt": "2021-06-07T15:37:35Z",
      "updatedAt": "2021-06-14T19:24:35Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "db00bed8234460217bf49cc4a0a592b3dbaec1f5",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "punt-ip-problem",
      "headRefOid": "eccd3fe2ff67512af397e4498292594a0b3d9ae4",
      "closedAt": "2021-06-14T19:24:34Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, that we're really papering over DNS failing to match reality is a pretty solid argument. :-) I think the main thing that makes me nervous about #436 is it not wanting to commit to a MUST. I feel it is better to definitively try to resolve the problem, or definitively punt it, rather than leave it ambiguous. That is:\r\n\r\n* Either, we decide that DNS's syntax rules are insufficient and we write down explicitly what we mean. Perhaps that's the WHATWG parser. That means we are deciding every TLS stack must have an implementation of that parser, that this implementation may well be redundant in many applications due to layering, and that we are okay with this.\r\n* Or, we decide that we don't want to deal with this at the TLS level. This means we prefer that there not be redundant parsers, that TLS implementations not parse this messy format, and that in exchange we are okay with punting this to application, with all the risks that entails of the application failing to handle this.\r\n\r\nI'm not opposed to either, but the more I think about it, the more unhappy I am with the SHOULD option. SHOULD seems to basically leave it to interpretation which side we're on.",
          "createdAt": "2021-06-08T17:18:11Z",
          "updatedAt": "2021-06-08T17:19:08Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favor of #456.",
          "createdAt": "2021-06-14T19:24:34Z",
          "updatedAt": "2021-06-14T19:24:34Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3NjQxOTA0",
          "commit": {
            "abbreviatedOid": "eccd3fe"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I'm equally fine with this PR and #436, as I think the outcome will be the same for both. I wonder if we even need the sentence about `DNSOrIp` syntax though. The \"applications verify certificates using public name as a DNS reference identity\" seems like it ought to be sufficient?",
          "createdAt": "2021-06-07T16:30:40Z",
          "updatedAt": "2021-06-07T16:35:10Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "```suggestion\r\n?I-D.draft-ietf-httpbis-semantics}}, with the public name as a DNS-based\r\nreference identity. Applications that incorporate DNS names and IP addresses\r\ninto the same syntax (e.g. {{?RFC3986, Section 7.4}} and {{WHATWG-IPV4}}) MUST\r\nreject names that would be interpreted as IPv4 addresses.\r\n```",
              "createdAt": "2021-06-07T16:30:40Z",
              "updatedAt": "2021-06-07T16:35:10Z"
            },
            {
              "originalPosition": 71,
              "body": "(simplifying to further punt on particulars of what certificate validators do with DNS names)",
              "createdAt": "2021-06-07T16:30:50Z",
              "updatedAt": "2021-06-07T16:35:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3NzA1NTc0",
          "commit": {
            "abbreviatedOid": "eccd3fe"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T17:38:33Z",
          "updatedAt": "2021-06-07T17:38:33Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "Hrm. I guess I was viewing \"I think this is actually an IP\" as a special case of \"I don't accept that DNS name\". But maybe that's an unnecessary generalization?",
              "createdAt": "2021-06-07T17:38:33Z",
              "updatedAt": "2021-06-07T17:38:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3NzA3Mjc0",
          "commit": {
            "abbreviatedOid": "eccd3fe"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T17:40:34Z",
          "updatedAt": "2021-06-07T17:40:35Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "Yeah, that's what I'm thinking. Less words overall, and it seems to have the same effect.",
              "createdAt": "2021-06-07T17:40:35Z",
              "updatedAt": "2021-06-07T17:40:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3OTk1MzE2",
          "commit": {
            "abbreviatedOid": "eccd3fe"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I would greatly prefer #436.  I don't think that making this someone else's problem is the responsible thing to do.  Most applications take IPv4 and domain names in the same field.  That's how the Internet works, for better or worse, and this approach only creates a negative externality.  As minor as it might seem, that's not how I would like us to operate.",
          "createdAt": "2021-06-08T00:44:05Z",
          "updatedAt": "2021-06-08T00:44:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 449,
      "id": "MDExOlB1bGxSZXF1ZXN0NjYzNzU3NjI5",
      "title": "Make the acceptance signal pseudorandom",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/449",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Based on #423.\r\nCloses #448.\r\n\r\nChanges the acceptance signal to use HKDF-Extract(0, ClientHelloInner.random) as the PRK.",
      "createdAt": "2021-06-07T17:16:14Z",
      "updatedAt": "2021-06-17T21:17:45Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9f9f26ddcefc771f3e2b77aa75a824f76f3cf981",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "accept-conf-hkdf",
      "headRefOid": "90d26a198af458e645978b6a8f4536519f9030e1",
      "closedAt": "2021-06-11T22:23:26Z",
      "mergedAt": "2021-06-11T22:23:26Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "4020104686a05312d2c7c34ed0ccd80c70450121"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Rebased.",
          "createdAt": "2021-06-07T18:04:05Z",
          "updatedAt": "2021-06-07T18:04:05Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Rebased.",
          "createdAt": "2021-06-11T22:22:25Z",
          "updatedAt": "2021-06-11T22:22:25Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3Njg3NTMz",
          "commit": {
            "abbreviatedOid": "5b945bb"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T17:21:20Z",
          "updatedAt": "2021-06-07T17:21:20Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Do we need to worry about `transcript_ech_conf` itself containing `ClientHelloInner.random` (and a hash of something containing it if HRR), or does that work out in the analysis?",
              "createdAt": "2021-06-07T17:21:20Z",
              "updatedAt": "2021-06-07T17:21:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3NjkxNDU0",
          "commit": {
            "abbreviatedOid": "5b945bb"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T17:26:05Z",
          "updatedAt": "2021-06-07T17:26:05Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Hmm... what do you mean by \"worry\" here? (Do you think there's a problem with this formulation?) ",
              "createdAt": "2021-06-07T17:26:05Z",
              "updatedAt": "2021-06-07T17:26:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3NzAzNjg5",
          "commit": {
            "abbreviatedOid": "5b945bb"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T17:36:14Z",
          "updatedAt": "2021-06-07T17:36:15Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Dunno if there's a problem. This was meant to be a non-leading question as to whether or not it's fine. :-)\r\n\r\nMy very vague understanding was that formal analyses tended to break down when to you do things like encrypt a key with itself. We're kinda doing that here. So the question is whether this would be a problem.",
              "createdAt": "2021-06-07T17:36:14Z",
              "updatedAt": "2021-06-07T17:36:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3NzA1MDIw",
          "commit": {
            "abbreviatedOid": "5b945bb"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T17:37:52Z",
          "updatedAt": "2021-06-07T17:37:53Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Ah, okay, I see. I sent Hugo a message out of band to get confirmation on the best outcome here. I'll follow up when I hear back. :-)",
              "createdAt": "2021-06-07T17:37:53Z",
              "updatedAt": "2021-06-07T17:37:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3NzM4NTU1",
          "commit": {
            "abbreviatedOid": "178938e"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T18:12:23Z",
          "updatedAt": "2021-06-07T18:12:23Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "> My very vague understanding was that formal analyses tended to break down when to you do things like encrypt a key with itself. We're kinda doing that here. So the question is whether this would be a problem.\r\n\r\nThis is a problem for symmetric encryption, but what we're doing here is different enough that I don't think we can draw any conclusions from that. Though looking at Definition 7 in [the HKDF paper](https://eprint.iacr.org/2010/264), it doesn't seem like this has been explicitly considered. My hunch is that this definition can be extended in a way that let's the info string incorporate the IKM, and that the current proof could be modified to handle this.\r\n\r\n",
              "createdAt": "2021-06-07T18:12:23Z",
              "updatedAt": "2021-06-07T18:12:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3OTE3OTQ4",
          "commit": {
            "abbreviatedOid": "178938e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T21:50:30Z",
          "updatedAt": "2021-06-07T21:50:30Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Confirmed with Hugo that this change is not needed if we model the hash function as a RO. If we don't want to do that, and instead want to rely on a PRF assumption, then we'd need to take this suggestion. The existing TLS [security proofs already rely on RO liberally](https://link.springer.com/article/10.1007/s00145-021-09388-x), so I think we can safely assume RO here. But I won't block this, either, if folks would be more comfortable with a weaker assumption at the cost of another chain of hashes.",
              "createdAt": "2021-06-07T21:50:30Z",
              "updatedAt": "2021-06-07T22:22:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3OTIwMjkx",
          "commit": {
            "abbreviatedOid": "178938e"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T21:54:38Z",
          "updatedAt": "2021-06-07T21:54:38Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "The analysis here is in the standard model (no random oracles): https://eprint.iacr.org/2020/1044.pdf",
              "createdAt": "2021-06-07T21:54:38Z",
              "updatedAt": "2021-06-07T21:54:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3OTIyNTE1",
          "commit": {
            "abbreviatedOid": "178938e"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T21:58:20Z",
          "updatedAt": "2021-06-07T21:58:20Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "My vote would be to do the conservative thing here.",
              "createdAt": "2021-06-07T21:58:20Z",
              "updatedAt": "2021-06-07T21:58:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3OTUzNTU2",
          "commit": {
            "abbreviatedOid": "178938e"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T23:02:00Z",
          "updatedAt": "2021-06-07T23:02:00Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I know nothing about this and will defer to you all.",
              "createdAt": "2021-06-07T23:02:00Z",
              "updatedAt": "2021-06-07T23:02:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3OTczMDE4",
          "commit": {
            "abbreviatedOid": "178938e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T23:49:23Z",
          "updatedAt": "2021-06-07T23:49:23Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "It occurred to me that [QUIC _does_ Extract before calling Expand](https://www.rfc-editor.org/rfc/rfc9001.html#name-initial-secrets) in a similar way, so, if for no other reason than consistency, I'd be OK with this change. We might even consider doing something similar with a per-version salt. ",
              "createdAt": "2021-06-07T23:49:23Z",
              "updatedAt": "2021-06-07T23:49:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc4NzY4Mzk5",
          "commit": {
            "abbreviatedOid": "178938e"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-08T16:55:15Z",
          "updatedAt": "2021-06-08T16:55:15Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "The signal is already bound to the ECH version via the codepoint, though I suppose we may end up choosing the codepoint in a different way eventually. I'd be OK with that change.",
              "createdAt": "2021-06-08T16:55:15Z",
              "updatedAt": "2021-06-08T16:55:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMjQ5Mjkw",
          "commit": {
            "abbreviatedOid": "90d26a1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-11T22:23:12Z",
          "updatedAt": "2021-06-11T22:23:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 452,
      "id": "MDExOlB1bGxSZXF1ZXN0NjY1MzQwOTI5",
      "title": "Document the other ech_outer_extensions DoS vector.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/452",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I forgot we still had this open. Closes #378.",
      "createdAt": "2021-06-08T21:30:19Z",
      "updatedAt": "2021-06-12T03:46:14Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f08b6cf4ab8378723f7b4ab36a1d68e29b1227a0",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "dos-duplicate-outer",
      "headRefOid": "c0352662c944b9ecb304f2ab1a2d7610ddd08636",
      "closedAt": "2021-06-12T03:46:14Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "From the discussion in https://github.com/tlswg/draft-ietf-tls-esni/pull/455 so far, it sounds like folks think that version is preferable. (I also prefer it over this.)",
          "createdAt": "2021-06-11T21:37:36Z",
          "updatedAt": "2021-06-11T21:37:54Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@davidben shall we close this out, then?",
          "createdAt": "2021-06-11T22:26:49Z",
          "updatedAt": "2021-06-11T22:26:49Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Sure.",
          "createdAt": "2021-06-12T03:46:14Z",
          "updatedAt": "2021-06-12T03:46:14Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc5MDgzMzMw",
          "commit": {
            "abbreviatedOid": "aea371d"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-08T23:17:47Z",
          "updatedAt": "2021-06-08T23:18:41Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "```suggestion\r\n  M is the number of extensions in ClientHelloOuter and N is the\r\n```",
              "createdAt": "2021-06-08T23:17:47Z",
              "updatedAt": "2021-06-08T23:18:41Z"
            },
            {
              "originalPosition": 47,
              "body": "Isn't the best way to avoid this to disallow backtracking?",
              "createdAt": "2021-06-08T23:18:36Z",
              "updatedAt": "2021-06-08T23:24:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc5MDg1MDMx",
          "commit": {
            "abbreviatedOid": "c035266"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-08T23:21:48Z",
          "updatedAt": "2021-06-08T23:21:48Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Sadly, there's currently no requirement that ech_outer_extensions and ClientHelloOuter extensions match in order. Though that would certainly simplify both mitigations!",
              "createdAt": "2021-06-08T23:21:48Z",
              "updatedAt": "2021-06-08T23:21:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc5MjA3ODYw",
          "commit": {
            "abbreviatedOid": "c035266"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-09T04:56:47Z",
          "updatedAt": "2021-06-09T04:56:48Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "As an alternate to this PR, I put together https://github.com/tlswg/draft-ietf-tls-esni/pull/455 which implements this suggestion. Thoughts? At the risk of yet another protocol change in draft-11, I'm starting to lean towards that option.",
              "createdAt": "2021-06-09T04:56:47Z",
              "updatedAt": "2021-06-09T04:56:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMjMwNTA5",
          "commit": {
            "abbreviatedOid": "c035266"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-11T21:35:50Z",
          "updatedAt": "2021-06-11T21:35:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 455,
      "id": "MDExOlB1bGxSZXF1ZXN0NjY1NTQ0MDIx",
      "title": "Require compressed extensions appear in the same relative order.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/455",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #378. This is an alternative to #452, which constrains the client such this suggestion is feasible:\r\nhttps://github.com/tlswg/draft-ietf-tls-esni/pull/452#discussion_r647858091\r\n\r\n@martinthomson, thoughts? This does constrain the client behavior, though our draft implementation would not be affected by it. (We run through all the extensions in our usual order and compute the inner value + whether to compress it. If we intend to compress it, we write it to a separate buffer instead of the pending ClientHelloInner. Then we drop in all the buffered extensions, so they're contiguous and, in the EncodedClientHelloInner, write ech_outer_extensions instead of the buffer. This process keeps the relative order of compressed extensions, so we follow this rule anyway.)",
      "createdAt": "2021-06-09T04:55:25Z",
      "updatedAt": "2021-06-14T21:01:31Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1ca01023a5dacf897b0a5c3faf1fecd356bf4cdf",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "dos-alternate",
      "headRefOid": "fc8602cc94a386d7b03285061f3b07b9e7380ba8",
      "closedAt": "2021-06-14T21:01:31Z",
      "mergedAt": "2021-06-14T21:01:31Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "d0f238bb07b7317d406a3ef469997f5d3f20b481"
      },
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 09/06/2021 07:38, Martin Thomson wrote:\n> I'm not going to nitpick this, but I like it.\n\nSame here (wrt liking:-).\n\nCheers,\nS.\n",
          "createdAt": "2021-06-09T11:21:10Z",
          "updatedAt": "2021-06-09T11:21:10Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> My only concern with this is that it is somewhat more prescriptive than I would generally like for a specification. Moving this algorithmic stuff to an appendix might be a good balance. Either way, if you are adding this much text, it needs a section heading.\r\n\r\nMoved to appendix.",
          "createdAt": "2021-06-09T14:47:17Z",
          "updatedAt": "2021-06-09T14:47:17Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@davidben can you please rebase?",
          "createdAt": "2021-06-11T22:27:09Z",
          "updatedAt": "2021-06-11T22:27:09Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased",
          "createdAt": "2021-06-12T03:47:30Z",
          "updatedAt": "2021-06-12T03:47:30Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc5MjYwNDE4",
          "commit": {
            "abbreviatedOid": "8ead80d"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I'm not going to nitpick this, but I like it.\r\n\r\nWe currently have the same triply-nested loop here:\r\n* the outer loop iterates over extensions in CHInner\r\n* for most extensions we just copy them into a new structure\r\n* for ech_outer we have two more layers of loop\r\n* the middle loop iterates over the items in ech_outer\r\n* the inner loop iterates over CHOuter, looking for a match\r\n\r\nThis wouldn't really reduce code complexity, but it would mean that we wouldn't need to start over every time for that innermost loop.  So we would be able to run in linear time as this says.\r\n\r\nLike you, as we iterate over extensions in the same order when constructing messages, this wouldn't have any effect on generating a ClientHello.\r\n\r\nMy only concern with this is that it is somewhat more prescriptive than I would generally like for a specification.  Moving this algorithmic stuff to an appendix might be a good balance.  Either way, if you are adding this much text, it needs a section heading.",
          "createdAt": "2021-06-09T06:37:47Z",
          "updatedAt": "2021-06-09T06:38:30Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "One nitpick: \"`i`th\" renders really badly in text.  Consider just avoiding the backticks.",
              "createdAt": "2021-06-09T06:37:47Z",
              "updatedAt": "2021-06-09T06:38:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc5NzU4Mzc1",
          "commit": {
            "abbreviatedOid": "1ea3945"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-09T14:47:02Z",
          "updatedAt": "2021-06-09T14:47:02Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "Done, and replaced with capital letters to match padding computation and keep the variables standing out.",
              "createdAt": "2021-06-09T14:47:02Z",
              "updatedAt": "2021-06-09T14:47:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMjcwMTI5",
          "commit": {
            "abbreviatedOid": "1ea3945"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Works for me!",
          "createdAt": "2021-06-11T23:40:12Z",
          "updatedAt": "2021-06-11T23:40:12Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzMjg3MDM5",
          "commit": {
            "abbreviatedOid": "d0356bc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM pending suggestions!",
          "createdAt": "2021-06-14T19:40:05Z",
          "updatedAt": "2021-06-14T19:54:18Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nno requirement that they be continguous. For example, OuterExtensions may\r\n```",
              "createdAt": "2021-06-14T19:40:05Z",
              "updatedAt": "2021-06-14T19:54:18Z"
            },
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nClientHelloInner. It can only be included in EncodedClientHelloInner, and MUST\r\nNOT be sent in either ClientHelloOuter or ClientHelloInner.\r\n```",
              "createdAt": "2021-06-14T19:42:44Z",
              "updatedAt": "2021-06-14T19:54:18Z"
            },
            {
              "originalPosition": 13,
              "body": "I was really confused by this at first, so hopefully this helps clarify for others.",
              "createdAt": "2021-06-14T19:44:18Z",
              "updatedAt": "2021-06-14T19:54:18Z"
            },
            {
              "originalPosition": 85,
              "body": "```suggestion\r\n   * While I is less than N and the I-th extension of\r\n```",
              "createdAt": "2021-06-14T19:52:58Z",
              "updatedAt": "2021-06-14T19:54:18Z"
            },
            {
              "originalPosition": 91,
              "body": "```suggestion\r\n   * Otherwise, the I-th extension of ClientHelloOuter has type E. Copy\r\n```",
              "createdAt": "2021-06-14T19:53:16Z",
              "updatedAt": "2021-06-14T19:54:18Z"
            },
            {
              "originalPosition": 96,
              "body": "```suggestion\r\n```\r\nThis seems really language and library specific, so I might just drop it.",
              "createdAt": "2021-06-14T19:53:49Z",
              "updatedAt": "2021-06-14T19:54:18Z"
            }
          ]
        }
      ]
    },
    {
      "number": 456,
      "id": "MDExOlB1bGxSZXF1ZXN0NjY4NDU4MDky",
      "title": "Require that someone validate public_name correctly.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/456",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This combines #436 and #447, requiring that validation of public_name happen _somewhere_, providing a reference parser (if one does not exist), and allowing it to happen when parsing ECHConfig.\r\n\r\nCloses #396, #405, #424\r\n\r\ncc @martinthomson, @davidben, @cjpatton, @sftcd",
      "createdAt": "2021-06-11T18:54:31Z",
      "updatedAt": "2021-06-14T21:01:49Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "68c4af7ec43fa834036587fcf5183bc7578495a1",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/public-name-validate",
      "headRefOid": "a35e46e0388038315f3ee8e93fadb00eb41f9828",
      "closedAt": "2021-06-14T21:01:49Z",
      "mergedAt": "2021-06-14T21:01:49Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "6abbf81e48b1bc1f05b01782f7d4c5364e6be9e0"
      },
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 14/06/2021 20:26, Christopher Wood wrote:\n> @chris-wood commented on this pull request.\n> \n> \n> \n>> +: This value MUST NOT begin or end with an ASCII dot and MUST be parsable as a\n> +dot-separated sequence of LDH labels, as defined in\n> +{{!RFC5890, Section 2.3.1}}. Clients MUST ignore any `ECHConfig` structure\n> +whose public_name does not meet these criteria.\n> +\n> \n> The public_name field is already limited to 255 characters, so I think we're fine.\n\nThe max for a label in a DNS name is 63 octets though isn't\nit?\n\n> \n",
          "createdAt": "2021-06-14T19:28:06Z",
          "updatedAt": "2021-06-14T19:28:06Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> The max for a label in a DNS name is 63 octets though isn't it?\r\n\r\nYeah, but RFC6066 has no similar requirements (that I can tell), so I don't see we need to impose anything new here. Maybe I'm missing something? And if so, can you please propose text?",
          "createdAt": "2021-06-14T19:33:33Z",
          "updatedAt": "2021-06-14T19:33:33Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 14/06/2021 20:33, Christopher Wood wrote:\n>> The max for a label in a DNS name is 63 octets though isn't it?\n> \n> Yeah, but RFC6066 has no similar requirements (that I can tell), so I\n> don't see we need to impose anything new here. Maybe I'm missing \n> something? And if so, can you please propose text?\n\nFair ask:-)\n\nI guess the public_name mostly has to go in a cert SAN so\nwould it help to use or refer to rfc5280 text?\n\nThe most relevant bit there seems to be:\n\n    When the subjectAltName extension contains a domain name\n    system label, the domain name MUST be stored in the\n    dNSName (an IA5String). The name MUST be in the \"preferred\n    name syntax\", as specified by Section 3.5 of [RFC1034] and\n    as modified by Section 2.1 of [RFC1123].  Note that while\n    uppercase and lowercase letters are allowed in domain\n    names, no significance is attached to the case.  In\n    addition, while the string \" \" is a legal domain name,\n    subjectAltName extensions with a dNSName of \" \" MUST NOT\n    be used.\n\n(That text is near [1]).\n\nThat said, that \" \" is a legal domain name surprises me (and\nI'm a co-author of 5280!)\n\nBTW, I'm fine that that all gets fixed later if that's\nbetter.\n\nS.\n\n[1] https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.6\n\n\n",
          "createdAt": "2021-06-14T19:47:28Z",
          "updatedAt": "2021-06-14T19:47:28Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> BTW, I'm fine that that all gets fixed later if that's better.\r\n\r\nSounds good -- I dropped an OPEN ISSUE to note this for later. @sftcd, would you have cycles to take that issue and propose a PR to address it?",
          "createdAt": "2021-06-14T19:52:16Z",
          "updatedAt": "2021-06-14T19:52:16Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 14/06/2021 20:52, Christopher Wood wrote:\n>> BTW, I'm fine that that all gets fixed later if that's better.\n> \n> Sounds good -- I dropped an OPEN ISSUE to note this for later.\n> @sftcd, would you have cycles to take that issue and propose a PR to\n> address it?\n\nSneaky eh:-)\n\nSure, I can look at it this week but don't wait on me.\n\nS\n\n> \n",
          "createdAt": "2021-06-14T19:58:04Z",
          "updatedAt": "2021-06-14T19:58:04Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Sure, I can look at it this week but don't wait on me.\r\n\r\nYeah, there's no rush here, I think. This seems like a smaller issue to resolve at some point.",
          "createdAt": "2021-06-14T20:04:00Z",
          "updatedAt": "2021-06-14T20:04:00Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMTQ4Mzk5",
          "commit": {
            "abbreviatedOid": "6599d49"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-11T19:15:16Z",
          "updatedAt": "2021-06-11T19:15:16Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMjI5NzYy",
          "commit": {
            "abbreviatedOid": "6599d49"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-11T21:34:02Z",
          "updatedAt": "2021-06-11T21:34:02Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMzIxMDg0",
          "commit": {
            "abbreviatedOid": "6599d49"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-12T12:09:23Z",
          "updatedAt": "2021-06-12T12:10:45Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Try splitting this up a little.  You can start multiple sections with \": \" to make separate paragraphs (I think).",
              "createdAt": "2021-06-12T12:09:23Z",
              "updatedAt": "2021-06-12T12:10:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMzIzMDY5",
          "commit": {
            "abbreviatedOid": "89a4e28"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-12T12:44:47Z",
          "updatedAt": "2021-06-12T12:44:47Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Oh, nice. I didn't know that was possible. I broke up the description into logical units.",
              "createdAt": "2021-06-12T12:44:47Z",
              "updatedAt": "2021-06-12T12:44:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyNDE2ODY5",
          "commit": {
            "abbreviatedOid": "89a4e28"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-06-13T14:29:17Z",
          "updatedAt": "2021-06-13T14:37:44Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Let's separate out the conformance requirements and the check. I think you want to say \"This value MUST be a valid domain name in accordance with XXX\".  I believe that would still allow trailing (but not leading) dot, so you may also have to say \"The value MUST NOT end with an ASCII dot\".\r\n\r\n\r\n\r\n\r\n\r\n",
              "createdAt": "2021-06-13T14:29:17Z",
              "updatedAt": "2021-06-13T14:37:44Z"
            },
            {
              "originalPosition": 38,
              "body": "```suggestion\r\n: Clients MUST ignore any `ECHConfig` structure\r\nwhose public_name does is not parsable as a\r\ndot-separated sequence of LDH labels, as defined in\r\n{{!RFC5890, Section 2.3.1}} or which\r\nbegins or end with an ASCII dot.\r\n```",
              "createdAt": "2021-06-13T14:36:31Z",
              "updatedAt": "2021-06-13T14:37:44Z"
            },
            {
              "originalPosition": 44,
              "body": "```suggestion\r\n:  Clients SHOULD ignore the\r\n`ECHConfig` if it contains an encoded IPv4 address. To determine if a\r\npublic_name value is an IPv4 address, clients can invoke the IPv4 parser\r\nalgorithm in {{WHATWG-IPV4}}. It returns a value when the input is an IPv4\r\naddress.\r\n```",
              "createdAt": "2021-06-13T14:36:57Z",
              "updatedAt": "2021-06-13T14:37:44Z"
            },
            {
              "originalPosition": 38,
              "body": "Note that I think this still allows for bogus names, like ones that are super-long. Do we want to allow clients to check for that?\r\n\r\n",
              "createdAt": "2021-06-13T14:37:23Z",
              "updatedAt": "2021-06-13T14:37:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzMjc2MjY4",
          "commit": {
            "abbreviatedOid": "89a4e28"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T19:26:28Z",
          "updatedAt": "2021-06-14T19:26:28Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "The public_name field is already limited to 255 characters, so I think we're fine.",
              "createdAt": "2021-06-14T19:26:28Z",
              "updatedAt": "2021-06-14T19:26:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzMjg0OTU3",
          "commit": {
            "abbreviatedOid": "cd87b16"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T19:37:31Z",
          "updatedAt": "2021-06-14T19:37:32Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Good call -- I believe your suggestions rephrased things to make the requirements and check read easier.",
              "createdAt": "2021-06-14T19:37:32Z",
              "updatedAt": "2021-06-14T19:37:32Z"
            }
          ]
        }
      ]
    },
    {
      "number": 457,
      "id": "MDExOlB1bGxSZXF1ZXN0NjY4NTc4MTE2",
      "title": "Define the Padding message",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/457",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #264. (Alternative to #313.)",
      "createdAt": "2021-06-11T21:32:36Z",
      "updatedAt": "2023-11-06T08:51:46Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "29b11353f3de0b21134eb820e537e30c466a7e69",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "padding_message",
      "headRefOid": "dbfdbbf8ca09bb0563b57f1893da904a8c8e76b8",
      "closedAt": "2023-11-06T08:51:45Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\nHiya,\n\nI'm not sure this is needed, nor whether this draft would\nbe the right place for it, if it is needed.\n\nImplementations already support padding certs and cert verify\n(well, I assume so, OpenSSL does anyway), so I'm unsure a new\ngeneric message is a sufficient improvement to justify the\nwork.\n\nSecondly, this isn't really (only) related to ECH so if it\nturns out to be a good idea, it might deserve it's own spec.\nWe seem to be discovering new issues related to padding\nvia ECH, so might discover yet more if e.g. padding and\nimproved resistance to traffic analysis had it's own draft.\n\nCheers,\nS.\n",
          "createdAt": "2021-06-11T21:43:03Z",
          "updatedAt": "2021-06-11T21:43:03Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "The reason to switch from the existing record-layer padding is covered in #264. There was also an email to the list in https://mailarchive.ietf.org/arch/msg/tls/tEbTOI7fz2KnHFEolSs7yAtl2AY/ and I believe it was discussed at some meeting. @chris-wood would remember the details better, but I believe we had consensus on *some* form of padding in the handshake? Just actually working it out was queued behind the various other issues to be solved.\r\n\r\nAs for something in ECH or more generic, it's true that padding may be relevant in other contexts, but the way the protocol works, we cannot introduce new mechanisms without some way to negotiate them. That would break compatibility. This can be smoothed over at some future TLS 1.4, where we can bake in the tweaks we want, but for now we need a way to signal it.\r\n\r\nWe can always choose to signal it with some completely separate code point later (`if ech || new_thing || tls14 { DoPaddingThing() }`). But while the use case is ECH, I think it is simplest to signal it based on ECH itself. Otherwise, implementations will need to pick up more complexity (#401) to handle what happens if the peer negotiates ECH without padding.",
          "createdAt": "2021-06-11T22:00:35Z",
          "updatedAt": "2021-06-11T22:01:38Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 11/06/2021 23:00, David Benjamin wrote:\n> The reason to switch from the existing record-layer padding is\n> covered in #264. There was also an email to the list in\n> https://mailarchive.ietf.org/arch/msg/tls/tEbTOI7fz2KnHFEolSs7yAtl2AY/\n\nI guess QUIC may be a valid justification.\n\n> and I believe it was discussed at some meeting. @chris-wood would\n> remember the details better, but I believe we had consensus on *some*\n> form of padding in the handshake? Just actually working it out was\n> queued behind the various other issues to be solved.\n> \n> As for something in ECH or more generic, it's true that padding may\n> be relevant in other contexts, but the way the protocols, we cannot\n> introduce new mechanisms without some way to negotiate them.\n\nI don't think that's really an issue here. I've been padding\nthe cert & cert-verify with the existing padding mechanism\nand I don't think that causes any problems.\n\nPartly, I'm worried that adding a new thing like this might\nadd more delay to what's already taking a very long time. And\nyet we seem to only be ending up with slightly better in\nterms of not sticking out and not leaking via lengths (e.g.\nthe length of the ServerHello key share can leak a little).\n\nIs that really worth the delay or would we be better to get\nthis out the door sooner and gain from more real experience?\n(I guess you can easily guess my personal bias on that:-)\n\nS\n\n> That\n> would break compatibility. This can be smoothed over at some future\n> TLS 1.4, where we can bake in the tweak we want, but for now we need\n> a way to signal it.\n> \n> We can always choose to signal it with some completely separate code\n> point later (`if ech || new_thing || tls14 { DoPaddingThing() }`).\n> But while the use case is ECH, I think it is simplest to signal it\n> based on ECH itself. Otherwise, implementations will need to pick up\n> more complexity (#401) to handle what happens if the peer negotiates\n> ECH without this padding scheme.\n> \n",
          "createdAt": "2021-06-11T22:18:30Z",
          "updatedAt": "2021-06-11T22:18:30Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@sftct, a big reason for filing this PR is that this is an alternative to #313 that we've been kicking around for a while, and I wanted to get it down on paper so that we can have something concrete to discuss. What's clear is that to solve #264 without rewriting a bunch of code, we need a way of adding padding via the handshake. Both this PR and #313 do this; this PR is intended to solve some problems with #313. ",
          "createdAt": "2021-06-11T22:30:52Z",
          "updatedAt": "2021-06-11T22:30:52Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 11/06/2021 23:31, Christopher Patton wrote:\n> @sftct, a big reason for filing this PR is that this is an\n> alternative to #313 that we've been kicking around for a while, and I\n> wanted to get it down on paper so that we can have something concrete\n> to discuss. What's clear is that to solve #264 without rewriting a\n> bunch of code, we need a way of adding padding via the handshake.\n> Both this PR and #313 do this; this PR is intended to solve some\n> problems with #313.\n\nI'll have to check those issues tomorrow sorry but just to\nnote that using the existing padding with an OpenSSL server\nvery simple - one callback that sets lengths was all it\nneeded for s_server [1] and it'd be the same for any server.\n\nI'd like to understand how this proposal is really better,\nas I'm fairly sure adding a new message will require mucking\nabout with the state machine which is harder and much much\nmore error prone and harder to test properly.\n\nTa,\nS.\n\n[1] \nhttps://github.com/sftcd/openssl/blob/ECH_UPFRONT_DEC/apps/s_server.c#L100\n\n",
          "createdAt": "2021-06-11T22:38:41Z",
          "updatedAt": "2021-06-11T22:38:41Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@cjpatton can you please rebase? (Sorry for the conflicts!)",
          "createdAt": "2021-06-15T15:19:30Z",
          "updatedAt": "2021-06-15T15:19:30Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Rebased (still need to address the design comments).",
          "createdAt": "2021-06-15T15:52:24Z",
          "updatedAt": "2021-06-15T15:52:24Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Some reorganization is probably in order.\r\n\r\nYeah it's awkward :grimacing: I was trying to avoid refactoring too much with this PR. What do you think about moving all of the padding bits into a single section? Something like:\r\n```\r\n# Handshake Padding\r\n\r\n## ClientHelloInner Padding\r\n\r\n[@davidben's scheme in #443].\r\n\r\n## Padding the Rest of the Handshake\r\n\r\n[Defines the Padding message and how it's used.]\r\n\r\n## Recommended Padding Schemes\r\n\r\n### Client\r\n\r\n[Recommend a way to compute the padding length for EncodedClientHelloInner and the client's Padding message]\r\n\r\n### Backend Server\r\n\r\n[Recommend a way to compute the padding length for the server's Padding message]\r\n```\r\n\r\n",
          "createdAt": "2021-06-18T00:52:21Z",
          "updatedAt": "2021-06-18T00:52:21Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That would certainly be better.  I would put that down the document, with forward references from the other sections.",
          "createdAt": "2021-06-18T01:08:45Z",
          "updatedAt": "2021-06-18T01:08:45Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Squashed. (@martinthomson, I'm gonna wait on editorial changes until #443 lands.)",
          "createdAt": "2021-06-22T20:35:11Z",
          "updatedAt": "2021-06-22T20:35:11Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Rebased.",
          "createdAt": "2021-06-30T21:37:06Z",
          "updatedAt": "2021-06-30T21:37:06Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "While it seems to me that none of the options are ideal, I'm not that enthusiastic about a new message here.\r\n\r\nI appreciate that putting the padding at the record layer adds some API complexity, but it seems modest. I note that that would also match the layering of having the ClientHelloInner padding existing outside the handshake message.\r\n\r\nNote that if it turns out that this is impractical, we can always add a padding message later with a new extension.\r\n",
          "createdAt": "2021-07-02T22:33:26Z",
          "updatedAt": "2021-07-02T22:33:26Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry about the close. Pushed the wrong button.",
          "createdAt": "2021-07-02T22:33:41Z",
          "updatedAt": "2021-07-02T22:33:41Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 02/07/2021 23:33, ekr wrote:\n> While it seems to me that none of the options are ideal, I'm not that\n> enthusiastic about a new message here.\n> \n> I appreciate that putting the padding at the record layer adds some\n> API complexity, but it seems modest. I note that that would also\n> match the layering of having the ClientHelloInner padding existing\n> outside the handshake message.\n> \n> Note that if it turns out that this is impractical, we can always add\n> a padding message later with a new extension.\n\n+1, I think I could live with the new message but still\nconsider it more work than worthwhile at this point.\n\nS.\n\n> \n> \n",
          "createdAt": "2021-07-02T23:49:08Z",
          "updatedAt": "2021-07-02T23:49:08Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ekr, @sftcd, see #264 for why record layer pasdding is impractical. An alternative to the padding message is #313, which moves the padding to an extension in EncryptedExtensions.",
          "createdAt": "2021-07-06T17:34:18Z",
          "updatedAt": "2021-07-06T17:34:18Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I've read #264. I don't think it's persuasive for the reasons I mentioned above.",
          "createdAt": "2021-07-06T18:11:59Z",
          "updatedAt": "2021-07-06T18:11:59Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 to @ekr's suggestion to move this to a separate draft. We don't need to block on it since we have record-layer padding, and we can always add it later. ",
          "createdAt": "2021-07-06T18:31:01Z",
          "updatedAt": "2021-07-06T18:31:01Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "A separate draft means that QUIC implementations of ECH need to handle cases where the client does and doesn't support this padding mechanism. That means a QUIC ECH deployment cannot rely on the preferred padding mechanism.\r\n\r\nThe record-level padding is more than just an API issue. QUIC's record layer is not a reliable transport. In order to properly hide lengths, you would need to handle retransmits as if the message were longer. That means padding needs to be integrated with retransmission logic, yet it is not sequenced like CRYPTO frames are. This gets extra fun if TLS believes it wants padding greater than a packet. (Consider, especially, whether an attacker can probe this length by manipulating which packets you see. The receiver doesn't know to block on an all-padding packet.) In contrast, something like this PR is embedded into the byte stream and we get the correct behavior for free.\r\n\r\nThe API issue has also only gotten worse over time, now that QUIC has been standardized and implementations treat their APIs as more and more stable. Indeed all this started because I went to get the needed support into QUIC APIs and implementation ahead of time. The overwhelming feedback I got from the QUIC side was that this was unreasonable, and the TLS WG agreed (https://github.com/tlswg/draft-ietf-tls-esni/issues/264#issuecomment-686645194). As noted in #264, HTTP/3 does something similar, and introduces a [reliable padding scheme](https://quicwg.org/base-drafts/draft-ietf-quic-http.html#name-padding-and-traffic-analysi), separate from the transport's unreliable one.\r\n\r\n> I note that that would also match the layering of having the ClientHelloInner padding existing outside the handshake message.\r\n\r\nNot all places outside the handshake message are equal. The EncodedClientHelloInner padding doesn't have any of the above issues because its bytes are ordered. It also doesn't cross a protocol boundary. Indeed, this PR also meets this analogy by being outside the messages that we are trying to pad. That analogy mostly disqualifies sticking the padding into EncryptedExtensions, since that's deeply tied with the rest of message generation.\r\n\r\nIt *is* inside the transcript, but @martinthomson reported that'd be easier for NSS. An earlier incarnation of the Padding message idea was perhaps even closer to this analogy by mirroring ChangeCipherSpec: receiver ignores it and never passes it up to the handshake, but it's still sequenced with the other messages. (And, given how DTLS integrates retransmission and handshake state machine, integrating it into the handshake is probably indeed easier to reason about. Though I think sequence numbers are probably sufficient? DTLS, like QUIC, would need to integrate padding with retransmission.)\r\n\r\nIt also matches what we'd likely do in QUIC, had we decided earlier to outsource this kind of padding. To integrate it into the CRYPTO stream, we'd probably divide the CRYPTO stream into _ordered_ data and padding chunks. Well, the stream is already divided into chunks (messages), so the natural answer is to use that layer. That's a Padding message.",
          "createdAt": "2021-07-08T14:44:28Z",
          "updatedAt": "2021-07-08T14:47:10Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing per decision at IETF 118 to close the issue.",
          "createdAt": "2023-11-06T08:51:45Z",
          "updatedAt": "2023-11-06T08:51:45Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMjMwNzg3",
          "commit": {
            "abbreviatedOid": "15d5c2e"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T21:36:28Z",
          "updatedAt": "2021-06-11T21:36:29Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Let's not have optional messages. They complicate the handshake state machine and are a source of security bugs.\r\n\r\nInstead, define when the message is sent (probably in ClientHelloInner handshakes where the server sends an confirmation signal). We need to do anyway because messages only work as an extension when point solicited. I.e. you need a signal from the peer that they're allowed before you send them. Once we've done that, there's no need for optionality and we can include it unconditionally.",
              "createdAt": "2021-06-11T21:36:29Z",
              "updatedAt": "2021-06-11T21:36:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMjQ5NzY5",
          "commit": {
            "abbreviatedOid": "15d5c2e"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T22:24:39Z",
          "updatedAt": "2021-06-11T22:24:39Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Just so I understand this correctly: The client sends an empty extension, which the server may reply to with the Padding message. Is that right? Do we also want to allow the server to solicit the Padding message? E.g., if it sends the extension in EE, then the client may reply with a Padding message?",
              "createdAt": "2021-06-11T22:24:39Z",
              "updatedAt": "2021-06-11T22:24:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMjUwNTc2",
          "commit": {
            "abbreviatedOid": "15d5c2e"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-11T22:27:12Z",
          "updatedAt": "2021-06-11T22:27:12Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "(Good catch, btw. Not sure how I missed this!)",
              "createdAt": "2021-06-11T22:27:12Z",
              "updatedAt": "2021-06-11T22:27:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzMjcwNjQ5",
          "commit": {
            "abbreviatedOid": "b01c887"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T19:19:11Z",
          "updatedAt": "2021-06-14T19:19:11Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "That works mechanically, but I think it's not the right design. It still involves an optional message, which complicates the receiver's state machine. It also means servers must account for clients that offer ECH without this new extension.\r\n\r\nRather, we can say:\r\n\r\n* If the client sends \"encrypted_client_hello\" with type \"inner\" AND the server sends the ECH confirmation signal, the connection has the \"ECH confirmed\" bit.\r\n* Both client and server will agree on this bit and, if set, we know both clients and servers are new enough to know about ECH. That clears the compatibility bar for tweaking the handshake.\r\n* If the connection has the \"ECH confirmed\" bit, the client and server MUST send and consume _exactly_ one Padding message before each Finished message. Making the message required means the state machine always knows the next message to expect.\r\n* How many bytes go in the Padding message is up to the respective sender. If you don't have anything to pad, just send a zero-length message.\r\n* If we decide we need in-handshake padding for another feature, we can always add some OR clauses to the second condition, if they meet the usual compatibility requirements.\r\n\r\n@martinthomson, I think this was also the construction you preferred?",
              "createdAt": "2021-06-14T19:19:11Z",
              "updatedAt": "2021-06-14T19:20:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzNDUzNzQ5",
          "commit": {
            "abbreviatedOid": "b01c887"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T00:12:42Z",
          "updatedAt": "2021-06-15T00:12:42Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "That's pretty much it.\r\n\r\nI also like the option for a message after the handshake.  That doesn't go in the transcript.  @davidben can just hold off on sending client Finished until it is all received, to avoid his fun deadlocks.",
              "createdAt": "2021-06-15T00:12:42Z",
              "updatedAt": "2021-06-15T00:12:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0MTQwMjY3",
          "commit": {
            "abbreviatedOid": "b01c887"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-15T15:09:43Z",
          "updatedAt": "2021-06-15T15:09:43Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "I think this is too clever to the point of demonstrating why post-handshake doesn't work. :-)\r\n\r\nIf the receiver does not block the handshake on it, I can tell whether it was padding by delaying that record and seeing if the connection is stuck. If the receiver does block the handshake on it, TCP concerns no longer apply but it's not \"after the handshake\" anymore.\r\n\r\nMoreover, making it post-handshake means it's after the key change, which gives a record boundary. Record boundaries are public, which means the padding becomes useless. It needs to be at handshake encryption level and buffered up and flushed to the record layer with the rest of the handshake flight. (But you may still have a padding-only record if you have more padding than your max record size. That's fine, the only requirement is that record boundaries are calculated independently of the padding/message boundary.)\r\n\r\nPost-Finished doesn't even keep it out of the transcript because the transcript is {..., ServerCertificate, ServerCertificateVerify, ServerFinished, ClientCertificate*, ClientCertificateVerify*, ClientFinished}. Any server message sent after ServerFinished but before reading ClientCertificate will naturally sandwich in there, unless we special case the message... at which point, why are we considering the transcript when positioning it?\r\n\r\nIf we want it to be post-Finished but pre-key-change and handshake-blocking, that's perfectly well-defined, I suppose, but having \"Finished\" not be the message which \"finishes\" the handshake seems weird. :-) We also need it after CertificateVerify due to variable-length ECDSA signatures. Put those together and we've uniquely identified the position: in between CertificateVerify and Finished.",
              "createdAt": "2021-06-15T15:09:43Z",
              "updatedAt": "2021-06-15T15:12:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg2OTA2OTIz",
          "commit": {
            "abbreviatedOid": "d64ff6b"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-17T22:52:05Z",
          "updatedAt": "2021-06-17T22:52:05Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "@martinthomson and @davidben, I've rebased this PR and updated it with David's construction. Please have another look.\r\n",
              "createdAt": "2021-06-17T22:52:05Z",
              "updatedAt": "2021-06-17T22:52:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg2OTI0NjU3",
          "commit": {
            "abbreviatedOid": "d64ff6b"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This structure is weird.  The section on padding talks about both, but only defines half of one of those (without a subsection).  The other padding stuff is somewhere else entirely.\r\n\r\nSome reorganization is probably in order.",
          "createdAt": "2021-06-17T23:34:56Z",
          "updatedAt": "2021-06-17T23:34:56Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOB-yxNc4xbxFk",
          "commit": {
            "abbreviatedOid": "dbfdbbf"
          },
          "author": "klinvill",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-10T21:56:48Z",
          "updatedAt": "2021-12-10T23:53:15Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "Should the \"server_name\" extension also be padded?",
              "createdAt": "2021-12-10T21:56:48Z",
              "updatedAt": "2021-12-10T23:53:15Z"
            },
            {
              "originalPosition": 149,
              "body": "The recommended client padding scheme recommends padding out to a multiple of 32 bytes. Should a similar scheme be employed here for server padding?",
              "createdAt": "2021-12-10T22:10:36Z",
              "updatedAt": "2021-12-10T23:53:15Z"
            },
            {
              "originalPosition": 68,
              "body": "Should this be \"the **number and lengths** of the records are independent...\"? I could imagine a scheme that would pad the records out to the same length, yet could still leak information about the size of the content through the number of records.",
              "createdAt": "2021-12-10T22:59:02Z",
              "updatedAt": "2021-12-10T23:53:15Z"
            },
            {
              "originalPosition": 66,
              "body": "Should the \"must\" here be a \"MUST\"?",
              "createdAt": "2021-12-10T23:01:30Z",
              "updatedAt": "2021-12-10T23:53:15Z"
            },
            {
              "originalPosition": 68,
              "body": "Sending padding as a separate message leaves open the possibility that some implementations could send the padding message in a separate record than the messages that need the padding to ensure indistinguishability. If that record can be reliably distinguished from the previous record (e.g. if an implementation always sends the padding and finished messages in the final handshake record from the server, and they are the only messages in that record), then the padding is no longer effective. \r\n\r\nI believe this scenario is addressed by the above warning about coalescing messages into a sequence of records, but I'm concerned it might be glossed over by implementors, especially if they send the messages one at a time without record-level padding assuming that the padding message is sufficient. Maybe instead it could be specified here that \"implementors MUST coalesce the handshake messages up through and including the padding message into a sequence of records so that the length of the records are identical, with the exception of the last record which can have a shorter length\"? While this is more restrictive, I think it may prevent some implementation errors down the road.",
              "createdAt": "2021-12-10T23:50:39Z",
              "updatedAt": "2021-12-10T23:53:15Z"
            }
          ]
        }
      ]
    },
    {
      "number": 458,
      "id": "MDExOlB1bGxSZXF1ZXN0NjY5NzU5MzEx",
      "title": "Bump codepoint for draft-11",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/458",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "cc/ @chris-wood ",
      "createdAt": "2021-06-14T17:48:47Z",
      "updatedAt": "2021-06-17T21:17:25Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1ca01023a5dacf897b0a5c3faf1fecd356bf4cdf",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "bump-codepoint",
      "headRefOid": "6887d1a7812ba832cfa19504fc5291fc4d0ae0e7",
      "closedAt": "2021-06-14T18:59:57Z",
      "mergedAt": "2021-06-14T18:59:57Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "68c4af7ec43fa834036587fcf5183bc7578495a1"
      },
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\nI don't think we need to also bump ech_outer_extensions\nbut just in case...\n\nS\n\nOn 14/06/2021 18:49, Christopher Patton wrote:\n> cc/ @chris-wood\n> You can view, comment on, or merge this pull request online at:\n> \n>    https://github.com/tlswg/draft-ietf-tls-esni/pull/458\n> \n> -- Commit Summary --\n> \n>    * Bump codepoint for draft-11\n> \n> -- File Changes --\n> \n>      M draft-ietf-tls-esni.md (4)\n> \n> -- Patch Links --\n> \n> https://github.com/tlswg/draft-ietf-tls-esni/pull/458.patch\n> https://github.com/tlswg/draft-ietf-tls-esni/pull/458.diff\n> \n",
          "createdAt": "2021-06-14T19:09:19Z",
          "updatedAt": "2021-06-14T19:09:19Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzMjU1NTYz",
          "commit": {
            "abbreviatedOid": "6887d1a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-14T18:59:53Z",
          "updatedAt": "2021-06-14T18:59:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 459,
      "id": "MDExOlB1bGxSZXF1ZXN0NjY5ODM5NDIw",
      "title": "Add 10-to-11 change log.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/459",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Since Padding is still being discussed, I figured we'd leave related issues out of this version and take this opportunity to mark the completion of most HRR issues.\r\n\r\ncc @davidben, @martinthomson, @cjpatton, @cbartle891, @ekr ",
      "createdAt": "2021-06-14T20:05:52Z",
      "updatedAt": "2021-06-14T21:04:11Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "68c4af7ec43fa834036587fcf5183bc7578495a1",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/changelog",
      "headRefOid": "388624357507519304a3b4b689f37022ce58a290",
      "closedAt": "2021-06-14T21:04:11Z",
      "mergedAt": "2021-06-14T21:04:11Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "d43fba63cc37ca68467ad228f4b405a93b649809"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzMzMxNjI2",
          "commit": {
            "abbreviatedOid": "59cdc93"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I would note which changes are wire breaking, but otherwise looks good.",
          "createdAt": "2021-06-14T20:38:00Z",
          "updatedAt": "2021-06-14T20:38:00Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzMzQ1OTcx",
          "commit": {
            "abbreviatedOid": "59cdc93"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-14T20:56:48Z",
          "updatedAt": "2021-06-14T20:58:57Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Maybe s/Fix/Simplify/? The old version wasn't broken. Just this new one's hopefully simpler.",
              "createdAt": "2021-06-14T20:56:48Z",
              "updatedAt": "2021-06-14T20:58:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzMzUwOTQ0",
          "commit": {
            "abbreviatedOid": "59cdc93"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T21:03:23Z",
          "updatedAt": "2021-06-14T21:03:23Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Yep, that's better!",
              "createdAt": "2021-06-14T21:03:23Z",
              "updatedAt": "2021-06-14T21:03:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzMzUwOTY0",
          "commit": {
            "abbreviatedOid": "59cdc93"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T21:03:25Z",
          "updatedAt": "2021-06-14T21:03:26Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\n- Simplify ClientHelloOuterAAD generation (#438, #442)\r\n```",
              "createdAt": "2021-06-14T21:03:25Z",
              "updatedAt": "2021-06-14T21:03:26Z"
            }
          ]
        }
      ]
    },
    {
      "number": 460,
      "id": "MDExOlB1bGxSZXF1ZXN0NjY5ODgxNzYy",
      "title": "Say that ECH acceptance is signaled at most once",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/460",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-06-14T21:16:55Z",
      "updatedAt": "2021-06-17T21:17:22Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "d43fba63cc37ca68467ad228f4b405a93b649809",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "accept-either-hrr-or-sh",
      "headRefOid": "61a7c6aca6003305e7a47f089137ceea5dc712fe",
      "closedAt": "2021-06-14T21:51:51Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for not doing this; it is easier to do it twice and check it twice than have extra logic for not checking.",
          "createdAt": "2021-06-15T00:15:03Z",
          "updatedAt": "2021-06-15T00:15:03Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzMzY1MTQx",
          "commit": {
            "abbreviatedOid": "61a7c6a"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T21:19:40Z",
          "updatedAt": "2021-06-14T21:19:40Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I suppose either works, but is there a reason we want to do it this way over just having it be confirmed in both? (I figure both reduces the number of variations between HRR and non-HRR SH.)",
              "createdAt": "2021-06-14T21:19:40Z",
              "updatedAt": "2021-06-14T21:19:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzMzY1NDI5",
          "commit": {
            "abbreviatedOid": "61a7c6a"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T21:20:06Z",
          "updatedAt": "2021-06-14T21:20:07Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Though I suppose both means the client needs to check it.",
              "createdAt": "2021-06-14T21:20:06Z",
              "updatedAt": "2021-06-14T21:20:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzMzcyNjI0",
          "commit": {
            "abbreviatedOid": "61a7c6a"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T21:31:01Z",
          "updatedAt": "2021-06-14T21:31:01Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "It seems like confirming in both is easier to implement. The only downside I see is that confirming in both requires a bit more hashing.",
              "createdAt": "2021-06-14T21:31:01Z",
              "updatedAt": "2021-06-14T21:31:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzMzczMjAw",
          "commit": {
            "abbreviatedOid": "61a7c6a"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T21:31:50Z",
          "updatedAt": "2021-06-14T21:31:50Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I'm fine either way, I just think this should be made explicit.",
              "createdAt": "2021-06-14T21:31:50Z",
              "updatedAt": "2021-06-14T21:31:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzMzgwOTk2",
          "commit": {
            "abbreviatedOid": "61a7c6a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-14T21:44:13Z",
          "updatedAt": "2021-06-14T21:44:13Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "It does seems simpler to do both (for client and server), and that has been my assumption here. I'd prefer if we did that.",
              "createdAt": "2021-06-14T21:44:13Z",
              "updatedAt": "2021-06-14T21:44:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 461,
      "id": "MDExOlB1bGxSZXF1ZXN0NjY5ODk5MzE5",
      "title": "Say that acceptance will be confirmed twice in case of HRR",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/461",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-06-14T21:51:18Z",
      "updatedAt": "2021-06-17T21:17:20Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "d43fba63cc37ca68467ad228f4b405a93b649809",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "accept-both-hrr-and-sh",
      "headRefOid": "ada32c0776a05ca270ed34877f87b0b72911d272",
      "closedAt": "2021-06-14T21:51:58Z",
      "mergedAt": "2021-06-14T21:51:58Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ab293857e5c2f25b84670987873c7d19443408a8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgzMzg1MzY5",
          "commit": {
            "abbreviatedOid": "ada32c0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-14T21:51:40Z",
          "updatedAt": "2021-06-14T21:51:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 462,
      "id": "MDExOlB1bGxSZXF1ZXN0NjcyMTAwNDM4",
      "title": "Editorial changes",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/462",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-06-17T02:10:01Z",
      "updatedAt": "2021-06-17T21:17:49Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "ab293857e5c2f25b84670987873c7d19443408a8",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "editorial",
      "headRefOid": "624779fdcad5ad37e740070a3164464f47f5da6f",
      "closedAt": "2021-06-17T03:26:29Z",
      "mergedAt": "2021-06-17T03:26:28Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "d3227bd57daab88a41b13888ec0cc2e88a85841a"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Oops. \ud83e\udd26\u200d\u2642\ufe0f",
          "createdAt": "2021-06-17T03:26:21Z",
          "updatedAt": "2021-06-17T03:26:21Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg1ODMzMDEz",
          "commit": {
            "abbreviatedOid": "624779f"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-17T03:25:30Z",
          "updatedAt": "2021-06-17T03:25:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 464,
      "id": "MDExOlB1bGxSZXF1ZXN0Njc1NzcyNjAx",
      "title": "Make ECHConfig.version match the codepoint",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/464",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "To be included with #463.\r\n\r\nNote that this is a wire-breaking change that should have landed in draft-11, but didn't.",
      "createdAt": "2021-06-22T21:30:40Z",
      "updatedAt": "2021-06-30T21:14:57Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "d3227bd57daab88a41b13888ec0cc2e88a85841a",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "bugfix",
      "headRefOid": "88d4aec5a171f6d0422badae7ee05b8180f9adeb",
      "closedAt": "2021-06-28T15:26:44Z",
      "mergedAt": "2021-06-28T15:26:44Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "8ef924171ddcfe9f3ee97629ab34b5e8a301ad48"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@cjpatton since this will go into the next version of the draft, can we bump everything to the next version here?",
          "createdAt": "2021-06-28T13:51:08Z",
          "updatedAt": "2021-06-28T13:51:08Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Done.",
          "createdAt": "2021-06-28T15:07:06Z",
          "updatedAt": "2021-06-28T15:07:06Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks!",
          "createdAt": "2021-06-28T15:26:41Z",
          "updatedAt": "2021-06-28T15:26:41Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjkwMDIzODMw",
          "commit": {
            "abbreviatedOid": "6115ee6"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-22T21:40:35Z",
          "updatedAt": "2021-06-22T21:40:35Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjkyMjQ0Nzk2",
          "commit": {
            "abbreviatedOid": "6115ee6"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-24T21:34:20Z",
          "updatedAt": "2021-06-24T21:34:20Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk0MDk1Njc4",
          "commit": {
            "abbreviatedOid": "88d4aec"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-28T15:26:36Z",
          "updatedAt": "2021-06-28T15:26:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 465,
      "id": "MDExOlB1bGxSZXF1ZXN0Njc2NTczOTYx",
      "title": "Fix up the backend server HRR text slightly.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/465",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The requirement to check the ClientHello for an inner ClientECH doesn't\r\nmake sense because the entire section is already conditioned by\r\nobserving an inner ClientECH. Also clarify that the client-facing vs.\r\nbackend server dispatch happens at the initial ClientHello. Switching\r\nroles mid-connection will not work very well.",
      "createdAt": "2021-06-23T19:57:17Z",
      "updatedAt": "2021-06-28T18:41:01Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "d3227bd57daab88a41b13888ec0cc2e88a85841a",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "hrr-backend",
      "headRefOid": "aaccc9f59170a34ef27104be47b5468194e45c6c",
      "closedAt": "2021-06-28T18:41:01Z",
      "mergedAt": "2021-06-28T18:41:01Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "9a74f5af39ac5813260cecbe523d6cad88288ba0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjkyMjI4NzM3",
          "commit": {
            "abbreviatedOid": "aaccc9f"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-24T21:09:19Z",
          "updatedAt": "2021-06-24T21:09:19Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjkyMzMyMDgy",
          "commit": {
            "abbreviatedOid": "aaccc9f"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-25T00:27:05Z",
          "updatedAt": "2021-06-25T00:27:06Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Why do we even need to mention this here since it has nothing to do with HRR? It's kind of confusing; it makes me wonder if there's a special accept_confirmation value that's used specifically when the server sent an HRR vs. when it didn't.",
              "createdAt": "2021-06-25T00:27:05Z",
              "updatedAt": "2021-06-25T00:27:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjkzOTg1ODg2",
          "commit": {
            "abbreviatedOid": "aaccc9f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-28T13:54:16Z",
          "updatedAt": "2021-06-28T13:54:16Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "> it makes me wonder if there's a special accept_confirmation value that's used specifically when the server sent an HRR vs. when it didn't.\r\n\r\nIsn't this precisely the case now? There are two separate signals: one for ECH acceptance without HRR, and one for ECH acceptance with HRR. ",
              "createdAt": "2021-06-28T13:54:16Z",
              "updatedAt": "2021-06-28T13:54:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjkzOTg2NzQ5",
          "commit": {
            "abbreviatedOid": "aaccc9f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-28T13:55:00Z",
          "updatedAt": "2021-06-28T13:55:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 467,
      "id": "MDExOlB1bGxSZXF1ZXN0Njc4MTg2ODMw",
      "title": "Don't require OuterExtensions de-duplication",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/467",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "There are two reasons for this. First, the algorithm in Appendix B for\r\ndecoding the EncodedClientHelloInner doesn't actually enforce this.\r\nSecond, aborting on duplicated extensions is slightly stricter than RFC\r\n8446 requires. It states that \"[t]here MUST NOT be more than one\r\nextension of the same type in a given extension block\", but doesn't\r\nspecify what the receiver does in this case.",
      "createdAt": "2021-06-25T21:19:26Z",
      "updatedAt": "2021-06-30T21:15:02Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "d3227bd57daab88a41b13888ec0cc2e88a85841a",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "outer-ext-dont-dedup",
      "headRefOid": "273a020a4ab7e14f19d960664d0295632f10e5bb",
      "closedAt": "2021-06-28T13:50:23Z",
      "mergedAt": "2021-06-28T13:50:23Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "bd557da9a8c9163570745e6c5059b5af3f6cdf18"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjkzOTgxMjc2",
          "commit": {
            "abbreviatedOid": "273a020"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-28T13:50:18Z",
          "updatedAt": "2021-06-28T13:50:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 468,
      "id": "MDExOlB1bGxSZXF1ZXN0Njc4MTg5NTY1",
      "title": "Editorial changes",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/468",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Just some minor nits I picked up during a slow pass of the spec.",
      "createdAt": "2021-06-25T21:25:16Z",
      "updatedAt": "2021-06-30T21:14:50Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "d3227bd57daab88a41b13888ec0cc2e88a85841a",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "editorial",
      "headRefOid": "94bb091bd686dca6cf56e1f8552112bbc2f87c5f",
      "closedAt": "2021-06-28T15:27:33Z",
      "mergedAt": "2021-06-28T15:27:33Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ce1098f6fde6438aba3e66a0ca529a1c5e4f7164"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjkzOTc5NDI5",
          "commit": {
            "abbreviatedOid": "d7d59ff"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM pending one nit.",
          "createdAt": "2021-06-28T13:48:40Z",
          "updatedAt": "2021-06-28T13:48:46Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "```suggestion\r\nPer the rules of {{real-ech}}, the server is not permitted to resume a\r\n```\r\n\r\nIt's true that the _client_ can't send a real ticket in the outer CH if it's attempting ECH, but it's the _server_ that actually determines whether or not to resume. ",
              "createdAt": "2021-06-28T13:48:40Z",
              "updatedAt": "2021-06-28T13:48:46Z"
            }
          ]
        }
      ]
    },
    {
      "number": 469,
      "id": "MDExOlB1bGxSZXF1ZXN0Njc5NDc5MDY2",
      "title": "Add -12 change log.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/469",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @cjpatton, @ekr, @davidben, @sftcd ",
      "createdAt": "2021-06-28T23:43:58Z",
      "updatedAt": "2021-07-07T20:01:11Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9a74f5af39ac5813260cecbe523d6cad88288ba0",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/change-log-12",
      "headRefOid": "1b27d54c52bd7f699210b6cba39832994a7e6772",
      "closedAt": "2021-07-07T20:01:11Z",
      "mergedAt": "2021-07-07T20:01:11Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "57b9e22624f1c7401cec35bb7ffed9ee93bb7041"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Happy to park this if we want to land a change for #466, but I don't think that's absolutely needed for a new version. ",
          "createdAt": "2021-06-28T23:51:12Z",
          "updatedAt": "2021-06-28T23:51:12Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk0NDc4OTkx",
          "commit": {
            "abbreviatedOid": "f1988bf"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-28T23:46:11Z",
          "updatedAt": "2021-06-28T23:46:11Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I think we should call out #464 as a bugfix. ECH-11 isn't implementable.",
              "createdAt": "2021-06-28T23:46:11Z",
              "updatedAt": "2021-06-28T23:46:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk0NDc5ODUy",
          "commit": {
            "abbreviatedOid": "94bd720"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-28T23:48:35Z",
          "updatedAt": "2021-06-28T23:48:36Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Well, not really. It just broke the convention. ",
              "createdAt": "2021-06-28T23:48:35Z",
              "updatedAt": "2021-06-28T23:48:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk0NDc5ODc5",
          "commit": {
            "abbreviatedOid": "94bd720"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-28T23:48:41Z",
          "updatedAt": "2021-06-28T23:48:41Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Fixed anyway.",
              "createdAt": "2021-06-28T23:48:41Z",
              "updatedAt": "2021-06-28T23:48:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk1NDkwNDE2",
          "commit": {
            "abbreviatedOid": "94bd720"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-29T20:54:15Z",
          "updatedAt": "2021-06-29T20:54:16Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Well, it was a convention break along with an incompatibility with ECH-10. So I guess it's implementable, but you don't want to implement it the way it was written. :-)",
              "createdAt": "2021-06-29T20:54:16Z",
              "updatedAt": "2021-06-29T20:54:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk1NDkyNDc5",
          "commit": {
            "abbreviatedOid": "94bd720"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM, though I think a fix for #466 would be prudent since it's currently ambiguous.",
          "createdAt": "2021-06-29T20:56:50Z",
          "updatedAt": "2021-06-29T20:56:50Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk3NzY3ODQ4",
          "commit": {
            "abbreviatedOid": "1b27d54"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-02T01:58:24Z",
          "updatedAt": "2021-07-02T01:58:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 470,
      "id": "MDExOlB1bGxSZXF1ZXN0NjgxMjQ5MTYy",
      "title": "Clarify client behavior when HRR acceptance signal is malformed",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/470",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #466. I left an OPEN ISSUE about possibly changing the client behavior here depending on how we solve #450.",
      "createdAt": "2021-06-30T21:32:02Z",
      "updatedAt": "2021-07-08T00:39:02Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "a39831f33ac8de762328f6fbf9f7f216862c1240",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "hrr-malformed",
      "headRefOid": "0135da2a2612b47eb33f47316f4f7f777845532c",
      "closedAt": "2021-07-07T19:59:40Z",
      "mergedAt": "2021-07-07T19:59:40Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "d8186c3c03b40ea2313db53c9b6f2009fcda1cc8"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "cc/ @davidben, @cbartle891, @chris-wood ",
          "createdAt": "2021-06-30T21:32:28Z",
          "updatedAt": "2021-06-30T21:32:28Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "cc @davidben for a quick look before merging.",
          "createdAt": "2021-07-01T18:40:29Z",
          "updatedAt": "2021-07-01T18:40:29Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Paging @davidben and @martinthomson for a quick look before merging and cutting -12.",
          "createdAt": "2021-07-06T23:42:18Z",
          "updatedAt": "2021-07-06T23:42:18Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Squashed and rebased.",
          "createdAt": "2021-07-07T19:44:42Z",
          "updatedAt": "2021-07-07T19:44:42Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk2NjU2MjYz",
          "commit": {
            "abbreviatedOid": "07395f6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-30T22:05:01Z",
          "updatedAt": "2021-06-30T22:05:01Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk2NjYxNzE4",
          "commit": {
            "abbreviatedOid": "07395f6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-30T22:14:39Z",
          "updatedAt": "2021-06-30T22:14:39Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "What if the payload is present but malformed, e.g., 1 byte long? Would we want the client to abort then? (Failing early and loudly)",
              "createdAt": "2021-06-30T22:14:39Z",
              "updatedAt": "2021-06-30T22:14:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk2NjYyMjc1",
          "commit": {
            "abbreviatedOid": "07395f6"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-30T22:15:40Z",
          "updatedAt": "2021-06-30T22:15:40Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "A 1-byte *can't* equal `hrr_accept_confirmation`, so the client would presume rejection.",
              "createdAt": "2021-06-30T22:15:40Z",
              "updatedAt": "2021-06-30T22:15:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk2NjYzNTIy",
          "commit": {
            "abbreviatedOid": "07395f6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-30T22:18:05Z",
          "updatedAt": "2021-06-30T22:18:06Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Right, but peers typically abort when values are malformed or otherwise incorrect. Presuming rejection in this case seems to break with that pattern. (This would be a server-side bug, so failing seems appropriate here.)",
              "createdAt": "2021-06-30T22:18:05Z",
              "updatedAt": "2021-06-30T22:20:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk2NjcyOTMw",
          "commit": {
            "abbreviatedOid": "e805112"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-30T22:37:24Z",
          "updatedAt": "2021-06-30T22:37:25Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Offline we agreed that the client should abort if the payload is malformed.",
              "createdAt": "2021-06-30T22:37:24Z",
              "updatedAt": "2021-06-30T22:37:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk4Mjg4Mzk0",
          "commit": {
            "abbreviatedOid": "e805112"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-02T15:15:42Z",
          "updatedAt": "2021-07-02T15:19:08Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "How about we capture this in syntax, as `opaque HelloRetryRequestECH[8]` or whatever? I think syntax errors are already implicitly fatal and come with an alert (`decode_error`). Less special-case bits.\r\n\r\nLooking at RFC8446, we seem to have a couple styles here. Sometimes we just define separate types for each context and link them in prose: `KeyShareClientHello`, `KeyShareHelloRetryRequest`, `KeyShareServerHello`. Sometimes we define one structure with a select:\r\n\r\n```\r\n      struct {\r\n          select (Handshake.msg_type) {\r\n              case new_session_ticket:   uint32 max_early_data_size;\r\n              case client_hello:         Empty;\r\n              case encrypted_extensions: Empty;\r\n          };\r\n      } EarlyDataIndication;\r\n\r\n      struct {\r\n          select (Handshake.msg_type) {\r\n              case client_hello:\r\n                   ProtocolVersion versions<2..254>;\r\n\r\n              case server_hello: /* and HelloRetryRequest */\r\n                   ProtocolVersion selected_version;\r\n          };\r\n      } SupportedVersions;\r\n```\r\n\r\nI guess the latter is a little interesting because, for HelloRetryRequest, `Handshake.msg_type` is still `server_hello`. Maybe that's why we did key shares in prose...\r\n\r\n(Interestingly, our naming scheme for ECH is funny because it doesn't actually tell you the message, only who sends it. We say ServerECH rather than EncryptedExtensionsECH. And I guess KeyShare's naming convention is ECHEncryptedExtensions. Maybe time to rename since the server sends two of them now...)",
              "createdAt": "2021-07-02T15:15:42Z",
              "updatedAt": "2021-07-02T15:19:48Z"
            },
            {
              "originalPosition": 34,
              "body": "If we allow the server to send HRR.ech with invalid value as rejection, does that mean that, by sending GREASE ECH, the client is obligated to handle this case? Do we need some text here? (Like the client checks HRR.ECH syntactically but interprets all values as rejection.)",
              "createdAt": "2021-07-02T15:19:03Z",
              "updatedAt": "2021-07-02T15:19:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk4MjkzMDgz",
          "commit": {
            "abbreviatedOid": "e805112"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-02T15:21:16Z",
          "updatedAt": "2021-07-02T15:21:16Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "> I guess the latter is a little interesting because, for HelloRetryRequest, Handshake.msg_type is still server_hello. Maybe that's why we did key shares in prose...\r\n\r\nAh yes, that's exactly why key share doesn't do this. So I guess the single struct with `select` is the convention, but if you need to distinguish SH and HRR, as we do, do it in prose:\r\nhttps://github.com/tlswg/tls13-spec/commit/9a9c3295140bf4880ca031a6512e350da108713b",
              "createdAt": "2021-07-02T15:21:16Z",
              "updatedAt": "2021-07-02T15:21:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk4Mzg3MDU5",
          "commit": {
            "abbreviatedOid": "e805112"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-02T17:31:22Z",
          "updatedAt": "2021-07-02T17:31:23Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Something like this?\r\n```\r\n      struct {\r\n          select (Handshake.msg_type) {\r\n              case server_hello: // Well, HRR, but this isn't a codepoint AFAIK\r\n                   opaque hrr_ech_accept_confirmation [8];\r\n              case encrypted_extensions:\r\n                   ECHConfigList retry_configs;\r\n          };\r\n      } ServerECH;\r\n```",
              "createdAt": "2021-07-02T17:31:22Z",
              "updatedAt": "2021-07-02T17:31:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk4Mzg4MjAw",
          "commit": {
            "abbreviatedOid": "e805112"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-02T17:33:15Z",
          "updatedAt": "2021-07-02T17:33:15Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Yeah, I think the client is obligated to handle this case. In particular, it should parse the extension. (Isn't the server obligated to do the same for the GREASE ECH extension?)",
              "createdAt": "2021-07-02T17:33:15Z",
              "updatedAt": "2021-07-02T17:33:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk4NDI1NTE4",
          "commit": {
            "abbreviatedOid": "e805112"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-02T18:37:50Z",
          "updatedAt": "2021-07-02T18:37:50Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Using a mix of the two styles seems a little odd. Normally, when extensions use a `select (Handshake.msg_type)`, we put everything in it, so the ClientHello extension would go here too. Though I suppose we don't have a SH extension so HRR using the SH code point does work. But I was thinking we just go the key_share route and define three structures:\r\n\r\n```\r\n    struct {\r\n       ClientECHType type;\r\n       select (ClientECH.type) {\r\n           case outer:\r\n               HpkeSymmetricCipherSuite cipher_suite;\r\n               uint8 config_id;\r\n               opaque enc<0..2^16-1>;\r\n               opaque payload<1..2^16-1>;\r\n           case inner:\r\n               Empty;\r\n       };\r\n    } ECHClientHello;\r\n\r\n    struct {\r\n       opaque confirmation[8];\r\n    } ECHHelloRetryRequest;\r\n    // Or, equivalently, opaque ECHHelloRetryRequest[8], but the struct might be easier to read.\r\n\r\n    struct {\r\n       ECHConfigList retry_configs;\r\n    } ECHEncryptedExtensions;\r\n```\r\n\r\nRenaming things might be too much churn, I dunno. That's just the convention RFC8446 used for key share.",
              "createdAt": "2021-07-02T18:37:50Z",
              "updatedAt": "2021-07-02T18:37:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk4NDI2NDg4",
          "commit": {
            "abbreviatedOid": "e805112"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-02T18:39:48Z",
          "updatedAt": "2021-07-02T18:39:48Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Right. What I'm saying is the server specification doesn't distinguish GREASE ECH from normal ECH that fails to decrypt (and one hopes it cannot!). But the client specification has a big branch between GREASE ECH and normal ECH, so we probably need text here if we want that to work. (And we need a big branch because a GREASE ECH client cannot actually run the steps to compute the confirmation. There's no ClientHelloInner or anything.)",
              "createdAt": "2021-07-02T18:39:48Z",
              "updatedAt": "2021-07-02T18:39:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk4NDI2NzM2",
          "commit": {
            "abbreviatedOid": "e805112"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-02T18:40:18Z",
          "updatedAt": "2021-07-02T18:40:18Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "This looks good to me. @chris-wood, what do you think?",
              "createdAt": "2021-07-02T18:40:18Z",
              "updatedAt": "2021-07-02T18:40:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk4NDg1ODA2",
          "commit": {
            "abbreviatedOid": "e805112"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-02T20:36:23Z",
          "updatedAt": "2021-07-02T20:36:23Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Seems reasonable to me!",
              "createdAt": "2021-07-02T20:36:23Z",
              "updatedAt": "2021-07-02T20:36:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAwMjEyNDA5",
          "commit": {
            "abbreviatedOid": "e805112"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-06T17:29:41Z",
          "updatedAt": "2021-07-06T17:29:41Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Do you think there needs to be text around this in this PR? I would think it would make sense to address this once we have text for #450.",
              "createdAt": "2021-07-06T17:29:41Z",
              "updatedAt": "2021-07-06T17:29:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAwMjEzMjAw",
          "commit": {
            "abbreviatedOid": "ec4545c"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-06T17:30:33Z",
          "updatedAt": "2021-07-06T17:30:34Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Done.",
              "createdAt": "2021-07-06T17:30:33Z",
              "updatedAt": "2021-07-06T17:30:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAwMjIzNzI4",
          "commit": {
            "abbreviatedOid": "ec4545c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM pending a small comment about GREASE ECH and HRR. (I would be fine with or without text.)",
          "createdAt": "2021-07-06T17:43:14Z",
          "updatedAt": "2021-07-06T17:48:22Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "```suggestion\r\n       opaque confirmation[8];\r\n```",
              "createdAt": "2021-07-06T17:43:15Z",
              "updatedAt": "2021-07-06T17:48:22Z"
            },
            {
              "originalPosition": 18,
              "body": "```suggestion\r\nhandshake with an \"decode_error\" alert. If the payload length is equal to\r\n```",
              "createdAt": "2021-07-06T17:45:11Z",
              "updatedAt": "2021-07-06T17:48:22Z"
            },
            {
              "originalPosition": 34,
              "body": "It seems somewhat separable. We can just say that, if the client send GREASE ECH, then it should always assume rejection and use CHOuter. ",
              "createdAt": "2021-07-06T17:47:15Z",
              "updatedAt": "2021-07-06T17:48:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAwMjcwMDg2",
          "commit": {
            "abbreviatedOid": "fb3df6f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-06T18:40:52Z",
          "updatedAt": "2021-07-06T18:40:53Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "(@cjpatton did you accidentally resolve this?)",
              "createdAt": "2021-07-06T18:40:52Z",
              "updatedAt": "2021-07-06T18:40:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAwNDY1NDMz",
          "commit": {
            "abbreviatedOid": "4a73647"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-06T23:53:05Z",
          "updatedAt": "2021-07-06T23:53:50Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I'm slightly worried that the \"MUST\" here violates extensions guidelines.",
              "createdAt": "2021-07-06T23:53:05Z",
              "updatedAt": "2021-07-06T23:53:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAwNDY3MjIx",
          "commit": {
            "abbreviatedOid": "4a73647"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-06T23:57:47Z",
          "updatedAt": "2021-07-06T23:57:48Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "How is this different from, say, requiring the server to send a key_share extension in SH?",
              "createdAt": "2021-07-06T23:57:48Z",
              "updatedAt": "2021-07-06T23:57:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAwNDY5Njk2",
          "commit": {
            "abbreviatedOid": "4a73647"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Seems fine.",
          "createdAt": "2021-07-07T00:04:38Z",
          "updatedAt": "2021-07-07T00:07:38Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "```suggestion\r\ninclude an \"encrypted_client_hello\" extension with the following payload:\r\n```",
              "createdAt": "2021-07-07T00:04:38Z",
              "updatedAt": "2021-07-07T00:07:38Z"
            },
            {
              "originalPosition": 44,
              "body": "Why isn't this in a `select {}` block for the extension?",
              "createdAt": "2021-07-07T00:05:59Z",
              "updatedAt": "2021-07-07T00:07:38Z"
            },
            {
              "originalPosition": 10,
              "body": "Does this field need to be explicit?  Empty/not is a pretty good discriminator.",
              "createdAt": "2021-07-07T00:07:31Z",
              "updatedAt": "2021-07-07T00:07:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAwNDg1MjA4",
          "commit": {
            "abbreviatedOid": "7d32720"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-07T00:50:54Z",
          "updatedAt": "2021-07-07T00:50:54Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Not any different, I don't think.",
              "createdAt": "2021-07-07T00:50:54Z",
              "updatedAt": "2021-07-07T00:50:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAwNDg2MTky",
          "commit": {
            "abbreviatedOid": "7d32720"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-07T00:53:53Z",
          "updatedAt": "2021-07-07T00:59:40Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "[We had a thread on this, but I accidentally resolve it and I can no longer find it. So ist das Leben.] We're following the precedent set by the \"key_share\" extension https://datatracker.ietf.org/doc/html/rfc8446#section-4.2.8. ",
              "createdAt": "2021-07-07T00:53:53Z",
              "updatedAt": "2021-07-07T00:59:40Z"
            },
            {
              "originalPosition": 10,
              "body": "This was a change made in https://github.com/tlswg/draft-ietf-tls-esni/pull/422. The reasoning is that 8446 requires extensions to be solicited by the client, meaning in order for there to be an ECH extension in HRR, there must be an ECH extension in CHInner.",
              "createdAt": "2021-07-07T00:59:34Z",
              "updatedAt": "2021-07-07T00:59:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAwNDk0Nzc1",
          "commit": {
            "abbreviatedOid": "7d32720"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-07T01:17:39Z",
          "updatedAt": "2021-07-07T01:17:40Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Yes, but the extension can be empty and achieve the same end.",
              "createdAt": "2021-07-07T01:17:39Z",
              "updatedAt": "2021-07-07T01:17:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAwNDk0ODcw",
          "commit": {
            "abbreviatedOid": "7d32720"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-07T01:17:54Z",
          "updatedAt": "2021-07-07T01:17:54Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Just noticed:\r\n\r\n```suggestion\r\nthe `inner` variant and the server responds with HelloRetryRequest, it MUST\r\n```",
              "createdAt": "2021-07-07T01:17:54Z",
              "updatedAt": "2021-07-07T01:17:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAxMTkyMzkw",
          "commit": {
            "abbreviatedOid": "4b65646"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-07T16:03:54Z",
          "updatedAt": "2021-07-07T16:03:55Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Yeah, whether or not we need the octet indicator was raised in a separate PR. I suggest we move this off to a separate issue if we want to change it. ",
              "createdAt": "2021-07-07T16:03:55Z",
              "updatedAt": "2021-07-07T16:03:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAxNDAxMDE3",
          "commit": {
            "abbreviatedOid": "0135da2"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-07T20:05:08Z",
          "updatedAt": "2021-07-07T20:05:08Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Agreed that empty or not is a fine discriminator, though I'm not sure how to encode that cleanly in the TLS presentation language.",
              "createdAt": "2021-07-07T20:05:08Z",
              "updatedAt": "2021-07-07T20:05:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAxNTQ5NDA0",
          "commit": {
            "abbreviatedOid": "0135da2"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-08T00:39:02Z",
          "updatedAt": "2021-07-08T00:39:02Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "We switch on external variables in other contexts.  Continuing to think of the presentation language as a formal grammar is probably not helpful..",
              "createdAt": "2021-07-08T00:39:02Z",
              "updatedAt": "2021-07-08T00:39:02Z"
            }
          ]
        }
      ]
    },
    {
      "number": 471,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg0MDI0MzEw",
      "title": "Missing punctuation in  draft-ietf-tls-esni.md",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/471",
      "state": "MERGED",
      "author": "D-Sinus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Missing Punctuation\r\nAt section 8. Compatibility Issues",
      "createdAt": "2021-07-06T03:03:13Z",
      "updatedAt": "2021-07-06T18:27:27Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "29b11353f3de0b21134eb820e537e30c466a7e69",
      "headRepository": "D-Sinus/draft-ietf-tls-esni",
      "headRefName": "master",
      "headRefOid": "8509077d183ad9a0820c9286768128820f33125c",
      "closedAt": "2021-07-06T18:27:27Z",
      "mergedAt": "2021-07-06T18:27:27Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "a39831f33ac8de762328f6fbf9f7f216862c1240"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks!",
          "createdAt": "2021-07-06T18:24:54Z",
          "updatedAt": "2021-07-06T18:24:54Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk5NTE2NjIw",
          "commit": {
            "abbreviatedOid": "8509077"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-06T04:00:08Z",
          "updatedAt": "2021-07-06T04:00:08Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAwMjEzNjM2",
          "commit": {
            "abbreviatedOid": "8509077"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-06T17:31:07Z",
          "updatedAt": "2021-07-06T17:31:07Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAwMjU3MjIz",
          "commit": {
            "abbreviatedOid": "8509077"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-06T18:24:49Z",
          "updatedAt": "2021-07-06T18:24:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 472,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg1NDcxMjE4",
      "title": "Editorial",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/472",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Based on #470 (merge that first).",
      "createdAt": "2021-07-07T19:58:17Z",
      "updatedAt": "2021-07-07T20:00:47Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "a39831f33ac8de762328f6fbf9f7f216862c1240",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "editorial",
      "headRefOid": "8a129e2ef6a68e1f5b8adf013da7a4d55e35c351",
      "closedAt": "2021-07-07T20:00:47Z",
      "mergedAt": "2021-07-07T20:00:47Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "be42f849217b4deabb5bff2a8a30b447f7ff8787"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAxMzk3NDUy",
          "commit": {
            "abbreviatedOid": "8a129e2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-07T20:00:42Z",
          "updatedAt": "2021-07-07T20:00:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 473,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg5MjE1OTgx",
      "title": "Use the encrypted_client_hello extension to signal acceptance in SH and HRR",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/473",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "PR on standby for #441. (This doesn't GREASE the signal, as that's still somewhat up in the air in #441.)",
      "createdAt": "2021-07-13T16:26:32Z",
      "updatedAt": "2021-07-29T21:33:07Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "57b9e22624f1c7401cec35bb7ffed9ee93bb7041",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/unify-signal",
      "headRefOid": "89fc65e0f971efc6cab1e6fe70283beecc0ca53f",
      "closedAt": "2021-07-29T21:33:07Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 475,
      "id": "MDExOlB1bGxSZXF1ZXN0NjkwODc0MjYx",
      "title": "Revise middlebox section.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/475",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #474. This makes a few changes to the middlebox section:\r\n\r\nFirst, using \"MITM proxies\" when RFC8446 talks about terminating TLS was\r\nconfusing, so align with the RFC8446 terminology.\r\n\r\nNext, RFC8446 does not quite require dropping unknown extensions, only\r\ngenerating your own ClientHello. Dropping unknown extensions happens if\r\nthe proxy tries to intersect its true capabilities with that of the\r\nclient. I've also dropped the \"a more serious problem\" introduction\r\nsince the point of this section is that it's not a serious problem.\r\n\r\nFinally, I've dropped the \"non-conformant MITM proxy\" paragraph. It's\r\nslightly out of date now that we've unified everything around trial\r\ndecryption. I believe, depending on what the proxy does with the\r\nserver's EncryptedExtensions response, things will either break, work on\r\naccident, or retry loop and hit the limit. It doesn't seem worth\r\nexpending a whole lot of text on something that is the proxy's fault.\r\n\r\nThis does drop the \"Clients SHOULD NOT attempt to repair the connection\r\nin this case\" line, but the client couldn't really detect this case\r\nanyway. It looks like any old connection failure without a proxy, and\r\nthe usual considerations for changing your TLS config on connection\r\nfailure apply.",
      "createdAt": "2021-07-15T16:28:52Z",
      "updatedAt": "2021-07-26T21:02:04Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "57b9e22624f1c7401cec35bb7ffed9ee93bb7041",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "revise-middlebox",
      "headRefOid": "fd6ca03279008075e9cf94d16cad4887913925c5",
      "closedAt": "2021-07-26T21:02:04Z",
      "mergedAt": "2021-07-26T21:02:04Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "848eee77ba3edd292940a5c03792c07d589be43d"
      },
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah good point. I dropped the \"which do not support this extension\" clause on accident. How's this new iteration?\r\n\r\n(Seems best not to get into middleboxes which do support the extension. \"which likely means being involved in\" feels too handwaivy, and I'd rather not expend a lot of text around how DNS works with HTTP CONNECT proxies, CDNs where the \"proxy\" is on the server's side and controls DNS, etc.)",
          "createdAt": "2021-07-16T15:36:57Z",
          "updatedAt": "2021-07-16T15:36:57Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA3ODkwMTE1",
          "commit": {
            "abbreviatedOid": "0513ae0"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "The middlebox could also support ECH, right? It would need a way to get a config, and probably would need to be involved in feeding a config too the client, but it is at least possible for interception to consume and use ECH.\r\n\r\nMaybe qualify with \"unless the middlebox understands ECH and is able to interpret the extension (which likely means being involved in providing the client with an ECHConfig)...\"",
          "createdAt": "2021-07-15T23:17:00Z",
          "updatedAt": "2021-07-15T23:17:00Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzEwMDY1NDg4",
          "commit": {
            "abbreviatedOid": "fd6ca03"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-19T23:36:24Z",
          "updatedAt": "2021-07-19T23:36:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 477,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk2MjM0ODY1",
      "title": "Trim the introduction section",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/477",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It is rather long. I've taken a pass at making it read a little clearer,\r\nhopefully. I've tried to preserve the bits of the old text that seemed\r\nimportant. Hopefully other folks agree. This still could use another\r\nediting pass (e.g. the first and second paragraphs both conclude\r\nwith the same thing), but I think it's an improvement.\r\n\r\nI've dropped the paragraph about about how the TLSWG has studied the\r\nproblem but had difficulties. That seemed more relevant when we were\r\ncomparing this approach against others.\r\n\r\nThe following paragraph then describes the setup (colocated servers) and\r\nwhat the extension achieves (stuff about anonymity sets). Thats\r\nredundant with the text above talking about how sometimes the server\r\nIP isn't identifying, and the text below talking about what the\r\nextension does. I've worked that text into those two paragraphs.\r\n\r\nI tweaked the bit about consistent TLS configuration, since it's not\r\nactually true: it's fine if the servers don't support the same ALPN\r\nprotocols. It's just a few externally-visible bits of TLS configuration.\r\nThat's probably worth defining more accurately, if we haven't already (I\r\nforget), but not in the introduction.\r\n\r\nI've also dropped the claim that we leak no more than the server IP. We\r\nhaven't addressed padding of application data, and cases where the\r\ncolocated servers have sufficiently different TLS configuration are out\r\nof scope.\r\n\r\nI tried to general tightened up language. For instance there was a paragraph\r\nthat says \"(assuming the server does not use domain-based virtual\r\nhosting)\" and then goes straight to talk about servers that *do* use\r\nvirtual hosting.",
      "createdAt": "2021-07-23T22:12:09Z",
      "updatedAt": "2021-07-27T20:17:22Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "57b9e22624f1c7401cec35bb7ffed9ee93bb7041",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "trim-intro",
      "headRefOid": "06592fac0f6ac564803a85e78d5b6580186f837a",
      "closedAt": "2021-07-27T20:17:22Z",
      "mergedAt": "2021-07-27T20:17:22Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "6a2b1c4cd43e62fa6f88370e2aa535ae55b8431a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE2MzM3MTM1",
          "commit": {
            "abbreviatedOid": "a369dea"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-27T20:15:06Z",
          "updatedAt": "2021-07-27T20:16:40Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "```suggestion\r\nconfigurations, including supported versions and cipher suites, form an anonymity set. Usage of\r\n```",
              "createdAt": "2021-07-27T20:15:06Z",
              "updatedAt": "2021-07-27T20:17:02Z"
            }
          ]
        }
      ]
    },
    {
      "number": 478,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk2MjQ0NTIz",
      "title": "Rephrase the overview",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/478",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The overview was a bit long, and slightly inaccurate. The\r\nClientHelloInner is encrypted after (most) of the ClientHelloOuter is\r\nconstructed. I've also merged the ECH-naive server case with the ECH\r\nrejection case. This is more consistent with the client text, and most\r\nother TLS extensions, where we do not distinguish between reasons why\r\nthe extension could not be negotiated.\r\n\r\nI've also generally tightened up the wording to make it shorter. As part\r\nof that, I'm trimmed the repeated list of sensitive ClientHello\r\nextensions. ECH itself is (mostly) agnostic to which extensions you\r\nbelieve are sensitive, and we already gave examples in the introduction.",
      "createdAt": "2021-07-23T22:47:10Z",
      "updatedAt": "2021-07-27T20:51:57Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "6a2b1c4cd43e62fa6f88370e2aa535ae55b8431a",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "trim-overview",
      "headRefOid": "5ef6f65b7598dbe3a8d1c7f016178c99ed5fd094",
      "closedAt": "2021-07-27T20:51:57Z",
      "mergedAt": "2021-07-27T20:51:57Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "a4364eb205e9a499211b6395125f95831b3782ba"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE2MzQwMzU0",
          "commit": {
            "abbreviatedOid": "2bf663b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This is very clean :-) Nice work!",
          "createdAt": "2021-07-27T20:19:06Z",
          "updatedAt": "2021-07-27T20:23:59Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "```suggestion\r\nthis for all the domains it serves directly or indirectly via Shared or Split Mode, respectively.\r\n```",
              "createdAt": "2021-07-27T20:19:06Z",
              "updatedAt": "2021-07-27T20:23:59Z"
            },
            {
              "originalPosition": 47,
              "body": "```suggestion\r\nconstructs a private ClientHello, referred to as the ClientHelloInner.\r\n```",
              "createdAt": "2021-07-27T20:20:02Z",
              "updatedAt": "2021-07-27T20:23:59Z"
            },
            {
              "originalPosition": 68,
              "body": "```suggestion\r\naccordingly. When ECH is rejected, the resulting connection is not usable by\r\nthe client for application data. Instead, ECH rejection allows the client to\r\nretry with up-to-date configuration ({{rejected-ech}}).\r\n```",
              "createdAt": "2021-07-27T20:23:01Z",
              "updatedAt": "2021-07-27T20:23:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE2MzQ2NTIy",
          "commit": {
            "abbreviatedOid": "2bf663b"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-27T20:26:34Z",
          "updatedAt": "2021-07-27T20:26:34Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Oh, I got this from the earlier version of the text. I wonder whether both OR clauses are even necessary. WDYT about:\r\n\r\n> for all the domains it serves via Shared or Split Mode.",
              "createdAt": "2021-07-27T20:26:34Z",
              "updatedAt": "2021-07-27T20:26:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE2MzY1MDcz",
          "commit": {
            "abbreviatedOid": "5ef6f65"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-27T20:49:15Z",
          "updatedAt": "2021-07-27T20:49:16Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Applied that version and rebased.",
              "createdAt": "2021-07-27T20:49:16Z",
              "updatedAt": "2021-07-27T20:49:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE2MzY1NjI4",
          "commit": {
            "abbreviatedOid": "5ef6f65"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-27T20:49:54Z",
          "updatedAt": "2021-07-27T20:49:54Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Lovely :-) thanks!",
              "createdAt": "2021-07-27T20:49:54Z",
              "updatedAt": "2021-07-27T20:49:54Z"
            }
          ]
        }
      ]
    },
    {
      "number": 479,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk4MTkwNzUz",
      "title": "Cite the correct section for the retry flow.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/479",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Handling server response discusses how to dispatch between accept/reject, but the retry flow is specifically the reject bit.",
      "createdAt": "2021-07-27T21:10:21Z",
      "updatedAt": "2021-07-27T22:15:35Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "2a661f72c545a16249e4b2b83fc1412eb44439b5",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "fix-citations",
      "headRefOid": "ad870fedfabee681bd7ced7bc9ccadd1d08779f6",
      "closedAt": "2021-07-27T22:15:35Z",
      "mergedAt": "2021-07-27T22:15:35Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "8b099c334470ffa185d7ec28f09235f705c42342"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE2NDI0MjQ4",
          "commit": {
            "abbreviatedOid": "ad870fe"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-27T22:15:30Z",
          "updatedAt": "2021-07-27T22:15:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 480,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk5ODA3NTU3",
      "title": "Tidy up client ECH accept and GREASE sections",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/480",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR cleans up the client text, in hopes of making it more precise\r\nand organized somewhat more chronologically. It then uses this cleanup\r\nto clarify bits we forgot to write down in the accept/reject/HRR\r\nmachinery:\r\n\r\n1. Handling the Server Response is now Determining ECH Acceptance and\r\n   only discusses the initial accept/reject decision.\r\n\r\n2. The portion of Handling HelloRetryRequest discussing the\r\n   accept/reject decision is moved to Determining ECH Acceptence.\r\n\r\n3. Determining ECH Acceptance is tidied up to discuss to what happens if\r\n   you see an older TLS version (it's a reject). In particular, in DTLS\r\n   1.2, the first server message might be HelloVerifyRequest and not\r\n   ServerHello or HelloRetryRequest.\r\n\r\n4. Accepted/Rejected ECH are now Handshaking with\r\n   ClientHelloInner/ClientHelloOuter to fit with the other section names\r\n   (lots of VERBing). They are unindented from (1) because that section\r\n   only talks about the accept/reject decision. This gives us a place to\r\n   discuss *all* changes to the handshake. We describe what it actually\r\n   means to handshake with ClientHelloInner, including implications to\r\n   the transcript. And...\r\n\r\n5. ...the portion of Handling HelloRetryRequest that discussed\r\n   constructing the second ClientHello never applied to the ECH Reject\r\n   case anyway, only ECH Accept. Move this to (4). Also expand on it so\r\n   it's a bit more clearly defined. I've also moved HPKE setup out of\r\n   Encrypting the ClientHello, as that's only relevant to one of the two\r\n   \"callers\" anyway. I'm not thrilled with this notion of \"partial\r\n   ClientHelloOuterAAD\", but the text used in Offering ECH and\r\n   Encrypting the ClientHello sections otherwise doesn't actually match.\r\n   Before this PR, both think they are responsible for constructing\r\n   ClientHelloOuter.\r\n\r\n6. With this and (1), Handling HelloRetryRequest is\r\n   now empty and removed.\r\n\r\n7. We forgot to write down the client half of\r\n   https://github.com/tlswg/draft-ietf-tls-esni/pull/461. There is now a\r\n   place for it in Handshaking with ClientHelloInner.\r\n\r\n8. We say that the ECH reject case ignores the HRR.ech extension, so ECH\r\n   GREASE says the same thing, to keep them aligned.\r\n\r\nThe Handshaking with ClientHelloOuter section could also do with an\r\neditorial pass, but I've omitted it from this PR because it was getting\r\na bit large as it is.",
      "createdAt": "2021-07-29T20:04:42Z",
      "updatedAt": "2021-07-30T22:52:01Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "8b099c334470ffa185d7ec28f09235f705c42342",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "tidy-client",
      "headRefOid": "94dd5b7f0c6940d3872bd5771bb90f74688965ff",
      "closedAt": "2021-07-30T22:52:01Z",
      "mergedAt": "2021-07-30T22:52:00Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "5082ba6fa57954e1a5c5a64993894d5ada5758bb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE4NTI2OTE5",
          "commit": {
            "abbreviatedOid": "a1b6001"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for capping the amount of changes in this PR :) ",
          "createdAt": "2021-07-29T20:56:40Z",
          "updatedAt": "2021-07-29T21:10:48Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "```suggestion\r\nas described in {{encrypting-clienthello}}, to construct a ClientHelloOuter. It\r\n```",
              "createdAt": "2021-07-29T20:56:40Z",
              "updatedAt": "2021-07-29T21:10:49Z"
            },
            {
              "originalPosition": 191,
              "body": "```suggestion\r\n```\r\nThis is covered by the first step (1), right?",
              "createdAt": "2021-07-29T21:05:10Z",
              "updatedAt": "2021-07-29T21:10:49Z"
            },
            {
              "originalPosition": 198,
              "body": "```suggestion\r\nThe client then sends the second ClientHelloOuter to the server. However, as\r\nabove, it uses the second ClientHelloInner for preferences, and both the\r\nClientHelloInner messages for the transcript hash. Additionally, it checks the\r\nresulting ServerHello for ECH acceptance as in {{determining-ech-acceptance}}.\r\nIf the ServerHello does not also indicate ECH acceptance, the client MUST\r\nterminate the connection with an \"illegal_parameter\" alert.\r\n```",
              "createdAt": "2021-07-29T21:06:20Z",
              "updatedAt": "2021-07-29T21:10:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE5NDkxMTE3",
          "commit": {
            "abbreviatedOid": "a1b6001"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-30T22:06:05Z",
          "updatedAt": "2021-07-30T22:06:41Z",
          "comments": [
            {
              "originalPosition": 191,
              "body": "Yeah, I guess there's no real need to restate it. Figured it wasn't obvious that the HelloRetryRequest might not match.",
              "createdAt": "2021-07-30T22:06:05Z",
              "updatedAt": "2021-07-30T22:06:41Z"
            }
          ]
        }
      ]
    },
    {
      "number": 481,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk5ODUzNjc0",
      "title": "Allow the client-facing server to GREASE the extension.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/481",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This assumes the formulation where, on ECH reject, the server is the client-facing server. In other words, backend servers will never get a CH without ECH having been accepted, so GREASE doesn't apply there. \r\n\r\ncc @davidben ",
      "createdAt": "2021-07-29T21:28:53Z",
      "updatedAt": "2021-08-05T22:23:26Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "8b099c334470ffa185d7ec28f09235f705c42342",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/allow-extension-grease",
      "headRefOid": "febb8fa9a6836b1e02ec319f83154650f8c8b594",
      "closedAt": "2021-08-05T22:23:26Z",
      "mergedAt": "2021-08-05T22:23:26Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "cf4e781e6c3ede230736b9b70ff856c8acbc094a"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "cc @martinthomson, too, since he had thoughts on this",
          "createdAt": "2021-08-03T20:05:24Z",
          "updatedAt": "2021-08-03T20:05:24Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIwNDYyNzMy",
          "commit": {
            "abbreviatedOid": "652daed"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I'm good with the change, but I think the spec needs more context for it.",
          "createdAt": "2021-08-02T18:01:58Z",
          "updatedAt": "2021-08-02T18:02:21Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "* In which message may the extension appear? ServerHello, HelloRetryRequest, or both?\r\n* I think we should make it clear that the purpose is to grease. Maybe point to Security Considerations and expand the relevant section to talk about this?",
              "createdAt": "2021-08-02T18:01:59Z",
              "updatedAt": "2021-08-02T18:02:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIwNDk1NDIx",
          "commit": {
            "abbreviatedOid": "929d5b0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-02T18:46:05Z",
          "updatedAt": "2021-08-02T18:46:05Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Good suggestions -- I moved some stuff around to try and clarify.",
              "createdAt": "2021-08-02T18:46:05Z",
              "updatedAt": "2021-08-02T18:46:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIwNTIwNjIy",
          "commit": {
            "abbreviatedOid": "929d5b0"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-02T19:20:58Z",
          "updatedAt": "2021-08-02T19:20:58Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIxNTUzNzg2",
          "commit": {
            "abbreviatedOid": "929d5b0"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-03T19:10:03Z",
          "updatedAt": "2021-08-03T19:18:51Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "This doesn't have anything to do with HRR. Do we need to restate it from the section here? (I wonder if the server half could also do with an editorial pass to make it more chronological.)",
              "createdAt": "2021-08-03T19:10:03Z",
              "updatedAt": "2021-08-03T19:18:51Z"
            },
            {
              "originalPosition": 19,
              "body": "This is a little long. How about:\r\n\r\n```\r\nOtherwise, if all candidate ECHConfig values fail to decrypt the extension, the\r\nclient-facing server MUST ignore the extension and proceed with the connection\r\nusing ClientHelloOuter, with the following modifications:\r\n\r\n* If sending a HelloRetryRequest, the server MAY include an\r\n  \"encrypted_client_hello\" extension with a payload of 8 random bytes; see\r\n  {{dont-stick-out}} for details.\r\n\r\n* The server MUST include the \"encrypted_client_hello\" extension in its\r\n  EncryptedExtensions message with ....\r\n```\r\n\r\nThis also fixes the issue where we need to duplicate the EncryptedExtensions text (see comment below).\r\n\r\nThough, it occurs to me, even that's a little odd because even non-ECH servers could send HRR.ECH for GREASE. Maybe we can handle that be deleting a few words. Suppose you are a server with zero ECHConfigs. The dispatch in {#server-behavior} still sends you to this section. The candidate ECHConfig values is then empty, so you'll hit this case. That means we actually should replace:\r\n\r\n> The server MUST include the \"encrypted_client_hello\" extension in its EncryptedExtensions message with [...]\r\n\r\nwith:\r\n\r\n> If the server is configured with any ECHConfigs, it MUST include the \"encrypted_client_hello\" extension in its EncryptedExtensions message with [...]",
              "createdAt": "2021-08-03T19:18:37Z",
              "updatedAt": "2021-08-03T19:18:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIxNTc3NjIx",
          "commit": {
            "abbreviatedOid": "929d5b0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-03T19:39:53Z",
          "updatedAt": "2021-08-03T19:39:53Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "That modification is good in both places -- I'll take it!",
              "createdAt": "2021-08-03T19:39:53Z",
              "updatedAt": "2021-08-03T19:39:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIxNTc4NjYy",
          "commit": {
            "abbreviatedOid": "929d5b0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-03T19:41:11Z",
          "updatedAt": "2021-08-03T19:41:11Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "We should do such a pass, but let's do it separately. ",
              "createdAt": "2021-08-03T19:41:11Z",
              "updatedAt": "2021-08-03T19:41:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIxNTc5ODEw",
          "commit": {
            "abbreviatedOid": "929d5b0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-03T19:42:37Z",
          "updatedAt": "2021-08-03T19:42:37Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "(The server still includes configs upon rejection, even in the event of HRR, right?)",
              "createdAt": "2021-08-03T19:42:37Z",
              "updatedAt": "2021-08-03T19:42:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIxNjY3NDAz",
          "commit": {
            "abbreviatedOid": "febb8fa"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-03T21:36:38Z",
          "updatedAt": "2021-08-03T21:36:38Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "It does. The point of my suggestion with the bullet points was instead to have the one sentence apply to both cases.",
              "createdAt": "2021-08-03T21:36:38Z",
              "updatedAt": "2021-08-03T21:36:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIxNjY4NDA0",
          "commit": {
            "abbreviatedOid": "febb8fa"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-03T21:38:12Z",
          "updatedAt": "2021-08-03T21:38:12Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Gotcha. In my reading this section it seemed clear to include here, but we can drop it later on if not needed.",
              "createdAt": "2021-08-03T21:38:12Z",
              "updatedAt": "2021-08-03T21:38:12Z"
            }
          ]
        }
      ]
    },
    {
      "number": 482,
      "id": "MDExOlB1bGxSZXF1ZXN0NzAyNDczNzUy",
      "title": "Add -12 changelog.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/482",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed in IETF 111. Blocked on #481.\r\n\r\ncc @martinthomson, @davidben, @cjpatton, @cbartle891, @sftcd ",
      "createdAt": "2021-08-03T17:42:18Z",
      "updatedAt": "2021-08-12T16:29:46Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9eef1de12f039ba52d3783ac269b4cfdf240906e",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/changelog-12",
      "headRefOid": "fcce167b118eb2728eeed2a89ee9b12f9cc8a235",
      "closedAt": "2021-08-12T16:29:46Z",
      "mergedAt": "2021-08-12T16:29:46Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "058aedcdc6ebefcbee81201dcb4ec960bdcafccc"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "(Noting here that I'll update this with some of @sftcd's changes that landed before merging.)",
          "createdAt": "2021-08-05T22:58:47Z",
          "updatedAt": "2021-08-05T22:58:47Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIxNTYxMjMx",
          "commit": {
            "abbreviatedOid": "70f8f61"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-03T19:19:34Z",
          "updatedAt": "2021-08-03T19:19:34Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIzOTU3MDU2",
          "commit": {
            "abbreviatedOid": "70f8f61"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-06T03:45:01Z",
          "updatedAt": "2021-08-06T03:45:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 483,
      "id": "MDExOlB1bGxSZXF1ZXN0NzAyNjgyMzc1",
      "title": "Update codepoints to -13.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/483",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @davidben, @martinthomson, @cbartle891, @cjpatton, @sftcd ",
      "createdAt": "2021-08-03T22:37:19Z",
      "updatedAt": "2021-08-04T20:20:07Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "7e79d8571880b6c87080d7fc86b370d00141b3d6",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/update-codepoints",
      "headRefOid": "fd484eed664cfd7410e7b9fb730d0b389d34cd66",
      "closedAt": "2021-08-04T20:20:07Z",
      "mergedAt": "2021-08-04T20:20:07Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "722f5e9175c9adb154ec54d74762cc2707c0546b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIxNzA1NzY2",
          "commit": {
            "abbreviatedOid": "fd484ee"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-03T22:47:48Z",
          "updatedAt": "2021-08-03T22:47:48Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIyNjYyMjM2",
          "commit": {
            "abbreviatedOid": "fd484ee"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-04T19:31:00Z",
          "updatedAt": "2021-08-04T19:31:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 484,
      "id": "MDExOlB1bGxSZXF1ZXN0NzAzODM5MzEx",
      "title": "HPKE isn't draft-08 any more",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/484",
      "state": "MERGED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-08-04T18:38:20Z",
      "updatedAt": "2021-08-05T21:15:19Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "7e79d8571880b6c87080d7fc86b370d00141b3d6",
      "headRepository": "sftcd/draft-ietf-tls-esni",
      "headRefName": "sftcd-patch-1",
      "headRefOid": "395a69a0d7b98f493472a54c96c060bb193c73af",
      "closedAt": "2021-08-05T21:15:19Z",
      "mergedAt": "2021-08-05T21:15:19Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "3152c3e03f1f370352839a9546e8ab17229d5ca0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIyNjIxODQ4",
          "commit": {
            "abbreviatedOid": "395a69a"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Hopefully HPKE is done enough that we no longer need to pin a draft version.",
          "createdAt": "2021-08-04T18:47:59Z",
          "updatedAt": "2021-08-04T18:47:59Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIzODAzOTg1",
          "commit": {
            "abbreviatedOid": "395a69a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-05T21:15:13Z",
          "updatedAt": "2021-08-05T21:15:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 485,
      "id": "MDExOlB1bGxSZXF1ZXN0NzAzODUzMjUx",
      "title": "note experiment",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/485",
      "state": "MERGED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Seems useful to note that -13 should be around for a while but still might change later ",
      "createdAt": "2021-08-04T18:49:45Z",
      "updatedAt": "2021-08-06T00:08:22Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "7e79d8571880b6c87080d7fc86b370d00141b3d6",
      "headRepository": "sftcd/draft-ietf-tls-esni",
      "headRefName": "note-experiments",
      "headRefOid": "89faadedf3ae24fad19437fa92c86ca385ed1543",
      "closedAt": "2021-08-05T21:56:19Z",
      "mergedAt": "2021-08-05T21:56:19Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "b4d73e7e1819ae74f935f13b60c38185879cace8"
      },
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 05/08/2021 22:56, Christopher Wood wrote:\n> @chris-wood approved this pull request.\n> \n> How about this simplification based on the outcome from 111? I think it's clear that future changes may occur, so I just dropped that.\n> \n>> +production systems. As of the time of publication, this draft is being used\n> +for ongoing experimentation and so may remain stable for some time. Changes\n> +are to be expected though once those experiments and analyses are completed.\n> \n> ```suggestion\n> production systems. This published version of the draft has been designated\n> an \"implementation draft\" for testing and interop purposes.\n\nYeah that's fine.\n\nTa,\nS.\n> ```\n> \n",
          "createdAt": "2021-08-06T00:08:22Z",
          "updatedAt": "2021-08-06T00:08:22Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIzODI4NTA1",
          "commit": {
            "abbreviatedOid": "f129c06"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "How about this simplification based on the outcome from 111? I think it's clear that future changes may occur, so I just dropped that. ",
          "createdAt": "2021-08-05T21:55:03Z",
          "updatedAt": "2021-08-05T21:56:09Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nproduction systems. This published version of the draft has been designated\r\nan \"implementation draft\" for testing and interop purposes.\r\n```",
              "createdAt": "2021-08-05T21:55:03Z",
              "updatedAt": "2021-08-05T21:56:09Z"
            }
          ]
        }
      ]
    },
    {
      "number": 486,
      "id": "MDExOlB1bGxSZXF1ZXN0NzAzODcxNTY3",
      "title": "redundant length",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/486",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "ECHConfig.length is either redundant or else it needs more explanation. This PR assumes the former. Either's fine by me (my draft-10 code supports >1 key per supplied ECHConfig for obscure API reasons anyway:-). This change notes that the field is currently redundant as there's only one ECHConfigContents per ECHConfig.  If we want to allow >1 ECHConfigContents per ECHConfig then we should say that explicitly here and likely somewhere else too. \r\n\r\nI'd have to look again at the SVCB spec but I think this being redundant also means that a deployment needs to have >1 HTTPS/SVCB RR value to publish more than one key at a time. If that's correct it may be worth noting here somewhere too.",
      "createdAt": "2021-08-04T19:06:14Z",
      "updatedAt": "2021-08-05T12:53:39Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "7e79d8571880b6c87080d7fc86b370d00141b3d6",
      "headRepository": "sftcd/draft-ietf-tls-esni",
      "headRefName": "useless-length",
      "headRefOid": "ce2db58053d55bd477e8d0aec4ff8aec609c44cc",
      "closedAt": "2021-08-05T12:53:39Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "No, the length prefix is necessary. It's not about having multiple ECHConfigContents per ECHConfig. It's about having multiple ECHConfigs in an ECHConfigList, and being able to skip over ECHConfigs from versions you don't understand. This property is a requirement for allowing us to experiment at all, without having to define a new SVCB/HTTPS key on every draft.\r\n\r\n(TLS structures are not automatically delimited by length prefixes. You need to know their definition in order to skip over them. That means we need a version-independent ECHConfig structure. The length prefix with opaque body gives that by hiding the version-dependent ECHConfigContents bit.)\r\n\r\n> a deployment needs to have >1 HTTPS/SVCB RR value to publish more than one key at a time.\r\n\r\nThis is precisely what we want to avoid, and why we have the length prefix. Using separate HTTPS/SVCB RR values will result in either downgrade vulnerabilities on the client, or a lot of complexity. Keep in mind that DNS, connection setup, and TLS logic can come from different OS components or parts of the system. If we make the choice of HTTPS/SVCB RR depend on TLS capabilities, your DNS API needs to take in a description of your TLS stack's capabilities.\r\n\r\nThis would be excessive complexity in the way of deploying ECH, so we should keep the current, overall simpler design.",
          "createdAt": "2021-08-04T19:16:59Z",
          "updatedAt": "2021-08-04T19:16:59Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "It's not redundant. It allows you to skip past ECHConfigs of unknown version, in, for instance ECHEncryptedExtensions.\r\n",
          "createdAt": "2021-08-04T19:17:18Z",
          "updatedAt": "2021-08-04T19:17:18Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "Ok, it's fine if this isn't redundant but then it being needed for ECHConflgList ought be explained IMO.\r\n\r\nAnd maybe also mention that SVCB now contains an encoded ECHConfigList at the same time too.",
          "createdAt": "2021-08-04T19:40:35Z",
          "updatedAt": "2021-08-04T19:43:48Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think we need to explain the rationale for every detail of how we define structures. It's not a security requirement someone needs to understand about how to implement this and the general need for this kind of length is just kind of community knowledge. If someone wanted to write that up in a TLS PDU style guide of some kind that would be fine, but it doesn't belong here.\r\n",
          "createdAt": "2021-08-04T21:21:09Z",
          "updatedAt": "2021-08-04T21:21:09Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "Fair enough that we disagree that this is unclear as-is and can usefully, simply and easily be improved, but that we don't have to do that:-) \r\n\r\nThe basic problem I think is that issues related to cardinality aren't clearly explained here nor in SVCB and I do think that'll bite some implementer sometime. I'm not fussed as to how exactly we improve that.\r\n\r\n(And I'm not asking for every detail to be explained, I'm commenting while doing a sorta-fresh read through as per list-discussion yesterday.)",
          "createdAt": "2021-08-04T21:25:58Z",
          "updatedAt": "2021-08-04T21:25:58Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed in favour of #496 ",
          "createdAt": "2021-08-05T12:53:39Z",
          "updatedAt": "2021-08-05T12:53:39Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 487,
      "id": "MDExOlB1bGxSZXF1ZXN0NzAzODk5MjQz",
      "title": "note potential config_id collisions",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/487",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "MUST->SHOULD for not publishing colliding config_id values.\r\n\r\nThis is a little more than editorial maybe but later text in any case seems to handle config_id collisions so given the MUST here is really on DNS provisioning code and not ECH code anyway, I'll claim it's editorial:-) I'd also be fine with s/MUST/should/ if that were thought better.\r\n\r\nI also suggest deleting a sentence that looks like it no longer belongs. (\"This process...\") It could be that ought be shifted to later where trial decryption is discussed, not sure. ",
      "createdAt": "2021-08-04T19:25:17Z",
      "updatedAt": "2021-08-04T21:40:23Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "7e79d8571880b6c87080d7fc86b370d00141b3d6",
      "headRepository": "sftcd/draft-ietf-tls-esni",
      "headRefName": "birthday",
      "headRefOid": "ef07feacf8b259c1acec5792224320d2ceca1ab6",
      "closedAt": "2021-08-04T21:39:41Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed - #491  is a better fix.",
          "createdAt": "2021-08-04T21:39:41Z",
          "updatedAt": "2021-08-04T21:40:23Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIyNjcyNjU2",
          "commit": {
            "abbreviatedOid": "ef07fea"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Agreed on MUST -> SHOULD, since it's just a performance thing. If you have a collision, trial decryption would repair it. It's just more server load. But I don't think the other two changes are right.",
          "createdAt": "2021-08-04T19:43:54Z",
          "updatedAt": "2021-08-04T19:45:27Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "This sentence is important to the recommendation, otherwise it doesn't actually avoid collisions.",
              "createdAt": "2021-08-04T19:43:54Z",
              "updatedAt": "2021-08-04T19:45:27Z"
            },
            {
              "originalPosition": 13,
              "body": "I don't think this example is right. If a backend server is supported by multiple client-facing servers (A and B), they need to set up their DNS properly, otherwise the connection will fail. For instance, multiple HTTPS RRs, one A's IP + A's ECHConfigList, and another with B's IP + B's  ECHConfigList.\r\n\r\nIndeed this is why we switched from the old ECH DNS record: we got feedback from CDN operators that IPs and ECHConfigLists need to be correlated to avoid multi-CDN problems.",
              "createdAt": "2021-08-04T19:45:04Z",
              "updatedAt": "2021-08-04T19:45:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIyNjg1NTg5",
          "commit": {
            "abbreviatedOid": "ef07fea"
          },
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-04T19:59:53Z",
          "updatedAt": "2021-08-04T19:59:53Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "I'm not clear how CDN-A knows that CDN-B (also used by the backend) will in future not collide. So while CDN-A can repeat the process as often as it wants, and the ECHConfig value from CDN-A won't collide with one another, the backend can still get a collision. Or where am I wrong?",
              "createdAt": "2021-08-04T19:59:53Z",
              "updatedAt": "2021-08-04T19:59:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIyNjg3NjQw",
          "commit": {
            "abbreviatedOid": "ef07fea"
          },
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-04T20:02:24Z",
          "updatedAt": "2021-08-04T20:02:25Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "\"They need to setup their DNS properly\" is the issue - it's the backend's DNS not the client-facing server's DNS.",
              "createdAt": "2021-08-04T20:02:25Z",
              "updatedAt": "2021-08-04T20:02:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIyNjg4NzU4",
          "commit": {
            "abbreviatedOid": "ef07fea"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-04T20:03:46Z",
          "updatedAt": "2021-08-04T20:03:46Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "They don't know, and don't have to know. You only hit trial decryption if, within a set of active configs *on the same client-facing server*, there is a config ID collision. The backend doesn't deal with configs in the first place.",
              "createdAt": "2021-08-04T20:03:46Z",
              "updatedAt": "2021-08-04T20:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIyNjkwNDUy",
          "commit": {
            "abbreviatedOid": "ef07fea"
          },
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-04T20:05:58Z",
          "updatedAt": "2021-08-04T20:05:59Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Sure. trial decryption is fine. The issue is that the sentence I suggest removing seems to me to claim that one can avoid config_id collisions in the DNS if you iterate the random picking. But that's not the case. ",
              "createdAt": "2021-08-04T20:05:58Z",
              "updatedAt": "2021-08-04T20:05:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIyNjkxNTgz",
          "commit": {
            "abbreviatedOid": "ef07fea"
          },
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-04T20:07:27Z",
          "updatedAt": "2021-08-04T20:07:28Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "If one changed that sentence via s/any valid ECHConfig/any known ECHConfig/ it'd be correct I guess. ",
              "createdAt": "2021-08-04T20:07:27Z",
              "updatedAt": "2021-08-04T20:07:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIyNjkzMjYz",
          "commit": {
            "abbreviatedOid": "ef07fea"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-04T20:09:37Z",
          "updatedAt": "2021-08-04T20:09:38Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Yes, the backend and client-facing servers do need to work out how they delegate this information. This has nothing to do with config_ids. The keys are a property of the client-facing server, one that will rotate over time, and the backend's DNS needs to somehow present those keys.\r\n\r\nIf the backend server and client-facing server share enough infrastructure (particularly shared versions of Shared Mode), maybe the client-facing server's provisioning process is able to directly configures the backend server's DNS. More likely, I expect the backend server will delegate the name with a CNAME or AliasForm HTTPS record.\r\n\r\nThis is the same sort of deployment decisions folks already go through with A/AAAA records.",
              "createdAt": "2021-08-04T20:09:38Z",
              "updatedAt": "2021-08-04T20:10:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIyNjk1NDY5",
          "commit": {
            "abbreviatedOid": "ef07fea"
          },
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-04T20:12:16Z",
          "updatedAt": "2021-08-04T20:12:16Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Sorry, but doesn't the protocol need to support the case where the split-mode backend's DNS operator is independent of all client-facing servers? If not, I've a problem with that. If so, then we can get config_id collisions, even if those aren't much of a problem. (We are after all only arguing here about the example to illustrate a SHOULD so it's not the end of the world:-)",
              "createdAt": "2021-08-04T20:12:16Z",
              "updatedAt": "2021-08-04T20:12:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIyNzA2NDY3",
          "commit": {
            "abbreviatedOid": "ef07fea"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-04T20:25:53Z",
          "updatedAt": "2021-08-04T20:25:53Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "The DNS isn't the scope we care about for collisions in the first place. It sounds like there's some misunderstanding here as to what the config_id is even for. I agree the current text is not right. However, this PR does not fix it. \"Any known ECHConfig\" is also weird after you've rotated 256 times.\r\n\r\nLet's take a step back here: we're encrypting a message for the client-facing server, which then dispatches to a backend server. An ECHConfig is a property of the client-facing server. It's the one generating the keys, etc. In fact, the backend server may not even have the key.\r\n\r\nIn the DNS, we *typically* only need one ECHConfig per route, because the client is ultimately going to just pick one. The multiplicity in the ECHConfigList is purely so a client-facing server can simultaneously support draft-13 and the final draft, or X25519 and fancy-future-post-quantum-KEM.\r\n\r\nHowever, we never design systems with unrotatable keys. That means, at some point, the client-facing server is going to generate a new a key and update DNS. DNS is cached, TTLs are lies, etc., so old DNS entries may still be used for a while after rotation.\r\n\r\nThat means the client-facing server needs to support a _window_ of ECHConfigs, perhaps the last week or so's worth, to avoid service interrupts. This window is *larger* than what's in DNS because, again, DNS only really needs the current ones.\r\n\r\nWhen the client-facing server gets a ClientHello, it needs to know which of those to use. It can either trial-decrypt, or it can filter on config_id. Trial decryption means, for every config you keep around, you have to do that many HPKE operations. That is poor performance and a DoS risk. Thus, we have a config_id, enough to disambiguate however many entries the client-facing server needs to keep alive. You *can* reuse config_ids, just, if you want to avoid trial decryption, you must have retired the old one first.\r\n\r\nThat means, when a client-facing server generates new keys, it should do so in a way that avoids collisions with any existing *active* ones. Rejection sampling is one strategy. Just incrementing and cycling IDs is another. (TBH, cycling seems simpler.)\r\n\r\nAll of this is relative to one client-facing server. If you use both CDN-A and CDN-B, A and B have separate sets of active keys and separate config ID spaces. There is no need for them to coordinate because we don't care about config_id collisions. CDN-A is never going to try one of CDN-B's keys.\r\n\r\nI'll take a stab at rewriting this.",
              "createdAt": "2021-08-04T20:25:53Z",
              "updatedAt": "2021-08-04T20:25:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIyNzA4MDc3",
          "commit": {
            "abbreviatedOid": "ef07fea"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-04T20:27:46Z",
          "updatedAt": "2021-08-04T20:27:46Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "> Sorry, but doesn't the protocol need to support the case where the split-mode backend's DNS operator is independent of all client-facing servers?\r\n\r\nThat's what CNAMEs and AliasForm records are for, no? Or do you mean independent as in without any pointers to the client-facing server at all? Even without ECHConfigs, you need to point at the client-facing server's A/AAAA records, no?\r\n\r\n>  If so, then we can get config_id collisions, even if those aren't much of a problem?\r\n\r\nAgain, collisions across client-facing servers aren't relevant to the protocol at all. See my comment above. I think you are misunderstanding what this is even doing.",
              "createdAt": "2021-08-04T20:27:46Z",
              "updatedAt": "2021-08-04T20:27:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIyNzEwNjA0",
          "commit": {
            "abbreviatedOid": "ef07fea"
          },
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-04T20:30:41Z",
          "updatedAt": "2021-08-04T20:30:42Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "I agree with all the above except the misunderstanding bit:-) The \"no need for them to co-ordinate\" at the end is important IMO and one reason the original \"MUST not publish collisions\" was wrong. s/MUST/SHOULD/ and s/valid/known active/ would be enough of a fix for me fwiw if you prefer minimalism:-)",
              "createdAt": "2021-08-04T20:30:42Z",
              "updatedAt": "2021-08-04T20:30:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIyNzE5ODcy",
          "commit": {
            "abbreviatedOid": "ef07fea"
          },
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-04T20:42:12Z",
          "updatedAt": "2021-08-04T20:42:13Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Collisions across client-facing servers would be relevant if the MUST not publish remained. I don't believe I'm misunderstanding config_id thanks:-)\r\n\r\nCNAMEs etc are one way of doing things and likely will be most used.  But a backend is not in a position to say to a likely much larger CDN - hey please change your config_id because that other big CDN used the same one;-) So if we want the protocol to allow the backend to choose any DNS operator (unrelated to all CDNs) then the MUST NOT was wrong but so was the assumption that one CDN could entirely avoid config_id collisions *in the DNS* via iteration at key gen time.",
              "createdAt": "2021-08-04T20:42:12Z",
              "updatedAt": "2021-08-04T20:42:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIyNzI1MDIz",
          "commit": {
            "abbreviatedOid": "ef07fea"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-04T20:48:30Z",
          "updatedAt": "2021-08-04T20:48:31Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Ah yeah, the sentence is just wrong all around. :-) It both should be a SHOULD, not a MUST, but the SHOULD is also wrong because it should be about an individual client-facing server, and not the backend at all.\r\n\r\n(I'm reworking that text now, which hopefully avoids this. Will upload a PR when that's done.)",
              "createdAt": "2021-08-04T20:48:30Z",
              "updatedAt": "2021-08-04T20:48:31Z"
            }
          ]
        }
      ]
    },
    {
      "number": 488,
      "id": "MDExOlB1bGxSZXF1ZXN0NzAzOTEzNjY3",
      "title": "sensible-pickers",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/488",
      "state": "MERGED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Not sure if this is needed, but I guess it would be another way to generate failures;-)",
      "createdAt": "2021-08-04T19:37:04Z",
      "updatedAt": "2021-08-05T22:27:34Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "7e79d8571880b6c87080d7fc86b370d00141b3d6",
      "headRepository": "sftcd/draft-ietf-tls-esni",
      "headRefName": "sensible-pickers",
      "headRefOid": "9040bb0e370faa9513b6acc4f203490c18df2213",
      "closedAt": "2021-08-05T22:27:34Z",
      "mergedAt": "2021-08-05T22:27:34Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "dd6febce17490c0309ce60c83fb86296543deb9f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIzODQ0OTI2",
          "commit": {
            "abbreviatedOid": "fd8ad71"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Good clarification! This was already somewhat in the real-ech section, so I just replaced this with a forward pointer there. ",
          "createdAt": "2021-08-05T22:27:03Z",
          "updatedAt": "2021-08-05T22:27:24Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nClientHelloInner. See {{real-ech}} for how clients choose from this list.\r\n```",
              "createdAt": "2021-08-05T22:27:03Z",
              "updatedAt": "2021-08-05T22:27:24Z"
            }
          ]
        }
      ]
    },
    {
      "number": 489,
      "id": "MDExOlB1bGxSZXF1ZXN0NzAzOTYzMDQ1",
      "title": "fe0c->fe0d",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/489",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This'd probably have been caught but just in case:-)",
      "createdAt": "2021-08-04T20:21:54Z",
      "updatedAt": "2021-08-04T20:23:16Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "722f5e9175c9adb154ec54d74762cc2707c0546b",
      "headRepository": "sftcd/draft-ietf-tls-esni",
      "headRefName": "codepoint",
      "headRefOid": "2aea6469c3373639e4fa839828bca6e02da1f682",
      "closedAt": "2021-08-04T20:22:56Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "and indeed it was:-)",
          "createdAt": "2021-08-04T20:22:56Z",
          "updatedAt": "2021-08-04T20:22:56Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": ":-)",
          "createdAt": "2021-08-04T20:23:16Z",
          "updatedAt": "2021-08-04T20:23:16Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 490,
      "id": "MDExOlB1bGxSZXF1ZXN0NzA0MDIzNTU3",
      "title": "Clarify a bit why server might send retry configs",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/490",
      "state": "MERGED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Current text seemed a bit opaque as to why a server might send retry configs.",
      "createdAt": "2021-08-04T21:14:32Z",
      "updatedAt": "2021-08-05T22:35:06Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "dd6febce17490c0309ce60c83fb86296543deb9f",
      "headRepository": "sftcd/draft-ietf-tls-esni",
      "headRefName": "maydoretry",
      "headRefOid": "e701a18b98d10cbc84a42a49982044a2b84479e7",
      "closedAt": "2021-08-05T22:35:06Z",
      "mergedAt": "2021-08-05T22:35:06Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "27cc51ad3f295ad76bcf19cbb16c1514c4e5765b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIzODQ3OTYx",
          "commit": {
            "abbreviatedOid": "4bc62d0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-05T22:33:40Z",
          "updatedAt": "2021-08-05T22:33:45Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nWhen a client offers the `outer` version of an \"encrypted_client_hello\"\r\nextension, the server MAY include an \"encrypted_client_hello\" extension in its\r\nEncryptedExtensions message, as described in {{client-facing-server}}, with the\r\nfollowing payload:\r\n```\r\n\r\nRather than duplicate text, this just drops a forward pointer to where the rationale is spelled out in more detail.",
              "createdAt": "2021-08-05T22:33:40Z",
              "updatedAt": "2021-08-05T22:33:45Z"
            }
          ]
        }
      ]
    },
    {
      "number": 491,
      "id": "MDExOlB1bGxSZXF1ZXN0NzA0MDQwODcz",
      "title": "Expand on config_ids.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/491",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@sftcd, how does this look to you?\r\n\r\nThe discussion on how to allocate config_ids made it very unclear\r\nwhether we cared about collisions in DNS or across client-facing\r\nservers. (The former is insufficient and the latter is practically\r\nimpossible.) Instead, pull this into a separate section, so we can be\r\nclear this is a recommendation for the client-facing server and the\r\nbackend server.\r\n\r\nAlso downgrade from MUST to SHOULD because collisions work fine, just\r\ndon't perform as well.\r\n\r\nIt was also weird that we talked about config_id in not the section\r\nabout config_ids, but in the little side note about HpkeKeyConfig.",
      "createdAt": "2021-08-04T21:28:56Z",
      "updatedAt": "2021-08-05T21:42:56Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "722f5e9175c9adb154ec54d74762cc2707c0546b",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "config-ids",
      "headRefOid": "0a036dfea07930bd7f78df2192ee7006b5fe5928",
      "closedAt": "2021-08-05T21:42:56Z",
      "mergedAt": "2021-08-05T21:42:56Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "49ff82f0bcf69a596485641e2f2ed3333c4bdaf5"
      },
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I went with \"known\" instead of \"active\" since {{client-facing-server}} already used \"known\". It just never defined it, so I guess now we have a definition or sorts. :-)",
          "createdAt": "2021-08-04T21:30:18Z",
          "updatedAt": "2021-08-04T21:30:18Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 04/08/2021 22:29, David Benjamin wrote:\n> @sftcd, how does this look to you?\n\nThat looks good, better than I'd suggested.\n\nI guess I'll close the other one in a few minutes (just to\ngive someone time to correct me that that's not the right\nbutton-pushing:-)\n\nThanks,\nS.\n\n> \n> The discussion on how to allocate config_ids made it very unclear\n> whether we cared about collisions in DNS or across client-facing\n> servers. (The former is insufficient and the latter is practically\n> impossible.) Instead, pull this into a separate section, so we can be\n> clear this is a recommendation for the client-facing server and the\n> backend server.\n> \n> Also downgrade from MUST to SHOULD because collisions work fine, just\n> don&#39;t perform as well.\n> \n> It was also weird that we talked about config_id in not the section\n> about config_ids, but in the little side note about HpkeKeyConfig.\n> You can view, comment on, or merge this pull request online at:\n> \n>    https://github.com/tlswg/draft-ietf-tls-esni/pull/491\n> \n> -- Commit Summary --\n> \n>    * Expand on config_ids.\n> \n> -- File Changes --\n> \n>      M draft-ietf-tls-esni.md (32)\n> \n> -- Patch Links --\n> \n> https://github.com/tlswg/draft-ietf-tls-esni/pull/491.patch\n> https://github.com/tlswg/draft-ietf-tls-esni/pull/491.diff\n> \n",
          "createdAt": "2021-08-04T21:33:25Z",
          "updatedAt": "2021-08-04T21:33:25Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIzODIwNTQw",
          "commit": {
            "abbreviatedOid": "cd04387"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-05T21:41:09Z",
          "updatedAt": "2021-08-05T21:42:42Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "```suggestion\r\nprevious values that may still be in use, since clients may cache DNS records\r\nup to a TTL or longer.\r\n```",
              "createdAt": "2021-08-05T21:41:09Z",
              "updatedAt": "2021-08-05T21:42:42Z"
            },
            {
              "originalPosition": 40,
              "body": "```suggestion\r\nallocate distinct `config_id` values for each ECHConfig in its known set. The\r\nRECOMMENDED strategy is via rejection sampling, i.e., to randomly select\r\n`config_id` repeatedly until it does not match any known ECHConfig.\r\n```",
              "createdAt": "2021-08-05T21:42:26Z",
              "updatedAt": "2021-08-05T21:42:43Z"
            }
          ]
        }
      ]
    },
    {
      "number": 492,
      "id": "MDExOlB1bGxSZXF1ZXN0NzA0MDYzNzQw",
      "title": "Bit more text on nominal backend processing",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/492",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "A description of handling this case seemed to be missing as I read through the draft. (It may be stated later, not sure, if so I'll close this.) \r\n\r\nThis does raise the knotty issue of protecting the ClientHelloInner between the client-facing server and backend, but I guess the best can say for now is just that we're not defining protocol for that here/now.",
      "createdAt": "2021-08-04T21:46:16Z",
      "updatedAt": "2021-08-09T19:11:40Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "722f5e9175c9adb154ec54d74762cc2707c0546b",
      "headRepository": "sftcd/draft-ietf-tls-esni",
      "headRefName": "nominalbackend",
      "headRefOid": "67cb5ead1d84294169c4854bd0cdabb209344d85",
      "closedAt": "2021-08-09T19:11:39Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I _think_ it's already in here, but the draft certainly could do with an editorial pass to make this clearer. (I made an attempt to clean up some of the client earlier, but I didn't get to the server.) The text is kinda scattered all over the place. Here's my read:\r\n\r\n* If you're a server, the Server Behavior section applies to you\r\n* If you see type `inner`, that section says to jump to the Backend Server section\r\n* That section says you do the `accept_confirmation` thingy, but otherwise doesn't modify the handshake.\r\n\r\nIt is likely the case that, as you say, you got something from a client-facing server. Although it's also possible the client decided to send you the extension for no particularly coherent reason. Folks wanted Split Mode to work without direct client-facing/backend coordination, so... okay we all that. :-)",
          "createdAt": "2021-08-04T22:26:19Z",
          "updatedAt": "2021-08-04T22:26:19Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, I'll just close this if it turns out not needed but in a linear reading, it seemed missing. \r\n\r\nWRT seeing inner as a backend (or ech_is_inner in my draft-10 code) - for the split mode backend I ended up making it a configuration setting as to whether the server will barf on that or assume it's come from a client-facing server so that'd kinda mean such server instances need to run on their own port maybe, just for tidiness. But I'm not sure what a misbehaving client might win from directly connecting to a backend and pretending to be a client-facing server. One for the security analysis to cover maybe. ",
          "createdAt": "2021-08-04T22:41:31Z",
          "updatedAt": "2021-08-04T22:41:31Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "By \"barf on that\", do you mean report an error? I don't believe that is supported by any text in the specification. If you want to make acting as a backend server configurable, the extension should be ignored when off, as is the default with any TLS extension.",
          "createdAt": "2021-08-05T19:26:01Z",
          "updatedAt": "2021-08-05T19:26:13Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\nHiya,\n\nOn 05/08/2021 20:26, David Benjamin wrote:\n> By \"barf on that\", do you mean report an error? \n\nWould have to look TBH, but I think so, some sort of\nmalformed extensions error or something.\n\n> I don't believe that\n> is supported by any text in the specification. If you want to make\n> acting as a backend server configurable, the extension should be\n> ignored when off.\n\nGenerally, it is.\n\nBut, again for draft-10, I think I generate an error when I\nencounter ech_is_inner in an outer CH, except if the server\nis explicitly configured as a split-mode backend. (And I\ndo similarly for outer_extensions when not expected.)\n\nI'd likely do the same for draft-13, generating an error on\nECH.type==inner if not configured as a split-mode backend.\n\nBut if there's a good reason to accept such, that'd be ok\ntoo I  think, even if it ought not happen. Is there such a\nreason?\n\n(I don't think Postel's principle applies when one does\nknow the semantics of an extension and you encounter it\nwhen you ought not.)\n\nCheers,\nS.\n\n",
          "createdAt": "2021-08-05T19:47:11Z",
          "updatedAt": "2021-08-05T19:47:11Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure this is needed, partly for the reasons @davidben points out. If the backend server doesn't recognize the extension, because it simply doesn't have ECH support or if it's not been enabled, the default posture should probably be to ignore the extension and carry on. ",
          "createdAt": "2021-08-05T22:52:38Z",
          "updatedAt": "2021-08-05T22:52:38Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with @chris-wood: \"what to do if an extension isn't enabled\" is just basic TLS extension semantics.\r\n",
          "createdAt": "2021-08-05T22:54:57Z",
          "updatedAt": "2021-08-05T22:54:57Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sftcd given the above, I propose we close that out, unless there's still additional clarification needed or wanted?",
          "createdAt": "2021-08-09T17:46:35Z",
          "updatedAt": "2021-08-09T17:46:35Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "Everyone else seems happy this was covered, so that's fine.",
          "createdAt": "2021-08-09T19:11:39Z",
          "updatedAt": "2021-08-09T19:11:39Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIzOTU3NTg4",
          "commit": {
            "abbreviatedOid": "67cb5ea"
          },
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-06T03:46:43Z",
          "updatedAt": "2021-08-06T03:46:44Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Why does \"`inner`\" get backticks but \"outer\" does not?",
              "createdAt": "2021-08-06T03:46:43Z",
              "updatedAt": "2021-08-06T03:46:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 493,
      "id": "MDExOlB1bGxSZXF1ZXN0NzA0MTA1MDY0",
      "title": "A bit more text to introduce EncodedClientHelloInner",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/493",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Could probably be done lots of other ways but something like this seems needed to introduce EncodedClientHelloInner.",
      "createdAt": "2021-08-04T22:23:42Z",
      "updatedAt": "2021-08-05T22:19:35Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "722f5e9175c9adb154ec54d74762cc2707c0546b",
      "headRepository": "sftcd/draft-ietf-tls-esni",
      "headRefName": "eci",
      "headRefOid": "4c13885acfead77d2ae25c18093487e18e41c01e",
      "closedAt": "2021-08-05T22:19:35Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "oops - ignore the 1st block of changes those are from another PR",
          "createdAt": "2021-08-04T22:27:27Z",
          "updatedAt": "2021-08-04T22:27:27Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Nice catch! I actually think we should go further and just straight-up define the structure first. How do you feel about https://github.com/tlswg/draft-ietf-tls-esni/pull/503?",
          "createdAt": "2021-08-05T17:03:44Z",
          "updatedAt": "2021-08-05T17:03:44Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 05/08/2021 18:03, David Benjamin wrote:\n> Nice catch! I actually think we should go further and just\n> straight-up define the structure first. How do you feel about\n> https://github.com/tlswg/draft-ietf-tls-esni/pull/503?\n\nLGTM\n\nCheers,\nS.\n\n> \n",
          "createdAt": "2021-08-05T17:27:01Z",
          "updatedAt": "2021-08-05T17:27:01Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favor of #503.",
          "createdAt": "2021-08-05T22:19:35Z",
          "updatedAt": "2021-08-05T22:19:35Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 494,
      "id": "MDExOlB1bGxSZXF1ZXN0NzA0MTg5Mzgy",
      "title": "config IDs aren't really optional",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/494",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Maybe calling 'em random is better?",
      "createdAt": "2021-08-04T23:54:46Z",
      "updatedAt": "2021-08-04T23:56:31Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "722f5e9175c9adb154ec54d74762cc2707c0546b",
      "headRepository": "sftcd/draft-ietf-tls-esni",
      "headRefName": "randomconfigid",
      "headRefOid": "175c3c899a93a640e051a3f9e886d0861b98f65b",
      "closedAt": "2021-08-04T23:56:31Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "Feck - mucked up the branch again, will close and open another.",
          "createdAt": "2021-08-04T23:56:31Z",
          "updatedAt": "2021-08-04T23:56:31Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 495,
      "id": "MDExOlB1bGxSZXF1ZXN0NzA0MjA2MzQ2",
      "title": "optional configids seems wrong, maybe random is better?",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/495",
      "state": "MERGED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "minor suggested change",
      "createdAt": "2021-08-05T00:14:21Z",
      "updatedAt": "2021-08-09T17:24:26Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "f7d85494bab46b6f33ec6b43bb4528d96dc01afe",
      "headRepository": "sftcd/draft-ietf-tls-esni",
      "headRefName": "randomconfigid",
      "headRefOid": "da5866cc3e2a515c7ffaa0fa01b4c011e3f760a5",
      "closedAt": "2021-08-09T17:24:26Z",
      "mergedAt": "2021-08-09T17:24:25Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "0ab7a4d5b55a29517ad3bdf65a5ee42c88305eb9"
      },
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nHiya,\n\nOn 05/08/2021 22:50, Christopher Wood wrote:\n> @chris-wood requested changes on this pull request.\n> \n> \n> \n>> `config_id` SHOULD be set to a randomly generated byte in the\n>> first\n> -ClientHelloOuter and MUST be left unchanged for the second\n> ClientHelloOuter. +ClientHelloOuter and, in the event of HRR, MUST be\n> left unchanged for +the second ClientHelloOuter.\n> \n> The intent was to say that optional IDs are to be implemented as\n> random IDs, i.e., if you don't care about IDs (hence optional), \n\nFor me, for a protocol element, \"optional\" means \"not\nincluded\" whereas here we're talking about \"optionally\nignoring the proposed value.\" (Yeah, I probably read\ntoo much ASN.1 once, or even twice:-)\n\n\"Random\" might not be right, but \"optional\" could maybe\nbriefly confuse an implementer.\n\n> then\n> just set them to a random byte. So I'm not inclined to take this\n> change.\n> \n> I _do_ like the clarification to include \"in the event of HRR\" -- can\n> we split that out into a separate PR?\n\nSure. (Not that I know how to do that easily, but feel free\nto just do it, or wait for me to figure it out tomorrow;-)\n\nCheers,\nS.\n\n\n> \n",
          "createdAt": "2021-08-06T00:07:22Z",
          "updatedAt": "2021-08-06T00:07:22Z"
        },
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "> For me, for a protocol element, \"optional\" means \"not\r\n> included\" whereas here we're talking about \"optionally\r\n> ignoring the proposed value.\"\r\n\r\nI agree.",
          "createdAt": "2021-08-06T03:28:42Z",
          "updatedAt": "2021-08-06T03:28:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "It's not possible to omit the config ID (it's a byte). It's only possible to not use it. Optional seems like a fine word to capture that. We could also say that it's unused or ignored? For example:\r\n\r\n```\r\nIf `config_id` is ignored as specified by an application profile or otherwise \r\nexternally configured, `config_id` SHOULD be set to a randomly generated byte\r\nin the first ClientHelloOuter and, in the event of HRR, MUST be left unchanged\r\nfor the second ClientHelloOuter.\r\n```\r\n\r\nOr something, with similar updates to the text and section titles. Would that work?",
          "createdAt": "2021-08-06T12:45:14Z",
          "updatedAt": "2021-08-06T16:17:22Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 06/08/2021 13:45, Christopher Wood wrote:\n> It's not possible to omit the config ID (it's a byte). It's only\n> possible to not use it. Optional seems like a fine word to capture\n> that.\n\nInteresting, (but unimportant:-) my take on those facts\nis the opposite.\n\n> We could also say that it's unused or ignored? For example:\n> \n> ``` If `config_id` is unused as specified by an application profile\n> or otherwise externally configured, `config_id` SHOULD be set to a\n> randomly generated byte in the first ClientHelloOuter and, in the\n> event of HRR, MUST be left unchanged for the second\n> ClientHelloOuter. ```\n> \n> Or something, with similar updates to the text and section titles.\n> Would that work?\n\nFor me: \"ignored\" is ok, \"unused\" is as odd as \"optional.\"\n\nCheers,\nS.\n",
          "createdAt": "2021-08-06T13:02:32Z",
          "updatedAt": "2021-08-06T13:02:32Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sftcd updated the proposal above to use \"ignored\". Does that work?",
          "createdAt": "2021-08-06T16:17:40Z",
          "updatedAt": "2021-08-06T16:17:40Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 06/08/2021 17:17, Christopher Wood wrote:\n> @sftcd updated the proposal above to use \"ignored\". Does that work?\n\nSure. Thanks,\nS\n\n> \n",
          "createdAt": "2021-08-06T16:18:20Z",
          "updatedAt": "2021-08-06T16:18:20Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Great! Could you please update this PR to match?",
          "createdAt": "2021-08-06T16:43:39Z",
          "updatedAt": "2021-08-06T16:43:39Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "I think I've made those changes now. ",
          "createdAt": "2021-08-09T15:48:19Z",
          "updatedAt": "2021-08-09T15:48:19Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIzODI1NzMy",
          "commit": {
            "abbreviatedOid": "041fd26"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-08-05T21:50:08Z",
          "updatedAt": "2021-08-05T21:50:11Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "The intent was to say that optional IDs are to be implemented as random IDs, i.e., if you don't care about IDs (hence optional), then just set them to a random byte. So I'm not inclined to take this change.\r\n\r\nI _do_ like the clarification to include \"in the event of HRR\" -- can we split that out into a separate PR?",
              "createdAt": "2021-08-05T21:50:08Z",
              "updatedAt": "2021-08-05T21:50:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI1NjI3MTUy",
          "commit": {
            "abbreviatedOid": "1fb9c6b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-09T17:19:15Z",
          "updatedAt": "2021-08-09T17:19:15Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI1NjI5NDAw",
          "commit": {
            "abbreviatedOid": "1fb9c6b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-09T17:21:50Z",
          "updatedAt": "2021-08-09T17:21:51Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nClientHelloOuter and, in the event of HRR, MUST be left unchanged for\r\n```",
              "createdAt": "2021-08-09T17:21:51Z",
              "updatedAt": "2021-08-09T17:21:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI1NjMwNjY1",
          "commit": {
            "abbreviatedOid": "2328adc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-09T17:23:18Z",
          "updatedAt": "2021-08-09T17:23:19Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "```suggestion\r\nUnless specified by the application using (D)TLS or externally configured,\r\n```",
              "createdAt": "2021-08-09T17:23:18Z",
              "updatedAt": "2021-08-09T17:23:19Z"
            }
          ]
        }
      ]
    },
    {
      "number": 496,
      "id": "MDExOlB1bGxSZXF1ZXN0NzA0Njc5ODQy",
      "title": "Clarify cardinality via the use of the (non-redudant:-) length field",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/496",
      "state": "MERGED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The goal here is really to provide more clarify about cardinality, if there's a better way or place to do that, that'd be fine.",
      "createdAt": "2021-08-05T12:53:13Z",
      "updatedAt": "2021-08-06T00:06:53Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "722f5e9175c9adb154ec54d74762cc2707c0546b",
      "headRepository": "sftcd/draft-ietf-tls-esni",
      "headRefName": "clarifylength",
      "headRefOid": "6ca8b81ec7ec622c4025ef1751d910f7451730d5",
      "closedAt": "2021-08-05T21:48:01Z",
      "mergedAt": "2021-08-05T21:48:01Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "c6620e38a9fcb2cb438a14961be93c4b60bf684f"
      },
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't believe this is necessary. This idiom is well understood in TLS and this just appears to be excess verbiage.",
          "createdAt": "2021-08-05T15:30:51Z",
          "updatedAt": "2021-08-05T15:30:51Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\nHiya,\n\n(As with all these PRs, I'm ok if they're not accepted...)\n\nOn 05/08/2021 22:48, Christopher Wood wrote:\n> @chris-wood approved this pull request.\n> \n> \n> \n>> +: The length, in bytes, of the next field. One primary method of\n> +distributing ECHConfig values is via the DNS\n> +{{!HTTPS-RR=I-D.ietf-dnsop-svcb-https}} where they may be found in HTTPS or\n> +SVCB records that can (and will commonly) contain a list of ECHConfig values\n> +using the ECHConfigList syntax defined below.  This length field allows\n> +implementations to skip over the elements in such a list where they cannot\n> +parse the specific version of ECHConfig.\n> \n> ```suggestion\n> : The length, in bytes, of the next field. This length field allows\n> implementations to skip over the elements in such a list where they cannot\n> parse the specific version of ECHConfig.\n> ```\n\nFor me, that is better than the original, but I do think we\nought state the expected cardinality that implementers need\nto handle somewhere. I reckon it's better to not assume\nimplementers are very familiar with SVCB as for libraries at\nleast, the DNS stuff happens elsewhere. They will have to\nfigure that out eventually, but better to say it somewhere\nexplicitly I think, or we may face some important code base\nthat doesn't handle >1 public key when it ought.\n\nCheers,\nS.\n",
          "createdAt": "2021-08-06T00:06:53Z",
          "updatedAt": "2021-08-06T00:06:53Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIzODI0Mzk1",
          "commit": {
            "abbreviatedOid": "d6889bc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-05T21:47:47Z",
          "updatedAt": "2021-08-05T21:47:51Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "```suggestion\r\n: The length, in bytes, of the next field. This length field allows\r\nimplementations to skip over the elements in such a list where they cannot\r\nparse the specific version of ECHConfig.\r\n```",
              "createdAt": "2021-08-05T21:47:47Z",
              "updatedAt": "2021-08-05T21:47:51Z"
            }
          ]
        }
      ]
    },
    {
      "number": 497,
      "id": "MDExOlB1bGxSZXF1ZXN0NzA0NzAwNDM0",
      "title": "Try clarify an odd MUST in 6.1.5",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/497",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "6.1.5 says \"This message MUST be syntactically valid.\" I'm not entirely sure what was intended there, so took a stab at clarifying. In any case as-is that sentence doesn't really seem to say anything useful.\r\n\r\nMy suggestion assumes that enc is included as part of the ECH in the AAD used with HRR. Given we omit enc from the 2nd ECH as-sent that seems a bit wrong so may need a few more words.\r\n\r\nNote that the next bullet talks about using the \"emtpy string for enc\" - not sure if \"empty string\" precise enough but if we omit enc from both AAD and ECH (during HRR) we may need align how we describe things. ",
      "createdAt": "2021-08-05T13:18:12Z",
      "updatedAt": "2021-08-09T19:26:27Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "722f5e9175c9adb154ec54d74762cc2707c0546b",
      "headRepository": "sftcd/draft-ietf-tls-esni",
      "headRefName": "syntaxmust",
      "headRefOid": "86aa9aaab6f1a54869c105c927def17693ae6505",
      "closedAt": "2021-08-09T19:10:53Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed but opened issue #515 so we can re-visit later.",
          "createdAt": "2021-08-09T19:10:53Z",
          "updatedAt": "2021-08-09T19:10:53Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIzNDkzNzIz",
          "commit": {
            "abbreviatedOid": "86aa9aa"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "> Note that the next bullet talks about using the \"emtpy string for enc\" - not sure if \"empty string\" precise enough\r\n\r\nThere have been so many iterations over the how to say \"empty string\". I think this is where we settled last time? All the variations seem perfectly understandable to me. Can we please move on?\r\n\r\n> but if we omit enc from both AAD and ECH (during HRR) we may need align how we describe things.\r\n\r\nSince the AAD and ClientHelloOuter are both constructed from the same thing, they'll both always be empty or non-empty.",
          "createdAt": "2021-08-05T15:22:05Z",
          "updatedAt": "2021-08-05T15:25:24Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "This section doesn't even talk about constructing ClientHelloOuterAAD. Did you mean to cite something else? Though I'm not sure there is anything useful to cite here. I avoided citing {{real-ech}} when reorganizing this because that contains a ton of text specific to the first ClientHello.\r\n\r\n\"MUST be constructed afresh\" also does not seem particularly meaningful or accurate. Ultimately, the ClientHelloOuter wrapper is entirely pointless here. Both sides know it will be ignored. Some clients will find it easiest to apply RFC8446 rules (reuse some code), while others cannot because whether HelloRetryRequest will consistently apply to both depends on complex rules we never managed to write down. (This was the crux of the HelloRetryRequest fuss.) Since we didn't want to define a whole new message without all the extra baggage, this section just says to do whatever. And then maybe we'll learn something about interop needs during experimentation.",
              "createdAt": "2021-08-05T15:22:05Z",
              "updatedAt": "2021-08-05T15:25:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIzNTA5OTgx",
          "commit": {
            "abbreviatedOid": "86aa9aa"
          },
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-05T15:35:45Z",
          "updatedAt": "2021-08-05T15:35:45Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "So what was the intent of the original sentence? Maybe just deleting it would be fine, depending.",
              "createdAt": "2021-08-05T15:35:45Z",
              "updatedAt": "2021-08-05T15:35:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIzNTcwODgz",
          "commit": {
            "abbreviatedOid": "86aa9aa"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-05T16:35:02Z",
          "updatedAt": "2021-08-05T16:35:03Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "It probably can be dropped. It was mostly just \"the other side should be able to parse it\", which is probably implicit. We're in this weird situation where we're producing a ClientHelloOuter2 that may well not be consistent with ClientHelloOuter1 + HelloRetryRequest. But both sides have agreed it's meaningless... we're only sending it because I guess we haven't defined a better message.\r\n\r\nThere is probably a less goofy design buried in here somewhere. :-)",
              "createdAt": "2021-08-05T16:35:03Z",
              "updatedAt": "2021-08-05T16:35:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIzODUzNDcy",
          "commit": {
            "abbreviatedOid": "86aa9aa"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-05T22:46:11Z",
          "updatedAt": "2021-08-05T22:46:13Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "I propose we park this for now and file an issue to ask ourselves if we want a new message for this second CHOuter. @davidben or @sftcd, would one of you mind filing that issue?",
              "createdAt": "2021-08-05T22:46:11Z",
              "updatedAt": "2021-08-05T22:46:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI1NzE5MDcw",
          "commit": {
            "abbreviatedOid": "86aa9aa"
          },
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-09T19:08:46Z",
          "updatedAt": "2021-08-09T19:08:46Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Ah - the \"both sides have agreed it's meaningless\" finally enlightened me - what the original odd MUST meant is \"the client hello outer2 is mostly useless, but MUST be well formed even so\". I'm fine if we park that, just delete the odd sentence or replace with whatever the editors' think better.",
              "createdAt": "2021-08-09T19:08:46Z",
              "updatedAt": "2021-08-09T19:08:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI1NzMyODUz",
          "commit": {
            "abbreviatedOid": "86aa9aa"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-09T19:26:27Z",
          "updatedAt": "2021-08-09T19:26:27Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Parking SGTM. I am also okay deleting the sentence. I agree with you it's not really meaningful. I also agree this whole situation is confusing and silly. :-)",
              "createdAt": "2021-08-09T19:26:27Z",
              "updatedAt": "2021-08-09T19:26:27Z"
            }
          ]
        }
      ]
    },
    {
      "number": 498,
      "id": "MDExOlB1bGxSZXF1ZXN0NzA0NzExOTk3",
      "title": "retry configs: tweak about subsequent connections ",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/498",
      "state": "MERGED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "When retry-configs are defined in section 5 we say they are for \"subsequent connection attempts\" but in 6.1.6 we have a MUST NOT for using those for \"subsequent connections.\" That seems inconsistent and maybe even wrong if one thinks about how e.g. wget can crawl web pages, or how applications might use libcurl, so this change tries to fix that. Not sure if short duration is the right way to phrase it though.",
      "createdAt": "2021-08-05T13:32:23Z",
      "updatedAt": "2021-08-09T17:44:10Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "722f5e9175c9adb154ec54d74762cc2707c0546b",
      "headRepository": "sftcd/draft-ietf-tls-esni",
      "headRefName": "whatabaoutcrawling",
      "headRefOid": "66c295f842a0e877a76d6dc7ee0db1fcf65319a1",
      "closedAt": "2021-08-09T17:44:10Z",
      "mergedAt": "2021-08-09T17:44:10Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "62939b89688fd074b7d5c16f54e8c6f701160978"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIzNTAyMTYy",
          "commit": {
            "abbreviatedOid": "090fe34"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-05T15:28:50Z",
          "updatedAt": "2021-08-05T15:28:50Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Using a duration across the entire client application would introduce exactly the tracking vector the text was written to prevent. This allows information to flow across application contexts if, during that duration, two contexts need to talk to the same origin.\r\n\r\nThe intent of this text was that you do it just for exactly the one high-level connection attempt (the client application likely has a \"connect to server with these parameters\" procedure somewhere) and nothing else. That is, you use it _exactly_ once, and within the same application context.\r\n\r\nThat is, \"subsequent connections\" refers to the ones after the retry connection.",
              "createdAt": "2021-08-05T15:28:50Z",
              "updatedAt": "2021-08-05T15:28:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIzNTEzNzQ0",
          "commit": {
            "abbreviatedOid": "090fe34"
          },
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-05T15:39:10Z",
          "updatedAt": "2021-08-05T15:39:10Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "- The existing uses of \"subsequent\" are still conflicting.\r\n- I get the tracking issue, but wonder what'd we expect wget to do if asked to crawl a site? It seems wrong to expect it to try/fail/try-again for every URL and better to use a retry_config that worked for the all the requests corresponding to one command line invocation.\r\n- I agree \"duration\" isn't great though.",
              "createdAt": "2021-08-05T15:39:10Z",
              "updatedAt": "2021-08-05T15:39:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIzNTMzOTQ4",
          "commit": {
            "abbreviatedOid": "090fe34"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-05T15:58:15Z",
          "updatedAt": "2021-08-05T15:58:15Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Yup, agreed that the \"subsequent\" is unclear. Sorry, I was just trying to explain the intent, so the PR could rephrase it better.\r\n\r\n> It seems wrong to expect it to try/fail/try-again for every URL and better to use a retry_config that worked for the all the requests corresponding to one command line invocation.\r\n\r\nHTTP connection reuse would smooth it over (which needs to define its tracking vector implications elsewhere) but, yes, there is definitely room to be more permissive here. I wrote this bit originally, and my aim was to write down the simplest thing possible because:\r\n\r\n* At the time, we hadn't resolved the multi-CDN issue, so it was unclear how a sticky signal would work. Now we have, so this is possible to resolve, if we want to. (It's only good for those cached DNS entries.)\r\n* I didn't want to go down a huge rabbithole to define how stickiness would interact with the client application's correlation goals, at least not when introducing an error correction case. As we saw from the other discussion and the introduction of a tracking vector in this PR, tracking is a complex domain-specific problem and people tend to get very confused when you try to actually define it. \ud83d\ude04\r\n\r\nI'm not opposed to defining a more sticky option, though it's no longer an editorial change and we'd need to include solutions to the above problems. (Given it's a lot more fuss, my inclination at the time was to leave it alone until/unless we learn it's a problem.)",
              "createdAt": "2021-08-05T15:58:15Z",
              "updatedAt": "2021-08-05T16:01:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIzNTYxMDYw",
          "commit": {
            "abbreviatedOid": "090fe34"
          },
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-05T16:25:01Z",
          "updatedAt": "2021-08-05T16:25:01Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "So how about saying something like \"clients MUST NOT continue to use an ECHConfig from a set of retry_configs for extended periods - ideally a client would only use such an ECHConfig once and ensure the ensuing TLS session is then used for multiple application messages. Clients SHOULD NOT establish multiple TLS sessions using one such ECHConfig unless there is no additional tracking risk.\"",
              "createdAt": "2021-08-05T16:25:01Z",
              "updatedAt": "2021-08-05T16:26:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIzNTYzNTk4",
          "commit": {
            "abbreviatedOid": "090fe34"
          },
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-05T16:27:36Z",
          "updatedAt": "2021-08-05T16:27:37Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Oh and btw, it's fair to say part of this isn't editorial and so should just be punted for later.",
              "createdAt": "2021-08-05T16:27:37Z",
              "updatedAt": "2021-08-05T16:27:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIzODUyNDk4",
          "commit": {
            "abbreviatedOid": "090fe34"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-05T22:43:52Z",
          "updatedAt": "2021-08-05T22:43:56Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nretry connection. The client MUST NOT use retry configurations for connections\r\nbeyond the retry. This avoids introducing pinning concerns or a tracking \r\nvector, should a malicious server present client-specific retry configurations\r\nin order to identify the client in a subsequent ECH handshake.\r\n```\r\n\r\nHow about this proposal which flips the text around somewhat and avoids the possible confusion around \"subsequent\" connections?",
              "createdAt": "2021-08-05T22:43:53Z",
              "updatedAt": "2021-08-05T22:43:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIzODUyNjI5",
          "commit": {
            "abbreviatedOid": "090fe34"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-05T22:44:09Z",
          "updatedAt": "2021-08-05T22:44:10Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "cc @davidben @sftcd ",
              "createdAt": "2021-08-05T22:44:09Z",
              "updatedAt": "2021-08-05T22:44:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI1NjQzODE1",
          "commit": {
            "abbreviatedOid": "090fe34"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-09T17:38:30Z",
          "updatedAt": "2021-08-09T17:38:30Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI1NjQ1MTc2",
          "commit": {
            "abbreviatedOid": "66c295f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-09T17:40:03Z",
          "updatedAt": "2021-08-09T17:40:03Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nbeyond the retry. This avoids introducing pinning concerns or a tracking\r\n```",
              "createdAt": "2021-08-09T17:40:03Z",
              "updatedAt": "2021-08-09T17:40:03Z"
            }
          ]
        }
      ]
    },
    {
      "number": 499,
      "id": "MDExOlB1bGxSZXF1ZXN0NzA0NzkxNzU0",
      "title": "trial decryption configuration - \"both sides\" seems wrong",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/499",
      "state": "MERGED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "7.1 said to not use trial decryption unless \"externally configured on both sides\" but there's no way to know that, so I think the \"on both sides\" ought be deleted unless something else was intended.",
      "createdAt": "2021-08-05T15:07:28Z",
      "updatedAt": "2021-08-05T21:57:27Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "722f5e9175c9adb154ec54d74762cc2707c0546b",
      "headRepository": "sftcd/draft-ietf-tls-esni",
      "headRefName": "bothsides",
      "headRefOid": "1223a2430d4bf323fb21be58da63811675d79e03",
      "closedAt": "2021-08-05T21:57:27Z",
      "mergedAt": "2021-08-05T21:57:27Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "e436a2eaaffe8f42bcfcf5d6bddce558e706237c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIzODI5ODEx",
          "commit": {
            "abbreviatedOid": "1223a24"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-05T21:57:23Z",
          "updatedAt": "2021-08-05T21:57:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 500,
      "id": "MDExOlB1bGxSZXF1ZXN0NzA0ODM5MzA2",
      "title": "ech_retry_requested is a gonner",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/500",
      "state": "MERGED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I'm guessing this is almost a typo.",
      "createdAt": "2021-08-05T16:09:28Z",
      "updatedAt": "2021-08-05T21:40:08Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "722f5e9175c9adb154ec54d74762cc2707c0546b",
      "headRepository": "sftcd/draft-ietf-tls-esni",
      "headRefName": "ech_retry_requested",
      "headRefOid": "3adb669d1a0167aa2e3dd9be047e5607e6cbbf02",
      "closedAt": "2021-08-05T21:40:08Z",
      "mergedAt": "2021-08-05T21:40:08Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "a1de0020de9ab72cb14163f5b425f20c86a5d25b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIzNTQ3MzMx",
          "commit": {
            "abbreviatedOid": "658b7e5"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-05T16:10:57Z",
          "updatedAt": "2021-08-05T16:10:57Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Nice catch! Perhaps:\r\n\r\n> the server will reject ECH and respond with \"retry_configs\"\r\n\r\n(I think, at the time, ech_retry_requested was part of the accept/reject signal.)",
              "createdAt": "2021-08-05T16:10:57Z",
              "updatedAt": "2021-08-05T16:10:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIzNTY0NTAx",
          "commit": {
            "abbreviatedOid": "658b7e5"
          },
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-05T16:28:30Z",
          "updatedAt": "2021-08-05T16:28:30Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Either fix is fine by me. ",
              "createdAt": "2021-08-05T16:28:30Z",
              "updatedAt": "2021-08-05T16:28:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIzODE5NzY3",
          "commit": {
            "abbreviatedOid": "658b7e5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-05T21:39:51Z",
          "updatedAt": "2021-08-05T21:39:51Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nserver will reject ECH and respond with \"retry_configs\". If the server does\r\nnot understand\r\n```",
              "createdAt": "2021-08-05T21:39:51Z",
              "updatedAt": "2021-08-05T21:39:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIzODE5ODY2",
          "commit": {
            "abbreviatedOid": "658b7e5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-05T21:40:01Z",
          "updatedAt": "2021-08-05T21:40:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 501,
      "id": "MDExOlB1bGxSZXF1ZXN0NzA0ODYxNDQw",
      "title": "Fix a bit of formatting and remove ref to resolved issue #384",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/501",
      "state": "MERGED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-08-05T16:42:33Z",
      "updatedAt": "2021-08-05T21:46:34Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "722f5e9175c9adb154ec54d74762cc2707c0546b",
      "headRepository": "sftcd/draft-ietf-tls-esni",
      "headRefName": "formatandabit",
      "headRefOid": "e846c37670dfd1d3928a1c88869e8c4815d342a6",
      "closedAt": "2021-08-05T21:46:34Z",
      "mergedAt": "2021-08-05T21:46:34Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "3f67240a567443311138115549268d628cc987d9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIzNjE0ODMy",
          "commit": {
            "abbreviatedOid": "e846c37"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-05T17:22:10Z",
          "updatedAt": "2021-08-05T17:22:10Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIzODIzNjQ2",
          "commit": {
            "abbreviatedOid": "e846c37"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-05T21:46:30Z",
          "updatedAt": "2021-08-05T21:46:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 502,
      "id": "MDExOlB1bGxSZXF1ZXN0NzA0ODY1MDM4",
      "title": "not sure if omitting CH in IANA registry for ech_outer_extensions is right or not",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/502",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I don't know and pretty much don't care, but just in case this is an error... One could argue that \"CH\" should be set of ech_outer_extensions. I'm fine if this is just closed without discussion if it's not an error. ",
      "createdAt": "2021-08-05T16:48:26Z",
      "updatedAt": "2021-08-05T21:59:57Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "722f5e9175c9adb154ec54d74762cc2707c0546b",
      "headRepository": "sftcd/draft-ietf-tls-esni",
      "headRefName": "iana",
      "headRefOid": "f127384a9346cd96c39ebfcf29a1554e14b15798",
      "closedAt": "2021-08-05T21:59:57Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I think omitting it is better because it's not allowed in any actual ClientHello message. But this depends on whether you believe EncodedClientHelloInner counts as a ClientHello, so either seems defensible. :-)",
          "createdAt": "2021-08-05T16:57:34Z",
          "updatedAt": "2021-08-05T16:57:34Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "My impression is that we consider EncodedClientHelloInner a transient representation of a ClientHello, but not an actual handshake message, so I think we can safely omit this.",
          "createdAt": "2021-08-05T21:59:56Z",
          "updatedAt": "2021-08-05T21:59:56Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 503,
      "id": "MDExOlB1bGxSZXF1ZXN0NzA0ODc0NDE4",
      "title": "Define EncodedClientHelloInner before outer extensions.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/503",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Inspired by @sftcd's #493. We can go further and just completely define EncodedClientHelloInner first.",
      "createdAt": "2021-08-05T17:03:21Z",
      "updatedAt": "2021-08-05T22:23:11Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "722f5e9175c9adb154ec54d74762cc2707c0546b",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "enc-inner-first",
      "headRefOid": "68b72e1e1613fafdccacd5eba3d8feb604fd86e8",
      "closedAt": "2021-08-05T22:23:11Z",
      "mergedAt": "2021-08-05T22:23:10Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "499448fe90fd2678fc17e4b419537d6eb9d02256"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIzODQxNzc0",
          "commit": {
            "abbreviatedOid": "278644f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-05T22:20:08Z",
          "updatedAt": "2021-08-05T22:22:52Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "```suggestion\r\nreduce the size impact, the client MAY substitute extensions which it knows\r\n```",
              "createdAt": "2021-08-05T22:20:08Z",
              "updatedAt": "2021-08-05T22:22:52Z"
            },
            {
              "originalPosition": 67,
              "body": "```suggestion\r\nrelative order. However, there is no requirement that they be contiguous. For\r\n```",
              "createdAt": "2021-08-05T22:22:41Z",
              "updatedAt": "2021-08-05T22:22:52Z"
            },
            {
              "originalPosition": 72,
              "body": "```suggestion\r\nEncodedClientHelloInner, and MUST NOT appear in either ClientHelloOuter or\r\n```",
              "createdAt": "2021-08-05T22:22:47Z",
              "updatedAt": "2021-08-05T22:22:52Z"
            }
          ]
        }
      ]
    },
    {
      "number": 504,
      "id": "MDExOlB1bGxSZXF1ZXN0NzA1MDg2NDY4",
      "title": "Fix several typos",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/504",
      "state": "MERGED",
      "author": "pkelsey",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-08-05T23:30:22Z",
      "updatedAt": "2021-08-06T00:56:09Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "27cc51ad3f295ad76bcf19cbb16c1514c4e5765b",
      "headRepository": "pkelsey/draft-ietf-tls-esni",
      "headRefName": "typos",
      "headRefOid": "832276970ef4abc2dac83d242d21460ae55259c1",
      "closedAt": "2021-08-06T00:56:09Z",
      "mergedAt": "2021-08-06T00:56:09Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "4fc79b477a413a6026e65176796c16fa0c955b7f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIzODkzODYx",
          "commit": {
            "abbreviatedOid": "8322769"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-06T00:35:12Z",
          "updatedAt": "2021-08-06T00:35:12Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIzOTAwMDg5",
          "commit": {
            "abbreviatedOid": "8322769"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-06T00:54:54Z",
          "updatedAt": "2021-08-06T00:54:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 505,
      "id": "MDExOlB1bGxSZXF1ZXN0NzA1MDg2NzA3",
      "title": "More accurately describe provider plaintext access",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/505",
      "state": "MERGED",
      "author": "pkelsey",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-08-05T23:31:07Z",
      "updatedAt": "2021-08-06T12:32:43Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "27cc51ad3f295ad76bcf19cbb16c1514c4e5765b",
      "headRepository": "pkelsey/draft-ietf-tls-esni",
      "headRefName": "clarify-provider-plaintext-access",
      "headRefOid": "023beea3621a27a4c369954ded5ef503fa2b0f79",
      "closedAt": "2021-08-06T12:32:42Z",
      "mergedAt": "2021-08-06T12:32:42Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "7b603e187dc670835ad37617cefadcfcd34a95e6"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 506,
      "id": "MDExOlB1bGxSZXF1ZXN0NzA1MDg2OTQ5",
      "title": "Adjust caption of Figure 1",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/506",
      "state": "MERGED",
      "author": "pkelsey",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Make it clear at a glance that shared mode is client-facing and\r\nbackend combined, and that both of those terms are operative in each\r\ntopology.",
      "createdAt": "2021-08-05T23:31:48Z",
      "updatedAt": "2021-08-06T00:57:36Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "27cc51ad3f295ad76bcf19cbb16c1514c4e5765b",
      "headRepository": "pkelsey/draft-ietf-tls-esni",
      "headRefName": "clarify-figure-1",
      "headRefOid": "6f74c8dbf4234de4ac21ed27af48219edb5a755e",
      "closedAt": "2021-08-06T00:57:35Z",
      "mergedAt": "2021-08-06T00:57:35Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "2c7b34d0c83f364346ca9cb33bc47b114fb89689"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIzOTAwNzkz",
          "commit": {
            "abbreviatedOid": "6f74c8d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-06T00:57:19Z",
          "updatedAt": "2021-08-06T00:57:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 507,
      "id": "MDExOlB1bGxSZXF1ZXN0NzA1MDg3MjQ2",
      "title": "Replace broader, conflicting description of client retry_config use...",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/507",
      "state": "MERGED",
      "author": "pkelsey",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "\u2026with reference to Section 6.1.6\r\n\r\nSee also the discussion on tlswg/draft-ietf-tls-esni#498.",
      "createdAt": "2021-08-05T23:32:48Z",
      "updatedAt": "2021-08-06T12:47:01Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "27cc51ad3f295ad76bcf19cbb16c1514c4e5765b",
      "headRepository": "pkelsey/draft-ietf-tls-esni",
      "headRefName": "clarify-retry-config-use",
      "headRefOid": "b62d52830b369287c3dceaa9a593cfca241e5b5c",
      "closedAt": "2021-08-06T12:47:01Z",
      "mergedAt": "2021-08-06T12:47:01Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f7d85494bab46b6f33ec6b43bb4528d96dc01afe"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI0MzE5NjEx",
          "commit": {
            "abbreviatedOid": "b62d528"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-06T12:46:57Z",
          "updatedAt": "2021-08-06T12:46:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 508,
      "id": "MDExOlB1bGxSZXF1ZXN0NzA1MDg3NTQx",
      "title": "Rework Handshaking with ClientHelloInner to remove conflicts and...",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/508",
      "state": "MERGED",
      "author": "pkelsey",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "\u2026eliminate redundancies\r\n\r\n- Avoid restatement by relying on the itemization of conditions that\r\n  constitute ECH rejection given in 6.1.4.\r\n\r\n- The prior text described aborting the connection with an alert,\r\n  *then* processing retry_configs, which processing could then lead to\r\n  additional instructions to abort the (aborted) connection with an\r\n  alert (and possibly a different alert than at first).\r\n\r\n- Remove the use of the \"illegal_parameter\" alert in the case of \"if\r\n  the field contains any other value\", which apparently referred to\r\n  the retry_config version fields.  First, this conflicts with the\r\n  requirement that the connection be aborted with ech_required.\r\n  Second, it's not clear what \"any other value\" is supposed to mean as\r\n  this determination follows determining whether the members of the\r\n  set of values are either \"supported\" or \"unsupported\".  Perhaps it\r\n  meant a value not considered valid as of the specification version\r\n  the client was implemented according to?  Certainly, in the case\r\n  where there is at least one supported version found but also at\r\n  least one such invalid value, it would not be desriable to use an\r\n  illegal_parameter alert, as this situation will naturally arise when\r\n  servers deploying a new ECH version alongside an existing one serve\r\n  clients that have not yet been upgraded.  It's also unclear what\r\n  value client discrimination of unsupported-recognized-as-valid from\r\n  unsupported-not-recognized-as-valid provides.\r\n\r\n- Linearize the presentation.\r\n\r\n- Fix the reference to the obsolete \"ech_retry_request\". (See also\r\n  tlswg/draft-ietf-tls-esni#500).",
      "createdAt": "2021-08-05T23:33:45Z",
      "updatedAt": "2021-08-09T23:06:54Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "04447f2be1b494eff1917a7c293cd6d718d98570",
      "headRepository": "pkelsey/draft-ietf-tls-esni",
      "headRefName": "clarify-handshaking-with-client-hello-outer",
      "headRefOid": "782ca5f9c923ed0de0e53857285e8c8d5400a7b4",
      "closedAt": "2021-08-09T23:06:54Z",
      "mergedAt": "2021-08-09T23:06:54Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "07ebd142ffb0af3733100a0c04f51a5d5605a30a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI0NTI5MjQx",
          "commit": {
            "abbreviatedOid": "741736c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-06T16:32:54Z",
          "updatedAt": "2021-08-06T16:32:57Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\nclient then processes the server's response as follows. If the server supplied\r\nan \"encrypted_client_hello\" extension in its EncryptedExtensions message, the\r\nclient MUST check that it is syntactically valid and the client MUST abort the\r\nconnection with a \"decode_error\" alert otherwise. If the extension is valid,\r\nthe client processes the \"retry_configs\" from the extension as described below\r\nand then abort the connection with an \"ech_required\" alert.\r\n```\r\n\r\nThe intent of the differentiator was to fail early and loudly in the presence of server bugs, though I concur that \"illegal_parameter\" was perhaps not the best alert. I tried to fix that with this suggestion. What do you think?",
              "createdAt": "2021-08-06T16:32:54Z",
              "updatedAt": "2021-08-06T16:32:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI0Njk4OTg5",
          "commit": {
            "abbreviatedOid": "741736c"
          },
          "author": "pkelsey",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-06T20:43:47Z",
          "updatedAt": "2021-08-06T20:43:47Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "The decode_error alert language makes sense and is nicely consistent with the requirements for processing a GREASE response.  However, the relocation of the  'abort with ech_required' language ties it to the extension present case and makes it no longer apply to the earlier-TLS-version case down below.  I'm going to take a stab at either trying to refactor this a bit with your new decode_error language on board.",
              "createdAt": "2021-08-06T20:43:47Z",
              "updatedAt": "2021-08-06T20:43:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI0NzExMDk3",
          "commit": {
            "abbreviatedOid": "189896e"
          },
          "author": "pkelsey",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-06T21:06:15Z",
          "updatedAt": "2021-08-06T21:06:16Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "It seemed the only reasonable way to resolve things was to duplicate the ech_required language in the earler-TLS-version part.  I pushed a new commit to that effect.",
              "createdAt": "2021-08-06T21:06:15Z",
              "updatedAt": "2021-08-06T21:06:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI0NzE2NDEy",
          "commit": {
            "abbreviatedOid": "189896e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-06T21:17:04Z",
          "updatedAt": "2021-08-06T21:17:04Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI1NjMyMDI4",
          "commit": {
            "abbreviatedOid": "189896e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-09T17:24:57Z",
          "updatedAt": "2021-08-09T17:24:57Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "The latest change LGTM \ud83d\udc4d ",
              "createdAt": "2021-08-09T17:24:57Z",
              "updatedAt": "2021-08-09T17:24:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI1NjQwMTc1",
          "commit": {
            "abbreviatedOid": "189896e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-09T17:34:15Z",
          "updatedAt": "2021-08-09T17:36:46Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I understand the intent here, but this seems somewhat out of order. The checks below happen _before_ the handshake completes, but this text suggests they happen afterwards. Perhaps we can rewrite this as follows?\r\n\r\n```\r\nOtherwise, in authenticating the server and completing the handshake, \r\nthe client then processes the server's response as follows.\r\n```",
              "createdAt": "2021-08-09T17:34:15Z",
              "updatedAt": "2021-08-09T17:36:46Z"
            },
            {
              "originalPosition": 47,
              "body": "```suggestion\r\nsecurely disabled by the server. If the client retries, the client MUST NOT\r\nenable the False Start optimization {{RFC7918}} for this handshake, and the\r\nclient MUST abort the connection with an \"ech_required\" alert.\r\n```",
              "createdAt": "2021-08-09T17:36:06Z",
              "updatedAt": "2021-08-09T17:36:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI1NzIwMzg1",
          "commit": {
            "abbreviatedOid": "189896e"
          },
          "author": "pkelsey",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-09T19:10:26Z",
          "updatedAt": "2021-08-09T19:10:26Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Good catch - this ordering issue is one I was trying to expunge during the first pass, and it has now crept back in with the decode_error processing.  There's possibly another instance of this in the suggestion for the comment below, depending on how the question I'm asking there resolves.",
              "createdAt": "2021-08-09T19:10:26Z",
              "updatedAt": "2021-08-09T19:10:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI1NzIwNjY1",
          "commit": {
            "abbreviatedOid": "189896e"
          },
          "author": "pkelsey",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-09T19:10:49Z",
          "updatedAt": "2021-08-09T19:10:49Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "> securely disabled by the server. If the client retries, the client MUST NOT\r\n\r\nI had been under the impression that the prohibition on RFC7918 use was for the handshake that contains the ECH rejection (that is, don't send application data into a handshake that is going to be aborted once it completes).  It's not clear why this prohibition would be conditioned on the client retrying the connection, or now whether it is meant to apply only to a retry handshake?",
              "createdAt": "2021-08-09T19:10:49Z",
              "updatedAt": "2021-08-09T19:10:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI1NzIzNjkw",
          "commit": {
            "abbreviatedOid": "189896e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-09T19:14:36Z",
          "updatedAt": "2021-08-09T19:14:36Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "The existing text already predicated RFC7918 on whether or not the client retried. (You can't do RFC7918 if you don't retry in this instance, that is.) This suggestion is meant as an editorial improvement (but YMMV), not as a semantic one.",
              "createdAt": "2021-08-09T19:14:36Z",
              "updatedAt": "2021-08-09T19:14:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI1NzQ0OTAy",
          "commit": {
            "abbreviatedOid": "189896e"
          },
          "author": "pkelsey",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-09T19:41:59Z",
          "updatedAt": "2021-08-09T19:41:59Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "So I think we're understanding this the same way - that the point is not to plow through with RFC7918 in a connection that is being aborted due to ECH rejection, but the client is free to do so on the retry connection.  My mileage is definitely still varying on the \"if the client retries\", as it's really outside of the context of 'this handshake', which is what that part is about.\r\n\r\nWould you say this would be equivalent?\r\n\r\n```suggestion\r\nsecurely disabled by the server, the client MUST NOT enable the False Start\r\noptimization {{RFC7918}} for this handshake (it may be enabled for the retry\r\nconnection), and the client MUST abort the connection with an \"ech_required\" alert.\r\n```\r\n\r\n\r\nI'm going to push a commit shortly that I think irons out the ordering issue you flagged.",
              "createdAt": "2021-08-09T19:41:59Z",
              "updatedAt": "2021-08-09T19:41:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI1NzcwMTk5",
          "commit": {
            "abbreviatedOid": "189896e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-09T20:14:08Z",
          "updatedAt": "2021-08-09T20:14:08Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Yep! (And reading that pointed out the confusion I introduced, so, thanks for clarifying.)",
              "createdAt": "2021-08-09T20:14:08Z",
              "updatedAt": "2021-08-09T20:14:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI1Nzg3NDUx",
          "commit": {
            "abbreviatedOid": "afe530f"
          },
          "author": "pkelsey",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-09T20:36:24Z",
          "updatedAt": "2021-08-09T20:36:24Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "The new commit I just pushed I think incorporates everything we've talked about (and is actually a bit more compact in the end) except that parenthetical about RFC7918 on the retry connection was still an open question when I did the commit.  If you think the new commit is otherwise good and that parenthetical will clarify it further, I'm all for it.",
              "createdAt": "2021-08-09T20:36:24Z",
              "updatedAt": "2021-08-09T20:36:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI1Nzk1MTA1",
          "commit": {
            "abbreviatedOid": "afe530f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Much more concise =) Just a couple more comments.",
          "createdAt": "2021-08-09T20:46:20Z",
          "updatedAt": "2021-08-09T20:48:57Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Can we bring back the text that landed in #498?",
              "createdAt": "2021-08-09T20:46:21Z",
              "updatedAt": "2021-08-09T20:48:57Z"
            },
            {
              "originalPosition": 26,
              "body": "```suggestion\r\nalert before sending any application data to the server.\r\n```",
              "createdAt": "2021-08-09T20:48:42Z",
              "updatedAt": "2021-08-09T20:48:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI1ODIxOTQ2",
          "commit": {
            "abbreviatedOid": "afe530f"
          },
          "author": "pkelsey",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-09T21:22:00Z",
          "updatedAt": "2021-08-09T21:22:01Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Looks like I missed a merge...",
              "createdAt": "2021-08-09T21:22:00Z",
              "updatedAt": "2021-08-09T21:22:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI1ODM4NjY3",
          "commit": {
            "abbreviatedOid": "782ca5f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-09T21:47:22Z",
          "updatedAt": "2021-08-09T21:47:25Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "This bit seems somewhat out of place -- why include it here? Or include it at all, given the \"before sending any application data to the server\" clause below?",
              "createdAt": "2021-08-09T21:47:22Z",
              "updatedAt": "2021-08-09T21:47:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI1ODUzMTkz",
          "commit": {
            "abbreviatedOid": "782ca5f"
          },
          "author": "pkelsey",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-09T22:12:28Z",
          "updatedAt": "2021-08-09T22:12:28Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "They are not redundant statements.  Forbidding RFC7918 prevents the client from sending application data to the server before the handshake completes.  The additional statement that you suggested (\"before sending application data to the server\") requires that the connection be aborted before sending any application data to the server after the handshake completes successfully.\r\n\r\nI put the RFC7918 statement where it is as it affects what is done (or not) as the handshake progresses, so it is more concise to discuss it prior to everything that follows \"If both the authentication and the handshake complete successfully...\".  The requirement to validate the syntax of the encrypted_client_hello extension is co-located there under similar reasoning, which is that the syntax must be validated in order to proceed with the \"after the handshake\" processing that follows (although I think there is currently leeway there for an implementation to postpone the decode until after the handshake completes).",
              "createdAt": "2021-08-09T22:12:28Z",
              "updatedAt": "2021-08-09T22:12:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI1ODUzODY5",
          "commit": {
            "abbreviatedOid": "782ca5f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-09T22:13:39Z",
          "updatedAt": "2021-08-09T22:13:39Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "> The additional statement that you suggested (\"before sending application data to the server\") requires that the connection be aborted before sending any application data to the server after the handshake completes successfully.\r\n\r\nI don't see how this is the case. The statement says \"do not send any application data to the server,\" which includes, IMO, False Start data, or data that would otherwise be sent when the handshake normally completes. ",
              "createdAt": "2021-08-09T22:13:39Z",
              "updatedAt": "2021-08-09T22:13:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI1ODYzNjQ1",
          "commit": {
            "abbreviatedOid": "782ca5f"
          },
          "author": "pkelsey",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-09T22:32:35Z",
          "updatedAt": "2021-08-09T22:32:35Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "It's the predicate that begins that sentence \"If both authentication and the handshake complete successfully,...\" that I think places the effect of prohibiting sending application data to the server between the completion of the handshake and the sending of the ech_required alert.",
              "createdAt": "2021-08-09T22:32:35Z",
              "updatedAt": "2021-08-09T22:32:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI1ODc5MjU4",
          "commit": {
            "abbreviatedOid": "782ca5f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-09T23:06:40Z",
          "updatedAt": "2021-08-09T23:06:40Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "It seems redundant, but I can live with it.\r\n",
              "createdAt": "2021-08-09T23:06:40Z",
              "updatedAt": "2021-08-09T23:06:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI1ODc5MzIy",
          "commit": {
            "abbreviatedOid": "782ca5f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-09T23:06:48Z",
          "updatedAt": "2021-08-09T23:06:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 509,
      "id": "MDExOlB1bGxSZXF1ZXN0NzA1MDg3Nzc0",
      "title": "Clarify the document's assumption of restricted attacker location",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/509",
      "state": "CLOSED",
      "author": "pkelsey",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-08-05T23:34:29Z",
      "updatedAt": "2021-08-06T14:31:59Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "27cc51ad3f295ad76bcf19cbb16c1514c4e5765b",
      "headRepository": "pkelsey/draft-ietf-tls-esni",
      "headRefName": "clarify-attacker-location",
      "headRefOid": "72af02c610c1ac9f7e8e1820e1f1941014fdfc33",
      "closedAt": "2021-08-06T12:36:04Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This isn't accurate -- we assume the attacker can exist anywhere. Closing as a result.",
          "createdAt": "2021-08-06T12:36:04Z",
          "updatedAt": "2021-08-06T12:36:04Z"
        },
        {
          "author": "pkelsey",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Do you assume the attacker can exist on both network segments in split mode?",
          "createdAt": "2021-08-06T13:59:41Z",
          "updatedAt": "2021-08-06T13:59:41Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yep, we assume the attacker can exist anywhere.",
          "createdAt": "2021-08-06T14:31:59Z",
          "updatedAt": "2021-08-06T14:31:59Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 510,
      "id": "MDExOlB1bGxSZXF1ZXN0NzA1MDg3OTg1",
      "title": "Clarify ambiguous grammar",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/510",
      "state": "MERGED",
      "author": "pkelsey",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As previously written, the wording could be understood as referring to\r\nan application using some other (D)TLS mechanism to indicate which\r\nECHConfig candidate value selection method to use.",
      "createdAt": "2021-08-05T23:35:12Z",
      "updatedAt": "2021-08-06T12:38:03Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "35e998e4bbc61e2309176128084c3fadb45289e1",
      "headRepository": "pkelsey/draft-ietf-tls-esni",
      "headRefName": "clarify-choice-of-ech-config-candidate-selection-method",
      "headRefOid": "e95cde0fc723db7ee94e6f3f77e5c3bbbad3c3d9",
      "closedAt": "2021-08-06T12:38:03Z",
      "mergedAt": "2021-08-06T12:38:03Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "470020e9785390674e2de754884517a89b66a237"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 511,
      "id": "MDExOlB1bGxSZXF1ZXN0NzA1MDg4MjQw",
      "title": "Remove sentence that is redundant with the paragraph that follows",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/511",
      "state": "MERGED",
      "author": "pkelsey",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-08-05T23:36:05Z",
      "updatedAt": "2021-08-06T12:34:34Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "27cc51ad3f295ad76bcf19cbb16c1514c4e5765b",
      "headRepository": "pkelsey/draft-ietf-tls-esni",
      "headRefName": "redundancy-unrecognzied-mandatory-extension",
      "headRefOid": "1d3315b4fdc7a68a144b52775d492f7c6a3593d3",
      "closedAt": "2021-08-06T12:34:34Z",
      "mergedAt": "2021-08-06T12:34:34Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "35e998e4bbc61e2309176128084c3fadb45289e1"
      },
      "comments": [
        {
          "author": "cbartle891",
          "authorAssociation": "COLLABORATOR",
          "body": "I can see how that sentence is redundant, but it seems like it would be helpful to implementers.",
          "createdAt": "2021-08-06T03:23:36Z",
          "updatedAt": "2021-08-06T03:23:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI0MzA4NTkx",
          "commit": {
            "abbreviatedOid": "1d3315b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-06T12:33:38Z",
          "updatedAt": "2021-08-06T12:33:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 514,
      "id": "MDExOlB1bGxSZXF1ZXN0NzA2NzI0NDQ2",
      "title": "Abort on duplicate OuterExtensions",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/514",
      "state": "MERGED",
      "author": "dennisjackson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "If OuterExtensions contains duplicate references to the same extension in the ClientHelloOuter, a draft-compliant implementation may create a ClientHelloInner many times larger than the received ClientHelloOuter. In split mode, this allows for network DoS via packet amplification. In shared mode, this could lead to memory or CPU exhaustion. \r\n\r\nThis PR requires implementions to reject OuterExtensions which reference the same extension more than once. This can be achieved in practice by using the algorithm suggested in Appendix B. ",
      "createdAt": "2021-08-09T18:00:14Z",
      "updatedAt": "2021-08-10T23:13:02Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "07ebd142ffb0af3733100a0c04f51a5d5605a30a",
      "headRepository": "dennisjackson/draft-ietf-tls-esni",
      "headRefName": "decompression-size",
      "headRefOid": "2c332158b29346a65fd6ec7d5bcee9821e84f7ae",
      "closedAt": "2021-08-10T23:13:02Z",
      "mergedAt": "2021-08-10T23:13:02Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "9eef1de12f039ba52d3783ac269b4cfdf240906e"
      },
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "This used to be in there and then was removed in https://github.com/tlswg/draft-ietf-tls-esni/pull/467 (@cjpatton). It's a little weird because the algorithm in the appendix does not *actually* check for duplicate extensions, merely that you never try to copy the same extension twice. It only implicitly checks for duplicate extensions if you had previously checked the ClientHelloOuter for duplicate extensions.\r\n\r\nHow we want to reflect this in the spec, I'm not sure. Our implementation always checks for duplications, so I don't have much of a horse in this race. But I think many don't (it requires a sort or so), and I do feel that you should be able to apply the appendix and not think about it so hard.\r\n\r\nThe current text, without this PR, says it's not a strict requirement on the parsing side, but that you should avoid DoS. I think those do imply you need to do _something_ here, but it is unfortunate that it doesn't call out this case. I suppose you could argue that a duplicate is violating the order rule.",
          "createdAt": "2021-08-09T19:07:40Z",
          "updatedAt": "2021-08-09T19:07:40Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": ">  I think those do imply you need to do something here, but it is unfortunate that it doesn't call out this case.\r\n\r\nRight, so, the simplest thing seems to just be to address the case directly, no?",
          "createdAt": "2021-08-09T19:11:39Z",
          "updatedAt": "2021-08-09T19:11:39Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Well, I think the question is whether this is compliant:\r\n\r\n* ClientHelloOuter parser does not reject duplicate unknown extensions. (I don't believe it's required to?)\r\n* ClientHelloInner decoder just implements the algorithm in the appendix.\r\n\r\nThis has no DoS issues, but will accept a duplicate if, say:\r\n\r\n* ClientHelloOuter {A, B, C, A}\r\n* ClientHelloInner { outer_extensions { A, A } }\r\n\r\nThis'll copy the first A and then the second A. There are no DoS problems (the same extension is never copied twice), but it does not always reject duplicates. Is that compliant?",
          "createdAt": "2021-08-09T19:20:34Z",
          "updatedAt": "2021-08-09T19:20:34Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Putting compliance aside, let me flip this around -- what is the benefit of allowing duplicates? Rejecting them seems incredibly trivial.",
          "createdAt": "2021-08-09T19:34:48Z",
          "updatedAt": "2021-08-09T19:34:48Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\n\nOn 09/08/2021 20:35, Christopher Wood wrote:\n> Putting compliance aside, let me flip this around -- what is the\n> benefit of allowing duplicates? \n\nSlightly cooler than more obvious covert channels? :-)\n\n> Rejecting them seems incredibly\n> trivial.\n\nYep. I think it's fine either left alone or specified. The\nonly reason I can think of to specify it is that a client\ncould test whether or not a server does reject. If adding\nnew text just make it a MUST requirement, no need to say\nHOWTO.\n\nCheers,\nS.\n\n\n",
          "createdAt": "2021-08-09T19:40:06Z",
          "updatedAt": "2021-08-09T19:40:06Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd be fine with a change here, but let's make sure the algorithm in the appendix actually checks for duplicates.",
          "createdAt": "2021-08-09T19:49:17Z",
          "updatedAt": "2021-08-09T19:49:17Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> what is the benefit of allowing duplicates? Rejecting them seems incredibly trivial.\r\n\r\nLess code, for simpler implementations that don't want to pay for things they don't need? I do not believe RFC8446 requires that you check for it. Rejecting duplicates of extensions you know about is easy (it's a bitmask). Rejecting them of extensions you don't know about requires a sort, or building a hash table or so. We do this, but I've not seen any other implementation that does it.\r\n\r\n> I'd be fine with a change here, but let's make sure the algorithm in the appendix actually checks for duplicates.\r\n\r\nRight, that's the thing I am _not_ okay with. The algorithm in the appendix is duplicate-check-preserving, and it does no one any good to check for duplicates in the algorithm:\r\n\r\n* If you reject duplicates in your ClientHello parser, implement the appendix and it'll enforce there are no duplicates.\r\n* If you don't reject duplicates in your ClientHello parser, implement the appendix and you will avoid DoS but potentially have some duplicates. But apparently you were okay with that before ECH, so that's not really any worse.\r\n* If you don't reject duplicates in your ClientHello parser but _do_ separately reject them in your OuterExtensions decoder, you haven't done anything useful because OuterExtensions can still duplicate with an uncompressed extension.\r\n\r\nThis means the only useful place to apply this check is the ClientHello parser, RFC8446. But we haven't tried to get consensus on mandating ClientHello parsers check for ordered extensions. That would make a bunch of TLS implementations non-compliant. Thus I think the most pragmatic solution is to omit this requirement in ECH.",
          "createdAt": "2021-08-09T19:55:00Z",
          "updatedAt": "2021-08-09T19:56:06Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "I think David is correct. OpenSSL IIRC checks for dupes in the existing non-ECH  ClientHello handling code. Adding a requirement to barf on dups in outers is ok for me (because it'll just happen), saying HOWTO is likely something I'd ignore as you're unlikely to stumble on the exact way that OpenSSL does it.",
          "createdAt": "2021-08-09T20:00:45Z",
          "updatedAt": "2021-08-09T20:00:45Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> This means the only useful place to apply this check is the ClientHello parser, RFC8446. But we haven't tried to get consensus on mandating ClientHello parsers check for ordered extensions. That would make a bunch of TLS implementations non-compliant. Thus I think the most pragmatic solution is to omit this requirement in ECH.\r\n\r\nI agree with the decision tree, but I don't find this a compelling reason to _not_ prohibit them. We're already changing stacks to accommodate ECH.\r\n\r\n(As a side question: has anyone really looked at what can happen if certain TLS extensions are repeated?)",
          "createdAt": "2021-08-09T20:12:03Z",
          "updatedAt": "2021-08-09T20:12:03Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@dennisjackson given the analysis above, how about we close this an open an issue against rfc8446bis to track extension duplication detection/rejection?",
          "createdAt": "2021-08-09T20:21:56Z",
          "updatedAt": "2021-08-09T20:21:56Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> (As a side question: has anyone really looked at what can happen if certain TLS extensions are repeated?)\r\n\r\nI guess it depends on what you do. The duplicate will be present in the transcript, so...\r\n\r\n* If the server isn't parsing the extension, I expect it doesn't really do anything.\r\n* If the server is parsing the extension, it's pretty easy to check for duplicates. Supposing it doesn't...\r\n* If the server ignores one of the duplicates, then we're just pretending that's the interpretation of duplicate extensions. Seems a coherent enough interpretation, if silly.\r\n* If the server gets confused and mixes the fields together, then it depends on whether that gets the server in a state that it couldn't have gotten into before. If not, no harm. If it does, that novel state might do something weird and untested.\r\n* If you've got two halves of ClientHello processing and the two have different, non-rejecting interpretations, that may also cause some mishaps. But that sort of thing is a little dubious in TLS anyway given how end-to-end all our negotiations are.\r\n\r\nPragmatically, I think rejecting duplicate extensions you already know how to parse is definitely a good idea. It costs next to nothing because you just maintain a bitmask, and reduces some risk. Doing it for extensions you don't recognize is a bit more fuss.\r\n\r\nGiven a time machine, I think we should have mandated all extensions be sorted, so duplicate-checking is easy. Too late now. :-(",
          "createdAt": "2021-08-09T20:25:10Z",
          "updatedAt": "2021-08-09T20:25:10Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> If the server gets confused and mixes the fields together, then it depends on whether that gets the server in a state that it couldn't have gotten into before. If not, no harm. If it does, that novel state might do something weird and untested.\r\n\r\nThis is the scenario that concerns me most, sort of like checking for certain extensions on CH1 in HRR but not on CH2. In any case, I think it's safe to say this is external to ECH, as much as I would prefer we just do it here. ",
          "createdAt": "2021-08-09T20:43:17Z",
          "updatedAt": "2021-08-09T20:43:17Z"
        },
        {
          "author": "dennisjackson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Most of the discussion has veered away from the point of this PR, unfortunately perhaps lead astray by the renaming of the PR. All the discussion about duplicate extensions (or not) in TLS1.3 is not relevant to the property we need to enforce. \r\n\r\nThe intended goal is to ensure that after decompression, the resulting ClientHelloInner must be equal or smaller in size than the received ClientHelloOuter. I believe this is an important security property which must be enforced by ECH. Otherwise, an attacker can send small CHOs to the client-facing server, which then must deliver CHIs potentially >1000x larger to the backend server.\r\n\r\nRegarding the phrasing of the requirement: \r\n\r\n> [Bail if...] Any extension is referenced in OuterExtensions more than once.\r\n\r\nThis does not require implementations to reject duplicate extensions in CHs and as @davidben noted, whether they do or not doesn't matter, as this requirement still ensures the correct security property. If you remove this requirement, regardless of whether duplicate extensions are tolerated, there's an amplification attack. \r\n\r\nI did consider two alternative formulations \r\n\r\n* Encoding the |CHI| <= |CHO| size requirement directly in the RFC, or\r\n* Requiring that no CHO extension be included in in the CHI inner more than once. \r\n\r\nThe first option puts the burden entirely on the implementor and seems prone to mistakes. The second seems hard to make precise. Hence this formulation. \r\n\r\n\r\n",
          "createdAt": "2021-08-09T23:11:55Z",
          "updatedAt": "2021-08-09T23:11:55Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Ohhhh! I think I see. Yeah, that is actually slightly different from what we removed in #467. Sorry, I did not notice this subtlety. Let me try to restate this to make sure we're on the same page:\r\n\r\n#467 removed the sentence \"OuterExtensions contains duplicate values\", which means that if the same extension type appears twice in OuterExtensions, the server is obligated to reject.\r\n\r\nThis PR, however, says \"Any extension is referenced in OuterExtensions more than once\", which one could interpret to not mean the extension *type*, but the extension itself. And so we're saying that you cannot *copy* a given [Extension](https://www.rfc-editor.org/rfc/rfc8446.html#section-4.2) (as in the extension_type/extension_data tuple) twice.\r\n\r\nIs that the idea? If so, I like that. It handily punts the RFC8446 problem. :-) I'm not sure how obviously this subtlety comes off in the text, but I don't have a better idea either.",
          "createdAt": "2021-08-10T00:04:41Z",
          "updatedAt": "2021-08-10T00:04:41Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Is that the idea? If so, I like that. It handily punts the RFC8446 problem. :-) \r\n\r\n\ud83d\udc4d \ud83e\udd26 ",
          "createdAt": "2021-08-10T00:07:22Z",
          "updatedAt": "2021-08-10T00:07:22Z"
        },
        {
          "author": "dennisjackson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I was looking through previous PRs and it looks like this has been discussed before: \r\n* [Document the other ech_outer_extensions DoS vector](https://github.com/tlswg/draft-ietf-tls-esni/pull/452) highlighted this issue. \r\n* [Require compressed extensions appear in the same relative order.](https://github.com/tlswg/draft-ietf-tls-esni/pull/455) fixed the issue. \r\n* [Don't require OuterExtensions de-duplication](https://github.com/tlswg/draft-ietf-tls-esni/pull/467) re-introduced it. \r\n\r\nI think it makes sense to add @davidben's paragraph on the attack to the security considerations section to explain the requirements around decompression better. ",
          "createdAt": "2021-08-10T11:11:41Z",
          "updatedAt": "2021-08-10T11:11:41Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI1NjcwMTYz",
          "commit": {
            "abbreviatedOid": "a119cb4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-09T18:09:22Z",
          "updatedAt": "2021-08-09T18:09:22Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI1OTIzODMx",
          "commit": {
            "abbreviatedOid": "a119cb4"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Seems OK to me.",
          "createdAt": "2021-08-10T01:05:08Z",
          "updatedAt": "2021-08-10T01:05:17Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\n{{encoding-inner}}) in linear time, ensuring that each referenced extension in the\r\n```",
              "createdAt": "2021-08-10T01:05:08Z",
              "updatedAt": "2021-08-10T01:05:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI2NDc1ODAz",
          "commit": {
            "abbreviatedOid": "4c6066a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "\ud83d\udc4d Looks great",
          "createdAt": "2021-08-10T14:00:03Z",
          "updatedAt": "2021-08-10T14:02:53Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "```suggestion\r\norder, that duplicate references be rejected, and by recommending that\r\n```",
              "createdAt": "2021-08-10T14:00:03Z",
              "updatedAt": "2021-08-10T14:02:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI2NDg5NjUw",
          "commit": {
            "abbreviatedOid": "4c6066a"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-10T14:10:43Z",
          "updatedAt": "2021-08-10T14:10:43Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "I claim that the algorithm below doesn't actually enforce this. It's straightforward to do so, however. How about just adding a bullet just below the second step that says \"If E already appeared previously in OuterExtensions, then abort with \"illegal_parameter\".\"",
              "createdAt": "2021-08-10T14:10:43Z",
              "updatedAt": "2021-08-10T14:10:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI2NDkxMTAy",
          "commit": {
            "abbreviatedOid": "4c6066a"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-10T14:11:51Z",
          "updatedAt": "2021-08-10T14:11:51Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Or, based on the security considerations above, perhaps the intent is just to skip duplicate extensions?",
              "createdAt": "2021-08-10T14:11:51Z",
              "updatedAt": "2021-08-10T14:11:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI2NTMxNjk0",
          "commit": {
            "abbreviatedOid": "e41ed16"
          },
          "author": "dennisjackson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-10T14:43:39Z",
          "updatedAt": "2021-08-10T14:43:40Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "This language is intended to be compatible with or without duplicate extensions in the client hello outer. \r\n\r\nIf the reader is assuming extension ids are unique, and rejects duplicate extensions in the CHO, the linear scan can't include the same extension twice and will bail. \r\n\r\nIf the reader is assuming duplicate extensions are tolerated, they must treat `ExtFoo ExtFoo` as two different extensions, but the same requirement still works, as in this reading the same extension isn't included twice and there's no amplification attack and no panic. \r\n\r\nIf the TLS1.3 RFC is ever update to clarify this, the language here can be tightened to point to that, without impacting implementations :-). ",
              "createdAt": "2021-08-10T14:43:40Z",
              "updatedAt": "2021-08-10T14:43:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI2ODIyMjA0",
          "commit": {
            "abbreviatedOid": "e41ed16"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-10T20:36:02Z",
          "updatedAt": "2021-08-10T20:36:02Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Ok.",
              "createdAt": "2021-08-10T20:36:02Z",
              "updatedAt": "2021-08-10T20:36:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI2ODIyNjEy",
          "commit": {
            "abbreviatedOid": "e41ed16"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-10T20:36:29Z",
          "updatedAt": "2021-08-10T20:36:29Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI2ODYyMzkz",
          "commit": {
            "abbreviatedOid": "e41ed16"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-10T21:29:04Z",
          "updatedAt": "2021-08-10T21:32:26Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "+1 to @dennisjackson's interpretation. Adding something like \"If E already appeared previously in OuterExtensions\" requires auxiliary state and is redundant with whatever the ClientHelloOuter story is.",
              "createdAt": "2021-08-10T21:29:05Z",
              "updatedAt": "2021-08-10T21:32:26Z"
            },
            {
              "originalPosition": 10,
              "body": "Now that we have a section detailing this, maybe link to it in the paragraph below.",
              "createdAt": "2021-08-10T21:30:00Z",
              "updatedAt": "2021-08-10T21:32:26Z"
            },
            {
              "originalPosition": 26,
              "body": "Nit: Given the weird ambiguity around what a \"duplicate extension\" is, how about \"If the same ClientHelloOuter extension can be copied multiple times\".",
              "createdAt": "2021-08-10T21:31:57Z",
              "updatedAt": "2021-08-10T21:32:26Z"
            }
          ]
        }
      ]
    },
    {
      "number": 522,
      "id": "PR_kwDOB-yxNc4whwtw",
      "title": "Fix extension count in IANA considerations",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/522",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #521",
      "createdAt": "2022-01-04T19:48:01Z",
      "updatedAt": "2022-01-04T20:54:44Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "058aedcdc6ebefcbee81201dcb4ec960bdcafccc",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "fix-extension-count",
      "headRefOid": "aa666deeb9b9f3a53d6d2a786fdb2b4d90876c73",
      "closedAt": "2022-01-04T20:54:44Z",
      "mergedAt": "2022-01-04T20:54:43Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f1f9416779134d037dba7bc915463e61a4064a03"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOB-yxNc4yTl1R",
          "commit": {
            "abbreviatedOid": "aa666de"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "\ud83d\ude4f thanks!",
          "createdAt": "2022-01-04T20:54:39Z",
          "updatedAt": "2022-01-04T20:54:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 539,
      "id": "PR_kwDOB-yxNc4_zWSV",
      "title": "Add ACM CCS 2022 reference with updated security considerations",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/539",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @ekr ",
      "createdAt": "2022-09-28T18:54:57Z",
      "updatedAt": "2022-10-11T07:18:53Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "b14629bf6a2e3421a13f93b0c9e63a8e555ba728",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/add-analysis-reference",
      "headRefOid": "3539c66aeeae462b2a62e5a1e2786b21b6bda7a1",
      "closedAt": "2022-10-03T11:50:26Z",
      "mergedAt": "2022-10-03T11:50:26Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "39564d24226ef26a4a55df6009605cadead9583f"
      },
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\nNice!\r\n\r\nS\r\n\r\nOn 28/09/2022 19:55, Christopher Wood wrote:\r\n> cc @ekr\r\n> You can view, comment on, or merge this pull request online at:\r\n> \r\n>    https://github.com/tlswg/draft-ietf-tls-esni/pull/539\r\n> \r\n> -- Commit Summary --\r\n> \r\n>    * Add ACM CCS 2022 reference with updated security considerations\r\n> \r\n> -- File Changes --\r\n> \r\n>      M draft-ietf-tls-esni.md (58)\r\n> \r\n> -- Patch Links --\r\n> \r\n> https://github.com/tlswg/draft-ietf-tls-esni/pull/539.patch\r\n> https://github.com/tlswg/draft-ietf-tls-esni/pull/539.diff\r\n> \r\n",
          "createdAt": "2022-10-11T07:18:53Z",
          "updatedAt": "2022-10-11T07:18:53Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOB-yxNc5DBTXm",
          "commit": {
            "abbreviatedOid": "26d89b4"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-28T22:12:18Z",
          "updatedAt": "2022-09-28T22:12:19Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "You should probably nuke this file.",
              "createdAt": "2022-09-28T22:12:18Z",
              "updatedAt": "2022-09-28T22:12:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5DBaKs",
          "commit": {
            "abbreviatedOid": "26d89b4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-28T22:55:17Z",
          "updatedAt": "2022-09-28T22:55:17Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "Thanks -- didn't even notice that I pushed this. I'll remove it.",
              "createdAt": "2022-09-28T22:55:17Z",
              "updatedAt": "2022-09-28T22:55:17Z"
            }
          ]
        }
      ]
    },
    {
      "number": 550,
      "id": "PR_kwDOB-yxNc5WW-f4",
      "title": "Make references official",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/550",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #548 \r\nCloses #549",
      "createdAt": "2023-07-25T17:36:16Z",
      "updatedAt": "2023-09-20T18:46:20Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "173a0c6c3ab8e3cd54e84ea6c0a43ae4e74bf223",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/fix-references",
      "headRefOid": "0c0bcabc506520d3a48cd4a391403f3b453cae50",
      "closedAt": "2023-09-20T18:46:20Z",
      "mergedAt": "2023-09-20T18:46:20Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "7650197a6de481aa8c32804276f84aa211856dc3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOB-yxNc5cMjvq",
          "commit": {
            "abbreviatedOid": "b4a7df1"
          },
          "author": "sayrer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-26T04:18:38Z",
          "updatedAt": "2023-07-26T04:18:47Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Maybe:\r\n`ECH is supported in TLS 1.3, DTLS 1.3, and newer versions of the TLS and DTLS protocols.`\r\n\r\nRationale: \"only supported with\" sounds wrong, and Section 6.1 prohibits TLS 1.2 anyway.",
              "createdAt": "2023-07-26T04:18:38Z",
              "updatedAt": "2023-07-26T04:18:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5cRG6-",
          "commit": {
            "abbreviatedOid": "b4a7df1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-26T15:06:53Z",
          "updatedAt": "2023-07-26T15:06:53Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nECH is supported in TLS 1.3 {{!RFC8446}}, DTLS 1.3 {{!RFC9147}}, and\r\n```",
              "createdAt": "2023-07-26T15:06:53Z",
              "updatedAt": "2023-07-26T15:06:53Z"
            }
          ]
        }
      ]
    },
    {
      "number": 552,
      "id": "PR_kwDOB-yxNc5Y26_k",
      "title": "Fix typo retry_configs",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/552",
      "state": "MERGED",
      "author": "thekuwayama",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR fixes a small typo.",
      "createdAt": "2023-08-26T21:27:28Z",
      "updatedAt": "2023-10-09T15:33:55Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "173a0c6c3ab8e3cd54e84ea6c0a43ae4e74bf223",
      "headRepository": "thekuwayama/draft-ietf-tls-esni",
      "headRefName": "fix-typo",
      "headRefOid": "f639e99aa91d0b22eb9cd4516b681939e94edabc",
      "closedAt": "2023-10-09T11:04:11Z",
      "mergedAt": "2023-10-09T11:04:11Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ec2a23949130c19a27c0396a38550206249757b7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOB-yxNc5jMct6",
          "commit": {
            "abbreviatedOid": "f639e99"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-09T11:04:06Z",
          "updatedAt": "2023-10-09T11:04:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 553,
      "id": "PR_kwDOB-yxNc5a5gMh",
      "title": "Officially request the SVCB codepoint",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/553",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Now that the SVCB draft no longer defines this code point, we have to do it here.",
      "createdAt": "2023-09-21T14:39:32Z",
      "updatedAt": "2023-10-09T21:02:20Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "7650197a6de481aa8c32804276f84aa211856dc3",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/iana-svcb",
      "headRefOid": "363bce0301a1805217ef3e314ad7ff7eebe4f5bb",
      "closedAt": "2023-09-21T16:51:03Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 556,
      "id": "PR_kwDOB-yxNc5cTMs8",
      "title": "Cite draft-ietf-tls-svcb-ech for ECH in DNS",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/556",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #554 ",
      "createdAt": "2023-10-09T21:04:59Z",
      "updatedAt": "2023-10-12T15:16:59Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "86c60ecde2179e54f6e2160cf551c72f0c77b9ce",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/cite-ech-bootstrapping",
      "headRefOid": "76741468b5f2defc5212506c2d27805e727742d1",
      "closedAt": "2023-10-12T15:16:59Z",
      "mergedAt": "2023-10-12T15:16:59Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "a2de29dc72f2fa91f64ae03e3426b929fde47a0b"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 557,
      "id": "PR_kwDOB-yxNc5cTSxJ",
      "title": "Create a new ECH config extension registry",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/557",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #555 \r\n\r\ncc @dennisjackson ",
      "createdAt": "2023-10-09T21:22:06Z",
      "updatedAt": "2023-10-12T15:22:18Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "86c60ecde2179e54f6e2160cf551c72f0c77b9ce",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/ech-config-extensions",
      "headRefOid": "eb9872d363bd6c01404540706bc2b89e6323adbf",
      "closedAt": "2023-10-12T15:22:18Z",
      "mergedAt": "2023-10-12T15:22:18Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "6374d534622c9b039b11fdf58887f3b071724108"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOB-yxNc5jSSy7",
          "commit": {
            "abbreviatedOid": "1ad4c58"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-10T01:22:12Z",
          "updatedAt": "2023-10-10T01:24:14Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Extremely nitpicky nitpick: I guess it's `ech_config_extension_type` instead of `extension_type` to distinguish from Extension's `extension_type`, but then `extension_data` is still the same. This is a little odd.\r\n\r\nI might suggest we just call them `extension_type` and `extension_data` or perhaps even `type` and `data`. There's no actual requirement that field names be unique.",
              "createdAt": "2023-10-10T01:22:12Z",
              "updatedAt": "2023-10-10T01:24:14Z"
            },
            {
              "originalPosition": 43,
              "body": "Perhaps something like:\r\n\r\n```suggestion\r\nthan one extension of the same type in the extensions block. Unlike TLS extensions, an extension can\r\n```\r\nOtherwise it kind reads like this is carried over from TLS.",
              "createdAt": "2023-10-10T01:23:18Z",
              "updatedAt": "2023-10-10T01:24:14Z"
            },
            {
              "originalPosition": 83,
              "body": "I've never written text that sets up an IANA registry before, so all I can do is skim it and say it seems plausible. :-)",
              "createdAt": "2023-10-10T01:24:04Z",
              "updatedAt": "2023-10-10T01:24:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5jcSib",
          "commit": {
            "abbreviatedOid": "1ad4c58"
          },
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T16:58:08Z",
          "updatedAt": "2023-10-10T16:58:08Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Do we really need this mandatory mechanism? ISTM using it would be the equivalent of changing the TLS extension codepoint for ECH - do we even have a thought-experiment example of how such a \"mandatory\" extension could be deployed and see that work with the current/RFC-to-be TLS extension codepoint for ECH?",
              "createdAt": "2023-10-10T16:58:08Z",
              "updatedAt": "2023-10-10T16:58:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5jcUkn",
          "commit": {
            "abbreviatedOid": "1ad4c58"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T16:59:00Z",
          "updatedAt": "2023-10-10T16:59:00Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "This is existing text, so we'll keep it as is and track extensions in general separately.",
              "createdAt": "2023-10-10T16:59:00Z",
              "updatedAt": "2023-10-10T16:59:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5jceZU",
          "commit": {
            "abbreviatedOid": "1ad4c58"
          },
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T17:04:20Z",
          "updatedAt": "2023-10-10T17:04:20Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Yes, it's existing text, however I'm quite skeptical that the mechanism will be useful. If we don't even have a thought-experiment indicating it's deployable, then removing the mechanism would seem to me wise.",
              "createdAt": "2023-10-10T17:04:20Z",
              "updatedAt": "2023-10-10T17:04:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5jcgIp",
          "commit": {
            "abbreviatedOid": "1ad4c58"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T17:05:40Z",
          "updatedAt": "2023-10-10T17:05:40Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "I'm not disagreeing. I'm saying this PR is not the place to discuss the merits of the existing text.",
              "createdAt": "2023-10-10T17:05:40Z",
              "updatedAt": "2023-10-10T17:05:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5jcg9W",
          "commit": {
            "abbreviatedOid": "1ad4c58"
          },
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T17:06:29Z",
          "updatedAt": "2023-10-10T17:06:30Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "If my comment is better as some other github artefact (e.g. a new issue or PR) I'm fine creating one.",
              "createdAt": "2023-10-10T17:06:29Z",
              "updatedAt": "2023-10-10T17:06:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5jck48",
          "commit": {
            "abbreviatedOid": "1ad4c58"
          },
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T17:12:58Z",
          "updatedAt": "2023-10-10T17:12:58Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "K, I'll create a new issue.",
              "createdAt": "2023-10-10T17:12:58Z",
              "updatedAt": "2023-10-10T17:12:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5jzgd6",
          "commit": {
            "abbreviatedOid": "1ad4c58"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-12T15:18:13Z",
          "updatedAt": "2023-10-12T15:18:14Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Good point -- `type` and `data` is much more succinct!",
              "createdAt": "2023-10-12T15:18:14Z",
              "updatedAt": "2023-10-12T15:18:14Z"
            }
          ]
        }
      ]
    },
    {
      "number": 558,
      "id": "PR_kwDOB-yxNc5cTXKe",
      "title": "Remove alternative designs",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/558",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This doesn't make sense to keep in the final document, so let's remove it.\r\n\r\ncc @dennisjackson, @davidben, @cjpatton ",
      "createdAt": "2023-10-09T21:41:15Z",
      "updatedAt": "2023-10-12T15:24:32Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "86c60ecde2179e54f6e2160cf551c72f0c77b9ce",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/remove-alts",
      "headRefOid": "8404709ba75e8d3fbd09de8a67eb94786094c1ac",
      "closedAt": "2023-10-12T15:24:32Z",
      "mergedAt": "2023-10-12T15:24:32Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "5be3bc5f5b4a4257052c403396c4a9069a3baa85"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOB-yxNc5jSSkm",
          "commit": {
            "abbreviatedOid": "8404709"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Don't feel strongly whether it goes or stays in, but if you want to remove it, SGTM.",
          "createdAt": "2023-10-10T01:20:33Z",
          "updatedAt": "2023-10-10T01:20:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 559,
      "id": "PR_kwDOB-yxNc5cTY5_",
      "title": "Note timing side channels",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/559",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #400 \r\n\r\nThere may be other ways to spell this, or other places to put it, so please feel free to leave suggestions or propose alternative PRs if desired.\r\n\r\ncc @dennisjackson, @davidben, @cjpatton ",
      "createdAt": "2023-10-09T21:49:31Z",
      "updatedAt": "2023-10-12T15:16:45Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "86c60ecde2179e54f6e2160cf551c72f0c77b9ce",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/timing-side-channels",
      "headRefOid": "a2b72a8ef84c3c1209c310f993187ccd66e43db3",
      "closedAt": "2023-10-12T15:16:45Z",
      "mergedAt": "2023-10-12T15:16:45Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "1a4087f66b8996d01ae745e24b50598f5cd389a7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOB-yxNc5jSR2N",
          "commit": {
            "abbreviatedOid": "78d9bbf"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-10T01:14:43Z",
          "updatedAt": "2023-10-10T01:14:50Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "https://www.rfc-editor.org/rfc/rfc6919.html#section-2 ;-)",
              "createdAt": "2023-10-10T01:14:43Z",
              "updatedAt": "2023-10-10T01:14:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5jSR6Y",
          "commit": {
            "abbreviatedOid": "78d9bbf"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T01:15:11Z",
          "updatedAt": "2023-10-10T01:15:12Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "(I don't have a suggestion and am not requesting a change. Just amused.)",
              "createdAt": "2023-10-10T01:15:11Z",
              "updatedAt": "2023-10-10T01:15:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5jSSDe",
          "commit": {
            "abbreviatedOid": "78d9bbf"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T01:16:19Z",
          "updatedAt": "2023-10-10T01:16:19Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Heh, yeah. I mostly just copied boilerplate language we use in Privacy Pass. \ud83e\udd37",
              "createdAt": "2023-10-10T01:16:19Z",
              "updatedAt": "2023-10-10T01:16:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5jbd6q",
          "commit": {
            "abbreviatedOid": "78d9bbf"
          },
          "author": "klinvill",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T15:43:51Z",
          "updatedAt": "2023-10-10T15:43:51Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Minor typo:\r\n> Values which _depend_ on ...",
              "createdAt": "2023-10-10T15:43:51Z",
              "updatedAt": "2023-10-10T15:43:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5jjO2f",
          "commit": {
            "abbreviatedOid": "78d9bbf"
          },
          "author": "dennisjackson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-11T06:56:13Z",
          "updatedAt": "2023-10-11T06:56:13Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOB-yxNc5jmgF7",
          "commit": {
            "abbreviatedOid": "78d9bbf"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-11T12:17:46Z",
          "updatedAt": "2023-10-11T12:17:46Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "```suggestion\r\nValues which depend on the contents of ClientHelloInner, such as the\r\n```",
              "createdAt": "2023-10-11T12:17:46Z",
              "updatedAt": "2023-10-11T12:17:47Z"
            }
          ]
        }
      ]
    },
    {
      "number": 560,
      "id": "PR_kwDOB-yxNc5cTa_q",
      "title": "Note behavior and give an example alongside configurations",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/560",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #519\r\n\r\ncc @klinvill, @davidben, @dennisjackson, @cjpatton ",
      "createdAt": "2023-10-09T21:57:29Z",
      "updatedAt": "2023-10-13T23:04:10Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "c08b4e6fc958fa00b189fbd30e59cf7460d5b706",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/note-behavior",
      "headRefOid": "b88f046ede4bf5d0335e9e35a60faa4cb908f6d5",
      "closedAt": "2023-10-13T23:04:10Z",
      "mergedAt": "2023-10-13T23:04:10Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "90756038a517af05d1691c9e0ad33294f4513cad"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@klinvill we talk about the anonymity set in the security considerations -- we could simply point there?",
          "createdAt": "2023-10-12T16:32:56Z",
          "updatedAt": "2023-10-12T16:32:56Z"
        },
        {
          "author": "klinvill",
          "authorAssociation": "NONE",
          "body": "> @klinvill we talk about the anonymity set in the security considerations -- we could simply point there?\r\n\r\nAnonymity sets are discussed there, but not precisely defined. I think it might be nicer to have a canonical precise definition that could be referenced by the rest of the spec. I opened #568 to discuss this further (if warranted) and would be happy to take a stab at what such revisions would look like (as a PR).",
          "createdAt": "2023-10-12T16:51:07Z",
          "updatedAt": "2023-10-12T16:51:07Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOB-yxNc5jSSUN",
          "commit": {
            "abbreviatedOid": "a0fe479"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T01:18:26Z",
          "updatedAt": "2023-10-10T01:18:27Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I'm not sure what you mean by \"how they respond to incoming client connections\". Which certificate you send is arguably how part of \"how they respond\" but presumably we don't mean that! I suppose it could cover other externally-visible implementation choices like division of data into record-layer boundaries. That'd be a pretty solid example... but #519 talks about cipher suite selection, and that's already covered by configurations. So I'm just very confused right now.",
              "createdAt": "2023-10-10T01:18:26Z",
              "updatedAt": "2023-10-10T01:18:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5jXyvj",
          "commit": {
            "abbreviatedOid": "a0fe479"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T10:32:26Z",
          "updatedAt": "2023-10-10T10:32:26Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "The idea here is that how a server responds, and how that response is visible to the attacker, influences the anonymity set. So on that basis I would consider what certificate they send to be covered here. Note that we don't need to be very rigorous here -- this is just the introduction and the point is to convey the high-level goal of ECH. ",
              "createdAt": "2023-10-10T10:32:26Z",
              "updatedAt": "2023-10-10T10:32:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5jbS0y",
          "commit": {
            "abbreviatedOid": "a0fe479"
          },
          "author": "klinvill",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T15:21:43Z",
          "updatedAt": "2023-10-10T15:34:33Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "The broader point I meant to raise in #519 is that there are several choices servers can make that result in visible differences from the vantage point of an attacker, only some of which I would consider as part of the server's configuration (from an end-user's perspective) while others could end up being implementation differences like David mentions. For example, I would consider which cipher suites a server supports as part of a server's configuration. However, the order that extensions (e.g. key_share, pre_shared_key, supported_versions) appear in the plaintext ServerHello message is not typically a configuration value in the server but may be implementation dependent (since an extension order is not specified in neither the TLS 1.3 nor TLS ECH specs).\r\n\r\nOne could argue that these externally observable behaviors are part of the \"externally visible TLS configurations\", but I would argue that configurations should primarily refer to user-specifiable configurations to be consistent with the mental model I believe most server-providers would have upon reading the spec. I think it is therefore helpful to have additional text that points out that subtle implementation differences beyond user-provided configurations can result in servers being part of smaller anonymity sets than they may initially believe.\r\n\r\nA server's cipher suite preferences could be user-specified, but other implementations may opt for a single static preference which may be incompatible with another implementations preferences. Other distinguishable behavior that I believe is not user-configured but implementation-specific includes choosing to send EncryptedExtensions, CertificateRequest, Certificate, CertificateVerify, and Finished messages as separate records or pack them into a few records (which I believe is a subset of what David is referring to as division of data into record-layer boundaries).",
              "createdAt": "2023-10-10T15:21:43Z",
              "updatedAt": "2023-10-10T15:34:33Z"
            },
            {
              "originalPosition": 12,
              "body": "Given that my main concern is that implementation-specific behavior can result in smaller anonymity sets than a user might believe based on their user-provided configurations, maybe we could rewrite the text to explicitly mention implementation-specific behavior. So the text could be something like:\r\n\r\n> Co-located servers with consistent externally visible TLS configurations and behavior, including supported versions and cipher suites and how they respond to incoming client connections, form an anonymity set. _Note that implementation-specific choices, such as extension ordering within ServerHello and HelloRetryRequest messages or division of data into record-layer boundaries, can result in different externally visible behavior, even when servers run using the same user-provided TLS configurations._ Usage of this mechanism reveals that a client is connecting to a particular service provider, but does not reveal which server from the anonymity set terminates the connection.",
              "createdAt": "2023-10-10T15:32:55Z",
              "updatedAt": "2023-10-10T15:34:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5jbaw8",
          "commit": {
            "abbreviatedOid": "a0fe479"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T15:37:29Z",
          "updatedAt": "2023-10-10T15:37:29Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "As above, I don't think we need to be rigorous or precise here. This suggestion is a lot more text than I think is warranted for this small point.  That said... @davidben, does this additional text clarify your confusion?",
              "createdAt": "2023-10-10T15:37:29Z",
              "updatedAt": "2023-10-10T15:45:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5jztjN",
          "commit": {
            "abbreviatedOid": "a0fe479"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-12T15:32:57Z",
          "updatedAt": "2023-10-12T15:32:57Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "@klinvill after thinking on this some more I decided to fold in a variant of your suggestion has a parenthetical. Please have another look?",
              "createdAt": "2023-10-12T15:32:57Z",
              "updatedAt": "2023-10-12T15:32:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5j0LWT",
          "commit": {
            "abbreviatedOid": "3e3d2a1"
          },
          "author": "klinvill",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "Thanks for the changes Chris, this looks good to me! I think the explicit parenthetical will help readers of this document understand that external configurations and behavior can include implementation-specific behaviors.\r\n\r\nOn a related note, I noticed that the security goals section includes a parenthetical that states: `(The set of hosts which share the same ECHConfig and TLS configuration is referred to as the anonymity set.)`. Perhaps this should be updated to reflect the text here (e.g. include \"externally visible\"), or better yet drop the parenthetical all together and add an explicit definition of \"anonymity set\". I'll open a separate issue for this though since it's a different concern from what this PR addresses.",
          "createdAt": "2023-10-12T16:32:00Z",
          "updatedAt": "2023-10-12T16:32:00Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOB-yxNc5j-UN7",
          "commit": {
            "abbreviatedOid": "b88f046"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-13T20:09:36Z",
          "updatedAt": "2023-10-13T20:09:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 561,
      "id": "PR_kwDOB-yxNc5cTfWn",
      "title": "Cross-implementation decisions may be differentiators",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/561",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #512\r\n\r\nThe idea here is that some real and fake ECH differentiator mitigations may require different implementations to agree on how things are done, which is out of scope. This PR also cleans up some text in the Do Not Stick Out section.\r\n\r\ncc @dennisjackson, @davidben, @cjpatton ",
      "createdAt": "2023-10-09T22:09:58Z",
      "updatedAt": "2023-10-13T23:15:26Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "86c60ecde2179e54f6e2160cf551c72f0c77b9ce",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/clarify-cross-impl-differences",
      "headRefOid": "c69bbfd52085b3ff9d7b761529bda90081d75ad2",
      "closedAt": "2023-10-13T23:15:25Z",
      "mergedAt": "2023-10-13T23:15:25Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ddff9d9451bd474aeb434c0547d891c2849b5dfb"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@davidben would you like to see changes here, or can we merge this? @dennisjackson, I'd also appreciate your review.",
          "createdAt": "2023-10-12T15:24:18Z",
          "updatedAt": "2023-10-12T15:24:18Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOB-yxNc5jSTfI",
          "commit": {
            "abbreviatedOid": "dddc10e"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T01:27:13Z",
          "updatedAt": "2023-10-10T01:27:13Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "This is a little interesting. The length of the ECH ciphertext only matches if the implementation accurately simulates things. The length of the encrypted certificate only matches if implementation applies the same padding between the two cases.\r\n\r\nNot sure how best to phrase this. It's not out-of-scope per se in that we don't completely ignore it. But we also can't claim they were designed not to not vary without any qualifications.",
              "createdAt": "2023-10-10T01:27:13Z",
              "updatedAt": "2023-10-10T01:27:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5jXz9r",
          "commit": {
            "abbreviatedOid": "dddc10e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T10:33:49Z",
          "updatedAt": "2023-10-10T10:33:50Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "This is existing text (just formatted differently), so I'd be inclined to address that in a followup PR or do nothing.",
              "createdAt": "2023-10-10T10:33:49Z",
              "updatedAt": "2023-10-10T10:33:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5j-W-h",
          "commit": {
            "abbreviatedOid": "dddc10e"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-13T20:20:11Z",
          "updatedAt": "2023-10-13T20:23:31Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "```suggestion\r\n1. the code points of extensions negotiated in the clear, and their order;\r\n```",
              "createdAt": "2023-10-13T20:20:11Z",
              "updatedAt": "2023-10-13T20:23:31Z"
            },
            {
              "originalPosition": 12,
              "body": "What about qualifying \"do not very\"? \"do not vary significantly\"?\r\n\r\nQuestion: Do we believe it's possible for an implementation to make real ECH computationally indistinguishable from grease ECH? Would such an implementation be non-compliant? ",
              "createdAt": "2023-10-13T20:23:28Z",
              "updatedAt": "2023-10-13T20:23:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5j_OqR",
          "commit": {
            "abbreviatedOid": "81874ba"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-13T23:03:14Z",
          "updatedAt": "2023-10-13T23:03:14Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\ndo not noticeably vary to the attacker, i.e., they are not distinguishers:\r\n```",
              "createdAt": "2023-10-13T23:03:14Z",
              "updatedAt": "2023-10-13T23:03:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5j_Osk",
          "commit": {
            "abbreviatedOid": "c69bbfd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-13T23:03:33Z",
          "updatedAt": "2023-10-13T23:03:33Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I took the suggestion to qualify \"do not vary\" -- @cjpatton please have a look.",
              "createdAt": "2023-10-13T23:03:33Z",
              "updatedAt": "2023-10-13T23:03:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5j_O3A",
          "commit": {
            "abbreviatedOid": "c69bbfd"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-13T23:05:14Z",
          "updatedAt": "2023-10-13T23:05:57Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I think it's fine as is, but my suggestion was to tack on \"significantly\". See suggestion above.",
              "createdAt": "2023-10-13T23:05:14Z",
              "updatedAt": "2023-10-13T23:05:57Z"
            },
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nMoreover, real ECH and GREASE ECH are designed so that implementations can ensure the following features\r\ndo not vary significantly:\r\n```",
              "createdAt": "2023-10-13T23:05:54Z",
              "updatedAt": "2023-10-13T23:05:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5j_PBL",
          "commit": {
            "abbreviatedOid": "81874ba"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-13T23:06:54Z",
          "updatedAt": "2023-10-13T23:06:54Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "I don't really know if this is a helpful qualifier because we don't have a definition of \"significantly,\" so I think I'd prefer to leave this off for now.",
              "createdAt": "2023-10-13T23:06:54Z",
              "updatedAt": "2023-10-13T23:06:54Z"
            }
          ]
        }
      ]
    },
    {
      "number": 562,
      "id": "PR_kwDOB-yxNc5cTmGi",
      "title": "Punt on new transport connection specifics",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/562",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #524 \r\n\r\nAs always, happy to take suggestions or alternative PRs.\r\n\r\ncc @dennisjackson, @davidben, @martinthomson ",
      "createdAt": "2023-10-09T22:30:34Z",
      "updatedAt": "2023-10-16T13:26:33Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "86c60ecde2179e54f6e2160cf551c72f0c77b9ce",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/new-transport-punt",
      "headRefOid": "0a97d054199c463a42258fc2caa3768d03547582",
      "closedAt": "2023-10-16T13:26:32Z",
      "mergedAt": "2023-10-16T13:26:32Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "48e5eb62073ad358586a6ad455bdefc5a8ec74c3"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@davidben @dennisjackson, can you please review?",
          "createdAt": "2023-10-12T15:23:29Z",
          "updatedAt": "2023-10-12T15:23:29Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOB-yxNc5jR6qh",
          "commit": {
            "abbreviatedOid": "eb3ee35"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T00:18:48Z",
          "updatedAt": "2023-10-10T00:44:36Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nThe retry configurations may only be applied to the retried connection. The\r\n```",
              "createdAt": "2023-10-10T00:18:48Z",
              "updatedAt": "2023-10-10T00:44:36Z"
            },
            {
              "originalPosition": 14,
              "body": "Is this a \"MUST only\"?",
              "createdAt": "2023-10-10T00:19:02Z",
              "updatedAt": "2023-10-10T00:53:57Z"
            },
            {
              "originalPosition": 9,
              "body": "This paragraph got thicc.  Do you want to turn it into three?",
              "createdAt": "2023-10-10T00:19:26Z",
              "updatedAt": "2023-10-10T00:44:36Z"
            },
            {
              "originalPosition": 15,
              "body": "Unrelated to this change, but if a client is making multiple connections (hello HTTP/1.1), can it use the retry configuration it learns from its first connection to guide all connections in that pool?\r\n\r\nLet's say that the client is making these connections within the same context and so has no concerns about the connection attempts being correlated (maybe it was going to send the same cookies in all of them).  Should the client only use the retry configuration for a single connection, even knowing that it will be forced to retry multiple times, or can it propagate that information immediately?\r\n\r\nI like that this text largely avoids 2119 language (questionable lowercase \"may\" and \"should\" usage notwithstanding), but this one comes with a \"MUST NOT\" that seems misguided.",
              "createdAt": "2023-10-10T00:23:43Z",
              "updatedAt": "2023-10-10T00:44:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5jX1At",
          "commit": {
            "abbreviatedOid": "e64796a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T10:34:59Z",
          "updatedAt": "2023-10-10T10:35:00Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nserver.\r\n\r\nClients can implement a new transport connection in a way that best\r\nsuits their deployment. For example, clients can reuse the same IP address\r\nwhen establishing the new transport connection or they can choose to use a\r\ndifferent IP address if provided with options from DNS. ECH does not mandate\r\nany specific implementation choices when establishing this new connection.\r\n\r\n```",
              "createdAt": "2023-10-10T10:34:59Z",
              "updatedAt": "2023-10-10T10:35:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5jX12d",
          "commit": {
            "abbreviatedOid": "0a97d05"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T10:36:02Z",
          "updatedAt": "2023-10-10T10:36:03Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Indeed -- unrelated, since this is existing text. I filed [this issue](https://github.com/tlswg/draft-ietf-tls-esni/issues/565) to track resolution separately.",
              "createdAt": "2023-10-10T10:36:03Z",
              "updatedAt": "2023-10-10T10:36:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5kDGgo",
          "commit": {
            "abbreviatedOid": "0a97d05"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-15T01:22:50Z",
          "updatedAt": "2023-10-15T01:22:50Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOB-yxNc5kGBgj",
          "commit": {
            "abbreviatedOid": "0a97d05"
          },
          "author": "dennisjackson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-16T07:34:37Z",
          "updatedAt": "2023-10-16T07:34:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 563,
      "id": "PR_kwDOB-yxNc5cTnWO",
      "title": "TCP is not the only transport",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/563",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #551 \r\n\r\nI realize that QUIC, being a transport that inlines TLS, would not immediately apply here, but I think the intent is generic enough to not be confusing or misleading. Plus, this was literally the only place we used \"TCP,\" whereas elsewhere we use \"transport connection,\" so this is also for consistency.\r\n\r\ncc @dennisjackson, @davidben, @cjpatton ",
      "createdAt": "2023-10-09T22:33:21Z",
      "updatedAt": "2023-10-12T15:15:32Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "86c60ecde2179e54f6e2160cf551c72f0c77b9ce",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/not-tcp-specific",
      "headRefOid": "9173bc3e7e2d4781306c85b11605e1d3ad15bc7e",
      "closedAt": "2023-10-12T15:15:32Z",
      "mergedAt": "2023-10-12T15:15:32Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "36158efbd25361a383033b0e27a3eab4dcd33dd1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOB-yxNc5jSRtQ",
          "commit": {
            "abbreviatedOid": "9173bc3"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-10T01:13:35Z",
          "updatedAt": "2023-10-10T01:13:35Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOB-yxNc5jcls4",
          "commit": {
            "abbreviatedOid": "9173bc3"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-10T17:15:01Z",
          "updatedAt": "2023-10-10T17:15:01Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOB-yxNc5jesda",
          "commit": {
            "abbreviatedOid": "9173bc3"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-10T21:01:53Z",
          "updatedAt": "2023-10-10T21:01:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 564,
      "id": "PR_kwDOB-yxNc5cTxxm",
      "title": "Clarify attacker capabilities",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/564",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #513 \r\nCloses #544 \r\n\r\nThe intent here is to punt entirely on the mechanism by which messages between client-facing and backend servers are protected in transit, and simply to state the assumption that these messages do not let the attacker trivially learn information that ECH otherwise protects via encryption. Suggestions for further clarifications are welcome!\r\n\r\ncc @dennisjackson, @davidben, @cjpatton ",
      "createdAt": "2023-10-09T23:06:00Z",
      "updatedAt": "2023-10-15T01:18:24Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "86c60ecde2179e54f6e2160cf551c72f0c77b9ce",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/clarify-network-capabilities",
      "headRefOid": "670d46e8b986558363f50790295d6841a10d66e5",
      "closedAt": "2023-10-13T22:59:42Z",
      "mergedAt": "2023-10-13T22:59:42Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "567b79cc1b534c0b8a0e62773fe762ea99017319"
      },
      "comments": [
        {
          "author": "dennisjackson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "LGTM ",
          "createdAt": "2023-10-11T06:48:15Z",
          "updatedAt": "2023-10-11T06:48:15Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@dennisjackson can I interpret your LGTM as approval? @cjpatton, are you able to take a look at the linked issues?",
          "createdAt": "2023-10-12T15:26:21Z",
          "updatedAt": "2023-10-12T15:26:21Z"
        },
        {
          "author": "dennisjackson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @dennisjackson can I interpret your LGTM as approval?\r\n\r\nYes. My two cents are that thetext is general enough to cover the various issues and specific enough to be easy to understand. ",
          "createdAt": "2023-10-13T11:49:28Z",
          "updatedAt": "2023-10-13T11:49:28Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood Thank you for writing this. The changes look good.",
          "createdAt": "2023-10-15T01:18:24Z",
          "updatedAt": "2023-10-15T01:18:24Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOB-yxNc5jgXP4",
          "commit": {
            "abbreviatedOid": "218f6b8"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Looks good but I want to double check that this actually resolve the issue before approving. One minor suggestion on wording.",
          "createdAt": "2023-10-11T00:28:17Z",
          "updatedAt": "2023-10-11T00:32:49Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "```suggestion\r\n1. The channel between each client-facing and each backend server is authenticated\r\n```",
              "createdAt": "2023-10-11T00:28:17Z",
              "updatedAt": "2023-10-11T00:32:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5j6m1C",
          "commit": {
            "abbreviatedOid": "670d46e"
          },
          "author": "dennisjackson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-13T11:44:40Z",
          "updatedAt": "2023-10-13T11:44:40Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOB-yxNc5j_ChH",
          "commit": {
            "abbreviatedOid": "670d46e"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "This addresses the concerns raised, in my opinion. It acknowledges that in Split Mode the attack surface changes in a way that ECH cannot address on its own. I think @kazuho would prefer we not describe Split Mode, but the precedent has been sent and I don't think we can change this at this point.",
          "createdAt": "2023-10-13T22:23:51Z",
          "updatedAt": "2023-10-13T22:23:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 566,
      "id": "PR_kwDOB-yxNc5cXhya",
      "title": "Add text describing deployment impacts of no SNI access",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/566",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This lifts text from the ECH deployment considerations draft for inclusion in the ECH draft. It is not uncommon for protocol documents to address deployment considerations head on, and this PR attempts to do so. As always, feedback on the exact phrasing is welcome.\r\n\r\ncc @dennisjackson, @davidben, @martinthomson, @cjpatton, @sftcd",
      "createdAt": "2023-10-10T10:47:18Z",
      "updatedAt": "2023-10-13T13:35:24Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "86c60ecde2179e54f6e2160cf551c72f0c77b9ce",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/deployment-impact",
      "headRefOid": "62ddbc95e81f87ef558fb57a4a0a7150c272569d",
      "closedAt": "2023-10-13T13:35:24Z",
      "mergedAt": "2023-10-13T13:35:24Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "c08b4e6fc958fa00b189fbd30e59cf7460d5b706"
      },
      "comments": [
        {
          "author": "dennisjackson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "LGTM. Do you want to add something about untrusted environments? e.g. \r\n\r\n\"In an environment where the network operator controls the endpoint devices, but is concerned about malware or similar exfiltrating data, the SNI field is unsuitable for use as a control even in the absence of ECH. This is because malware is able to spoof the value in an SNI field already, and can even fool security appliances which try to 'double-check' the websites hosted by the target server. ECH does not materially change this situation.\"   ",
          "createdAt": "2023-10-11T06:54:43Z",
          "updatedAt": "2023-10-11T06:54:43Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@dennisjackson I worked in your suggested paragraph. Please take another look!",
          "createdAt": "2023-10-12T15:30:32Z",
          "updatedAt": "2023-10-12T15:30:32Z"
        },
        {
          "author": "dennisjackson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @dennisjackson I worked in your suggested paragraph. Please take another look!\r\n\r\nTwo small suggestions, otherwise LGTM. ",
          "createdAt": "2023-10-13T11:38:57Z",
          "updatedAt": "2023-10-13T11:38:57Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOB-yxNc5jbj3R",
          "commit": {
            "abbreviatedOid": "4627bb5"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-10T15:54:48Z",
          "updatedAt": "2023-10-10T15:57:35Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "```suggestion\r\nfor use cases of information that ECH protects. In particular,\r\n```",
              "createdAt": "2023-10-10T15:54:48Z",
              "updatedAt": "2023-10-10T15:57:35Z"
            },
            {
              "originalPosition": 60,
              "body": "```suggestion\r\nimplementations will fall back to TLS without ECH in the event of disablement.\r\n```",
              "createdAt": "2023-10-10T15:56:45Z",
              "updatedAt": "2023-10-10T15:57:35Z"
            },
            {
              "originalPosition": 66,
              "body": "It might be worth suggesting how to disable ECH here. (Toggle in DNS?)",
              "createdAt": "2023-10-10T15:57:32Z",
              "updatedAt": "2023-10-10T15:57:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5jeBbs",
          "commit": {
            "abbreviatedOid": "4627bb5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T20:20:49Z",
          "updatedAt": "2023-10-10T20:20:49Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "We could offer that as an example, yeah. ",
              "createdAt": "2023-10-10T20:20:49Z",
              "updatedAt": "2023-10-10T20:20:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5jjM_O",
          "commit": {
            "abbreviatedOid": "e4a9dea"
          },
          "author": "dennisjackson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-11T06:51:12Z",
          "updatedAt": "2023-10-11T06:51:12Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "I don't think we should point people to unauthenticated DNS toggles if we can help it. Perhaps just \"disable ECH entirely via group policy\"? ",
              "createdAt": "2023-10-11T06:51:12Z",
              "updatedAt": "2023-10-11T06:51:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5jzpMA",
          "commit": {
            "abbreviatedOid": "4627bb5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-12T15:27:04Z",
          "updatedAt": "2023-10-12T15:27:04Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "That's a good suggestion -- I'll work it in.",
              "createdAt": "2023-10-12T15:27:04Z",
              "updatedAt": "2023-10-12T15:27:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5j6jz-",
          "commit": {
            "abbreviatedOid": "06c1f3a"
          },
          "author": "dennisjackson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-13T11:36:22Z",
          "updatedAt": "2023-10-13T11:36:23Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "```suggestion\r\nIn environments where the network operator does not control the endpoint devices, or does controls the endpoint devices, but\r\n```",
              "createdAt": "2023-10-13T11:36:22Z",
              "updatedAt": "2023-10-13T11:36:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5j6kp2",
          "commit": {
            "abbreviatedOid": "06c1f3a"
          },
          "author": "dennisjackson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-13T11:38:06Z",
          "updatedAt": "2023-10-13T11:38:06Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "```suggestion\r\nabsence of ECH. This is because devices without controls, or which have been compromised, can alter or spoof the\r\n```",
              "createdAt": "2023-10-13T11:38:06Z",
              "updatedAt": "2023-10-13T11:38:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5j7aiC",
          "commit": {
            "abbreviatedOid": "ba75a63"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-13T13:33:45Z",
          "updatedAt": "2023-10-13T13:33:46Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "```suggestion\r\nIn environments where the network operator does not control the endpoint\r\ndevices, or does controls the endpoint devices, but is concerned about the\r\nsecurity consequences of compromised devices, e.g., data exfiltration, the\r\nSNI field is unsuitable for use as a control even in the absence of ECH. This\r\nis because devices without controls, or which have been compromised, can alter\r\nor spoof the value in an SNI field already, and can even bypass security\r\nappliances which try to 'double-check' websites hosted by the target server.\r\nECH does not materially change this situation.\r\n```",
              "createdAt": "2023-10-13T13:33:46Z",
              "updatedAt": "2023-10-13T13:33:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5j7a3V",
          "commit": {
            "abbreviatedOid": "bfa5d43"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-13T13:34:27Z",
          "updatedAt": "2023-10-13T13:34:27Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "```suggestion\r\ndevices, or does controls the endpoint devices but is concerned about the\r\n```",
              "createdAt": "2023-10-13T13:34:27Z",
              "updatedAt": "2023-10-13T13:34:27Z"
            }
          ]
        }
      ]
    },
    {
      "number": 569,
      "id": "PR_kwDOB-yxNc5dEbyK",
      "title": "Initial grease codepoints",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/569",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #451 \r\n\r\ncc @davidben, @dennisjackson, @cjpatton ",
      "createdAt": "2023-10-17T22:27:25Z",
      "updatedAt": "2023-10-18T14:28:17Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "48e5eb62073ad358586a6ad455bdefc5a8ec74c3",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/grease",
      "headRefOid": "716bf47595ae6ae74e3ae295b3677ec63728c73d",
      "closedAt": "2023-10-18T14:28:16Z",
      "mergedAt": "2023-10-18T14:28:16Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "539eab81d53815f09b7c70c3ee13960da0e977eb"
      },
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "What's the expected behaviour of an ECHConfig generator that wants to include a \"mandatory\" GREASE ECH extension in an HTTTPS RR? If it really ought to include >1 entry in the ECHConfigList in that case (incl. one without that mandatory GREASE ECH extension) then we should say that. (Better would be to get rid of these mandatory extensions IMO, but that's a different topic.)\r\n",
          "createdAt": "2023-10-17T22:35:33Z",
          "updatedAt": "2023-10-17T22:35:33Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think there are any expected behaviors for config generators -- they can put as many greased values in the thing as they want. ",
          "createdAt": "2023-10-17T22:37:43Z",
          "updatedAt": "2023-10-17T22:37:43Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "But then doesn't that mean that all consumers of ECHConfig values MUST know about the GREASE values and ignore those with the mandatory bit set? Don't we need to say that?",
          "createdAt": "2023-10-17T22:38:30Z",
          "updatedAt": "2023-10-17T22:38:30Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think it needs to be explicit. If the client knows it's a grease value, then it will recognize the mandatory bit and \"ignore\" it as desired (it understands that the extension value is grease), but if it doesn't know it's a grease value then it'll drop the config.",
          "createdAt": "2023-10-17T22:43:18Z",
          "updatedAt": "2023-10-17T22:43:18Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "Right, if the client drops the config then things break unless the ECHConfig generator made a list where one doesn't have the \"mandatory\" GREASE codepoint. I think the text as-is is likely to leave a crack into which what may be different sets of implementers may fall, causing interop issues. ",
          "createdAt": "2023-10-17T22:58:31Z",
          "updatedAt": "2023-10-17T22:58:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@sftcd feel free to suggest text if you think it's warranted. I'm OK with the text as-is.",
          "createdAt": "2023-10-17T23:09:42Z",
          "updatedAt": "2023-10-17T23:09:42Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "Sure, I'd add \"Clients MUST know of, and ignore, all these codepoints, including those with the high-order bit set.\" ",
          "createdAt": "2023-10-17T23:12:04Z",
          "updatedAt": "2023-10-17T23:12:04Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry if the above is better supplied some other way, but not sure if you do/don't want 2119 terms in IANA considerations which'd affect where the suggested sentence goes maybe.",
          "createdAt": "2023-10-17T23:14:02Z",
          "updatedAt": "2023-10-17T23:14:02Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "body": "@sftcd \r\n> Sure, I'd add \"Clients MUST know of, and ignore, all these codepoints, including those with the high-order bit set.\"\r\n\r\nOr, we could add something like \"Some extension IDs are reserved for greasing; clients MUST ignore them\" to the [last paragraph of Section 4.2](https://tlswg.org/draft-ietf-tls-esni/draft-ietf-tls-esni.html#section-4.2-3). That's where we define how the client parses all the extensions.",
          "createdAt": "2023-10-18T00:49:07Z",
          "updatedAt": "2023-10-18T00:49:07Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Requiring clients know about grease values would be counterproductive and defeat the point of greasing. Indeed, we specifically *want* the high-order bit values to be treated as unrecognized mandatory extensions. This way config generators can ensure clients actually implement this correctly! Add a bunch of garbage ECHConfigs with unrecognized mandatory configs to make sure clients exercise skipping it.",
          "createdAt": "2023-10-18T02:24:22Z",
          "updatedAt": "2023-10-18T02:24:22Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "That is, the current text is fine and we **_definitely_** should not use the suggested replacement. I'll add a suggestion for a sentence or two, since it sounds like the implications of \"Note that the reserved values with the high-order bit set to 1 are mandatory, as defined in {{config-extensions}}\" are not obvious.",
          "createdAt": "2023-10-18T02:28:30Z",
          "updatedAt": "2023-10-18T02:28:39Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOB-yxNc5kXNLe",
          "commit": {
            "abbreviatedOid": "1a5353e"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T02:31:16Z",
          "updatedAt": "2023-10-18T02:37:34Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nECH configuration, as inspired by {{?RFC8701}}. This helps ensure clients\r\nprocess ECH extensions correctly. When constructing ECH configurations,\r\nservers SHOULD randomly select from reserved values with the high-order\r\nbit clear. Correctly-implemented client will ignore those extensions.\r\n\r\nThe reserved values with the high-order bit set are mandatory, as defined\r\nin {{config-extensions}}. Servers SHOULD randomly select from these\r\nvalues and include them in extraneous ECH configurations. These\r\nextraneous ECH configurations SHOULD have invalid keys, and public\r\nnames which the server does not respond to. Correctly-implemented\r\nclients will ignore these configurations.\r\n```",
              "createdAt": "2023-10-18T02:34:45Z",
              "updatedAt": "2023-10-18T02:37:34Z"
            },
            {
              "originalPosition": 5,
              "body": "Clients don't actually send these, so I think this should be:\r\n\r\n```suggestion\r\nThese can be used by servers to \"grease\" the contents of the\r\n```",
              "createdAt": "2023-10-18T02:35:46Z",
              "updatedAt": "2023-10-18T02:37:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5ka7gQ",
          "commit": {
            "abbreviatedOid": "1a5353e"
          },
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T11:12:20Z",
          "updatedAt": "2023-10-18T11:12:21Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Actually, it's the ECHConfig generator not the TLS server that does this.",
              "createdAt": "2023-10-18T11:12:21Z",
              "updatedAt": "2023-10-18T11:12:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5ka9In",
          "commit": {
            "abbreviatedOid": "1a5353e"
          },
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T11:16:12Z",
          "updatedAt": "2023-10-18T11:16:13Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "I'd be fine with spelling stuff out for the ECHConfig generator. I dunno why \"extraneous\" is a SHOULD though, nor why invalid key values are better? I'd need to think whether or not inventing random public_name values is a good idea.",
              "createdAt": "2023-10-18T11:16:12Z",
              "updatedAt": "2023-10-18T11:16:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5ka9hZ",
          "commit": {
            "abbreviatedOid": "1a5353e"
          },
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T11:17:09Z",
          "updatedAt": "2023-10-18T11:17:09Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Well, unless we're expecting to GREASE retry_configs? I'd not thought about that.",
              "createdAt": "2023-10-18T11:17:09Z",
              "updatedAt": "2023-10-18T11:17:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5kbSEf",
          "commit": {
            "abbreviatedOid": "1a5353e"
          },
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T12:03:08Z",
          "updatedAt": "2023-10-18T12:03:08Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Ah, I guess you want a random key so decryption definitely fails. That seems reasonable. Still not sure about a random public_name though. In any case, some text like this is needed and shows I guess that GREASEing that mandatory bit requires an additional ~70 octets.\r\n",
              "createdAt": "2023-10-18T12:03:08Z",
              "updatedAt": "2023-10-18T12:03:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5kcejZ",
          "commit": {
            "abbreviatedOid": "1a5353e"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T14:05:13Z",
          "updatedAt": "2023-10-18T14:05:14Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Junk public name is so we don't mask the decryption failure with the recovery flow. Don't think it needs to be random though. `ech.invalid` is probably good enough. :-)\r\n\r\nNo strong feelings about SHOULD or MAY or whatever. This is a bit heavier, so downgrading the shouty verb seems reasonable I suppose.",
              "createdAt": "2023-10-18T14:05:14Z",
              "updatedAt": "2023-10-18T14:05:14Z"
            }
          ]
        }
      ]
    },
    {
      "number": 570,
      "id": "PR_kwDOB-yxNc5dEdNy",
      "title": "Relax requirements around retry config usage",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/570",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #565 \r\n\r\ncc @davidben, @dennisjackson, @martinthomson",
      "createdAt": "2023-10-17T22:33:26Z",
      "updatedAt": "2023-10-18T14:26:53Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "48e5eb62073ad358586a6ad455bdefc5a8ec74c3",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/relax-retry",
      "headRefOid": "3b2d64cef6a5279e95dcdb2995ff694afe6dc3f0",
      "closedAt": "2023-10-18T14:26:53Z",
      "mergedAt": "2023-10-18T14:26:53Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "0cfcb8e06d582617e1520e2054c2ab9f482e5735"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOB-yxNc5kWgx7",
          "commit": {
            "abbreviatedOid": "3b2d64c"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-17T23:17:09Z",
          "updatedAt": "2023-10-17T23:17:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 571,
      "id": "PR_kwDOB-yxNc5dEf_y",
      "title": "Only one anonymity set definition",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/571",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #568 \r\n\r\ncc @klinvill, @davidben, @dennisjackson ",
      "createdAt": "2023-10-17T22:43:46Z",
      "updatedAt": "2023-10-18T14:26:44Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "48e5eb62073ad358586a6ad455bdefc5a8ec74c3",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/anon-set",
      "headRefOid": "7b1553927ed65089cbaaa9f5e395afce35ddeebc",
      "closedAt": "2023-10-18T14:26:44Z",
      "mergedAt": "2023-10-18T14:26:44Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "94b56163c1bc9852b2abae2c44ed8d554a8b1738"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOB-yxNc5kW0LF",
          "commit": {
            "abbreviatedOid": "7b15539"
          },
          "author": "kazuho",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-18T00:55:22Z",
          "updatedAt": "2023-10-18T00:55:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 573,
      "id": "PR_kwDOB-yxNc5dEk1Z",
      "title": "Limit DNS label length",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/573",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @davidben, @dennisjackson, @martinthomson ",
      "createdAt": "2023-10-17T23:04:52Z",
      "updatedAt": "2023-10-18T14:26:33Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "b04619b5218c2857816c24a87f70d97471c66f54",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/limit-dns-labels",
      "headRefOid": "44e73b06de55b2bce91edba8fefc25d6718f61f4",
      "closedAt": "2023-10-18T14:26:33Z",
      "mergedAt": "2023-10-18T14:26:33Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "a8009ce64b1982429ac0dd9845b34a5ae3cb3b4a"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm OK with MAY (and would also be OK with a MUST, heh).",
          "createdAt": "2023-10-18T14:26:29Z",
          "updatedAt": "2023-10-18T14:26:29Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOB-yxNc5kWho9",
          "commit": {
            "abbreviatedOid": "3ebe2fa"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Why \"SHOULD\" and not \"MUST\"?\r\n\r\nPersonally, I wouldn't bother implementing this check. The server won't be able to obtain a valid certificate for a name that violates this constraint, or -- if it can -- you are trusting it based on a bogus root certificate.  So this doesn't really help.  It doesn't hurt either, but I'm not sure that you need defense in depth.  That suggests \"MAY\" instead.",
          "createdAt": "2023-10-17T23:19:47Z",
          "updatedAt": "2023-10-17T23:19:47Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOB-yxNc5kcsdu",
          "commit": {
            "abbreviatedOid": "265412f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T14:25:52Z",
          "updatedAt": "2023-10-18T14:25:52Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\ninterpreted as IPv4 literals. Additionally, clients MAY ignore the\r\n```",
              "createdAt": "2023-10-18T14:25:52Z",
              "updatedAt": "2023-10-18T14:26:06Z"
            }
          ]
        }
      ]
    },
    {
      "number": 574,
      "id": "PR_kwDOB-yxNc5dGJ3k",
      "title": "Avoid a normative reference to WHATWG-IPV4",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/574",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "DNS names and IPv4 literals are a bit of a mess. RFC 1738 said:\r\n\r\n> The rightmost domain label will never start with a digit, though,\r\n> which syntactically distinguishes all domain names from the IP\r\n> addresses.\r\n\r\nThis is sensible, but was replaced by RFC 3986 with a \"first-match-wins\" algorithm:\r\n\r\n> If host matches the rule for IPv4address, then it should be\r\n> considered an IPv4 address literal and not a reg-name.\r\n\r\nThe WHATWG URL spec originally mirrored this, but with a *much* more permissive IPv4 parser, to reflect reality. ECH originally cited this, to be sure we don't accidentally mix up IPv4 literals and DNS names.\r\n\r\nThe change in RFC 3986 was a mistake and introduced a security problem. The RFC 1738 formulation said a.1.2.3.4 was a syntax error, neither a DNS name nor IPv4 literal. The RFC 3986, along with the analog copied into WHATWG, says it's a DNS name because the IPv4 parser rejects it. But this means:\r\n\r\n- a.1.2.3.4 is a DNS name\r\n- 1.2.3.4 is an IPv4 literal\r\n\r\nSee also https://github.com/whatwg/url/issues/560\r\n\r\nThis means DNS names are no longer closed under suffixes! This causes problems for any systems (e.g. eTLD+1s) that need to suffix a DNS name. WHATWG since effectively reverted the RFC 3986 mistake. After https://github.com/whatwg/url/commit/ab0e820b0b559610b30c731b7f2c1a8094181680, the rule in WHATWG is: if it ends in a number (all digits, or 0x + all hex), parse as an IPv4 literal. Otherwise it's a DNS name.\r\n\r\nThis rule is finally simple enough that we can just lift it into ECH.\r\n\r\n(If we want, we can simplify this by just reverting to the RFC 1738 formulation, which should be safe in this context. It is a pity RFC 3986 made a mess here.)",
      "createdAt": "2023-10-18T06:00:45Z",
      "updatedAt": "2023-10-18T14:24:06Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "48e5eb62073ad358586a6ad455bdefc5a8ec74c3",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "ipv4",
      "headRefOid": "2660209e03b2d7f9c6db9cc9a70c65978914da0d",
      "closedAt": "2023-10-18T14:24:06Z",
      "mergedAt": "2023-10-18T14:24:06Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "b04619b5218c2857816c24a87f70d97471c66f54"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOB-yxNc5kcrZ0",
          "commit": {
            "abbreviatedOid": "2660209"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-18T14:24:01Z",
          "updatedAt": "2023-10-18T14:24:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 575,
      "id": "PR_kwDOB-yxNc5dUGrb",
      "title": "Relax requirements around the outer SNI value",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/575",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #572 \r\n\r\ncc @dennisjackson, @davidben, @martinthomson, @cjpatton, @sftcd ",
      "createdAt": "2023-10-19T20:29:11Z",
      "updatedAt": "2023-11-06T08:51:40Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "539eab81d53815f09b7c70c3ee13960da0e977eb",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "caw/relax-outer-sni",
      "headRefOid": "ebc4d2c739697ab5a746fc5881f1d47f77556632",
      "closedAt": "2023-11-06T08:51:30Z",
      "mergedAt": "2023-11-06T08:51:30Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ad5828912743dcb2c336a3aaabf412eb56147446"
      },
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think this quite works. As I understand it, we:\r\n\r\n1. Are silent on what clients have to do, but just tell them \"this may not work\" if you don't make the names match, but only for the retry mechanism.\r\n2. We tell the servers that they SHOULD check that the names match.\r\n\r\nThe result here is that a conformant client can fail to interoperate with a server that behaves as we RECOMMEND. That seems bad.\r\n\r\n\r\n",
          "createdAt": "2023-10-19T20:40:18Z",
          "updatedAt": "2023-10-19T20:40:18Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I thought the silence was to be interpreted as a SHOULD, but I would be fine to explicitly say that. ",
          "createdAt": "2023-10-19T20:59:43Z",
          "updatedAt": "2023-10-19T20:59:43Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm fine with the change from MUST to SHOULD for the client, and I think calling out the SHOULD for clients as in the most recent commit is better than omitting 2119 terms for that.\r\n\r\nThe addition of a SHOULD for servers is wrong. (I would prefer a SHOULD NOT for servers but am ok with less.) The ECH protocol works fine without that, (unlike the reasonable SHOULD for clients related to fallback), so I'd at most be ok with a MAY for servers. Noting that servers that do not enforce that that check (the behaviour or all servers I've tested so far)  has consequences is fine, but there's no need to add a SHOULD recommending making that check. ",
          "createdAt": "2023-10-19T23:47:51Z",
          "updatedAt": "2023-10-19T23:47:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> The addition of a SHOULD for servers is wrong. (I would prefer a SHOULD NOT for servers but am ok with less.) The ECH protocol works fine without that, (unlike the reasonable SHOULD for clients related to fallback), so I'd at most be ok with a MAY for servers. Noting that servers that do not enforce that that check (the behaviour or all servers I've tested so far)  has consequences is fine, but there's no need to add a SHOULD recommending making that check. \n\nIt's not wrong -- it just doesn't match what you'd like. As has been clearly stated, failure to implement this check admits domain fronting. The normative language is here to discourage that behavior for servers. \n",
          "createdAt": "2023-10-19T23:56:40Z",
          "updatedAt": "2023-10-19T23:56:40Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "What's \"wrong\" is certainly debatable. However, while there may be good or bad reasons to (dis)like domain fronting, making this check a SHOULD is not necessary to make the ECH protocol to work. That's (I claim, not that strongly) demonstrated as current servers do not make that check.",
          "createdAt": "2023-10-19T23:58:58Z",
          "updatedAt": "2023-10-19T23:58:58Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "It's not just about making things work. It's incumbent on us to write the spec in a way that discourages undesirable outcomes. ",
          "createdAt": "2023-10-20T00:02:29Z",
          "updatedAt": "2023-10-20T00:02:29Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, so we seem to agree that server-side check is not necessary to make the protocol work.\r\n\r\nIt's not clear to me we that we on here (or the TLS WG) have rough consensus as to the desirability of encouraging implementations to make domain fronting less or more possible. Deployments can of course validly make such choices, but that's different from a SHOULD that recommends that implementations make that choice for those deploying the protocol.\r\n\r\nSo overall it seems to me the spec here is better saying that servers MAY make such checks, calling out the consequences, but no more.",
          "createdAt": "2023-10-20T00:07:39Z",
          "updatedAt": "2023-10-20T00:07:39Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Implementations can of course make a decision as they see fit, which is precisely why this is phrased in the way it is. That said, I don't have any interest in debating what is the right verb to use here. ",
          "createdAt": "2023-10-20T00:14:02Z",
          "updatedAt": "2023-10-20T00:14:02Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "I do have such a verbal interest:-) That;s a 2119 verb, so a SHOULD implies (to me) that servers really ought have code to make that check and send that error, which I think is a less good outcome.",
          "createdAt": "2023-10-20T00:19:30Z",
          "updatedAt": "2023-10-20T00:19:30Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "So here's a different argument against such a SHOULD for the server-side check. Not hugely strong, but worth thinking about.\r\n\r\nSay a server supports thousands of public_names but very few ECH private keys. That will create config_id collisions and likely lead to erroneous protocol failures if the server-side SHOULD check we're discussing is enforced, especially if/as public_name values change and servers and clients are or are not up to date with the latest settings.\r\n\r\nI'm not claiming that's a winning argument, but it's worth pondering as the (un)desirability of domain fronting may not be the only thing in play here.",
          "createdAt": "2023-10-20T00:25:14Z",
          "updatedAt": "2023-10-20T00:25:14Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Some further thoughts.\r\n\r\n1. I don't find the domain fronting argument for requiring this check on the server to be very persuasive. Why is ECH the right place for the TLS WG to take a position on this, even assuming we have consensus to do so?\r\n\r\n2. ISTM that the stronger rationale for this check is that (1) clients which don't out the correct value in ClientHelloOuter will not interoperate properly in case of the need for fallback (2) fallback will be uncommon and so this is unlikely to be detected in normal operation (3) the check ensures that clients do the right thing (this is the argument of RFC 9413). From this perspective, @sftcd's observation that nothing untoward has happened from existing server's failure to check doesn't tell us much, because it's in the nature of this kind of issue that nonconformance is mostly not a problem until it is, at which point it is hard to repair. \r\n\r\n3. I still don't think that the SHOULD/SHOULD combination works because, as noted before, RFC 2119 allows for implementations to violate SHOULDs and we don't really provide reasons why this might be OK in this case. I think the following combinations are reasonable (I.e., they provide interoperability by conformant implementations):\r\n\r\n* MUST send and any behavior by the server\r\n* MUST send unless you have some out of band reason to know that the server doesn't check and that it won't do fallback, combined with any behavior on the server.\r\n* Any behavior by the client combined with MUST ignore on the server\r\n\r\nWith that said, for the RFC 9413 reasons above, I believe we should require the client to send and encourage the server to check. I could be persuaded to have an exception for clients who have some out of band reason to believe that the server doesn't want it, as in my second option above.\r\n",
          "createdAt": "2023-10-20T13:50:50Z",
          "updatedAt": "2023-10-20T13:50:50Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> With that said, for the RFC 9413 reasons above, I believe we should require the client to send and encourage the server to check. I could be persuaded to have an exception for clients who have some out of band reason to believe that the server doesn't want it, as in my second option above.\n\nThe intent of the PR is exactly this. It requires clients to do this, with exceptions (hence the SHOULD), and encourages servers to check (hence the SHOULD). It's possible there are better ways to phrase it, but that's the goal here. ",
          "createdAt": "2023-10-20T14:02:58Z",
          "updatedAt": "2023-10-20T14:02:58Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks. In that case, I don't think that the \"if you don't do this these are the consequences\" works. Rather it actually needs to be a MUST and lay out the specific conditions under which clients can violate that MUST. E.g.,\r\n\r\n\"It MUST place the value of `ECHConfig.contents.public_name` in the\r\n   \"server_name\" extension unless it has a specific reason to know that\r\n   the server in question does not implement the retry\r\n   mechanism described in {{rejected-ech}} and does not enforce the\r\n  above requirement {{client-facing-server}}.\"",
          "createdAt": "2023-10-20T14:27:31Z",
          "updatedAt": "2023-10-20T14:27:31Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "> \"It MUST place the value of `ECHConfig.contents.public_name` in the\r\n> \"server_name\" extension unless it has a specific reason to know that\r\n> the server in question does not implement the retry\r\n> mechanism described in {{rejected-ech}} and does not enforce the\r\n> above requirement {{client-facing-server}}.\"\r\n\r\nI don't think the above quite makes sense, because the client (as a \r\nTLS library) won't know things, in particular cannot know what the \r\nserver may or may not check and, once a correct ECHConfig is used,\r\nand ECH decryption has succeeded, the retry scheme doesn't come\r\ninto play so there's no benefit to the server in that case in making\r\nthe check.\r\n\r\nI'm fine with a SHOULD (or \"MUST ... unless\") for clients, but the \r\n\"unless\" clause above seems wrong. How would this be?\r\n\r\n'Clients SHOULD place the the value of `ECHConfig.contents.public_name`\r\nin the (outer) \"server_name\" extension unless specifically directed otherwise\r\nby application layer code. Clients that do not include that value will not\r\nbenefit from the retry mechanism described in {{rejected-ech}}, therefore\r\napplications need to exercise caution if sending any other value, and e.g.\r\nonly use this approach with servers for which the application client can be\r\nconfident a correct ECHConfig value has been used and where the server\r\ndoes not make a check comparing the outer \"server_name\" to an \"\r\n`ECHConfig.contents.public_name` value.'\r\n\r\n",
          "createdAt": "2023-10-20T16:35:48Z",
          "updatedAt": "2023-10-20T16:35:48Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "> I don't think the above quite makes sense, because the client (as a\r\nTLS library) won't know things, in particular cannot know what the\r\nserver may or may not check and, once a correct ECHConfig is used,\r\nand ECH decryption has succeeded, the retry scheme doesn't come\r\ninto play so there's no benefit to the server in that case in making\r\nthe check.\r\n\r\nNo, I don't think this is correct. The purpose of this mandate is to restrain the behavior of TLS clients on the wire, not the behavior of individual TLS libraries. \r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2023-10-20T17:16:34Z",
          "updatedAt": "2023-10-20T17:16:34Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "My argument is not only only about libraries. The part of my argument about libraries referred only to the specific wording you proposed. (Maybe github issues aren't the best way to argue such things though, the quoting is hard to do and interpret IMO.)",
          "createdAt": "2023-10-20T18:48:18Z",
          "updatedAt": "2023-10-20T18:48:18Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Well, your proposed wording is about the interaction of the application and the library, and I think that this text should refer solely to the behavior of the client as a unit. And the only normative text is about the library's behavior and my point is that the text should refer to the unit.\r\n\r\n",
          "createdAt": "2023-10-20T19:00:16Z",
          "updatedAt": "2023-10-20T19:00:16Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "So you'd prefer this (if forced to choose)?\r\n\r\n'Clients SHOULD place the the value of ECHConfig.contents.public_name\r\nin the (outer) \"server_name\" extension unless specifically directed otherwise. \r\nClients that do not include that value will not benefit from the retry mechanism\r\ndescribed in {{rejected-ech}}, therefore clients need to exercise caution if\r\nsending any other value, and e.g. only use this approach with servers for\r\nwhich the client can be confident a correct ECHConfig value has been used\r\nand where the server does not make a check comparing the outer \r\n\"server_name\" to an ``ECHConfig.contents.public_name`` value.'\r\n\r\nI could live with something like that but think it's less useful than the first text I suggested myself.\r\n",
          "createdAt": "2023-10-20T19:10:53Z",
          "updatedAt": "2023-10-20T19:10:53Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "> So you'd prefer this (if forced to choose)?\r\n> \r\n> 'Clients SHOULD place the the value of ECHConfig.contents.public_name in the (outer) \"server_name\" extension unless specifically directed otherwise. Clients that do not include that value will not benefit from the retry mechanism described in {{rejected-ech}}, therefore clients need to exercise caution if sending any other value, and e.g. only use this approach with servers for which the client can be confident a correct ECHConfig value has been used and where the server does not make a check comparing the outer \"server_name\" to an `ECHConfig.contents.public_name` value.'\r\n> \r\n> I could live with something like that but think it's less useful than the first text I suggested myself.\r\n\r\nAs I already provided text,  I'm not really sure why I would be forced to choose between this and your prior suggestion.\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2023-10-20T20:16:15Z",
          "updatedAt": "2023-10-20T20:16:15Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n\r\nOn 20/10/2023 21:16, Eric Rescorla wrote:\r\n> As I already provided text,  I'm not really sure why I would be\r\n> forced to choose between this and your prior suggestion.\r\n\r\nFair enough. I guess we can see if others chime in and/or take it\r\nto the list and/or Prague.\r\n\r\nS.\r\n",
          "createdAt": "2023-10-20T20:53:30Z",
          "updatedAt": "2023-10-20T20:53:30Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm OK with the stricter language @ekr suggests.  A stack can conform with this requirement if it has an option to disable the outer SNI.  A stack can conform with this requirement without implementing the outer SNI if it is clearly stated that it can only be used in cases where servers don't need the outer SNI (for the listed reasons).",
          "createdAt": "2023-10-22T23:49:28Z",
          "updatedAt": "2023-10-22T23:49:28Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n\r\nOn 23/10/2023 00:49, Martin Thomson wrote:\r\n> I'm OK with the stricter language @ekr suggests.  A stack can conform\r\n> with this requirement if it has an option to disable the outer SNI.\r\n> A stack can conform with this requirement without implementing the\r\n> outer SNI if it is clearly stated that it can only be used in cases\r\n> where servers don't need the outer SNI (for the listed reasons).\r\n\r\nI don't find my position altered tbh, but in case it helps, that\r\nought not delay production of an updated I-D by the editors. We\r\ncan argue whatever needs arguing before/during WGLC.\r\n\r\nS.\r\n\r\n",
          "createdAt": "2023-10-23T01:28:24Z",
          "updatedAt": "2023-10-23T01:28:24Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": " If I understand @sftcd's point correctly (please let me know if I'm missing anything), it's that \"SHOULD\" is better because it permits clients to do something different \"as long as they know what they're doing\". But I'm worried that a careless reader might ignore the SHOULD and fill in the unspecified behavior in arbitrary ways. This could lead to bugs and/or increase the attack surface for applications built on top of TLS in ways we can't anticipate right now. \r\n\r\nI'd also prefer @ekr's stricter language, as a future-proofing measure. Simpler semantics is always better. That said, I actually think this PR is a strict improvement over the current text, since it makes the consequences of ignoring the MUST (or SHOULD) clear.",
          "createdAt": "2023-10-23T14:54:15Z",
          "updatedAt": "2023-10-23T14:54:35Z"
        },
        {
          "author": "dennisjackson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The current PR for the client reads: \r\n\r\n>    [The Client] SHOULD place the value of `ECHConfig.contents.public_name` in the\r\n>    \"server_name\" extension. Clients that do not follow this step, or place a\r\n>    different value in the \"server_name\" extension, risk breaking the retry\r\n>    mechanism described in {{rejected-ech}} or failing to interoperate with\r\n>    servers that require this step to be done; see {{client-facing-server}}.\r\n\r\nI think this is fine. It's very clear as to what the expected behaviour is and what the consequences might be. For the server:\r\n\r\n> Once the server has chosen the correct ECHConfig, it SHOULD verify that the\r\n> value in the ClientHelloOuter \"server_name\" extension matches the value of\r\n> `ECHConfig.contents.public_name`, and abort with an \"illegal_parameter\" alert\r\n> if these do not match. Failure to enforce this check can allow clients to lie\r\n> about the ClientHelloOuter SNI, possibly with the intent of bypassing network\r\n> policies that might otherwise block ECH.\r\n\r\nI don't think this text is great for two reasons: \r\n 1) It's not clear how to choose the correct ECHConfig, especially if multiple configs use the same keypair and distinct public names (as @sftcd pointed out).\r\n 2) I don't think there's going to be any kind of consensus for recommending this check (with a SHOULD) or the rationale for why. Implementers are going to be split between those doing the check and those refusing to. \r\n\r\nI see we've already had plenty of suggested changes with little support, so one more can't hurt: \r\n\r\n> Once the server has chosen the correct ECHConfig, it MAY verify that the value in the ClientHelloOuter \"server_name\" extension matches the value of `ECHConfig.contents.public_name`, and abort with an \"illegal_parameter\" alert if these do not match. This optional check allows the server to limit ECH connections to only use the public SNI values advertised in its ECHConfigs. The server must be careful not to unnecessarily reject connections if the same ECHConfig id or keypair is used in multiple ECHConfigs with distinct public names.  \r\n\r\nThe intent here is to permit the check without taking a stand on whether its desirable or necessary. ",
          "createdAt": "2023-10-26T11:23:35Z",
          "updatedAt": "2023-10-26T11:24:25Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n\r\nOn 26/10/2023 12:23, Dennis Jackson wrote:\r\n> Once the server has chosen the correct ECHConfig, it MAY verify that the \r\n> value in the ClientHelloOuter \"server_name\" extension matches the value \r\n> of `ECHConfig.contents.public_name`, and abort with an \r\n> \"illegal_parameter\" alert if these do not match. This optional check \r\n> allows the server to limit ECH connections to only use the public SNI \r\n> values advertised in its ECHConfigs. The server must be careful not to \r\n> unnecessarily reject connections if the same ECHConfig id or keypair is \r\n> used in multiple ECHConfigs with distinct public names.\r\n\r\nI'd be fine with the above. (Maybe with a friendly amendment\r\nof s/chosen the correct/successfully decrypted/ or similar.)\r\n\r\nAnd as Dennis said, I think we're all on the same page wrt the\r\nclient side.\r\n\r\nS.\r\n",
          "createdAt": "2023-10-26T11:33:49Z",
          "updatedAt": "2023-10-26T11:33:49Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Took @dennisjackson's suggestion. I'm fine with this as well.",
          "createdAt": "2023-10-26T13:42:49Z",
          "updatedAt": "2023-10-26T13:42:49Z"
        },
        {
          "author": "roelfdutoit",
          "authorAssociation": "NONE",
          "body": "I believe this PR is incomplete without adding a corresponding warning to the \"8.2 Middleboxes\" section.  The logic in that section is:  Proxy does not understand ECH -> Proxy must act as conforming TLS server -> Proxy forges the disable signal by being authoritative for `public name`.  If outer SNI != `public_name` then Proxy does not know `public name` (because it does not understand ECH) and can only be \"authoritative\" for the outer SNI.\r\nAt a mimimum the following phrase in that section would have to change from `the proxy will act as if connecting to the public name` to `the proxy will act as if connecting to the ClientHelloOuter server_name, which SHOULD match the public name`",
          "createdAt": "2023-11-01T14:56:53Z",
          "updatedAt": "2023-11-01T14:56:53Z"
        },
        {
          "author": "taddhar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Funny the timing coincidence @roelfdutoit I was about to come back on this section as well for a number of other reasons that for non educated people and non english native people this part is very very hard to parse. Am trying to edit it in my corner since yesterday to find the right words but in short a few paused definitions would help naive readers. ",
          "createdAt": "2023-11-01T15:07:24Z",
          "updatedAt": "2023-11-01T15:07:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Good catch @roelfdutoit! I fixed that text.",
          "createdAt": "2023-11-02T11:39:50Z",
          "updatedAt": "2023-11-02T11:39:50Z"
        },
        {
          "author": "ckcr4lyf",
          "authorAssociation": "NONE",
          "body": "Is there any strong reason for a client to be `SHOULD` instead of `MAY`? \r\n\r\n`public_name` _may_ help the ECH server to determine which config to use, however, it may be that the server has only one config, and doesn't need additional `public_name` logic to determine which config to use.\r\n\r\nI am coming from the angle of censorship-resistance. When SNI was introduced initially, many websites would work without it just fine, however browsers started sending it for any and every website, which lead to leaks where it wasn't even necessary.\r\n\r\nI've talked about this on the mailing list: <https://mailarchive.ietf.org/arch/msg/tls/HUG1CU0Q4PorZ7fD0yafVfj7VUY/> , and even in the original Github Issue for this PR: <https://github.com/tlswg/draft-ietf-tls-esni/issues/572#issuecomment-1780859252>\r\n\r\nSince I didn't receive replies there and it seems this PR is active, I'd like to raise this point again. If this is not the appropriate place, please let me know where the WG group prefers to have such discussions.",
          "createdAt": "2023-11-06T05:52:44Z",
          "updatedAt": "2023-11-06T05:52:44Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "The reason to have it be SHOULD is that, as listed, failure to do so causes compatibility issues.\r\n\r\n> I am coming from the angle of censorship-resistance. When SNI was introduced initially, many websites would work without it just fine, however browsers started sending it for any and every website, which lead to leaks where it wasn't even necessary.\r\n\r\nI'm not following this argument. SNI is necessary except in cases where the required certificate is completely determined by the IP address. Similarly, when ECH is used, the same public SNI will be used but it's just enough to determine the required certificate, which doesn't tell you anything that you didn't know already from the IP address and the DNS records.",
          "createdAt": "2023-11-06T06:26:45Z",
          "updatedAt": "2023-11-06T06:26:45Z"
        },
        {
          "author": "ckcr4lyf",
          "authorAssociation": "NONE",
          "body": "> Similarly, when ECH is used, the same public SNI will be used but it's just enough to determine the required certificate, which doesn't tell you anything that you didn't know already from the IP address and the DNS records.\r\n\r\nAssuming you used DoH, then someone in the middle (e.g. an ISP) cannot know which domain you're connecting to. However passing the \"public name\" SNI in plaintext would reveal this.\r\n\r\nIn the initial ESNI draft / implementation (prior to ECH), this was not a problem, since ESNI replaces SNI completely (if ESNI was used).",
          "createdAt": "2023-11-06T06:51:46Z",
          "updatedAt": "2023-11-06T06:51:46Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> > Similarly, when ECH is used, the same public SNI will be used but it's just enough to determine the required certificate, which doesn't tell you anything that you didn't know already from the IP address and the DNS records.\n> \n> \n> \n> Assuming you used DoH, then someone in the middle (e.g. an ISP) cannot know which domain you're connecting to. However passing the \"public name\" SNI in plaintext would reveal this.\n> \n> \n> \n> In the initial ESNI draft / implementation (prior to ECH), this was not a problem, since ESNI replaces SNI completely (if ESNI was used).\n\n@ekr's point is that the IP address reveals effectively the same information as the public name.",
          "createdAt": "2023-11-06T07:23:25Z",
          "updatedAt": "2023-11-06T07:23:25Z"
        },
        {
          "author": "ckcr4lyf",
          "authorAssociation": "NONE",
          "body": "An IP address however can be rotated much more easily (in the context of end users of a service), e.g. for a VPS using IPs owned(?) by a cloud provider, where the actual cloud customer behind it could change from one day to the next. Whereas if I am operating a service, the end-users would expect the domain to be static.\r\n\r\nIn such scenarios, the ECH public_name would still leak the domain to those in the middle",
          "createdAt": "2023-11-06T07:28:09Z",
          "updatedAt": "2023-11-06T07:28:09Z"
        },
        {
          "author": "ckcr4lyf",
          "authorAssociation": "NONE",
          "body": "Cloudflare has a blog post talking about something tangential: [Identity is attached to names, never addresses](https://blog.cloudflare.com/consequences-of-ip-blocking/#identity-is-attached-to-names-never-addresses)",
          "createdAt": "2023-11-06T07:31:25Z",
          "updatedAt": "2023-11-06T07:31:25Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Merging after discussion in ECH.",
          "createdAt": "2023-11-06T08:51:39Z",
          "updatedAt": "2023-11-06T08:51:39Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOB-yxNc5kqLvU",
          "commit": {
            "abbreviatedOid": "ac034a5"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-19T22:20:52Z",
          "updatedAt": "2023-10-19T22:23:36Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "I think it's a bit more clear to put this SHOULD at the end of the trial decryption loop.\r\n\r\n```suggestion\r\nEncodedClientHelloInner, as described in {{encoding-inner}}. It then stops\r\niterating over the candidate ECHConfig values.\r\n\r\nOnce the server has chosen the correct ECHConfig, it SHOULD verify that the\r\nvalue in the ClientHelloOuter \"server_name\" extension matches the value of\r\n`ECHConfig.contents.public_name`, and abort with an \"illegal_parameter\" alert\r\nif these do not match. Failure to enforce this check can allow clients to lie\r\nabout the ClientHelloOuter SNI, possibly with the intent of bypassing network\r\npolicies that might otherwise block ECH.\r\n```",
              "createdAt": "2023-10-19T22:20:52Z",
              "updatedAt": "2023-10-19T22:26:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5kqOzN",
          "commit": {
            "abbreviatedOid": "ac034a5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-19T22:27:03Z",
          "updatedAt": "2023-10-19T22:27:03Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Thanks \ud83d\udc4d This is better!",
              "createdAt": "2023-10-19T22:27:03Z",
              "updatedAt": "2023-10-19T22:27:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5kqbB3",
          "commit": {
            "abbreviatedOid": "33d4163"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-19T23:27:49Z",
          "updatedAt": "2023-10-19T23:27:49Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOB-yxNc5lTwfJ",
          "commit": {
            "abbreviatedOid": "33d4163"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-26T13:35:04Z",
          "updatedAt": "2023-10-26T13:35:05Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "```suggestion\r\nOnce the server has chosen the correct ECHConfig, it MAY verify that the value\r\nin the ClientHelloOuter \"server_name\" extension matches the value of\r\nECHConfig.contents.public_name, and abort with an \"illegal_parameter\" alert if\r\nthese do not match. This optional check allows the server to limit ECH\r\nconnections to only use the public SNI values advertised in its ECHConfigs.\r\nThe server must be careful not to unnecessarily reject connections if the same\r\nECHConfig id or keypair is used in multiple ECHConfigs with distinct public\r\nnames.\r\n```",
              "createdAt": "2023-10-26T13:35:04Z",
              "updatedAt": "2023-10-26T13:35:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5lVA2H",
          "commit": {
            "abbreviatedOid": "845aeaa"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I'm fine with this. I think it's strictly better than the status quo regardless of the verb we choose. Clarifying what can go wrong if the verb is ignored is the most important thing.",
          "createdAt": "2023-10-26T15:57:39Z",
          "updatedAt": "2023-10-26T15:57:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 576,
      "id": "PR_kwDOB-yxNc5dUjKt",
      "title": "editorial: Thus -> This",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/576",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-19T22:12:41Z",
      "updatedAt": "2023-10-19T22:13:16Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "539eab81d53815f09b7c70c3ee13960da0e977eb",
      "headRepository": "cjpatton/draft-ietf-tls-esni",
      "headRefName": "typo-1",
      "headRefOid": "1f43286fff6f0ffa5db5301c4db551cdd7c02dd3",
      "closedAt": "2023-10-19T22:13:16Z",
      "mergedAt": "2023-10-19T22:13:16Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "9d068a00409f3fa5a6f37a3cf44e237335756efc"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOB-yxNc5kqH-W",
          "commit": {
            "abbreviatedOid": "1f43286"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-19T22:13:12Z",
          "updatedAt": "2023-10-19T22:13:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 577,
      "id": "PR_kwDOB-yxNc5eDznL",
      "title": "Define ECHConfigExtensionType before referencing it.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/577",
      "state": "MERGED",
      "author": "jmcrawford45",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Everything else in the definition is defined before being referenced. The only other details on this field occur pretty far into the doc, so I thought it'd be nice to define it with a pointer to the relevant section with more details",
      "createdAt": "2023-10-29T23:57:39Z",
      "updatedAt": "2023-10-30T18:29:21Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9d068a00409f3fa5a6f37a3cf44e237335756efc",
      "headRepository": "jmcrawford45/draft-ietf-tls-esni",
      "headRefName": "patch-1",
      "headRefOid": "4efe6ec1da6c67c85e71f69766efaa99d76cd82c",
      "closedAt": "2023-10-30T18:29:21Z",
      "mergedAt": "2023-10-30T18:29:21Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "9b25a58bba36017cd2b1f39ed40041a6d2c1133d"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks!",
          "createdAt": "2023-10-30T18:25:53Z",
          "updatedAt": "2023-10-30T18:25:53Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOB-yxNc5lnXzj",
          "commit": {
            "abbreviatedOid": "45c0def"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-30T18:25:32Z",
          "updatedAt": "2023-10-30T18:25:32Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOB-yxNc5lnZFP",
          "commit": {
            "abbreviatedOid": "45c0def"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-30T18:28:37Z",
          "updatedAt": "2023-10-30T18:28:37Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\n    uint16 ECHConfigExtensionType; // Defined in Section 11.3\r\n```",
              "createdAt": "2023-10-30T18:28:37Z",
              "updatedAt": "2023-10-30T18:28:38Z"
            }
          ]
        }
      ]
    },
    {
      "number": 579,
      "id": "PR_kwDOB-yxNc5eQgp5",
      "title": "Minor edit and first attempts to do a GitHub contribution to the ECH \u2026",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/579",
      "state": "MERGED",
      "author": "taddhar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "\u2026Internet Draft.",
      "createdAt": "2023-10-31T17:19:47Z",
      "updatedAt": "2023-10-31T17:25:35Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "9b25a58bba36017cd2b1f39ed40041a6d2c1133d",
      "headRepository": "taddhar/draft-ietf-tls-esni",
      "headRefName": "master",
      "headRefOid": "bc74462e950a259aa71a812a39e0a9ae910886bb",
      "closedAt": "2023-10-31T17:25:35Z",
      "mergedAt": "2023-10-31T17:25:35Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "1c6ea1a6c758c02f1f231bef3da827f331391181"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 581,
      "id": "PR_kwDOB-yxNc5eoBmc",
      "title": "Minor editorial fixes before more substantial ones.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/581",
      "state": "MERGED",
      "author": "taddhar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-11-05T20:30:28Z",
      "updatedAt": "2023-11-06T12:33:41Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1c6ea1a6c758c02f1f231bef3da827f331391181",
      "headRepository": "taddhar/draft-ietf-tls-esni",
      "headRefName": "arnaud-dev-branch1",
      "headRefOid": "1daa0728832239b1d7b6e06f3b1fe59433e99f23",
      "closedAt": "2023-11-06T12:30:17Z",
      "mergedAt": "2023-11-06T12:30:17Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "4ed0d7c03ace019e7539d4646b69b83f30dcbac3"
      },
      "comments": [
        {
          "author": "taddhar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Note I was tired yesterday and did click on the button as I would do in other github projects where I am involved. My apologies, hope (and doubt) I didn't damage anything. ",
          "createdAt": "2023-11-06T06:12:35Z",
          "updatedAt": "2023-11-06T06:12:35Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@taddhar the build failure was caused by a line exceeding the 80 character limit. If you try to build locally (via `make`), you should be able to reproduce the error yourself. I fixed it here so we can merge.",
          "createdAt": "2023-11-06T12:29:12Z",
          "updatedAt": "2023-11-06T12:29:12Z"
        },
        {
          "author": "taddhar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oh I see, indeed am not doing a 'make' at the moment on that text on my machine. Agreed, I should. \r\n\r\nOk this means I need to improve my own process before the next PR I am working on. Will work on it tonight.",
          "createdAt": "2023-11-06T12:33:41Z",
          "updatedAt": "2023-11-06T12:33:41Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOB-yxNc5mOYFd",
          "commit": {
            "abbreviatedOid": "aa61889"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-06T12:28:06Z",
          "updatedAt": "2023-11-06T12:28:07Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nwould appear to a network observer as if the server were sending this\r\n```",
              "createdAt": "2023-11-06T12:28:07Z",
              "updatedAt": "2023-11-06T12:28:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5mOYQI",
          "commit": {
            "abbreviatedOid": "2f3027d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-06T12:28:31Z",
          "updatedAt": "2023-11-06T12:28:31Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\n1. Let I be initialized to zero and N be set to the number of extensions\r\nin ClientHelloOuter.\r\n```",
              "createdAt": "2023-11-06T12:28:31Z",
              "updatedAt": "2023-11-06T12:28:31Z"
            }
          ]
        }
      ]
    },
    {
      "number": 582,
      "id": "PR_kwDOB-yxNc5ezLFl",
      "title": "Update draft-ietf-tls-esni.md",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/582",
      "state": "MERGED",
      "author": "grittygrease",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Update affiliation for Nick Sullivan",
      "createdAt": "2023-11-07T12:22:40Z",
      "updatedAt": "2023-11-07T12:26:26Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "4ed0d7c03ace019e7539d4646b69b83f30dcbac3",
      "headRepository": "grittygrease/draft-rescorla-tls-esni",
      "headRefName": "patch-1",
      "headRefOid": "b9b6ebb9c2a726c7c582a4f9c96b20f4cabce5fb",
      "closedAt": "2023-11-07T12:26:26Z",
      "mergedAt": "2023-11-07T12:26:26Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "b5839c267389093aedb0874937c5173891c17c9a"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 584,
      "id": "PR_kwDOB-yxNc5e8ogJ",
      "title": "DTLS-Only Column Value",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/584",
      "state": "MERGED",
      "author": "seanturner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #583.",
      "createdAt": "2023-11-08T16:27:49Z",
      "updatedAt": "2023-11-08T16:33:07Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "b5839c267389093aedb0874937c5173891c17c9a",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "seanturner-iana-dtls-only",
      "headRefOid": "ec2925c8f0bf68e468d16dfe9f60d594e31a052f",
      "closedAt": "2023-11-08T16:33:07Z",
      "mergedAt": "2023-11-08T16:33:07Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "774dff4e3a49533e9510dc04a905a2638992f7e5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOB-yxNc5mkS3R",
          "commit": {
            "abbreviatedOid": "a8e54e3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-08T16:30:44Z",
          "updatedAt": "2023-11-08T16:30:44Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOB-yxNc5mkTTA",
          "commit": {
            "abbreviatedOid": "a8e54e3"
          },
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-08T16:31:33Z",
          "updatedAt": "2023-11-08T16:31:34Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n   \"CH, HRR, EE\", \"DTLS-Only\" column set to \"N\", and \"Recommended\" column set\r\n   to \"Yes\".\r\n```",
              "createdAt": "2023-11-08T16:31:33Z",
              "updatedAt": "2023-11-08T16:31:34Z"
            }
          ]
        }
      ]
    },
    {
      "number": 587,
      "id": "PR_kwDOB-yxNc5fgMU4",
      "title": "Proposed changes to the overview section to give better justice to ECH.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/587",
      "state": "CLOSED",
      "author": "taddhar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "propose to close"
      ],
      "body": "Currently the overview section is a sentence that is actually not giving an overview of the protocol. The sentence is simply the highlight for the topologies sub-section. But the topologies sub-section is not a protocol overview. ECH is much more than just a topology. \r\n\r\nThe proposal is to give justice to ECH and improve the overview section. \r\n\r\nAs I am both coming at a very late state of the development of this text and this is the first time I do this review I contemplate that there could be more options. \r\n\r\nFor example the first part of my text is a bit redundant with some of the text in the introduction, calling for whether my proposal should be moved to introductions or to rearrange the sections. \r\n\r\nYet, there is no where in the text a description on all the key design ideas and maybe my selection could be completed by more ideas, e.g. list DoH and DPRIVE too in this list, which will then be calling to overlaps with introduction section.\r\n\r\nAnyway, this is my current proposal because right now, the overview is not giving justice nor anywhere in the text to ECH.\r\n",
      "createdAt": "2023-11-15T10:21:35Z",
      "updatedAt": "2024-02-25T00:04:51Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "774dff4e3a49533e9510dc04a905a2638992f7e5",
      "headRepository": "taddhar/draft-ietf-tls-esni",
      "headRefName": "ech-improve-overview",
      "headRefOid": "26733de8130746f707f13ff13728344a190da47c",
      "closedAt": "2024-02-25T00:04:51Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "See #602",
          "createdAt": "2024-02-17T17:17:59Z",
          "updatedAt": "2024-02-17T18:13:01Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 588,
      "id": "PR_kwDOB-yxNc5fgUi4",
      "title": "Ech proposed definitions",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/588",
      "state": "CLOSED",
      "author": "taddhar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "propose to close"
      ],
      "body": "This is a first attempt to propose some definitions. \r\n\r\nThere are indeed a number of problems in the document. \r\n\r\n- Some terms are inconsistently used, e.g. 'provider', 'ECH-service provider', 'client-facing' server. So I tried to fix that a little bit in the text. I think that the concept of 'provider' is actually good and is so indirectly understood, I wonder if there shouldn't be a bit more text to develop this good concept.\r\n- Some terms are abused e.g. 'public name' and 'public_name'. In addition on this one if you come the first time to this text, the immediate thinking is 'public name of what?'. So I understand why this term in the context of this text and understand it would be heavy to precise the 'public name of the origin server client-facing role' but still. Would be happy to discuss how we can make it a bit more explicit if at all possible.\r\n\r\nI am wondering if there are other terms that we should define too here but let's propose this first change. ",
      "createdAt": "2023-11-15T10:44:17Z",
      "updatedAt": "2024-02-25T00:04:52Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "774dff4e3a49533e9510dc04a905a2638992f7e5",
      "headRepository": "taddhar/draft-ietf-tls-esni",
      "headRefName": "ech-proposed-definitions",
      "headRefOid": "67a063fb7bded671aee843eae6f1c1324126a968",
      "closedAt": "2024-02-25T00:04:51Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I see what you're getting at here. See #601.",
          "createdAt": "2024-02-17T17:17:17Z",
          "updatedAt": "2024-02-17T17:17:17Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 589,
      "id": "PR_kwDOB-yxNc5fgbnA",
      "title": "Minor editorial issues and fixing metadata to stop annoying make errors.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/589",
      "state": "CLOSED",
      "author": "taddhar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "- Fixing some minor editorial issues, e.g. the abuse of 'first' with no 'then' or 'second' or 'secondly' etc. \r\n- In X.509 don't forget the dot\r\n- Boring make errors because of metadata issues\r\n\r\nAbout the latter, I get the warning that I don't know how to fix\r\n\r\n```\r\nwarnings.warn(\r\n*** attributes left {\"authors\"=>[{\"ins\"=>\"K. Bhargavan\", \"org\"=>\"Inria\"}, {\"ins\"=>\"V. Cheval\", \"org\"=>\"Inria\"}, {\"ins\"=>\"C. Wood\", \"org\"=>\"Cloudflare\"}]}!\r\n```\r\n",
      "createdAt": "2023-11-15T10:57:59Z",
      "updatedAt": "2024-02-17T15:12:28Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "774dff4e3a49533e9510dc04a905a2638992f7e5",
      "headRepository": "taddhar/draft-ietf-tls-esni",
      "headRefName": "ech-minor-edits",
      "headRefOid": "a3aa9ab121d365b656294901da0864c03ebd752b",
      "closedAt": "2024-02-17T15:12:27Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "There's nothing wrong with \"First\"...\"later\". I don't think we should change these.",
          "createdAt": "2023-11-15T17:20:49Z",
          "updatedAt": "2023-11-15T17:20:49Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I have fixed the metadata issue in #599. \r\n\r\nAs noted above, I don't believe the proposed text changes are necessary/right and as they are within editorial discretion, I am closing the PR unmerged.",
          "createdAt": "2024-02-17T15:12:28Z",
          "updatedAt": "2024-02-17T15:12:28Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOB-yxNc5nRHUS",
          "commit": {
            "abbreviatedOid": "a3aa9ab"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-11-15T17:19:57Z",
          "updatedAt": "2023-11-15T17:21:06Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "This is not correct. Yes, they are X.509 certificates, but the name of the enum in RFC 8446 (S 4.4.2i) ix \"X509\"\r\n\r\n```suggestion\r\nparticularly when using the X509 CertificateType, may result in additional\r\n```",
              "createdAt": "2023-11-15T17:19:57Z",
              "updatedAt": "2023-11-15T17:21:06Z"
            }
          ]
        }
      ]
    },
    {
      "number": 590,
      "id": "PR_kwDOB-yxNc5fgr8Q",
      "title": "Experimental proposal to add an Abbreviation section ommitting 'well \u2026",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/590",
      "state": "CLOSED",
      "author": "taddhar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "\u2026known' ones.\r\n\r\nSo this one is an experimental proposal because indeed I couldn't see many Abbreviation sections in any RFCs. \r\nI found an abbreviation list from 'Editors' but it stops being updated in 2021 (wondering the story behind this one).\r\nBut I liked the concept of well known abbreviations vs not well known ones. \r\n\r\nIn general when I read a text and moreover a complicated text, I hate to have to guess what means acronym A, B, C and or to have my brain to 'calculate' on the fly what it is or to have to research in another document. In my mind, it is 'basic respect' to the reader to put the acronym in plain. \r\n\r\nOF COURSE I do understand that for developers these are completely obvious. I get that. But for Operational people or other persona, sorry, I am not coding TLS every day so I made a mistake to understand HRR or EE and for example AAD has two meanings ... which is calling why we might want to put more definitions (See my other PR on definitions).\r\n\r\nAnyway we can debate if X or Y or Z is well known or not but I think there are too many new things in this one and an Abbreviation section would help.\r\n\r\nAs said in IETF 118, ECH is complex, so am trying to help a little bit on that line, but if nobody happy with it, just reject it.\r\n",
      "createdAt": "2023-11-15T11:46:30Z",
      "updatedAt": "2024-02-17T15:13:53Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "774dff4e3a49533e9510dc04a905a2638992f7e5",
      "headRepository": "taddhar/draft-ietf-tls-esni",
      "headRefName": "ech-proposed-abbreviations",
      "headRefOid": "6c991962d14c6c5b7899f2a97cbd95a9fa0bf52a",
      "closedAt": "2024-02-17T15:13:52Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think this is necessary. Most of these are terms of art in TLS. I don't see how it's possible to understand this specification in the context of TLS without knowing what AEAD is, for instance.",
          "createdAt": "2024-02-17T15:13:52Z",
          "updatedAt": "2024-02-17T15:13:52Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 592,
      "id": "PR_kwDOB-yxNc5fiVZ8",
      "title": "Deployment considerations: Improving the compatibility middlebox sect\u2026",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/592",
      "state": "CLOSED",
      "author": "taddhar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "\u2026ion a little bit.\r\n\r\nIn this proposal I believe what is missing is the intention of this section. So I simply made it explicit so that it is easier to read what then comes after. \r\n\r\nIf not, it took me a long time and a discussion with colleagues to understand it without this context. Now you have a 'direction' of reading and it falls better in at least my mind.",
      "createdAt": "2023-11-15T16:17:17Z",
      "updatedAt": "2024-02-17T15:29:21Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "774dff4e3a49533e9510dc04a905a2638992f7e5",
      "headRepository": "taddhar/draft-ietf-tls-esni",
      "headRefName": "ech-compatibility-middleboxes",
      "headRefOid": "8bdfbe4cc1e853cd7827f1d09550bfe1a8e4da90",
      "closedAt": "2024-02-17T15:29:20Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Superceded by PR #600",
          "createdAt": "2024-02-17T15:29:20Z",
          "updatedAt": "2024-02-17T15:29:20Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 593,
      "id": "PR_kwDOB-yxNc5fiidk",
      "title": "A first proposal to fix the no-sni section.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/593",
      "state": "CLOSED",
      "author": "taddhar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In this part of the text there would be a lot to say. \r\n\r\nFirst for non-English native speakers who are not familiar with the topic and in particular in operations or even to some degree in system architecture or network security domains, the text will be very difficult to read. \r\n\r\nIn fact think about someone in a Small and Medium Enterprises organization that has to ensure the security of its organization it will be close to impossible to connect the dots. How many dozen of millions of SMEs on the planet? \r\n\r\nAnyway, it is VERY hard to be more explicit in the context of this draft though I would be tempted to add examples and be more explicit on sub-contexts and on use cases e.g. put in hard BYOD will fail. but anyway this links to OUR Internet Draft on Deployment Considerations that suddenly makes a lot of sense as an expansion of this section from 1 page to 20+.\r\n\r\nOne could argue that there are many types of Middleboxes and they all will be affected by that (DPI, Firewalls, Proxies, etc.)\r\n\r\nHowever there is ONE section which is simply 1) wrong and 2) completely irrelevant is the last section which I removed. The only alternative would be to make a significant fix in that section and even if I fix it, it will add nothing to the fact that when a number of devices won't be able to access the SNI, they will break, period. \r\n\r\nSo I am happy to rework a section but the section will say that whilst in general the SNI is unreliable, in practice there are essential sub-context where is is not only VERY reliable but as well is a very valuable information for in-path actors who have many ways to check and validate and handle the unreliable part.",
      "createdAt": "2023-11-15T16:52:03Z",
      "updatedAt": "2023-11-16T11:24:45Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "774dff4e3a49533e9510dc04a905a2638992f7e5",
      "headRepository": "taddhar/draft-ietf-tls-esni",
      "headRefName": "ech-proposed-no-sni-2",
      "headRefOid": "615b0807b5c849b8b3cb8c4acd7d8866e1c0a136",
      "closedAt": "2023-11-16T11:24:45Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "taddhar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sorry this one is a mistake and should be rejected. I forgot to actually remove the paragraph. #594 is correct.",
          "createdAt": "2023-11-15T16:59:43Z",
          "updatedAt": "2023-11-15T16:59:43Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 594,
      "id": "PR_kwDOB-yxNc5fikZG",
      "title": "A first proposal to fix the no-sni section.",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/594",
      "state": "MERGED",
      "author": "taddhar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "merge ready"
      ],
      "body": "In this part of the text there would be a lot to say.\r\n\r\nFirst for non-English native speakers who are not familiar with the topic and in particular in operations or even to some degree in system architecture or network security domains, the text will be very difficult to read.\r\n\r\nIn fact think about someone in a Small and Medium Enterprises organization that has to ensure the security of its organization it will be close to impossible to connect the dots. How many dozen of millions of SMEs on the planet?\r\n\r\nAnyway, it is VERY hard to be more explicit in the context of this draft though I would be tempted to add examples and be more explicit on sub-contexts and on use cases e.g. put in hard BYOD will fail. but anyway this links to OUR Internet Draft on Deployment Considerations that suddenly makes a lot of sense as an expansion of this section from 1 page to 20+.\r\n\r\nOne could argue that there are many types of Middleboxes and they all will be affected by that (DPI, Firewalls, Proxies, etc.)\r\n\r\nHowever there is ONE section which is simply 1) wrong and 2) completely irrelevant is the last section which I removed. The only alternative would be to make a significant fix in that section and even if I fix it, it will add nothing to the fact that when a number of devices won't be able to access the SNI, they will break, period.\r\n\r\nSo I am happy to rework a section but the section will say that whilst in general the SNI is unreliable, in practice there are essential sub-context where is is not only VERY reliable but as well is a very valuable information for in-path actors who have many ways to check and validate and handle the unreliable part.",
      "createdAt": "2023-11-15T16:57:15Z",
      "updatedAt": "2024-02-24T23:46:02Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "774dff4e3a49533e9510dc04a905a2638992f7e5",
      "headRepository": "taddhar/draft-ietf-tls-esni",
      "headRefName": "ech-proposed-no-sni-3",
      "headRefOid": "1030cfb565bb6efc17fe38bf8f356c1b760135c1",
      "closedAt": "2024-02-24T23:46:02Z",
      "mergedAt": "2024-02-24T23:46:02Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "9f5c3f122700ee83b6e6a25eff96b73dad187697"
      },
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "> So I am happy to rework a section but the section will say that whilst in general the SNI is unreliable, in practice there are essential sub-context where is is not only VERY reliable but as well is a very valuable information for in-path actors who have many ways to check and validate and handle the unreliable part.\r\n\r\nYou're going to have to explain more about why you think this is the case. Validating the certificate is insufficient. You need to ensure that the site has the corresponding private key, which you can't do passively with TLS 1.2 in non-PFS mode.",
          "createdAt": "2023-11-15T17:05:22Z",
          "updatedAt": "2023-11-15T17:05:22Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I appreciate that people *use* the SNI the way you indicate. But the point of this text is that this practice is not secure if the endpoint is compromised.",
          "createdAt": "2023-11-15T17:14:12Z",
          "updatedAt": "2023-11-15T17:14:12Z"
        },
        {
          "author": "roelfdutoit",
          "authorAssociation": "NONE",
          "body": "Network security middleboxes utilize various techniques to improve the reliability of the control in an enterprise environment, inter alia:\r\n1. DNS hostname lookup of SNI and optional destination redirect or failure on mismatch.\r\n2. TLS \"probe\" sessions to validate not only the certificate and SAN entries, but also the ability of the destination to complete the TLS handshake.",
          "createdAt": "2023-11-15T18:38:48Z",
          "updatedAt": "2023-11-15T18:38:48Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't understand what (1) means. Re (2) this is not reliable because the attacker can simply forward the TLS connection to the true endpoint when being probed and it's straightforward to arrange that the probe connection doesn't look like a connection from their own compromised clients.\r\n",
          "createdAt": "2023-11-15T18:50:34Z",
          "updatedAt": "2023-11-15T18:50:34Z"
        },
        {
          "author": "roelfdutoit",
          "authorAssociation": "NONE",
          "body": "> I don't understand what (1) means\r\n\r\ndstip_client = destination as observed on client side of middlebox\r\ndstip_sni = gethostbyname(SNI)\r\nOption 1: if (dstip_sni != dstip_client) then reset connection.\r\nOption 2: dstip = dstip_sni, i.e. redirect the connection to dstip_sni, where \"redirect\" is implementation specific.",
          "createdAt": "2023-11-15T19:03:01Z",
          "updatedAt": "2023-11-15T19:03:28Z"
        },
        {
          "author": "roelfdutoit",
          "authorAssociation": "NONE",
          "body": "> (2) this is not reliable because the attacker can simply forward the TLS connection to the true endpoint \r\n\r\nSure, I agree, but do they really?  Implementing (2) forces the attacker to implement this relay, and when combined with (1) gives the middlebox a mechanism to detect an anomaly where the true endpoint dstip seems to have \"jumped\".",
          "createdAt": "2023-11-15T19:12:56Z",
          "updatedAt": "2023-11-15T19:12:56Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "> > I don't understand what (1) means\r\n> \r\n> dstip_client = destination as observed on client side of middlebox dstip_sni = gethostbyname(SNI) Option 1: if (dstip_sni != dstip_client) then reset connection. Option 2: dstip = dstip_sni, i.e. redirect the connection to dstip_sni, where \"redirect\" is implementation specific.\r\n\r\nWait, you're talking about comparing the IP address? It's incredibly common to get different IPs for the same DNS name, so (1) is a non-starter (2) is really just like fighting with the load balancing on the server, so is bad news.\r\n",
          "createdAt": "2023-11-15T19:25:06Z",
          "updatedAt": "2023-11-15T19:25:06Z"
        },
        {
          "author": "roelfdutoit",
          "authorAssociation": "NONE",
          "body": "> Wait, you're talking about comparing the IP address? It's incredibly common to get different IPs for the same DNS name, so (1) is a non-starter (2) is really just like fighting with the load balancing on the server, so is bad news.\r\n\r\nThe context of my comments is \"enterprise environment\".  Calling (1) a non-starter ignores the level of control an enterprise has over DNS (including DoH requests) and `gethostbyname` in my pseudo-code is not referring to a simple lookup.\r\n\r\nAs for (2).. the attacker tries to bypass the middlebox by using `www.example.org` as SNI on a TLS session to `c2.attacker.xxx`.  The middlebox will resolve `www.example.org` and connect upstream to `www.example.org`, not to `c2.attacker.xxx`.",
          "createdAt": "2023-11-15T19:48:38Z",
          "updatedAt": "2023-11-15T19:48:38Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n\r\nOn 15/11/2023 19:48, Roelof DuToit wrote:\r\n> The context of my comments is \"enterprise environment\".\r\n\r\nIMO any disagreement about the goals of this specification needs to be\r\nraised on the TLS WG list and (if it to have any effect) not as an\r\nissue on github. And in particular, one ought note the TLS WG and IETF\r\nmore broadly have already reached consensus on RFC8744 so attempts to\r\ncircumvent that consensus via github issues/PRs should and will\r\neventually be rejected on at least that basis.\r\n\r\nS.\r\n\r\n",
          "createdAt": "2023-11-15T23:14:19Z",
          "updatedAt": "2023-11-15T23:14:19Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "> > Wait, you're talking about comparing the IP address? It's incredibly common to get different IPs for the same DNS name, so (1) is a non-starter (2) is really just like fighting with the load balancing on the server, so is bad news.\r\n> \r\n> The context of my comments is \"enterprise environment\". Calling (1) a non-starter ignores the level of control an enterprise has over DNS (including DoH requests) and `gethostbyname` in my pseudo-code is not referring to a simple lookup.\r\n> \r\n> As for (2).. the attacker tries to bypass the middlebox by using `www.example.org` as SNI on a TLS session to `c2.attacker.xxx`. The middlebox will resolve `www.example.org` and connect upstream to `www.example.org`, not to `c2.attacker.xxx`.\r\n\r\nThe relevant case here is one where the endpoint is doing its own DNS resolution invisibly to the enterprise, because *otherwise* the enterprise can just strip the ECHConfigs.\r\n\r\n",
          "createdAt": "2023-11-16T00:05:38Z",
          "updatedAt": "2023-11-16T00:05:38Z"
        },
        {
          "author": "roelfdutoit",
          "authorAssociation": "NONE",
          "body": "> The relevant case here is one where the endpoint is doing its own DNS resolution invisibly to the enterprise, because otherwise the enterprise can just strip the ECHConfigs.\r\n\r\nUnderstood, but I thought we were discussing the reliabillity of SNI as control irrespective of ECH as stated in the text this PR is trying to modify: _\"use as a control even in the absence of ECH\"_.\r\n\r\nIn an enterprise environment where the client device is compromised the network security device will use the techniques I have described above to **improve** the reliability of SNI as a control.  I understand that the attacker can also improve its chances of not being detected, but it has to move up the [Pyramid of Pain](https://detect-respond.blogspot.com/2013/03/the-pyramid-of-pain.html) - just spoofing the SNI is an unreliable way to bypass advanced network security devices.",
          "createdAt": "2023-11-16T00:31:29Z",
          "updatedAt": "2023-11-16T00:31:29Z"
        },
        {
          "author": "taddhar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There is no disagreement on the goal of this draft, the disagreement is that the clause we are debating is wrong but more importantly it is irrelevant to this draft, so we are not even trying to fix it, this will confuse anyone and adds nothing to the benefit of ECH. ",
          "createdAt": "2023-11-16T07:14:08Z",
          "updatedAt": "2023-11-16T07:14:08Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n\r\nOn 16/11/2023 07:14, Arnaud Taddei wrote:\r\n> There is no disagreement on the goal of this draft\r\n\r\nGreat! I was more reacting to the discussion on the PR\r\nthan the PR text itself btw.\r\n\r\nS.\r\n",
          "createdAt": "2023-11-16T12:35:58Z",
          "updatedAt": "2023-11-16T12:35:58Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, given that this is not in security considerations and (1) the text here makes a claim which is disputed and (2) the effect of removing the text is to make the impact of ECH seem bigger than it did in the previous text which seems to be erring on the safe side, I'm going to merge this PR unless someone objects by 2/24.\r\n",
          "createdAt": "2024-02-17T15:32:10Z",
          "updatedAt": "2024-02-17T15:32:30Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOB-yxNc5wcy7g",
          "commit": {
            "abbreviatedOid": "1030cfb"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-17T15:32:57Z",
          "updatedAt": "2024-02-17T15:32:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 596,
      "id": "PR_kwDOB-yxNc5gC8Cl",
      "title": "Figure 5: figure spacing",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/596",
      "state": "MERGED",
      "author": "seanturner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I think ech_outer_extensions should be indented under ech.",
      "createdAt": "2023-11-21T16:52:07Z",
      "updatedAt": "2024-02-17T15:07:29Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "774dff4e3a49533e9510dc04a905a2638992f7e5",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "seanturner-fig5-spacing",
      "headRefOid": "94993b2085bab0104d9923069fcffd22499723d6",
      "closedAt": "2024-02-17T15:07:29Z",
      "mergedAt": "2024-02-17T15:07:29Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "5706c9c88055510068e76b326ac23b3473b99042"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 597,
      "id": "PR_kwDOB-yxNc5gFNjd",
      "title": "ech_outer_extensions: TLS 1.3 column change",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/597",
      "state": "MERGED",
      "author": "seanturner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Change from \"\" to \"N/A\".",
      "createdAt": "2023-11-22T01:40:23Z",
      "updatedAt": "2024-02-17T15:07:06Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "774dff4e3a49533e9510dc04a905a2638992f7e5",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "seanturner-reg-tweak-forech_out_ext",
      "headRefOid": "da089351db4572042acb0c514e9c695c9b1f6d79",
      "closedAt": "2024-02-17T15:07:06Z",
      "mergedAt": "2024-02-17T15:07:06Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "0e0774798496fb04009c778e4cf8a4f9413efb80"
      },
      "comments": [
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood squash and merge when you get a chance.",
          "createdAt": "2023-12-12T14:51:38Z",
          "updatedAt": "2023-12-12T14:51:38Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOB-yxNc5p83oT",
          "commit": {
            "abbreviatedOid": "5268e5b"
          },
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-12T14:10:24Z",
          "updatedAt": "2023-12-12T14:10:25Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\n1. ech_outer_extensions(0xfd00), with the \"TLS 1.3\" column values set to \"CH\",\r\n   \"DTLS-Only\" column set to \"N\", \"Recommended\" column set to \"Yes\", and the\r\n   \"Comments\" column set to \"Only appears in inner CH.\"\r\n```",
              "createdAt": "2023-12-12T14:10:24Z",
              "updatedAt": "2023-12-12T14:10:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5p86Kc",
          "commit": {
            "abbreviatedOid": "b7ffdae"
          },
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-12T14:15:15Z",
          "updatedAt": "2023-12-12T14:15:15Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\n   \"Comment\" column set to \"Only appears in inner CH.\"\r\n```",
              "createdAt": "2023-12-12T14:15:15Z",
              "updatedAt": "2023-12-12T14:15:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5qA6KC",
          "commit": {
            "abbreviatedOid": "da08935"
          },
          "author": "dconnolly",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-13T00:03:11Z",
          "updatedAt": "2023-12-13T00:03:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 599,
      "id": "PR_kwDOB-yxNc5nLAeK",
      "title": "Fix the metadata fields",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/599",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-02-17T15:10:26Z",
      "updatedAt": "2024-02-17T15:11:15Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "5706c9c88055510068e76b326ac23b3473b99042",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "fix_metadata",
      "headRefOid": "120d12f6366853b0c540d25994b48e7839c6e584",
      "closedAt": "2024-02-17T15:11:15Z",
      "mergedAt": "2024-02-17T15:11:15Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "8ad257a7088b71a2c11786785149742ee4dda60e"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 600,
      "id": "PR_kwDOB-yxNc5nLDZb",
      "title": "Ech compatibility middleboxes",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/600",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Clarify the intention of the Middlebox section.  Closes PR#592.",
      "createdAt": "2024-02-17T15:24:03Z",
      "updatedAt": "2024-02-17T15:24:50Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "8ad257a7088b71a2c11786785149742ee4dda60e",
      "headRepository": "ekr/draft-ietf-tls-esni",
      "headRefName": "ech-compatibility-middleboxes",
      "headRefOid": "e63c783c4b843cbc30a0a743fefc6071ff9bedff",
      "closedAt": "2024-02-17T15:24:50Z",
      "mergedAt": "2024-02-17T15:24:50Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "5bb3bbbac8f11412f00c9a2c1cf3f6fdd674bb72"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 601,
      "id": "PR_kwDOB-yxNc5nLj_O",
      "title": "Expand overview to clarify the topologies. Fixes #588",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/601",
      "state": "CLOSED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I rewrote this section a bit to try to make things clearer. I think this addresses @taddhar's issues from #588.\r\n\r\n@martinthomson @dennisjackson  PTAL.",
      "createdAt": "2024-02-17T17:16:30Z",
      "updatedAt": "2024-02-17T18:09:31Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "b5aed7b1680f8eb94b36456ee72c236e61ab10d5",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "overview_expansion",
      "headRefOid": "89998fd98ea6a85c9bafcc126163ee22229b2295",
      "closedAt": "2024-02-17T18:09:31Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Please hold off on reviewing this. More changes coming.",
          "createdAt": "2024-02-17T17:43:34Z",
          "updatedAt": "2024-02-17T17:43:34Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 602,
      "id": "PR_kwDOB-yxNc5nL0ko",
      "title": "More explanatory text.. Fixes #587. Fixes #591",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/602",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Rewrite the overview section to be a bit clearer and clarified the misconfiguration pieces.\r\n\r\n* Added more narrative text around the topologies.\r\n* Moved much of misconfiguration piece up to overview so people have some signposting.\r\n* Expanded the misconfiguration pieces a bit.\r\n",
      "createdAt": "2024-02-17T18:12:09Z",
      "updatedAt": "2024-02-25T00:04:30Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "overview_expansion",
      "baseRefOid": "89998fd98ea6a85c9bafcc126163ee22229b2295",
      "headRepository": "ekr/draft-ietf-tls-esni",
      "headRefName": "overview_expansion",
      "headRefOid": "a34f66e6533dd10904e41332f08e91d3ccdee8eb",
      "closedAt": "2024-02-25T00:04:29Z",
      "mergedAt": "2024-02-25T00:04:29Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "4053b38e1bbe5ef70f0a85ec79d1cd19bf748e61"
      },
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@dennisjackson @martinthomson ",
          "createdAt": "2024-02-17T18:12:30Z",
          "updatedAt": "2024-02-17T18:12:30Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "other than the above, this change seems fine",
          "createdAt": "2024-02-18T23:24:40Z",
          "updatedAt": "2024-02-18T23:24:40Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOB-yxNc5weqva",
          "commit": {
            "abbreviatedOid": "80ec944"
          },
          "author": "wbl",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-18T05:41:42Z",
          "updatedAt": "2024-02-18T05:41:42Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "Looks spurious",
              "createdAt": "2024-02-18T05:41:42Z",
              "updatedAt": "2024-02-18T05:41:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5wfsue",
          "commit": {
            "abbreviatedOid": "80ec944"
          },
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-18T23:16:34Z",
          "updatedAt": "2024-02-18T23:16:34Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Missing a negative in 2nd bullet above?",
              "createdAt": "2024-02-18T23:16:34Z",
              "updatedAt": "2024-02-18T23:16:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5wgvUG",
          "commit": {
            "abbreviatedOid": "80ec944"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Any point saying that:\r\n\r\n> This makes availability of a certificate for the public name - and its associated private key - a critical component for server deployment of ECH.  This certificate is used both to recover from transient misconfiguration problems and to disable ECH in the event that a server cannot continue to support the capability.",
          "createdAt": "2024-02-19T06:18:39Z",
          "updatedAt": "2024-02-19T06:31:05Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "```suggestion\r\nloses its ECH keys, or if a deployment of ECH is rolled back on the server.\r\n```\r\nor \"needs to be\", but \"is\" works.",
              "createdAt": "2024-02-19T06:18:39Z",
              "updatedAt": "2024-02-19T06:31:05Z"
            },
            {
              "originalPosition": 47,
              "body": "```suggestion\r\n* The server does not have ECH configured but the client has a ECH configuration\r\n  and so is attempting ECH.\r\n```",
              "createdAt": "2024-02-19T06:19:09Z",
              "updatedAt": "2024-02-19T06:31:05Z"
            },
            {
              "originalPosition": 97,
              "body": "```suggestion\r\nthe keys. The security of this mechanism depends on the server having\r\n```",
              "createdAt": "2024-02-19T06:22:10Z",
              "updatedAt": "2024-02-19T06:31:05Z"
            },
            {
              "originalPosition": 122,
              "body": "```suggestion\r\nFalling back to an unencrypted ClientHello in any of these cases would\r\n```",
              "createdAt": "2024-02-19T06:22:58Z",
              "updatedAt": "2024-02-19T06:31:05Z"
            },
            {
              "originalPosition": 126,
              "body": "```suggestion\r\nit impossible to complete an ECH connection where an ordinary TLS\r\n```",
              "createdAt": "2024-02-19T06:28:22Z",
              "updatedAt": "2024-02-19T06:31:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5xOVTn",
          "commit": {
            "abbreviatedOid": "80ec944"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-25T00:02:10Z",
          "updatedAt": "2024-02-25T00:02:11Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "```suggestion\r\n* The server does not have ECH configured but the client has a  ECH configuration\r\n```",
              "createdAt": "2024-02-25T00:02:10Z",
              "updatedAt": "2024-02-25T00:02:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5xOVUW",
          "commit": {
            "abbreviatedOid": "80ec944"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-25T00:02:47Z",
          "updatedAt": "2024-02-25T00:03:07Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "```suggestion\r\n```",
              "createdAt": "2024-02-25T00:02:47Z",
              "updatedAt": "2024-02-25T00:03:07Z"
            }
          ]
        }
      ]
    },
    {
      "number": 603,
      "id": "PR_kwDOB-yxNc5nL5Gb",
      "title": "Clarify that you can fall back by providing no ECH in EE",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/603",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Clarification due to Elardus Erasmus",
      "createdAt": "2024-02-17T18:27:26Z",
      "updatedAt": "2024-02-24T23:47:41Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "b5aed7b1680f8eb94b36456ee72c236e61ab10d5",
      "headRepository": "ekr/draft-ietf-tls-esni",
      "headRefName": "no_ech_in_ee_means_retry",
      "headRefOid": "0054c8e0476a02490a6bb7456131af828f767a84",
      "closedAt": "2024-02-24T23:47:41Z",
      "mergedAt": "2024-02-24T23:47:41Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "52048599a9af744a3c01bab68be7d6924fce74db"
      },
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@dennisjackson",
          "createdAt": "2024-02-17T18:27:39Z",
          "updatedAt": "2024-02-17T18:27:39Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOB-yxNc5wfUUt",
          "commit": {
            "abbreviatedOid": "0054c8e"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-18T15:00:19Z",
          "updatedAt": "2024-02-18T15:00:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 607,
      "id": "PR_kwDOB-yxNc5n2ZHZ",
      "title": "Ladd review1",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/607",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This addresses most of the comments in @wbl's review, except for (1) whether we should recommend grease-psk and (2) restructuring the text around ClientHelloOuterAAD.\r\n\r\n\r\n\r\n",
      "createdAt": "2024-02-25T21:10:05Z",
      "updatedAt": "2024-03-01T01:05:57Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "52048599a9af744a3c01bab68be7d6924fce74db",
      "headRepository": "ekr/draft-ietf-tls-esni",
      "headRefName": "ladd_review1",
      "headRefOid": "c14e934e3011a1659f5fca362052e67633c33d3a",
      "closedAt": "2024-03-01T01:05:57Z",
      "mergedAt": "2024-03-01T01:05:56Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "1ed98b5891355bcc0e3da3a6168ff92c91745810"
      },
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Updated to restructure the text around ClientHelloOuterAAD.",
          "createdAt": "2024-02-25T21:29:31Z",
          "updatedAt": "2024-02-25T21:29:31Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOB-yxNc5xy7fd",
          "commit": {
            "abbreviatedOid": "c58f999"
          },
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-29T15:21:21Z",
          "updatedAt": "2024-02-29T15:26:23Z",
          "comments": [
            {
              "originalPosition": 147,
              "body": "```suggestion\r\n* A client-facing server expects a `ECHClientHello.type` of `outer`, and\r\n```",
              "createdAt": "2024-02-29T15:21:22Z",
              "updatedAt": "2024-02-29T15:26:23Z"
            },
            {
              "originalPosition": 203,
              "body": "nit: \"ensure\" twice in one sentence\r\n```suggestion\r\nIn order to guarantee that the retry mechanism works successfully servers\r\n```",
              "createdAt": "2024-02-29T15:24:52Z",
              "updatedAt": "2024-02-29T15:26:23Z"
            },
            {
              "originalPosition": 224,
              "body": "Orthogonal: Do we want to add a note for the RFC editor to drop this text about \"an earlier version of this specification\"?",
              "createdAt": "2024-02-29T15:26:19Z",
              "updatedAt": "2024-02-29T15:26:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5x2lH3",
          "commit": {
            "abbreviatedOid": "c58f999"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-01T01:01:50Z",
          "updatedAt": "2024-03-01T01:01:51Z",
          "comments": [
            {
              "originalPosition": 224,
              "body": "No, I think this is helpful",
              "createdAt": "2024-03-01T01:01:50Z",
              "updatedAt": "2024-03-01T01:01:51Z"
            }
          ]
        }
      ]
    },
    {
      "number": 609,
      "id": "PR_kwDOB-yxNc5n2cYv",
      "title": "Explain when clients can remember rejected ECH. Fixes #604",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/609",
      "state": "OPEN",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-02-25T21:56:55Z",
      "updatedAt": "2024-07-07T13:25:04Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "c5c7baab39f837b0fe4d240b09746d82ef5e097b",
      "headRepository": "ekr/draft-ietf-tls-esni",
      "headRefName": "retry_memory",
      "headRefOid": "ba7aadbb667bba9dee960e19eb732004e74ffb50",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson ",
          "createdAt": "2024-02-25T21:57:02Z",
          "updatedAt": "2024-02-25T21:57:02Z"
        },
        {
          "author": "dennisjackson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Reading the discussion, are you sure the complexity of doing this is worth the gain? The principle mechanism server operators have for controlling ECH attempts is updating their DNS records. Presuming they can do that reasonably quickly, aren't most clients going to maintain an open connection for the relevant time period anyway? How long is the window in which we won't have an open usable connection (with ECH or not) but we'd be willing to remember the past ECH failure/retry-config for? \r\n\r\nI'd also point out that we also can't assume that ECHConfigs always come from DNS for the purposes of working out an expiration time. It could be that applications are configured by some other out of band mechanism, or even that they deliberately use a known-bad config and intend to rely on a provided retry-config.",
          "createdAt": "2024-03-01T14:42:42Z",
          "updatedAt": "2024-03-01T14:42:42Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "The complexity of specifying it or the complexity of implementing it? Right now I read the spec as just prohibiting it.\r\n\r\nWRT multiple connections, the case I am concerned about is HTTP connection sharding when you might have 4 or so concurrent connections. I suppose we can just say that this is a reason to use H2 or H3.\r\n\r\nWRT not-DNS, I think we could practically just limit this kind of memory to DNS.\r\n\r\nAnyway, i don't feel strongly about this, and we could always relax this restriction later, so if others aren't enthusiastic, we can just close this unchanged.\r\n",
          "createdAt": "2024-03-01T16:43:43Z",
          "updatedAt": "2024-03-01T16:43:43Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this may need a little more bake time. I'm going to ship the next version without it and hopefully we can refine over the next few weeks, or alternately decide we don't need it.",
          "createdAt": "2024-03-04T02:18:29Z",
          "updatedAt": "2024-03-04T02:18:29Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n\r\nOn 04/03/2024 02:18, Eric Rescorla wrote:\r\n> I'm going to ship the next version\r\n\r\nYes, shipping a version good enough for WGLC and then IETF LC\r\nis the right plan. There'll be plenty of chances for fixing\r\nwording at those stages.\r\n\r\nS.\r\n",
          "createdAt": "2024-03-04T02:29:14Z",
          "updatedAt": "2024-03-04T02:29:14Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Revisiting this....\r\n\r\n1. I think we should make the \"single retry\" change. I split that into #616. There's no reason that should happen.\r\n\r\n2. I'm less sure about the \"you can remember\" stuff, but on balance I think it's worth it. I've updated it to take @bemasc's comments and now I think it's correct. @martinthomson  @bemasc @dennisjackson @davidben ?\r\n",
          "createdAt": "2024-05-27T15:04:00Z",
          "updatedAt": "2024-05-27T15:04:00Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson  how's this",
          "createdAt": "2024-05-27T18:43:50Z",
          "updatedAt": "2024-05-27T18:43:50Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOB-yxNc5xPE_E",
          "commit": {
            "abbreviatedOid": "ff23cac"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-25T23:33:33Z",
          "updatedAt": "2024-02-25T23:39:35Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "```suggestion\r\nClients MUST NOT use ECHConfigs with IP addresses other than those\r\nassociated with the DNS queries for the original\r\nconnection. Otherwise, it might become possible for the client to have\r\n```\r\n\r\nHowever, do you think that you should instead insist on some sort of equality check on something else?  Like the SVCB (or HTTPS) record being for the same QNAME or simply validating that the SVCB record has the same public name?\r\n\r\nThat latter check seems key, so I might instead say:\r\n\r\n```suggestion\r\nClients MUST NOT reuse ECHConfigs that identify a different public name from\r\nthe one used to acquire the IP address of the server. ECHConfigs MUST be freshly\r\nretrieved or taken from a cached SVCB (or HTTPS) record that is within its TTL.\r\nOtherwise, it might become possible for the client to have\r\n```",
              "createdAt": "2024-02-25T23:33:33Z",
              "updatedAt": "2024-02-25T23:39:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5xPNGH",
          "commit": {
            "abbreviatedOid": "ff23cac"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-26T00:54:12Z",
          "updatedAt": "2024-02-26T00:54:12Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "I don't think this is quite right. Suppose that we resolve `example.com`, retrieve HTTPS and it has:\r\n\r\n```\r\npublic_name = example.com\r\nkey = ABC\r\nIP = 192.0.2.1\r\n```\r\n\r\nWe connect to the server and it supplies:\r\n```\r\npublic_name = example.com\r\nkey = XYZ\r\nIP = 192.0.2.1\r\n```\r\n\r\nIt seems like it's safe to reuse this second ECHConfig.\r\n\r\nHowever, it's not safe if we resolve `example.com` and get an A record  for `192.0.2.2`.\r\n\r\nRelatedly, if we resolve `example.com` and get HTTPS of\r\n\r\n```\r\npublic_name = example.com\r\nkey = DEF\r\nIP = 192.0.2.2\r\n```\r\n\r\nWe don't *know* that it's safe to reuse the old key XYZ, right?\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
              "createdAt": "2024-02-26T00:54:12Z",
              "updatedAt": "2024-02-26T00:54:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5x2iJM",
          "commit": {
            "abbreviatedOid": "ff23cac"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-01T00:47:57Z",
          "updatedAt": "2024-03-01T00:47:58Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "@martinthomson  ping",
              "createdAt": "2024-03-01T00:47:58Z",
              "updatedAt": "2024-03-01T00:47:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5x2xRk",
          "commit": {
            "abbreviatedOid": "ff23cac"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-01T01:53:20Z",
          "updatedAt": "2024-03-01T01:53:20Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "There is no IP in the ECHConfig though, so I'm struggling to understand this.\r\n\r\nThe trick that I was suggesting was that a server that uses multiple providers could use public name rather than IP to separate those providers.  This is on the presumption that |the set of IP addresses for each provider| > 1 but the number of public names is under their direct control.",
              "createdAt": "2024-03-01T01:53:20Z",
              "updatedAt": "2024-03-01T01:53:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5x21fo",
          "commit": {
            "abbreviatedOid": "ff23cac"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-01T02:09:13Z",
          "updatedAt": "2024-03-01T02:09:13Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "I have to admit that I have kind of lost track of how the DNS pieces fit together, but...\r\n\r\nAs I remember, the basic design requirement for multi-CDN was that we had to ensure that there was no way that the client could get ECHConfig for CDN A and the IP address for CDN B, because that just won't work. When I had last checked, that was intended to be accomplished by having the IP address delivered alongside the ECHConfig, which I thought was done with ipv6hint. But maybe I've misremembered or things evolved.\r\n\r\n@tfpauly @bemasc?\r\n\r\n\r\n\r\n\r\n\r\n",
              "createdAt": "2024-03-01T02:09:13Z",
              "updatedAt": "2024-03-01T02:09:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5x24h6",
          "commit": {
            "abbreviatedOid": "ff23cac"
          },
          "author": "tfpauly",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-01T02:28:35Z",
          "updatedAt": "2024-03-01T02:28:35Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "The record can contain v4 and v6 hints, and also is associated with A and AAAA records for that specific service (which would be distinct from the IP addresses for other cdns, etc), that are queried after receiving the HTTPS record. ",
              "createdAt": "2024-03-01T02:28:35Z",
              "updatedAt": "2024-03-01T02:28:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5x25Pm",
          "commit": {
            "abbreviatedOid": "ff23cac"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-01T02:32:41Z",
          "updatedAt": "2024-03-01T02:32:41Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Can you elaborate on how that second process works? By dereferencing the TargetName?",
              "createdAt": "2024-03-01T02:32:41Z",
              "updatedAt": "2024-03-01T02:32:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5x25xY",
          "commit": {
            "abbreviatedOid": "ff23cac"
          },
          "author": "tfpauly",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-01T02:36:01Z",
          "updatedAt": "2024-03-01T02:36:01Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Yes, from the target name. See both of these:\n\nhttps://www.rfc-editor.org/rfc/rfc9460.html#section-7.3\n\nhttps://www.rfc-editor.org/rfc/rfc9460.html#section-3",
              "createdAt": "2024-03-01T02:36:01Z",
              "updatedAt": "2024-03-01T02:36:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc5x8Wxj",
          "commit": {
            "abbreviatedOid": "ff23cac"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-01T17:11:17Z",
          "updatedAt": "2024-03-01T17:38:44Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "In SVCB, ECH is a property of the \"endpoint\", which is represented by one ServiceMode record (out of an RRset that might contain several).  An endpoint also specifies a pool of IP addresses (by the A+AAAA records on the TargetName, or by IP hints in the SvcParams).  As far as SVCB is concerned, ECH can keep state within the scope of a single endpoint, but that state must not leak across to other endpoints of the same \"service\" (i.e. origin).\r\n\r\nThis draft doesn't have the concept of an \"endpoint\", but I think we can define a close enough notion here (without requiring DNS, which is not required for ECH!): call it an \"ECHConfig source\".\r\n\r\n```suggestion\r\nAny persisted information MUST be associated with the ECHConfig source used\r\nto bootstrap the connection, such as a DNS SVCB ServiceMode record {{ECH-IN-DNS}}.\r\nClients MUST limit any sharing of persisted ECH-related state to connections that use\r\nthe same ECHConfig source. Otherwise, it might become possible for the client to have\r\n```\r\n\r\nNote that \"matching ECHConfig\" is arguably too broad a scope: if I have two ServiceMode records pointing at separate server pools that initially have the same ECHConfig, I should be able to update one pool without changing the connection behaviors observed by the other one.",
              "createdAt": "2024-03-01T17:11:17Z",
              "updatedAt": "2024-03-04T14:50:54Z"
            },
            {
              "originalPosition": 37,
              "body": "I really can't tell what this is trying to say.\r\n\r\n```suggestion\r\nIn general, the safest way for clients to minimize ECH retries is to\r\ncomply with any freshness rules (e.g., DNS TTLs) imposed by the\r\nECHConfig source. This makes it most likely that the client will\r\n```",
              "createdAt": "2024-03-01T17:14:27Z",
              "updatedAt": "2024-03-01T17:38:44Z"
            },
            {
              "originalPosition": 32,
              "body": "```suggestion\r\nvector. Clients SHOULD impose the same lifetime and scope restrictions\r\nthat they apply to other server-based\r\n```",
              "createdAt": "2024-03-01T17:37:14Z",
              "updatedAt": "2024-03-01T17:38:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc58DhM9",
          "commit": {
            "abbreviatedOid": "ba12a23"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-27T17:21:04Z",
          "updatedAt": "2024-05-27T17:21:04Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I commented on the other PR, but maybe this can point at the new section as a way of explaining the \"SHOULD\".",
              "createdAt": "2024-05-27T17:21:04Z",
              "updatedAt": "2024-05-27T17:21:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc58Dh6V",
          "commit": {
            "abbreviatedOid": "ba12a23"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-27T17:24:38Z",
          "updatedAt": "2024-05-27T17:24:38Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "This \"however\" was a little unclear to me at first.\r\n\r\nI think that what you are saying is that when you save a retry config that worked for a future connection, you need to treat a retry that results as though you did not have a retry.  The result is that you will use the retry config and try again.\r\n\r\nThis needs to be part of the text that explains that you shouldn't accept a retry config if you just used one.  Otherwise, it's a little confusing.",
              "createdAt": "2024-05-27T17:24:38Z",
              "updatedAt": "2024-05-27T17:24:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc58FeY-",
          "commit": {
            "abbreviatedOid": "96701ce"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-05-28T05:56:20Z",
          "updatedAt": "2024-05-28T05:56:24Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "```suggestion\r\ncomply with any freshness rules (e.g., DNS TTLs) imposed by the ECH configuration.\r\n```",
              "createdAt": "2024-05-28T05:56:21Z",
              "updatedAt": "2024-05-28T05:56:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc58Jcso",
          "commit": {
            "abbreviatedOid": "ba7aadb"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-05-28T13:48:49Z",
          "updatedAt": "2024-05-28T13:48:49Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOB-yxNc58OqlP",
          "commit": {
            "abbreviatedOid": "ba7aadb"
          },
          "author": "elardus-erasmus",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-29T04:03:45Z",
          "updatedAt": "2024-05-29T04:03:46Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Wondering if this `MAY` should not be a stronger `SHOULD`. If not implemented by the client, it does mean that there is a doubling in the number of (expensive PKI involving) connections for ECH disabled retries. For example, in situations like TLS-terminating proxies (all TLS 1.3+ECH connections going through it), temporary disabling of ECH on a server, or indefinitely in case of a server config issue.",
              "createdAt": "2024-05-29T04:03:45Z",
              "updatedAt": "2024-05-29T04:22:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc6A2hLa",
          "commit": {
            "abbreviatedOid": "ba7aadb"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-07T02:47:14Z",
          "updatedAt": "2024-07-07T02:47:15Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "If it's indefinitely, then the DNS records will time out. I think probably a SHOULD is too strong.",
              "createdAt": "2024-07-07T02:47:14Z",
              "updatedAt": "2024-07-07T02:47:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc6A21-u",
          "commit": {
            "abbreviatedOid": "ba7aadb"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-07T13:25:03Z",
          "updatedAt": "2024-07-07T13:25:04Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "```suggestion\r\nthe server, making recovery impossible.\r\n```",
              "createdAt": "2024-07-07T13:25:04Z",
              "updatedAt": "2024-07-07T13:25:04Z"
            }
          ]
        }
      ]
    },
    {
      "number": 610,
      "id": "PR_kwDOB-yxNc5oiFB4",
      "title": "Encourage greasing PSK. Fixes #606",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/610",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-03-04T02:17:12Z",
      "updatedAt": "2024-03-04T15:59:59Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "1ed98b5891355bcc0e3da3a6168ff92c91745810",
      "headRepository": "ekr/draft-ietf-tls-esni",
      "headRefName": "encourage_greasing_psk",
      "headRefOid": "0abc258cd5005e652b02493c1ec2576f1102ad63",
      "closedAt": "2024-03-04T15:59:59Z",
      "mergedAt": "2024-03-04T15:59:59Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "dca0d9e236e301542000df25f3e9124f4ce22959"
      },
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson @dennisjackson ",
          "createdAt": "2024-03-04T02:17:19Z",
          "updatedAt": "2024-03-04T02:17:19Z"
        },
        {
          "author": "dennisjackson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "LGTM",
          "createdAt": "2024-03-04T14:57:48Z",
          "updatedAt": "2024-03-04T14:57:48Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 611,
      "id": "PR_kwDOB-yxNc5pIQOx",
      "title": "I-D.ietf-dnsop-svcb-https is now RFC9460",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/611",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-03-08T23:12:54Z",
      "updatedAt": "2024-03-08T23:21:50Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "dca0d9e236e301542000df25f3e9124f4ce22959",
      "headRepository": "davidben/draft-ietf-tls-esni",
      "headRefName": "rfc9460",
      "headRefOid": "14d242ee7b89a0369a2743c8a0aab4ba23eefa31",
      "closedAt": "2024-03-08T23:21:50Z",
      "mergedAt": "2024-03-08T23:21:50Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "063b8add41a2ee808824b75fb64805f1d9d016c4"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 613,
      "id": "PR_kwDOB-yxNc5rdudZ",
      "title": "link for formal analysis paper",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/613",
      "state": "MERGED",
      "author": "seanturner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-04-02T17:03:38Z",
      "updatedAt": "2024-04-03T13:17:44Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "063b8add41a2ee808824b75fb64805f1d9d016c4",
      "headRepository": "tlswg/draft-ietf-tls-esni",
      "headRefName": "seanturner-fa-link",
      "headRefOid": "dd87c474a3093b7cd18a35ccd83880dd7e074e18",
      "closedAt": "2024-04-03T13:17:44Z",
      "mergedAt": "2024-04-03T13:17:44Z",
      "mergedBy": "dconnolly",
      "mergeCommit": {
        "oid": "c298098702d6fe9b9db50f2a76878b5aea6e357d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOB-yxNc5102GQ",
          "commit": {
            "abbreviatedOid": "dd87c47"
          },
          "author": "dconnolly",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-04-03T13:17:31Z",
          "updatedAt": "2024-04-03T13:17:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 614,
      "id": "PR_kwDOB-yxNc5ske15",
      "title": "Correct `ECHConfigList` length bounds",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/614",
      "state": "MERGED",
      "author": "ctz",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Draft 18.\r\n\r\n`ECHConfig` is:\r\n\r\n```\r\n       struct {\r\n           uint16 version;\r\n           uint16 length;\r\n           select (ECHConfig.version) {\r\n             case 0xfe0d: ECHConfigContents contents;\r\n           }\r\n       } ECHConfig;\r\n```\r\n\r\n4 bytes each minimum.\r\n\r\n`ECHConfigList` is:\r\n\r\n```\r\n       ECHConfig ECHConfigList<1..2^16-1>;\r\n```\r\n\r\nThat implies an `ECHConfig` could be encoded in one byte? I think this should be:\r\n\r\n```\r\n       ECHConfig ECHConfigList<4..2^16-4>;\r\n```",
      "createdAt": "2024-04-13T15:25:04Z",
      "updatedAt": "2024-05-27T14:44:18Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "c298098702d6fe9b9db50f2a76878b5aea6e357d",
      "headRepository": "ctz/draft-ietf-tls-esni",
      "headRefName": "ctz-patch-1",
      "headRefOid": "01c111ea3e3b764c6d131b2a6bf6e63b72633b81",
      "closedAt": "2024-05-27T14:44:18Z",
      "mergedAt": "2024-05-27T14:44:18Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "22199f66e8fcffd9b24238d8d8c5d33679474dee"
      },
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Where are you getting `2^16-4` from? That seems wrong. It seems like you are confusing minimum of 4 with multiple of 4.\r\n\r\nBeyond that, agreed that 4 is a valid value, but 1 is also just as valid, as is 2 or 3. It makes no difference whether you reject 1 bytes at this layer of parser, or immediately afterwards when you actually go to parse the ECHConfigs. The only thing we're actually saying with any of these values is \"there must be at least one ECHConfig\".\r\n\r\nTo be honest, I think the TLSWG's habit of trying to compute the theoretical minimum value here, instead of just 1, is a waste of energy. At best it is confusing, and at worse we get the value wrong on accident and say the wrong thing.\r\nhttps://mailarchive.ietf.org/arch/msg/tls/kA1C6C0Wluwp6ui1VDmrFbaEm1U/\r\nhttps://mailarchive.ietf.org/arch/msg/tls/Vlcshsrq1QmWDgIqJO3se8K25jA/\r\n\r\nSo while I'm not _opposed_ to this PR, since it is a habit we have in other specifications, the lack of opposition only comes from the pre-existing habit. On its own, I think the habit is a bad one and ultimately makes our documents less readable.",
          "createdAt": "2024-04-15T03:06:38Z",
          "updatedAt": "2024-04-15T03:18:40Z"
        },
        {
          "author": "ctz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Where are you getting `2^16-4` from? That seems wrong. It seems like you are confusing minimum of 4 with multiple of 4.\r\n\r\nYou're right. Corrected.\r\n\r\n> Beyond that, agreed that 4 is a valid value, but 1 is also just as valid, as is 2 or 3. It makes no difference whether you reject 1 bytes at this layer of parser, or immediately afterwards when you actually go to parse the ECHConfigs. The only thing we're actually saying with any of these values is \"there must be at least one ECHConfig\".\r\n\r\nWell I agree. I'm not sure who the TLS presentation language is for, but it always seems to me to detract from the descriptive text and take oxygen from more useful artifacts like test vectors or a reference implementation -- but I realise the TLSWG doesn't have a culture of either of those.",
          "createdAt": "2024-04-15T08:29:32Z",
          "updatedAt": "2024-04-15T08:29:32Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 615,
      "id": "PR_kwDOB-yxNc5wrHTJ",
      "title": "Explain about reused keyshares. Fixes #612",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/615",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-05-27T14:51:22Z",
      "updatedAt": "2024-05-27T18:30:34Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "22199f66e8fcffd9b24238d8d8c5d33679474dee",
      "headRepository": "ekr/draft-ietf-tls-esni",
      "headRefName": "issue612_reused_key_share",
      "headRefOid": "8980078932344b750beaa809c852d7fed571a487",
      "closedAt": "2024-05-27T18:30:34Z",
      "mergedAt": "2024-05-27T18:30:34Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "c5c7baab39f837b0fe4d240b09746d82ef5e097b"
      },
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson ",
          "createdAt": "2024-05-27T14:51:39Z",
          "updatedAt": "2024-05-27T14:51:39Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOB-yxNc58DgJh",
          "commit": {
            "abbreviatedOid": "8980078"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "...despite strong recommendations not to reuse a KeyShare value...\r\n\r\nThis seems almost unnecessary, really.  But it's correct.",
          "createdAt": "2024-05-27T17:16:13Z",
          "updatedAt": "2024-05-27T17:16:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 616,
      "id": "PR_kwDOB-yxNc5wrLcs",
      "title": "Don't retry from retry",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/616",
      "state": "OPEN",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This was split off from PR#609. Hopefully this is uncontroversial.",
      "createdAt": "2024-05-27T15:02:08Z",
      "updatedAt": "2024-05-29T03:34:19Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "22199f66e8fcffd9b24238d8d8c5d33679474dee",
      "headRepository": "ekr/draft-ietf-tls-esni",
      "headRefName": "retry_once",
      "headRefOid": "28786bd66ffaf1b1a96d18e343bb916168f035da",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I added some text.",
          "createdAt": "2024-05-27T18:44:01Z",
          "updatedAt": "2024-05-27T18:44:01Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOB-yxNc58DglQ",
          "commit": {
            "abbreviatedOid": "70bb82d"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-27T17:18:33Z",
          "updatedAt": "2024-05-27T17:18:33Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Do we have a little more color to add here?\r\n\r\nThis is mostly about the case where a retry config is supplied by one server instance, but other server instances don't work.  That is a server configuration error, unless the client decided to keep the retry config for too long, in which case it is a signal that the client shouldn't hold on to old state.\r\n\r\nAdding that sort of context might make the SHOULD a little more useful.",
              "createdAt": "2024-05-27T17:18:33Z",
              "updatedAt": "2024-05-27T17:18:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOB-yxNc58OluC",
          "commit": {
            "abbreviatedOid": "28786bd"
          },
          "author": "elardus-sophos",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-29T03:34:18Z",
          "updatedAt": "2024-05-29T03:34:19Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "The previous paragraph also talks about a \"retry\". But that is an ECH *disabled* retry.\r\nIn this paragraph, based on the context, it is referring to an ECH *enabled* retry.\r\nShould the client be allowed to perform an ECH disabled retry here? And should anything about that, allowed or not allowed, be noted in this paragraph also?",
              "createdAt": "2024-05-29T03:34:19Z",
              "updatedAt": "2024-05-29T03:34:19Z"
            }
          ]
        }
      ]
    },
    {
      "number": 617,
      "id": "PR_kwDOB-yxNc5x_ESr",
      "title": "Fix two broken internal references",
      "url": "https://github.com/tlswg/draft-ietf-tls-esni/pull/617",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-06-10T14:22:57Z",
      "updatedAt": "2024-07-07T02:45:49Z",
      "baseRepository": "tlswg/draft-ietf-tls-esni",
      "baseRefName": "master",
      "baseRefOid": "c5c7baab39f837b0fe4d240b09746d82ef5e097b",
      "headRepository": "MikeBishop/draft-ietf-tls-esni",
      "headRefName": "mbishop-ref-fix",
      "headRefOid": "5c6bfed4088b254bf10b0336e17298a89e08649c",
      "closedAt": "2024-07-07T02:45:49Z",
      "mergedAt": "2024-07-07T02:45:49Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "8a439af1ca1751d19696f34820af72d86d491ac8"
      },
      "comments": [],
      "reviews": []
    }
  ]
}